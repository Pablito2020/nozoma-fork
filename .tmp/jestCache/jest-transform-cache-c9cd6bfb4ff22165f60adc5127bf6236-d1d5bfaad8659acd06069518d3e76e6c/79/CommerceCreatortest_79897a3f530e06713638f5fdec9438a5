e659e5b49dfea716689315ad2fda2221
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CommerceCreator_1 = __importDefault(require("@backoffice-contexts/commerces/app/create/CommerceCreator"));
const CommerceRepository_mock_1 = __importDefault(require("@backoffice-contexts/commerces/__mocks__/CommerceRepository.mock"));
const CommerceCreatorHandler_1 = __importDefault(require("@backoffice-contexts/commerces/app/create/CommerceCreatorHandler"));
const EventBus_mock_1 = __importDefault(require("@shared/__mocks__/EventBus.mock"));
const Commerce_mother_1 = __importDefault(require("@backoffice-contexts/commerces/mothers/Commerce.mother"));
const CreateCommerceCommand_mother_1 = __importDefault(require("@backoffice-contexts/commerces/mothers/CreateCommerceCommand.mother"));
const AlreadyExists_1 = __importDefault(require("@shared/domain/AlreadyExists"));
const CommerceCreatedEvent_mother_1 = __importDefault(require("@backoffice-contexts/commerces/mothers/CommerceCreatedEvent.mother"));
describe(CommerceCreator_1.default, () => {
    it('should throw AlreadyExists when commerce with same email already exists', async () => {
        const repo = new CommerceRepository_mock_1.default(), creator = new CommerceCreator_1.default(repo, new EventBus_mock_1.default()), handler = new CommerceCreatorHandler_1.default(creator), expected = Commerce_mother_1.default.random(), command = CreateCommerceCommand_mother_1.default.fromCommerce(expected);
        repo.whenFindByIdThenReturn(null);
        repo.whenFindByEmailThenReturn(expected);
        await expect(handler.handle(command))
            .rejects
            .toBeInstanceOf(AlreadyExists_1.default);
        repo.assertFindByEmailIsCalledWith(expected.email);
        repo.assertFindIdIsCalledWith(expected.id);
        repo.assertSaveIsNotCalled();
    });
    it('should fail when commerce with same email fail', async () => {
        const repo = new CommerceRepository_mock_1.default(), creator = new CommerceCreator_1.default(repo, new EventBus_mock_1.default()), handler = new CommerceCreatorHandler_1.default(creator), expected = Commerce_mother_1.default.random(), command = CreateCommerceCommand_mother_1.default.fromCommerce(expected);
        repo.whenFindByIdThenReturn(expected);
        repo.whenFindByEmailThenReturn(null);
        await expect(handler.handle(command))
            .rejects
            .toBeInstanceOf(AlreadyExists_1.default);
        repo.assertFindByEmailIsCalledWith(expected.email);
        repo.assertFindIdIsCalledWith(expected.id);
        repo.assertSaveIsNotCalled();
    });
    it('should create a new commerce', async () => {
        const repo = new CommerceRepository_mock_1.default(), creator = new CommerceCreator_1.default(repo, new EventBus_mock_1.default()), handler = new CommerceCreatorHandler_1.default(creator), expected = Commerce_mother_1.default.random(), command = CreateCommerceCommand_mother_1.default.fromCommerce(expected);
        repo.whenFindByIdThenReturn(null);
        repo.whenFindByEmailThenReturn(null);
        // eslint-disable-next-line one-var
        const response = await handler.handle(command);
        repo.assertFindByEmailIsCalledWith(expected.email);
        repo.assertFindIdIsCalledWith(expected.id);
        repo.assertSaveIsCalledWith(expected);
        expect(response.data)
            .toStrictEqual(expected);
    });
    it('should publish CommerceCreatedEvent', async () => {
        const repo = new CommerceRepository_mock_1.default(), eventBus = new EventBus_mock_1.default(), creator = new CommerceCreator_1.default(repo, eventBus), handler = new CommerceCreatorHandler_1.default(creator), commerce = Commerce_mother_1.default.random(), command = CreateCommerceCommand_mother_1.default.fromCommerce(commerce), expected = CommerceCreatedEvent_mother_1.default.fromCommerce(commerce);
        repo.whenFindByIdThenReturn(null);
        repo.whenFindByEmailThenReturn(null);
        await handler.handle(command);
        eventBus.assertLastPublishedEventIs(expected);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvZmVycmFuL3VuaS9jb21wdXRhY2lvL25vem9tYS1mb3JrL3NyYy9jb250ZXh0cy9iYWNrb2ZmaWNlL2NvbW1lcmNlcy9hcHAvY3JlYXRlL0NvbW1lcmNlQ3JlYXRvci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsZ0hBQXdGO0FBQ3hGLCtIQUFzRztBQUN0Ryw4SEFBc0c7QUFDdEcsb0ZBQTJEO0FBQzNELDZHQUFvRjtBQUNwRix1SUFBOEc7QUFDOUcsaUZBQXlEO0FBQ3pELHFJQUE0RztBQUU1RyxRQUFRLENBQUMseUJBQWUsRUFBRSxHQUFHLEVBQUU7SUFDM0IsRUFBRSxDQUFDLHlFQUF5RSxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ3JGLE1BQU0sSUFBSSxHQUFHLElBQUksaUNBQXNCLEVBQUUsRUFDckMsT0FBTyxHQUFHLElBQUkseUJBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSx1QkFBWSxFQUFFLENBQUMsRUFDdkQsT0FBTyxHQUFHLElBQUksZ0NBQXNCLENBQUMsT0FBTyxDQUFDLEVBQzdDLFFBQVEsR0FBRyx5QkFBYyxDQUFDLE1BQU0sRUFBRSxFQUNsQyxPQUFPLEdBQUcsc0NBQTJCLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWpFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMseUJBQXlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekMsTUFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNoQyxPQUFPO2FBQ1AsY0FBYyxDQUFDLHVCQUFhLENBQUMsQ0FBQztRQUVuQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFFakMsQ0FBQyxDQUFDLENBQUM7SUFD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Q0FBQyxDQUFDO0lBQ2xELENBQUMsQ0FBQyxDQUFDO0FBRVAsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvZmVycmFuL3VuaS9jb21wdXRhY2lvL25vem9tYS1mb3JrL3NyYy9jb250ZXh0cy9iYWNrb2ZmaWNlL2NvbW1lcmNlcy9hcHAvY3JlYXRlL0NvbW1lcmNlQ3JlYXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21tZXJjZUNyZWF0b3IgZnJvbSAnQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ29tbWVyY2VDcmVhdG9yJztcbmltcG9ydCBDb21tZXJjZVJlcG9zaXRvcnlNb2NrIGZyb20gJ0BiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9fX21vY2tzX18vQ29tbWVyY2VSZXBvc2l0b3J5Lm1vY2snO1xuaW1wb3J0IENvbW1lcmNlQ3JlYXRvckhhbmRsZXIgZnJvbSAnQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ29tbWVyY2VDcmVhdG9ySGFuZGxlcic7XG5pbXBvcnQgRXZlbnRCdXNNb2NrIGZyb20gJ0BzaGFyZWQvX19tb2Nrc19fL0V2ZW50QnVzLm1vY2snO1xuaW1wb3J0IENvbW1lcmNlTW90aGVyIGZyb20gJ0BiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9tb3RoZXJzL0NvbW1lcmNlLm1vdGhlcic7XG5pbXBvcnQgQ3JlYXRlQ29tbWVyY2VDb21tYW5kTW90aGVyIGZyb20gJ0BiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9tb3RoZXJzL0NyZWF0ZUNvbW1lcmNlQ29tbWFuZC5tb3RoZXInO1xuaW1wb3J0IEFscmVhZHlFeGlzdHMgZnJvbSAnQHNoYXJlZC9kb21haW4vQWxyZWFkeUV4aXN0cyc7XG5pbXBvcnQgQ29tbWVyY2VDcmVhdGVkRXZlbnRNb3RoZXIgZnJvbSAnQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL21vdGhlcnMvQ29tbWVyY2VDcmVhdGVkRXZlbnQubW90aGVyJztcblxuZGVzY3JpYmUoQ29tbWVyY2VDcmVhdG9yLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBBbHJlYWR5RXhpc3RzIHdoZW4gY29tbWVyY2Ugd2l0aCBzYW1lIGVtYWlsIGFscmVhZHkgZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXBvID0gbmV3IENvbW1lcmNlUmVwb3NpdG9yeU1vY2soKSxcbiAgICAgICAgICAgIGNyZWF0b3IgPSBuZXcgQ29tbWVyY2VDcmVhdG9yKHJlcG8sIG5ldyBFdmVudEJ1c01vY2soKSksXG4gICAgICAgICAgICBoYW5kbGVyID0gbmV3IENvbW1lcmNlQ3JlYXRvckhhbmRsZXIoY3JlYXRvciksXG4gICAgICAgICAgICBleHBlY3RlZCA9IENvbW1lcmNlTW90aGVyLnJhbmRvbSgpLFxuICAgICAgICAgICAgY29tbWFuZCA9IENyZWF0ZUNvbW1lcmNlQ29tbWFuZE1vdGhlci5mcm9tQ29tbWVyY2UoZXhwZWN0ZWQpO1xuXG4gICAgICAgIHJlcG8ud2hlbkZpbmRCeUlkVGhlblJldHVybihudWxsKTtcbiAgICAgICAgcmVwby53aGVuRmluZEJ5RW1haWxUaGVuUmV0dXJuKGV4cGVjdGVkKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QoaGFuZGxlci5oYW5kbGUoY29tbWFuZCkpXG4gICAgICAgICAgICAucmVqZWN0c1xuICAgICAgICAgICAgLnRvQmVJbnN0YW5jZU9mKEFscmVhZHlFeGlzdHMpO1xuXG4gICAgICAgIHJlcG8uYXNzZXJ0RmluZEJ5RW1haWxJc0NhbGxlZFdpdGgoZXhwZWN0ZWQuZW1haWwpO1xuICAgICAgICByZXBvLmFzc2VydEZpbmRJZElzQ2FsbGVkV2l0aChleHBlY3RlZC5pZCk7XG4gICAgICAgIHJlcG8uYXNzZXJ0U2F2ZUlzTm90Q2FsbGVkKCk7XG5cbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIGZhaWwgd2hlbiBjb21tZXJjZSB3aXRoIHNhbWUgZW1haWwgZmFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVwbyA9IG5ldyBDb21tZXJjZVJlcG9zaXRvcnlNb2NrKCksXG4gICAgICAgICAgICBjcmVhdG9yID0gbmV3IENvbW1lcmNlQ3JlYXRvcihyZXBvLCBuZXcgRXZlbnRCdXNNb2NrKCkpLFxuICAgICAgICAgICAgaGFuZGxlciA9IG5ldyBDb21tZXJjZUNyZWF0b3JIYW5kbGVyKGNyZWF0b3IpLFxuICAgICAgICAgICAgZXhwZWN0ZWQgPSBDb21tZXJjZU1vdGhlci5yYW5kb20oKSxcbiAgICAgICAgICAgIGNvbW1hbmQgPSBDcmVhdGVDb21tZXJjZUNvbW1hbmRNb3RoZXIuZnJvbUNvbW1lcmNlKGV4cGVjdGVkKTtcblxuICAgICAgICByZXBvLndoZW5GaW5kQnlJZFRoZW5SZXR1cm4oZXhwZWN0ZWQpO1xuICAgICAgICByZXBvLndoZW5GaW5kQnlFbWFpbFRoZW5SZXR1cm4obnVsbCk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KGhhbmRsZXIuaGFuZGxlKGNvbW1hbmQpKVxuICAgICAgICAgICAgLnJlamVjdHNcbiAgICAgICAgICAgIC50b0JlSW5zdGFuY2VPZihBbHJlYWR5RXhpc3RzKTtcblxuICAgICAgICByZXBvLmFzc2VydEZpbmRCeUVtYWlsSXNDYWxsZWRXaXRoKGV4cGVjdGVkLmVtYWlsKTtcbiAgICAgICAgcmVwby5hc3NlcnRGaW5kSWRJc0NhbGxlZFdpdGgoZXhwZWN0ZWQuaWQpO1xuICAgICAgICByZXBvLmFzc2VydFNhdmVJc05vdENhbGxlZCgpO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IGNvbW1lcmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXBvID0gbmV3IENvbW1lcmNlUmVwb3NpdG9yeU1vY2soKSxcbiAgICAgICAgICAgIGNyZWF0b3IgPSBuZXcgQ29tbWVyY2VDcmVhdG9yKHJlcG8sIG5ldyBFdmVudEJ1c01vY2soKSksXG4gICAgICAgICAgICBoYW5kbGVyID0gbmV3IENvbW1lcmNlQ3JlYXRvckhhbmRsZXIoY3JlYXRvciksXG4gICAgICAgICAgICBleHBlY3RlZCA9IENvbW1lcmNlTW90aGVyLnJhbmRvbSgpLFxuICAgICAgICAgICAgY29tbWFuZCA9IENyZWF0ZUNvbW1lcmNlQ29tbWFuZE1vdGhlci5mcm9tQ29tbWVyY2UoZXhwZWN0ZWQpO1xuXG4gICAgICAgIHJlcG8ud2hlbkZpbmRCeUlkVGhlblJldHVybihudWxsKTtcbiAgICAgICAgcmVwby53aGVuRmluZEJ5RW1haWxUaGVuUmV0dXJuKG51bGwpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvbmUtdmFyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5oYW5kbGUoY29tbWFuZCk7XG5cbiAgICAgICAgcmVwby5hc3NlcnRGaW5kQnlFbWFpbElzQ2FsbGVkV2l0aChleHBlY3RlZC5lbWFpbCk7XG4gICAgICAgIHJlcG8uYXNzZXJ0RmluZElkSXNDYWxsZWRXaXRoKGV4cGVjdGVkLmlkKTtcbiAgICAgICAgcmVwby5hc3NlcnRTYXZlSXNDYWxsZWRXaXRoKGV4cGVjdGVkKTtcblxuICAgICAgICBleHBlY3QocmVzcG9uc2UuZGF0YSlcbiAgICAgICAgICAgIC50b1N0cmljdEVxdWFsKGV4cGVjdGVkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHVibGlzaCBDb21tZXJjZUNyZWF0ZWRFdmVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVwbyA9IG5ldyBDb21tZXJjZVJlcG9zaXRvcnlNb2NrKCksXG4gICAgICAgICAgICBldmVudEJ1cyA9IG5ldyBFdmVudEJ1c01vY2soKSxcbiAgICAgICAgICAgIGNyZWF0b3IgPSBuZXcgQ29tbWVyY2VDcmVhdG9yKHJlcG8sIGV2ZW50QnVzKSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBuZXcgQ29tbWVyY2VDcmVhdG9ySGFuZGxlcihjcmVhdG9yKSxcbiAgICAgICAgICAgIGNvbW1lcmNlID0gQ29tbWVyY2VNb3RoZXIucmFuZG9tKCksXG4gICAgICAgICAgICBjb21tYW5kID0gQ3JlYXRlQ29tbWVyY2VDb21tYW5kTW90aGVyLmZyb21Db21tZXJjZShjb21tZXJjZSksXG4gICAgICAgICAgICBleHBlY3RlZCA9IENvbW1lcmNlQ3JlYXRlZEV2ZW50TW90aGVyLmZyb21Db21tZXJjZShjb21tZXJjZSk7XG5cbiAgICAgICAgcmVwby53aGVuRmluZEJ5SWRUaGVuUmV0dXJuKG51bGwpO1xuICAgICAgICByZXBvLndoZW5GaW5kQnlFbWFpbFRoZW5SZXR1cm4obnVsbCk7XG5cbiAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGUoY29tbWFuZCk7XG5cbiAgICAgICAgZXZlbnRCdXMuYXNzZXJ0TGFzdFB1Ymxpc2hlZEV2ZW50SXMoZXhwZWN0ZWQpO1xuICAgIH0pO1xuXG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==
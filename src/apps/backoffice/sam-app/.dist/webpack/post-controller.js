/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../../node_modules/aws-sdk/clients/cognitoidentity.js":
/*!*******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/clients/cognitoidentity.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/node_loader */ "../../../../node_modules/aws-sdk/lib/node_loader.js");
var AWS = __webpack_require__(/*! ../lib/core */ "../../../../node_modules/aws-sdk/lib/core.js");
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/cognito-identity-2014-06-30.min.json */ "../../../../node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/cognito-identity-2014-06-30.paginators.json */ "../../../../node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json").pagination);
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/clients/dynamodb.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/clients/dynamodb.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/node_loader */ "../../../../node_modules/aws-sdk/lib/node_loader.js");
var AWS = __webpack_require__(/*! ../lib/core */ "../../../../node_modules/aws-sdk/lib/core.js");
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['dynamodb'] = {};
AWS.DynamoDB = Service.defineService('dynamodb', ['2011-12-05', '2012-08-10']);
__webpack_require__(/*! ../lib/services/dynamodb */ "../../../../node_modules/aws-sdk/lib/services/dynamodb.js");
Object.defineProperty(apiLoader.services['dynamodb'], '2011-12-05', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/dynamodb-2011-12-05.min.json */ "../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/dynamodb-2011-12-05.paginators.json */ "../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.paginators.json").pagination);
    model.waiters = (__webpack_require__(/*! ../apis/dynamodb-2011-12-05.waiters2.json */ "../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.waiters2.json").waiters);
    return model;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(apiLoader.services['dynamodb'], '2012-08-10', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/dynamodb-2012-08-10.min.json */ "../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/dynamodb-2012-08-10.paginators.json */ "../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.paginators.json").pagination);
    model.waiters = (__webpack_require__(/*! ../apis/dynamodb-2012-08-10.waiters2.json */ "../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.waiters2.json").waiters);
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.DynamoDB;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/clients/sts.js":
/*!*******************************************************!*\
  !*** ../../../../node_modules/aws-sdk/clients/sts.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/node_loader */ "../../../../node_modules/aws-sdk/lib/node_loader.js");
var AWS = __webpack_require__(/*! ../lib/core */ "../../../../node_modules/aws-sdk/lib/core.js");
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
__webpack_require__(/*! ../lib/services/sts */ "../../../../node_modules/aws-sdk/lib/services/sts.js");
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/sts-2011-06-15.min.json */ "../../../../node_modules/aws-sdk/apis/sts-2011-06-15.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/sts-2011-06-15.paginators.json */ "../../../../node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json").pagination);
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/api_loader.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/api_loader.js ***!
  \**********************************************************/
/***/ ((module) => {

function apiLoader(svc, version) {
  if (!apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return apiLoader.services[svc][version];
}

/**
 * @api private
 *
 * This member of AWS.apiLoader is private, but changing it will necessitate a
 * change to ../scripts/services-table-generator.ts
 */
apiLoader.services = {};

/**
 * @api private
 */
module.exports = apiLoader;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/config.js":
/*!******************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/config.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ./credentials */ "../../../../node_modules/aws-sdk/lib/credentials.js");
__webpack_require__(/*! ./credentials/credential_provider_chain */ "../../../../node_modules/aws-sdk/lib/credentials/credential_provider_chain.js");
var PromisesDependency;

/**
 * The main configuration class used by all service objects to set
 * the region, credentials, and other options for requests.
 *
 * By default, credentials and region settings are left unconfigured.
 * This should be configured by the application before using any
 * AWS service APIs.
 *
 * In order to set global configuration options, properties should
 * be assigned to the global {AWS.config} object.
 *
 * @see AWS.config
 *
 * @!group General Configuration Options
 *
 * @!attribute credentials
 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
 *
 * @!attribute region
 *   @example Set the global region setting to us-west-2
 *     AWS.config.update({region: 'us-west-2'});
 *   @return [AWS.Credentials] The region to send service requests to.
 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
 *     A list of available endpoints for each AWS service
 *
 * @!attribute maxRetries
 *   @return [Integer] the maximum amount of retries to perform for a
 *     service request. By default this value is calculated by the specific
 *     service object that the request is being made to.
 *
 * @!attribute maxRedirects
 *   @return [Integer] the maximum amount of redirects to follow for a
 *     service request. Defaults to 10.
 *
 * @!attribute paramValidation
 *   @return [Boolean|map] whether input parameters should be validated against
 *     the operation description before sending the request. Defaults to true.
 *     Pass a map to enable any of the following specific validation features:
 *
 *     * **min** [Boolean] &mdash; Validates that a value meets the min
 *       constraint. This is enabled by default when paramValidation is set
 *       to `true`.
 *     * **max** [Boolean] &mdash; Validates that a value meets the max
 *       constraint.
 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
 *       regular expression.
 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
 *       of the allowable enum values.
 *
 * @!attribute computeChecksums
 *   @return [Boolean] whether to compute checksums for payload bodies when
 *     the service accepts it (currently supported in S3 and SQS only).
 *
 * @!attribute convertResponseTypes
 *   @return [Boolean] whether types are converted when parsing response data.
 *     Currently only supported for JSON based services. Turning this off may
 *     improve performance on large response payloads. Defaults to `true`.
 *
 * @!attribute correctClockSkew
 *   @return [Boolean] whether to apply a clock skew correction and retry
 *     requests that fail because of an skewed client clock. Defaults to
 *     `false`.
 *
 * @!attribute sslEnabled
 *   @return [Boolean] whether SSL is enabled for requests
 *
 * @!attribute s3ForcePathStyle
 *   @return [Boolean] whether to force path style URLs for S3 objects
 *
 * @!attribute s3BucketEndpoint
 *   @note Setting this configuration option requires an `endpoint` to be
 *     provided explicitly to the service constructor.
 *   @return [Boolean] whether the provided endpoint addresses an individual
 *     bucket (false if it addresses the root API endpoint).
 *
 * @!attribute s3DisableBodySigning
 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
 *     Body signing can only be disabled when using https. Defaults to `true`.
 *
 * @!attribute s3UsEast1RegionalEndpoint
 *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
 *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
 *     applicable to S3 client;
 *     Defaults to 'legacy'
 * @!attribute s3UseArnRegion
 *   @return [Boolean] whether to override the request region with the region inferred
 *     from requested resource's ARN. Only available for S3 buckets
 *     Defaults to `true`
 *
 * @!attribute useAccelerateEndpoint
 *   @note This configuration option is only compatible with S3 while accessing
 *     dns-compatible buckets.
 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
 *     Defaults to `false`.
 *
 * @!attribute retryDelayOptions
 *   @example Set the base retry delay for all services to 300 ms
 *     AWS.config.update({retryDelayOptions: {base: 300}});
 *     // Delays with maxRetries = 3: 300, 600, 1200
 *   @example Set a custom backoff function to provide delay values on retries
 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
 *       // returns delay in ms
 *     }}});
 *   @return [map] A set of options to configure the retry delay on retryable errors.
 *     Currently supported options are:
 *
 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
 *       DynamoDB, where it defaults to 50ms.
 *
 *     * **customBackoff ** [function] &mdash; A custom function that accepts a
 *       retry count and error and returns the amount of time to delay in
 *       milliseconds. If the result is a non-zero negative value, no further
 *       retry attempts will be made. The `base` option will be ignored if this
 *       option is supplied. The function is only called for retryable errors.
 *
 * @!attribute httpOptions
 *   @return [map] A set of options to pass to the low-level HTTP request.
 *     Currently supported options are:
 *
 *     * **proxy** [String] &mdash; the URL to proxy requests through
 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
 *       HTTP requests with. Used for connection pooling. Note that for
 *       SSL connections, a special Agent object is used in order to enable
 *       peer certificate verification. This feature is only supported in the
 *       Node.js environment.
 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
 *       failing to establish a connection with the server after
 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
 *       connection has been established.
 *     * **timeout** [Integer] &mdash; The number of milliseconds a request can
 *       take before automatically being terminated.
 *       Defaults to two minutes (120000).
 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
 *       HTTP requests. Used in the browser environment only. Set to false to
 *       send requests synchronously. Defaults to true (async on).
 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
 *       property of an XMLHttpRequest object. Used in the browser environment
 *       only. Defaults to false.
 * @!attribute logger
 *   @return [#write,#log] an object that responds to .write() (like a stream)
 *     or .log() (like the console object) in order to log information about
 *     requests
 *
 * @!attribute systemClockOffset
 *   @return [Number] an offset value in milliseconds to apply to all signing
 *     times. Use this to compensate for clock skew when your system may be
 *     out of sync with the service time. Note that this configuration option
 *     can only be applied to the global `AWS.config` object and cannot be
 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
 *
 * @!attribute signatureVersion
 *   @return [String] the signature version to sign requests with (overriding
 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
 *
 * @!attribute signatureCache
 *   @return [Boolean] whether the signature to sign requests with (overriding
 *     the API configuration) is cached. Only applies to the signature version 'v4'.
 *     Defaults to `true`.
 *
 * @!attribute endpointDiscoveryEnabled
 *   @return [Boolean|undefined] whether to call operations with endpoints
 *     given by service dynamically. Setting this config to `true` will enable
 *     endpoint discovery for all applicable operations. Setting it to `false`
 *     will explicitly disable endpoint discovery even though operations that
 *     require endpoint discovery will presumably fail. Leaving it to
 *     `undefined` means SDK only do endpoint discovery when it's required.
 *     Defaults to `undefined`
 *
 * @!attribute endpointCacheSize
 *   @return [Number] the size of the global cache storing endpoints from endpoint
 *     discovery operations. Once endpoint cache is created, updating this setting
 *     cannot change existing cache size.
 *     Defaults to 1000
 *
 * @!attribute hostPrefixEnabled
 *   @return [Boolean] whether to marshal request parameters to the prefix of
 *     hostname. Defaults to `true`.
 *
 * @!attribute stsRegionalEndpoints
 *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
 *     regional endpoints.
 *     Defaults to 'legacy'.
 *
 * @!attribute useFipsEndpoint
 *   @return [Boolean] Enables FIPS compatible endpoints. Defaults to `false`.
 *
 * @!attribute useDualstackEndpoint
 *   @return [Boolean] Enables IPv6 dualstack endpoint. Defaults to `false`.
 */
AWS.Config = AWS.util.inherit({
  /**
   * @!endgroup
   */

  /**
   * Creates a new configuration object. This is the object that passes
   * option data along to service requests, including credentials, security,
   * region information, and some service specific settings.
   *
   * @example Creating a new configuration object with credentials and region
   *   var config = new AWS.Config({
   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
   *   });
   * @option options accessKeyId [String] your AWS access key ID.
   * @option options secretAccessKey [String] your AWS secret access key.
   * @option options sessionToken [AWS.Credentials] the optional AWS
   *   session token to sign requests with.
   * @option options credentials [AWS.Credentials] the AWS credentials
   *   to sign requests with. You can either specify this object, or
   *   specify the accessKeyId and secretAccessKey options directly.
   * @option options credentialProvider [AWS.CredentialProviderChain] the
   *   provider chain used to resolve credentials if no static `credentials`
   *   property is set.
   * @option options region [String] the region to send service requests to.
   *   See {region} for more information.
   * @option options maxRetries [Integer] the maximum amount of retries to
   *   attempt with a request. See {maxRetries} for more information.
   * @option options maxRedirects [Integer] the maximum amount of redirects to
   *   follow with a request. See {maxRedirects} for more information.
   * @option options sslEnabled [Boolean] whether to enable SSL for
   *   requests.
   * @option options paramValidation [Boolean|map] whether input parameters
   *   should be validated against the operation description before sending
   *   the request. Defaults to true. Pass a map to enable any of the
   *   following specific validation features:
   *
   *   * **min** [Boolean] &mdash; Validates that a value meets the min
   *     constraint. This is enabled by default when paramValidation is set
   *     to `true`.
   *   * **max** [Boolean] &mdash; Validates that a value meets the max
   *     constraint.
   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *     regular expression.
   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
   *     of the allowable enum values.
   * @option options computeChecksums [Boolean] whether to compute checksums
   *   for payload bodies when the service accepts it (currently supported
   *   in S3 only)
   * @option options convertResponseTypes [Boolean] whether types are converted
   *     when parsing response data. Currently only supported for JSON based
   *     services. Turning this off may improve performance on large response
   *     payloads. Defaults to `true`.
   * @option options correctClockSkew [Boolean] whether to apply a clock skew
   *     correction and retry requests that fail because of an skewed client
   *     clock. Defaults to `false`.
   * @option options s3ForcePathStyle [Boolean] whether to force path
   *   style URLs for S3 objects.
   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
   *   addresses an individual bucket (false if it addresses the root API
   *   endpoint). Note that setting this configuration option requires an
   *   `endpoint` to be provided explicitly to the service constructor.
   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
   *   should be disabled when using signature version `v4`. Body signing
   *   can only be disabled when using https. Defaults to `true`.
   * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
   *   is set to 'us-east-1', whether to send s3 request to global endpoints or
   *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
   *   Defaults to `legacy`
   * @option options s3UseArnRegion [Boolean] whether to override the request region
   *   with the region inferred from requested resource's ARN. Only available for S3 buckets
   *   Defaults to `true`
   *
   * @option options retryDelayOptions [map] A set of options to configure
   *   the retry delay on retryable errors. Currently supported options are:
   *
   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
   *     exponential backoff for operation retries. Defaults to 100 ms for all
   *     services except DynamoDB, where it defaults to 50ms.
   *   * **customBackoff ** [function] &mdash; A custom function that accepts a
   *     retry count and error and returns the amount of time to delay in
   *     milliseconds. If the result is a non-zero negative value, no further
   *     retry attempts will be made. The `base` option will be ignored if this
   *     option is supplied. The function is only called for retryable errors.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
   *     milliseconds of inactivity on the socket. Defaults to two minutes
   *     (120000).
   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
   *     HTTP requests. Used in the browser environment only. Set to false to
   *     send requests synchronously. Defaults to true (async on).
   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
   *     property of an XMLHttpRequest object. Used in the browser environment
   *     only. Defaults to false.
   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
   *   (or a date) that represents the latest possible API version that can be
   *   used in all services (unless overridden by `apiVersions`). Specify
   *   'latest' to use the latest possible version.
   * @option options apiVersions [map<String, String|Date>] a map of service
   *   identifiers (the lowercase service class name) with the API version to
   *   use when instantiating a service. Specify 'latest' for each individual
   *   that can use the latest available version.
   * @option options logger [#write,#log] an object that responds to .write()
   *   (like a stream) or .log() (like the console object) in order to log
   *   information about requests
   * @option options systemClockOffset [Number] an offset value in milliseconds
   *   to apply to all signing times. Use this to compensate for clock skew
   *   when your system may be out of sync with the service time. Note that
   *   this configuration option can only be applied to the global `AWS.config`
   *   object and cannot be overridden in service-specific configuration.
   *   Defaults to 0 milliseconds.
   * @option options signatureVersion [String] the signature version to sign
   *   requests with (overriding the API configuration). Possible values are:
   *   'v2', 'v3', 'v4'.
   * @option options signatureCache [Boolean] whether the signature to sign
   *   requests with (overriding the API configuration) is cached. Only applies
   *   to the signature version 'v4'. Defaults to `true`.
   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
   * @option options useAccelerateEndpoint [Boolean] Whether to use the
   *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
   * @option options clientSideMonitoring [Boolean] whether to collect and
   *   publish this client's performance metrics of all its API requests.
   * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
   *   call operations with endpoints given by service dynamically. Setting this
   * config to `true` will enable endpoint discovery for all applicable operations.
   *   Setting it to `false` will explicitly disable endpoint discovery even though
   *   operations that require endpoint discovery will presumably fail. Leaving it
   *   to `undefined` means SDK will only do endpoint discovery when it's required.
   *   Defaults to `undefined`
   * @option options endpointCacheSize [Number] the size of the global cache storing
   *   endpoints from endpoint discovery operations. Once endpoint cache is created,
   *   updating this setting cannot change existing cache size.
   *   Defaults to 1000
   * @option options hostPrefixEnabled [Boolean] whether to marshal request
   *   parameters to the prefix of hostname.
   *   Defaults to `true`.
   * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
   *   to global endpoints or regional endpoints.
   *   Defaults to 'legacy'.
   * @option options useFipsEndpoint [Boolean] Enables FIPS compatible endpoints.
   *   Defaults to `false`.
   * @option options useDualstackEndpoint [Boolean] Enables IPv6 dualstack endpoint.
   *   Defaults to `false`.
   */
  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },

  /**
   * @!group Managing Credentials
   */

  /**
   * Loads credentials from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Credentials} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your credentials are loaded prior to a request, you can use this method
   * directly to provide accurate credential data stored in the object.
   *
   * @note If you configure the SDK with static or environment credentials,
   *   the credential data should already be present in {credentials} attribute.
   *   This method is primarily necessary to load credentials from asynchronous
   *   sources, or sources that can refresh credentials periodically.
   * @example Getting your access key
   *   AWS.config.getCredentials(function(err) {
   *     if (err) console.log(err.stack); // credentials not loaded
   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
   *   })
   * @callback callback function(err)
   *   Called when the {credentials} have been properly set on the configuration
   *   object.
   *
   *   @param err [Error] if this is set, credentials were not successfully
   *     loaded and this error provides information why.
   * @see credentials
   * @see Credentials
   */
  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError',
        message: msg,
        name: 'CredentialsError'
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },

  /**
   * @!group Loading and Setting Configuration Options
   */

  /**
   * @overload update(options, allowUnknownKeys = false)
   *   Updates the current configuration object with new options.
   *
   *   @example Update maxRetries property of a configuration object
   *     config.update({maxRetries: 10});
   *   @param [Object] options a map of option keys and values.
   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
   *     the configuration object. Defaults to `false`.
   *   @see constructor
   */
  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },

  /**
   * Loads configuration data from a JSON file into this config object.
   * @note Loading configuration will reset all existing configuration
   *   on the object.
   * @!macro nobrowser
   * @param path [String] the path relative to your process's current
   *    working directory to load configuration from.
   * @return [AWS.Config] the same configuration object
   */
  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },

  /**
   * Clears configuration data on this object
   *
   * @api private
   */
  clear: function clear() {
    /*jshint forin:false */
    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    // reset credential provider
    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },

  /**
   * Sets a property on the configuration object, allowing for a
   * default value
   * @api private
   */
  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      // deep merge httpOptions
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },

  /**
   * All of the keys with their default values.
   *
   * @constant
   * @api private
   */
  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    s3UsEast1RegionalEndpoint: 'legacy',
    s3UseArnRegion: undefined,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {},
    useAccelerateEndpoint: false,
    clientSideMonitoring: false,
    endpointDiscoveryEnabled: undefined,
    endpointCacheSize: 1000,
    hostPrefixEnabled: true,
    stsRegionalEndpoints: 'legacy',
    useFipsEndpoint: false,
    useDualstackEndpoint: false
  },

  /**
   * Extracts accessKeyId, secretAccessKey and sessionToken
   * from a configuration hash.
   *
   * @api private
   */
  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },

  /**
   * Sets the promise dependency the SDK will use wherever Promises are returned.
   * Passing `null` will force the SDK to use native Promises if they are available.
   * If native Promises are not available, passing `null` will have no effect.
   * @param [Constructor] dep A reference to a Promise constructor
   */
  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    // if null was passed in, we should try to use native promises
    if (dep === null && typeof Promise === 'function') {
      PromisesDependency = Promise;
    }
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3) {
      constructors.push(AWS.S3);
      if (AWS.S3.ManagedUpload) {
        constructors.push(AWS.S3.ManagedUpload);
      }
    }
    AWS.util.addPromises(constructors, PromisesDependency);
  },

  /**
   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
   */
  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});

/**
 * @return [AWS.Config] The global configuration object singleton instance
 * @readonly
 * @see AWS.Config
 */
AWS.config = new AWS.Config();


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/config_regional_endpoint.js":
/*!************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/config_regional_endpoint.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
/**
 * @api private
 */
function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
  if (typeof configValue !== 'string') return undefined;
  else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
    return configValue.toLowerCase();
  } else {
    throw AWS.util.error(new Error(), errorOptions);
  }
}

/**
 * Resolve the configuration value for regional endpoint from difference sources: client
 * config, environmental variable, shared config file. Value can be case-insensitive
 * 'legacy' or 'reginal'.
 * @param originalConfig user-supplied config object to resolve
 * @param options a map of config property names from individual configuration source
 *  - env: name of environmental variable that refers to the config
 *  - sharedConfig: name of shared configuration file property that refers to the config
 *  - clientConfig: name of client configuration property that refers to the config
 *
 * @api private
 */
function resolveRegionalEndpointsFlag(originalConfig, options) {
  originalConfig = originalConfig || {};
  //validate config value
  var resolved;
  if (originalConfig[options.clientConfig]) {
    resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
      code: 'InvalidConfiguration',
      message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy" ' +
      ' or "regional". Got "' + originalConfig[options.clientConfig] + '".'
    });
    if (resolved) return resolved;
  }
  if (!AWS.util.isNode()) return resolved;
  //validate environmental variable
  if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
    var envFlag = process.env[options.env];
    resolved = validateRegionalEndpointsFlagValue(envFlag, {
      code: 'InvalidEnvironmentalVariable',
      message: 'invalid ' + options.env + ' environmental variable. Expect "legacy" ' +
      ' or "regional". Got "' + process.env[options.env] + '".'
    });
    if (resolved) return resolved;
  }
  //validate shared config file
  var profile = {};
  try {
    var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
    profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
  } catch (e) {};
  if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
    var fileFlag = profile[options.sharedConfig];
    resolved = validateRegionalEndpointsFlagValue(fileFlag, {
      code: 'InvalidConfiguration',
      message: 'invalid ' + options.sharedConfig + ' profile config. Expect "legacy" ' +
      ' or "regional". Got "' + profile[options.sharedConfig] + '".'
    });
    if (resolved) return resolved;
  }
  return resolved;
}

module.exports = resolveRegionalEndpointsFlag;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/core.js":
/*!****************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/core.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * The main AWS namespace
 */
var AWS = { util: __webpack_require__(/*! ./util */ "../../../../node_modules/aws-sdk/lib/util.js") };

/**
 * @api private
 * @!macro [new] nobrowser
 *   @note This feature is not supported in the browser environment of the SDK.
 */
var _hidden = {}; _hidden.toString(); // hack to parse macro

/**
 * @api private
 */
module.exports = AWS;

AWS.util.update(AWS, {

  /**
   * @constant
   */
  VERSION: '2.1126.0',

  /**
   * @api private
   */
  Signers: {},

  /**
   * @api private
   */
  Protocol: {
    Json: __webpack_require__(/*! ./protocol/json */ "../../../../node_modules/aws-sdk/lib/protocol/json.js"),
    Query: __webpack_require__(/*! ./protocol/query */ "../../../../node_modules/aws-sdk/lib/protocol/query.js"),
    Rest: __webpack_require__(/*! ./protocol/rest */ "../../../../node_modules/aws-sdk/lib/protocol/rest.js"),
    RestJson: __webpack_require__(/*! ./protocol/rest_json */ "../../../../node_modules/aws-sdk/lib/protocol/rest_json.js"),
    RestXml: __webpack_require__(/*! ./protocol/rest_xml */ "../../../../node_modules/aws-sdk/lib/protocol/rest_xml.js")
  },

  /**
   * @api private
   */
  XML: {
    Builder: __webpack_require__(/*! ./xml/builder */ "../../../../node_modules/aws-sdk/lib/xml/builder.js"),
    Parser: null // conditionally set based on environment
  },

  /**
   * @api private
   */
  JSON: {
    Builder: __webpack_require__(/*! ./json/builder */ "../../../../node_modules/aws-sdk/lib/json/builder.js"),
    Parser: __webpack_require__(/*! ./json/parser */ "../../../../node_modules/aws-sdk/lib/json/parser.js")
  },

  /**
   * @api private
   */
  Model: {
    Api: __webpack_require__(/*! ./model/api */ "../../../../node_modules/aws-sdk/lib/model/api.js"),
    Operation: __webpack_require__(/*! ./model/operation */ "../../../../node_modules/aws-sdk/lib/model/operation.js"),
    Shape: __webpack_require__(/*! ./model/shape */ "../../../../node_modules/aws-sdk/lib/model/shape.js"),
    Paginator: __webpack_require__(/*! ./model/paginator */ "../../../../node_modules/aws-sdk/lib/model/paginator.js"),
    ResourceWaiter: __webpack_require__(/*! ./model/resource_waiter */ "../../../../node_modules/aws-sdk/lib/model/resource_waiter.js")
  },

  /**
   * @api private
   */
  apiLoader: __webpack_require__(/*! ./api_loader */ "../../../../node_modules/aws-sdk/lib/api_loader.js"),

  /**
   * @api private
   */
  EndpointCache: (__webpack_require__(/*! ../vendor/endpoint-cache */ "../../../../node_modules/aws-sdk/vendor/endpoint-cache/index.js").EndpointCache)
});
__webpack_require__(/*! ./sequential_executor */ "../../../../node_modules/aws-sdk/lib/sequential_executor.js");
__webpack_require__(/*! ./service */ "../../../../node_modules/aws-sdk/lib/service.js");
__webpack_require__(/*! ./config */ "../../../../node_modules/aws-sdk/lib/config.js");
__webpack_require__(/*! ./http */ "../../../../node_modules/aws-sdk/lib/http.js");
__webpack_require__(/*! ./event_listeners */ "../../../../node_modules/aws-sdk/lib/event_listeners.js");
__webpack_require__(/*! ./request */ "../../../../node_modules/aws-sdk/lib/request.js");
__webpack_require__(/*! ./response */ "../../../../node_modules/aws-sdk/lib/response.js");
__webpack_require__(/*! ./resource_waiter */ "../../../../node_modules/aws-sdk/lib/resource_waiter.js");
__webpack_require__(/*! ./signers/request_signer */ "../../../../node_modules/aws-sdk/lib/signers/request_signer.js");
__webpack_require__(/*! ./param_validator */ "../../../../node_modules/aws-sdk/lib/param_validator.js");

/**
 * @readonly
 * @return [AWS.SequentialExecutor] a collection of global event listeners that
 *   are attached to every sent request.
 * @see AWS.Request AWS.Request for a list of events to listen for
 * @example Logging the time taken to send a request
 *   AWS.events.on('send', function startSend(resp) {
 *     resp.startTime = new Date().getTime();
 *   }).on('complete', function calculateTime(resp) {
 *     var time = (new Date().getTime() - resp.startTime) / 1000;
 *     console.log('Request took ' + time + ' seconds');
 *   });
 *
 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
 */
AWS.events = new AWS.SequentialExecutor();

//create endpoint cache lazily
AWS.util.memoizedProperty(AWS, 'endpointCache', function() {
  return new AWS.EndpointCache(AWS.config.endpointCacheSize);
}, true);


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Represents your AWS security credentials, specifically the
 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
 * Creating a `Credentials` object allows you to pass around your
 * security information to configuration and service objects.
 *
 * Note that this class typically does not need to be constructed manually,
 * as the {AWS.Config} and {AWS.Service} classes both accept simple
 * options hashes with the three keys. These structures will be converted
 * into Credentials objects automatically.
 *
 * ## Expiring and Refreshing Credentials
 *
 * Occasionally credentials can expire in the middle of a long-running
 * application. In this case, the SDK will automatically attempt to
 * refresh the credentials from the storage location if the Credentials
 * class implements the {refresh} method.
 *
 * If you are implementing a credential storage location, you
 * will want to create a subclass of the `Credentials` class and
 * override the {refresh} method. This method allows credentials to be
 * retrieved from the backing store, be it a file system, database, or
 * some network storage. The method should reset the credential attributes
 * on the object.
 *
 * @!attribute expired
 *   @return [Boolean] whether the credentials have been expired and
 *     require a refresh. Used in conjunction with {expireTime}.
 * @!attribute expireTime
 *   @return [Date] a time when credentials should be considered expired. Used
 *     in conjunction with {expired}.
 * @!attribute accessKeyId
 *   @return [String] the AWS access key ID
 * @!attribute secretAccessKey
 *   @return [String] the AWS secret access key
 * @!attribute sessionToken
 *   @return [String] an optional AWS session token
 */
AWS.Credentials = AWS.util.inherit({
  /**
   * A credentials object can be created using positional arguments or an options
   * hash.
   *
   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
   *   Creates a Credentials object with a given set of credential information
   *   as positional arguments.
   *   @param accessKeyId [String] the AWS access key ID
   *   @param secretAccessKey [String] the AWS secret access key
   *   @param sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
   * @overload AWS.Credentials(options)
   *   Creates a Credentials object with a given set of credential information
   *   as an options hash.
   *   @option options accessKeyId [String] the AWS access key ID
   *   @option options secretAccessKey [String] the AWS secret access key
   *   @option options sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials({
   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
   *     });
   */
  constructor: function Credentials() {
    // hide secretAccessKey from being displayed with util.inspect
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    this.refreshCallbacks = [];
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },

  /**
   * @return [Integer] the number of seconds before {expireTime} during which
   *   the credentials will be considered expired.
   */
  expiryWindow: 15,

  /**
   * @return [Boolean] whether the credentials object should call {refresh}
   * @note Subclasses should override this method to provide custom refresh
   *   logic.
   */
  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },

  /**
   * Gets the existing credentials, refreshing them if they are not yet loaded
   * or have expired. Users should call this method before using {refresh},
   * as this will not attempt to reload credentials when they are already
   * loaded into the object.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means either credentials
   *   do not need to be refreshed or refreshed credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   */
  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },

  /**
   * @!method  getPromise()
   *   Returns a 'thenable' promise.
   *   Gets the existing credentials, refreshing them if they are not yet loaded
   *   or have expired. Users should call this method before using {refresh},
   *   as this will not attempt to reload credentials when they are already
   *   loaded into the object.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means either credentials do not need to be refreshed or refreshed
   *     credentials information has been loaded into the object (as the
   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `get` call.
   *   @example Calling the `getPromise` method.
   *     var promise = credProvider.getPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * @!method  refreshPromise()
   *   Returns a 'thenable' promise.
   *   Refreshes the credentials. Users should call {get} before attempting
   *   to forcibly refresh credentials.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means refreshed credentials information has been loaded into the object
   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Calling the `refreshPromise` method.
   *     var promise = credProvider.refreshPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * Refreshes the credentials. Users should call {get} before attempting
   * to forcibly refresh credentials.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means refreshed
   *   credentials information has been loaded into the object (as the
   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @note Subclasses should override this class to reset the
   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
   *   on the credentials object and then call the callback with
   *   any error information.
   * @see get
   */
  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  },

  /**
   * @api private
   * @param callback
   */
  coalesceRefresh: function coalesceRefresh(callback, sync) {
    var self = this;
    if (self.refreshCallbacks.push(callback) === 1) {
      self.load(function onLoad(err) {
        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {
          if (sync) {
            callback(err);
          } else {
            // callback could throw, so defer to ensure all callbacks are notified
            AWS.util.defer(function () {
              callback(err);
            });
          }
        });
        self.refreshCallbacks.length = 0;
      });
    }
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    callback();
  }
});

/**
 * @api private
 */
AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};

/**
 * @api private
 */
AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js":
/*!*******************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in
 * the way masterCredentials and refreshes are handled.
 * AWS.ChainableTemporaryCredentials refreshes expired credentials using the
 * masterCredentials passed by the user to support chaining of STS credentials.
 * However, AWS.TemporaryCredentials recursively collapses the masterCredentials
 * during instantiation, precluding the ability to refresh credentials which
 * require intermediate, temporary credentials.
 *
 * For example, if the application should use RoleA, which must be assumed from
 * RoleB, and the environment provides credentials which can assume RoleB, then
 * AWS.ChainableTemporaryCredentials must be used to support refreshing the
 * temporary credentials for RoleA:
 *
 * ```javascript
 * var roleACreds = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: 'RoleA'},
 *   masterCredentials: new AWS.ChainableTemporaryCredentials({
 *     params: {RoleArn: 'RoleB'},
 *     masterCredentials: new AWS.EnvironmentCredentials('AWS')
 *   })
 * });
 * ```
 *
 * If AWS.TemporaryCredentials had been used in the previous example,
 * `roleACreds` would fail to refresh because `roleACreds` would
 * use the environment credentials for the AssumeRole request.
 *
 * Another difference is that AWS.ChainableTemporaryCredentials creates the STS
 * service instance during instantiation while AWS.TemporaryCredentials creates
 * the STS service instance during the first refresh. Creating the service
 * instance during instantiation effectively captures the master credentials
 * from the global config, so that subsequent changes to the global config do
 * not affect the master credentials used to refresh the temporary credentials.
 *
 * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned
 * to AWS.config.credentials:
 *
 * ```javascript
 * var envCreds = new AWS.EnvironmentCredentials('AWS');
 * AWS.config.credentials = envCreds;
 * // masterCredentials will be envCreds
 * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * Similarly, to use the CredentialProviderChain's default providers as the
 * master credentials, simply create a new instance of
 * AWS.ChainableTemporaryCredentials:
 *
 * ```javascript
 * AWS.config.credentials = new ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * @!attribute service
 *   @return [AWS.STS] the STS service instance used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @param options [map] a set of options
   * @option options params [map] ({}) a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
   *   also be passed in or an error will be thrown.
   * @option options masterCredentials [AWS.Credentials] the master credentials
   *   used to get and refresh temporary credentials from AWS STS. By default,
   *   AWS.config.credentials or AWS.config.credentialProvider will be used.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
   *   is called with value of `SerialNumber` and `callback`, and should provide
   *   the `TokenCode` or an error to the callback in the format
   *   `callback(err, token)`.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
   *     params: {
   *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
   *     }
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function ChainableTemporaryCredentials(options) {
    AWS.Credentials.call(this);
    options = options || {};
    this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
    this.expired = true;
    this.tokenCodeFn = null;

    var params = AWS.util.copy(options.params) || {};
    if (params.RoleArn) {
      params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
    }
    if (params.SerialNumber) {
      if (!options.tokenCodeFn || (typeof options.tokenCodeFn !== 'function')) {
        throw new AWS.util.error(
          new Error('tokenCodeFn must be a function when params.SerialNumber is given'),
          {code: this.errorCode}
        );
      } else {
        this.tokenCodeFn = options.tokenCodeFn;
      }
    }
    var config = AWS.util.merge(
      {
        params: params,
        credentials: options.masterCredentials || AWS.config.credentials
      },
      options.stsConfig || {}
    );
    this.service = new STS(config);
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
    this.getTokenCode(function (err, tokenCode) {
      var params = {};
      if (err) {
        callback(err);
        return;
      }
      if (tokenCode) {
        params.TokenCode = tokenCode;
      }
      self.service[operation](params, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  getTokenCode: function getTokenCode(callback) {
    var self = this;
    if (this.tokenCodeFn) {
      this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
        if (err) {
          var message = err;
          if (err instanceof Error) {
            message = err.message;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: self.errorCode}
            )
          );
          return;
        }
        callback(null, token);
      });
    } else {
      callback(null);
    }
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js":
/*!****************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var CognitoIdentity = __webpack_require__(/*! ../../clients/cognitoidentity */ "../../../../node_modules/aws-sdk/clients/cognitoidentity.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");

/**
 * Represents credentials retrieved from STS Web Identity Federation using
 * the Amazon Cognito Identity service.
 *
 * By default this provider gets credentials using the
 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
 * obtain an `IdentityId`. If the identity or identity pool is not configured in
 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
 * is provided, then this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
 *
 * In addition, if this credential provider is used to provide authenticated
 * login, the `Logins` map may be set to the tokens provided by the respective
 * identity providers. See {constructor} for an example on creating a credentials
 * object with proper property values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.CognitoIdentity.getId},
 *     {AWS.CognitoIdentity.getOpenIdToken}, and
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 * @!attribute identityId
 *   @return [String] the Cognito ID returned by the last call to
 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
 *     final resolved identity ID from Amazon Cognito.
 */
AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * @api private
   */
  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },

  /**
   * Creates a new credentials object.
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
   *
   *     // either IdentityPoolId or IdentityId is required
   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
   *
   *     // optional, only necessary when the identity pool is not configured
   *     // to use IAM roles in the Amazon Cognito Console
   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
   *
   *     // optional tokens, used for authenticated login
   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
   *     Logins: {
   *       'graph.facebook.com': 'FBTOKEN',
   *       'www.amazon.com': 'AMAZONTOKEN',
   *       'accounts.google.com': 'GOOGLETOKEN',
   *       'api.twitter.com': 'TWITTERTOKEN',
   *       'www.digits.com': 'DIGITSTOKEN'
   *     },
   *
   *     // optional name, defaults to web-identity
   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleSessionName: 'web',
   *
   *     // optional, only necessary when application runs in a browser
   *     // and multiple users are signed in at once, used for caching
   *     LoginId: 'example@gmail.com'
   *
   *   }, {
   *      // optionally provide configuration to apply to the underlying service clients
   *      // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *      // region should match the region your identity pool is located in
   *      region: 'us-east-1',
   *
   *      // specify timeout options
   *      httpOptions: {
   *        timeout: 100
   *      }
   *   });
   * @see AWS.CognitoIdentity.getId
   * @see AWS.CognitoIdentity.getCredentialsForIdentity
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.CognitoIdentity.getOpenIdToken
   * @see AWS.Config
   * @note If a region is not provided in the global AWS.config, or
   *   specified in the `clientConfig` to the CognitoIdentityCredentials
   *   constructor, you may encounter a 'Missing credentials in config' error
   *   when calling making a service call.
   */
  constructor: function CognitoIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this._identityId = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
    this.loadCachedId();
    var self = this;
    Object.defineProperty(this, 'identityId', {
      get: function() {
        self.loadCachedId();
        return self._identityId || self.params.IdentityId;
      },
      set: function(identityId) {
        self._identityId = identityId;
      }
    });
  },

  /**
   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
   * or {AWS.STS.assumeRoleWithWebIdentity}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self._identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * Clears the cached Cognito ID associated with the currently configured
   * identity pool ID. Use this to manually invalidate your cache if
   * the identity pool ID was deleted.
   */
  clearCachedId: function clearCache() {
    this._identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },

  /**
   * @api private
   */
  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },

  /**
   * Retrieves a Cognito ID, loading from cache if it was already retrieved
   * on this device.
   *
   * @callback callback function(err, identityId)
   *   @param err [Error, null] an error object if the call failed or null if
   *     it succeeded.
   *   @param identityId [String, null] if successful, the callback will return
   *     the Cognito ID.
   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
   *   localStorage in the browser environment of a device.
   * @api private
   */
  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },


  /**
   * @api private
   */
  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },

  /**
   * @api private
   */
  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * @api private
   */
  loadCachedId: function loadCachedId() {
    var self = this;

    // in the browser we source default IdentityId from localStorage
    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        // only load ID if at least one provider used this ID before
        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    var clientConfig = this._clientConfig;
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params, clientConfig);
    if (!this.cognito) {
      var cognitoConfig = AWS.util.merge({}, clientConfig);
      cognitoConfig.params = this.params;
      this.cognito = new CognitoIdentity(cognitoConfig);
    }
    this.sts = this.sts || new STS(clientConfig);
  },

  /**
   * @api private
   */
  cacheId: function cacheId(data) {
    this._identityId = data.IdentityId;
    this.params.IdentityId = this._identityId;

    // cache this IdentityId in browser localStorage if possible
    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },

  /**
   * @api private
   */
  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },

  /**
   * @api private
   */
  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },

  /**
   * @api private
   */
  storage: (function() {
    try {
      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
          window.localStorage : {};

      // Test set/remove which would throw an error in Safari's private browsing
      storage['aws.test-storage'] = 'foobar';
      delete storage['aws.test-storage'];

      return storage;
    } catch (_) {
      return {};
    }
  })()
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/credential_provider_chain.js":
/*!*************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/credential_provider_chain.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Creates a credential provider chain that searches for AWS credentials
 * in a list of credential providers specified by the {providers} property.
 *
 * By default, the chain will use the {defaultProviders} to resolve credentials.
 * These providers will look in the environment using the
 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
 *
 * ## Setting Providers
 *
 * Each provider in the {providers} list should be a function that returns
 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
 * form allows for delayed execution of the credential construction.
 *
 * ## Resolving Credentials from a Chain
 *
 * Call {resolve} to return the first valid credential object that can be
 * loaded by the provider chain.
 *
 * For example, to resolve a chain with a custom provider that checks a file
 * on disk after the set of {defaultProviders}:
 *
 * ```javascript
 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
 * var chain = new AWS.CredentialProviderChain();
 * chain.providers.push(diskProvider);
 * chain.resolve();
 * ```
 *
 * The above code will return the `diskProvider` object if the
 * file contains credentials and the `defaultProviders` do not contain
 * any credential settings.
 *
 * @!attribute providers
 *   @return [Array<AWS.Credentials, Function>]
 *     a list of credentials objects or functions that return credentials
 *     objects. If the provider is a function, the function will be
 *     executed lazily when the provider needs to be checked for valid
 *     credentials. By default, this object will be set to the
 *     {defaultProviders}.
 *   @see defaultProviders
 */
AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new CredentialProviderChain with a default set of providers
   * specified by {defaultProviders}.
   */
  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
    this.resolveCallbacks = [];
  },

  /**
   * @!method  resolvePromise()
   *   Returns a 'thenable' promise.
   *   Resolves the provider chain by searching for the first set of
   *   credentials in {providers}.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(credentials)
   *     Called if the promise is fulfilled and the provider resolves the chain
   *     to a credentials object
   *     @param credentials [AWS.Credentials] the credentials object resolved
   *       by the provider chain.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param err [Error] the error object returned if no credentials are found.
   *   @return [Promise] A promise that represents the state of the `resolve` method call.
   *   @example Calling the `resolvePromise` method.
   *     var promise = chain.resolvePromise();
   *     promise.then(function(credentials) { ... }, function(err) { ... });
   */

  /**
   * Resolves the provider chain by searching for the first set of
   * credentials in {providers}.
   *
   * @callback callback function(err, credentials)
   *   Called when the provider resolves the chain to a credentials object
   *   or null if no credentials can be found.
   *
   *   @param err [Error] the error object returned if no credentials are
   *     found.
   *   @param credentials [AWS.Credentials] the credentials object resolved
   *     by the provider chain.
   * @return [AWS.CredentialProviderChain] the provider, for chaining.
   */
  resolve: function resolve(callback) {
    var self = this;
    if (self.providers.length === 0) {
      callback(new Error('No providers'));
      return self;
    }

    if (self.resolveCallbacks.push(callback) === 1) {
      var index = 0;
      var providers = self.providers.slice(0);

      function resolveNext(err, creds) {
        if ((!err && creds) || index === providers.length) {
          AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
            callback(err, creds);
          });
          self.resolveCallbacks.length = 0;
          return;
        }

        var provider = providers[index++];
        if (typeof provider === 'function') {
          creds = provider.call();
        } else {
          creds = provider;
        }

        if (creds.get) {
          creds.get(function (getErr) {
            resolveNext(getErr, getErr ? null : creds);
          });
        } else {
          resolveNext(null, creds);
        }
      }

      resolveNext();
    }

    return self;
  }
});

/**
 * The default set of providers used by a vanilla CredentialProviderChain.
 *
 * In the browser:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = []
 * ```
 *
 * In Node.js:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = [
 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
 *   function () { return new AWS.SsoCredentials(); },
 *   function () { return new AWS.SharedIniFileCredentials(); },
 *   function () { return new AWS.ECSCredentials(); },
 *   function () { return new AWS.ProcessCredentials(); },
 *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
 *   function () { return new AWS.EC2MetadataCredentials() }
 * ]
 * ```
 */
AWS.CredentialProviderChain.defaultProviders = [];

/**
 * @api private
 */
AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};

/**
 * @api private
 */
AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js":
/*!************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ../metadata_service */ "../../../../node_modules/aws-sdk/lib/metadata_service.js");

/**
 * Represents credentials received from the metadata service on an EC2 instance.
 *
 * By default, this class will connect to the metadata service using
 * {AWS.MetadataService} and attempt to load any available credentials. If it
 * can connect, and credentials are available, these will be used with zero
 * configuration.
 *
 * This credentials class will by default timeout after 1 second of inactivity
 * and retry 3 times.
 * If your requests to the EC2 metadata service are timing out, you can increase
 * these values by configuring them directly:
 *
 * ```javascript
 * AWS.config.credentials = new AWS.EC2MetadataCredentials({
 *   httpOptions: { timeout: 5000 }, // 5 second timeout
 *   maxRetries: 10, // retry 10 times
 *   retryDelayOptions: { base: 200 }, // see AWS.Config for information
 *   logger: console // see AWS.Config for information
 * });
 * ```
 *
 * If your requests are timing out in connecting to the metadata service, such
 * as when testing on a development machine, you can use the connectTimeout
 * option, specified in milliseconds, which also defaults to 1 second.
 *
 * If the requests failed or returns expired credentials, it will
 * extend the expiration of current credential, with a warning message. For more
 * information, please go to:
 * https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html
 *
 * @!attribute originalExpiration
 *   @return [Date] The optional original expiration of the current credential.
 *   In case of AWS outage, the EC2 metadata will extend expiration of the
 *   existing credential.
 *
 * @see AWS.Config.retryDelayOptions
 * @see AWS.Config.logger
 *
 * @!macro nobrowser
 */
AWS.EC2MetadataCredentials = AWS.util.inherit(AWS.Credentials, {
  constructor: function EC2MetadataCredentials(options) {
    AWS.Credentials.call(this);

    options = options ? AWS.util.copy(options) : {};
    options = AWS.util.merge(
      {maxRetries: this.defaultMaxRetries}, options);
    if (!options.httpOptions) options.httpOptions = {};
    options.httpOptions = AWS.util.merge(
      {timeout: this.defaultTimeout,
        connectTimeout: this.defaultConnectTimeout},
       options.httpOptions);

    this.metadataService = new AWS.MetadataService(options);
    this.logger = options.logger || AWS.config && AWS.config.logger;
  },

  /**
   * @api private
   */
  defaultTimeout: 1000,

   /**
   * @api private
   */
  defaultConnectTimeout: 1000,

  /**
   * @api private
   */
  defaultMaxRetries: 3,

  /**
   * The original expiration of the current credential. In case of AWS
   * outage, the EC2 metadata will extend expiration of the existing
   * credential.
   */
  originalExpiration: undefined,

  /**
   * Loads the credentials from the instance metadata service
   *
   * @callback callback function(err)
   *   Called when the instance metadata service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.metadataService.loadCredentials(function(err, creds) {
      if (err) {
        if (self.hasLoadedCredentials()) {
          self.extendExpirationIfExpired();
          callback();
        } else {
          callback(err);
        }
      } else {
        self.setCredentials(creds);
        self.extendExpirationIfExpired();
        callback();
      }
    });
  },

  /**
   * Whether this credential has been loaded.
   * @api private
   */
  hasLoadedCredentials: function hasLoadedCredentials() {
    return this.AccessKeyId && this.secretAccessKey;
  },

  /**
   * if expired, extend the expiration by 15 minutes base plus a jitter of 5
   * minutes range.
   * @api private
   */
  extendExpirationIfExpired: function extendExpirationIfExpired() {
    if (this.needsRefresh()) {
      this.originalExpiration = this.originalExpiration || this.expireTime;
      this.expired = false;
      var nextTimeout = 15 * 60 + Math.floor(Math.random() * 5 * 60);
      var currentTime = AWS.util.date.getDate().getTime();
      this.expireTime = new Date(currentTime + nextTimeout * 1000);
      // TODO: add doc link;
      this.logger.warn('Attempting credential expiration extension due to a '
          + 'credential service availability issue. A refresh of these '
          + 'credentials will be attempted again at ' + this.expireTime
          + '\nFor more information, please visit: https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html');
    }
  },

  /**
   * Update the credential with new credential responded from EC2 metadata
   * service.
   * @api private
   */
  setCredentials: function setCredentials(creds) {
    var currentTime = AWS.util.date.getDate().getTime();
    var expireTime = new Date(creds.Expiration);
    this.expired = currentTime >= expireTime ? true : false;
    this.metadata = creds;
    this.accessKeyId = creds.AccessKeyId;
    this.secretAccessKey = creds.SecretAccessKey;
    this.sessionToken = creds.Token;
    this.expireTime = expireTime;
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/ecs_credentials.js":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/ecs_credentials.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Represents credentials received from relative URI specified in the ECS container.
 *
 * This class will request refreshable credentials from the relative URI
 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or the
 * AWS_CONTAINER_CREDENTIALS_FULL_URI environment variable. If valid credentials
 * are returned in the response, these will be used with zero configuration.
 *
 * This credentials class will by default timeout after 1 second of inactivity
 * and retry 3 times.
 * If your requests to the relative URI are timing out, you can increase
 * the value by configuring them directly:
 *
 * ```javascript
 * AWS.config.credentials = new AWS.ECSCredentials({
 *   httpOptions: { timeout: 5000 }, // 5 second timeout
 *   maxRetries: 10, // retry 10 times
 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
 * });
 * ```
 *
 * @see AWS.Config.retryDelayOptions
 *
 * @!macro nobrowser
 */
AWS.ECSCredentials = AWS.RemoteCredentials;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/environment_credentials.js":
/*!***********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/environment_credentials.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Represents credentials from the environment.
 *
 * By default, this class will look for the matching environment variables
 * prefixed by a given {envPrefix}. The un-prefixed environment variable names
 * for each credential value is listed below:
 *
 * ```javascript
 * accessKeyId: ACCESS_KEY_ID
 * secretAccessKey: SECRET_ACCESS_KEY
 * sessionToken: SESSION_TOKEN
 * ```
 *
 * With the default prefix of 'AWS', the environment variables would be:
 *
 *     AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
 *
 * @!attribute envPrefix
 *   @readonly
 *   @return [String] the prefix for the environment variable names excluding
 *     the separating underscore ('_').
 */
AWS.EnvironmentCredentials = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new EnvironmentCredentials class with a given variable
   * prefix {envPrefix}. For example, to load credentials using the 'AWS'
   * prefix:
   *
   * ```javascript
   * var creds = new AWS.EnvironmentCredentials('AWS');
   * creds.accessKeyId == 'AKID' // from AWS_ACCESS_KEY_ID env var
   * ```
   *
   * @param envPrefix [String] the prefix to use (e.g., 'AWS') for environment
   *   variables. Do not include the separating underscore.
   */
  constructor: function EnvironmentCredentials(envPrefix) {
    AWS.Credentials.call(this);
    this.envPrefix = envPrefix;
    this.get(function() {});
  },

  /**
   * Loads credentials from the environment using the prefixed
   * environment variables.
   *
   * @callback callback function(err)
   *   Called after the (prefixed) ACCESS_KEY_ID, SECRET_ACCESS_KEY, and
   *   SESSION_TOKEN environment variables are read. When this callback is
   *   called with no error, it means that the credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    if (!callback) callback = AWS.util.fn.callback;

    if (!process || !process.env) {
      callback(AWS.util.error(
        new Error('No process info or environment variables available'),
        { code: 'EnvironmentCredentialsProviderFailure' }
      ));
      return;
    }

    var keys = ['ACCESS_KEY_ID', 'SECRET_ACCESS_KEY', 'SESSION_TOKEN'];
    var values = [];

    for (var i = 0; i < keys.length; i++) {
      var prefix = '';
      if (this.envPrefix) prefix = this.envPrefix + '_';
      values[i] = process.env[prefix + keys[i]];
      if (!values[i] && keys[i] !== 'SESSION_TOKEN') {
        callback(AWS.util.error(
          new Error('Variable ' + prefix + keys[i] + ' not set.'),
        { code: 'EnvironmentCredentialsProviderFailure' }
        ));
        return;
      }
    }

    this.expired = false;
    AWS.Credentials.apply(this, values);
    callback();
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/file_system_credentials.js":
/*!***********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/file_system_credentials.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Represents credentials from a JSON file on disk.
 * If the credentials expire, the SDK can {refresh} the credentials
 * from the file.
 *
 * The format of the file should be similar to the options passed to
 * {AWS.Config}:
 *
 * ```javascript
 * {accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'optional'}
 * ```
 *
 * @example Loading credentials from disk
 *   var creds = new AWS.FileSystemCredentials('./configuration.json');
 *   creds.accessKeyId == 'AKID'
 *
 * @!attribute filename
 *   @readonly
 *   @return [String] the path to the JSON file on disk containing the
 *     credentials.
 * @!macro nobrowser
 */
AWS.FileSystemCredentials = AWS.util.inherit(AWS.Credentials, {

  /**
   * @overload AWS.FileSystemCredentials(filename)
   *   Creates a new FileSystemCredentials object from a filename
   *
   *   @param filename [String] the path on disk to the JSON file to load.
   */
  constructor: function FileSystemCredentials(filename) {
    AWS.Credentials.call(this);
    this.filename = filename;
    this.get(function() {});
  },

  /**
   * Loads the credentials from the {filename} on disk.
   *
   * @callback callback function(err)
   *   Called after the JSON file on disk is read and parsed. When this callback
   *   is called with no error, it means that the credentials information
   *   has been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    if (!callback) callback = AWS.util.fn.callback;
    try {
      var creds = JSON.parse(AWS.util.readFileSync(this.filename));
      AWS.Credentials.call(this, creds);
      if (!this.accessKeyId || !this.secretAccessKey) {
        throw AWS.util.error(
          new Error('Credentials not set in ' + this.filename),
        { code: 'FileSystemCredentialsProviderFailure' }
        );
      }
      this.expired = false;
      callback();
    } catch (err) {
      callback(err);
    }
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/process_credentials.js":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/process_credentials.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var proc = __webpack_require__(/*! child_process */ "child_process");
var iniLoader = AWS.util.iniLoader;

/**
 * Represents credentials loaded from shared credentials file
 * (defaulting to ~/.aws/credentials or defined by the
 * `AWS_SHARED_CREDENTIALS_FILE` environment variable).
 *
 * ## Using process credentials
 *
 * The credentials file can specify a credential provider that executes
 * a given process and attempts to read its stdout to recieve a JSON payload
 * containing the credentials:
 *
 *     [default]
 *     credential_process = /usr/bin/credential_proc
 *
 * Automatically handles refreshing credentials if an Expiration time is
 * provided in the credentials payload. Credentials supplied in the same profile
 * will take precedence over the credential_process.
 *
 * Sourcing credentials from an external process can potentially be dangerous,
 * so proceed with caution. Other credential providers should be preferred if
 * at all possible. If using this option, you should make sure that the shared
 * credentials file is as locked down as possible using security best practices
 * for your operating system.
 *
 * ## Using custom profiles
 *
 * The SDK supports loading credentials for separate profiles. This can be done
 * in two ways:
 *
 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
 *    loading the SDK.
 * 2. Directly load the AWS.ProcessCredentials provider:
 *
 * ```javascript
 * var creds = new AWS.ProcessCredentials({profile: 'myprofile'});
 * AWS.config.credentials = creds;
 * ```
 *
 * @!macro nobrowser
 */
AWS.ProcessCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new ProcessCredentials object.
   *
   * @param options [map] a set of options
   * @option options profile [String] (AWS_PROFILE env var or 'default')
   *   the name of the profile to load.
   * @option options filename [String] ('~/.aws/credentials' or defined by
   *   AWS_SHARED_CREDENTIALS_FILE process env var)
   *   the filename to use when loading credentials.
   * @option options callback [Function] (err) Credentials are eagerly loaded
   *   by the constructor. When the callback is called with no error, the
   *   credentials have been loaded successfully.
   */
  constructor: function ProcessCredentials(options) {
    AWS.Credentials.call(this);

    options = options || {};

    this.filename = options.filename;
    this.profile = options.profile || process.env.AWS_PROFILE || AWS.util.defaultProfile;
    this.get(options.callback || AWS.util.fn.noop);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    try {
      var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader, this.filename);
      var profile = profiles[this.profile] || {};

      if (Object.keys(profile).length === 0) {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' not found'),
          { code: 'ProcessCredentialsProviderFailure' }
        );
      }

      if (profile['credential_process']) {
        this.loadViaCredentialProcess(profile, function(err, data) {
          if (err) {
            callback(err, null);
          } else {
            self.expired = false;
            self.accessKeyId = data.AccessKeyId;
            self.secretAccessKey = data.SecretAccessKey;
            self.sessionToken = data.SessionToken;
            if (data.Expiration) {
              self.expireTime = new Date(data.Expiration);
            }
            callback(null);
          }
        });
      } else {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' did not include credential process'),
          { code: 'ProcessCredentialsProviderFailure' }
        );
      }
    } catch (err) {
      callback(err);
    }
  },

  /**
  * Executes the credential_process and retrieves
  * credentials from the output
  * @api private
  * @param profile [map] credentials profile
  * @throws ProcessCredentialsProviderFailure
  */
  loadViaCredentialProcess: function loadViaCredentialProcess(profile, callback) {
    proc.exec(profile['credential_process'], { env: process.env }, function(err, stdOut, stdErr) {
      if (err) {
        callback(AWS.util.error(
          new Error('credential_process returned error'),
          { code: 'ProcessCredentialsProviderFailure'}
        ), null);
      } else {
        try {
          var credData = JSON.parse(stdOut);
          if (credData.Expiration) {
            var currentTime = AWS.util.date.getDate();
            var expireTime = new Date(credData.Expiration);
            if (expireTime < currentTime) {
              throw Error('credential_process returned expired credentials');
            }
          }

          if (credData.Version !== 1) {
            throw Error('credential_process does not return Version == 1');
          }
          callback(null, credData);
        } catch (err) {
          callback(AWS.util.error(
            new Error(err.message),
            { code: 'ProcessCredentialsProviderFailure'}
          ), null);
        }
      }
    });
  },

  /**
   * Loads the credentials from the credential process
   *
   * @callback callback function(err)
   *   Called after the credential process has been executed. When this
   *   callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    iniLoader.clearCachedFiles();
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/remote_credentials.js":
/*!******************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/remote_credentials.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js"),
  ENV_RELATIVE_URI = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',
  ENV_FULL_URI = 'AWS_CONTAINER_CREDENTIALS_FULL_URI',
  ENV_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN',
  FULL_URI_UNRESTRICTED_PROTOCOLS = ['https:'],
  FULL_URI_ALLOWED_PROTOCOLS = ['http:', 'https:'],
  FULL_URI_ALLOWED_HOSTNAMES = ['localhost', '127.0.0.1'],
  RELATIVE_URI_HOST = '169.254.170.2';

/**
 * Represents credentials received from specified URI.
 *
 * This class will request refreshable credentials from the relative URI
 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or the
 * AWS_CONTAINER_CREDENTIALS_FULL_URI environment variable. If valid credentials
 * are returned in the response, these will be used with zero configuration.
 *
 * This credentials class will by default timeout after 1 second of inactivity
 * and retry 3 times.
 * If your requests to the relative URI are timing out, you can increase
 * the value by configuring them directly:
 *
 * ```javascript
 * AWS.config.credentials = new AWS.RemoteCredentials({
 *   httpOptions: { timeout: 5000 }, // 5 second timeout
 *   maxRetries: 10, // retry 10 times
 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
 * });
 * ```
 *
 * @see AWS.Config.retryDelayOptions
 *
 * @!macro nobrowser
 */
AWS.RemoteCredentials = AWS.util.inherit(AWS.Credentials, {
  constructor: function RemoteCredentials(options) {
    AWS.Credentials.call(this);
    options = options ? AWS.util.copy(options) : {};
    if (!options.httpOptions) options.httpOptions = {};
    options.httpOptions = AWS.util.merge(
      this.httpOptions, options.httpOptions);
    AWS.util.update(this, options);
  },

  /**
   * @api private
   */
  httpOptions: { timeout: 1000 },

  /**
   * @api private
   */
  maxRetries: 3,

  /**
   * @api private
   */
  isConfiguredForEcsCredentials: function isConfiguredForEcsCredentials() {
    return Boolean(
        process &&
        process.env &&
        (process.env[ENV_RELATIVE_URI] || process.env[ENV_FULL_URI])
    );
  },

  /**
   * @api private
   */
  getECSFullUri: function getECSFullUri() {
    if (process && process.env) {
      var relative = process.env[ENV_RELATIVE_URI],
          full = process.env[ENV_FULL_URI];
      if (relative) {
        return 'http://' + RELATIVE_URI_HOST + relative;
      } else if (full) {
        var parsed = AWS.util.urlParse(full);
        if (FULL_URI_ALLOWED_PROTOCOLS.indexOf(parsed.protocol) < 0) {
          throw AWS.util.error(
            new Error('Unsupported protocol:  AWS.RemoteCredentials supports '
              + FULL_URI_ALLOWED_PROTOCOLS.join(',') + ' only; '
              + parsed.protocol + ' requested.'),
            { code: 'ECSCredentialsProviderFailure' }
          );
        }

        if (FULL_URI_UNRESTRICTED_PROTOCOLS.indexOf(parsed.protocol) < 0 &&
            FULL_URI_ALLOWED_HOSTNAMES.indexOf(parsed.hostname) < 0) {
          throw AWS.util.error(
            new Error('Unsupported hostname: AWS.RemoteCredentials only supports '
              + FULL_URI_ALLOWED_HOSTNAMES.join(',') + ' for ' + parsed.protocol + '; '
              + parsed.protocol + '//' + parsed.hostname + ' requested.'),
            { code: 'ECSCredentialsProviderFailure' }
          );
        }

        return full;
      } else {
        throw AWS.util.error(
          new Error('Variable ' + ENV_RELATIVE_URI + ' or ' + ENV_FULL_URI +
            ' must be set to use AWS.RemoteCredentials.'),
          { code: 'ECSCredentialsProviderFailure' }
        );
      }
    } else {
      throw AWS.util.error(
        new Error('No process info available'),
        { code: 'ECSCredentialsProviderFailure' }
      );
    }
  },

  /**
   * @api private
   */
  getECSAuthToken: function getECSAuthToken() {
    if (process && process.env && process.env[ENV_FULL_URI]) {
      return process.env[ENV_AUTH_TOKEN];
    }
  },

  /**
   * @api private
   */
  credsFormatIsValid: function credsFormatIsValid(credData) {
    return (!!credData.accessKeyId && !!credData.secretAccessKey &&
      !!credData.sessionToken && !!credData.expireTime);
  },

  /**
   * @api private
   */
  formatCreds: function formatCreds(credData) {
    if (!!credData.credentials) {
      credData = credData.credentials;
    }

    return {
      expired: false,
      accessKeyId: credData.accessKeyId || credData.AccessKeyId,
      secretAccessKey: credData.secretAccessKey || credData.SecretAccessKey,
      sessionToken: credData.sessionToken || credData.Token,
      expireTime: new Date(credData.expiration || credData.Expiration)
    };
  },

  /**
   * @api private
   */
  request: function request(url, callback) {
    var httpRequest = new AWS.HttpRequest(url);
    httpRequest.method = 'GET';
    httpRequest.headers.Accept = 'application/json';
    var token = this.getECSAuthToken();
    if (token) {
      httpRequest.headers.Authorization = token;
    }
    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
  },

  /**
   * Loads the credentials from the relative URI specified by container
   *
   * @callback callback function(err)
   *   Called when the request to the relative URI responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, `sessionToken`, and `expireTime` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    var fullUri;

    try {
      fullUri = this.getECSFullUri();
    } catch (err) {
      callback(err);
      return;
    }

    this.request(fullUri, function(err, data) {
      if (!err) {
        try {
          data = JSON.parse(data);
          var creds = self.formatCreds(data);
          if (!self.credsFormatIsValid(creds)) {
            throw AWS.util.error(
              new Error('Response data is not in valid format'),
              { code: 'ECSCredentialsProviderFailure' }
            );
          }
          AWS.util.update(self, creds);
        } catch (dataError) {
          err = dataError;
        }
      }
      callback(err, creds);
    });
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/saml_credentials.js":
/*!****************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/saml_credentials.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");

/**
 * Represents credentials retrieved from STS SAML support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given, as well as a `PrincipalArn`
 * representing the ARN for the SAML identity provider. In addition, the
 * `SAMLAssertion` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the SAMLAssertion, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
 *     `params.SAMLAssertion` property.
 */
AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithSAML)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.SAMLCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
   *   });
   * @see AWS.STS.assumeRoleWithSAML
   */
  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js":
/*!***************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");
var iniLoader = AWS.util.iniLoader;

var ASSUME_ROLE_DEFAULT_REGION = 'us-east-1';

/**
 * Represents credentials loaded from shared credentials file
 * (defaulting to ~/.aws/credentials or defined by the
 * `AWS_SHARED_CREDENTIALS_FILE` environment variable).
 *
 * ## Using the shared credentials file
 *
 * This provider is checked by default in the Node.js environment. To use the
 * credentials file provider, simply add your access and secret keys to the
 * ~/.aws/credentials file in the following format:
 *
 *     [default]
 *     aws_access_key_id = AKID...
 *     aws_secret_access_key = YOUR_SECRET_KEY
 *
 * ## Using custom profiles
 *
 * The SDK supports loading credentials for separate profiles. This can be done
 * in two ways:
 *
 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
 *    loading the SDK.
 * 2. Directly load the AWS.SharedIniFileCredentials provider:
 *
 * ```javascript
 * var creds = new AWS.SharedIniFileCredentials({profile: 'myprofile'});
 * AWS.config.credentials = creds;
 * ```
 *
 * @!macro nobrowser
 */
AWS.SharedIniFileCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new SharedIniFileCredentials object.
   *
   * @param options [map] a set of options
   * @option options profile [String] (AWS_PROFILE env var or 'default')
   *   the name of the profile to load.
   * @option options filename [String] ('~/.aws/credentials' or defined by
   *   AWS_SHARED_CREDENTIALS_FILE process env var)
   *   the filename to use when loading credentials.
   * @option options disableAssumeRole [Boolean] (false) True to disable
   *   support for profiles that assume an IAM role. If true, and an assume
   *   role profile is selected, an error is raised.
   * @option options preferStaticCredentials [Boolean] (false) True to
   *   prefer static credentials to role_arn if both are present.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   STS Assume Role TokenCode, if mfa_serial is provided for profile in ini
   *   file. Function is called with value of mfa_serial and callback, and
   *   should provide the TokenCode or an error to the callback in the format
   *   callback(err, token)
   * @option options callback [Function] (err) Credentials are eagerly loaded
   *   by the constructor. When the callback is called with no error, the
   *   credentials have been loaded successfully.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; The number of milliseconds a request can
   *     take before automatically being terminated.
   *     Defaults to two minutes (120000).
   */
  constructor: function SharedIniFileCredentials(options) {
    AWS.Credentials.call(this);

    options = options || {};

    this.filename = options.filename;
    this.profile = options.profile || process.env.AWS_PROFILE || AWS.util.defaultProfile;
    this.disableAssumeRole = Boolean(options.disableAssumeRole);
    this.preferStaticCredentials = Boolean(options.preferStaticCredentials);
    this.tokenCodeFn = options.tokenCodeFn || null;
    this.httpOptions = options.httpOptions || null;
    this.get(options.callback || AWS.util.fn.noop);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    try {
      var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader, this.filename);
      var profile = profiles[this.profile] || {};

      if (Object.keys(profile).length === 0) {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' not found'),
          { code: 'SharedIniFileCredentialsProviderFailure' }
        );
      }

      /*
      In the CLI, the presence of both a role_arn and static credentials have
      different meanings depending on how many profiles have been visited. For
      the first profile processed, role_arn takes precedence over any static
      credentials, but for all subsequent profiles, static credentials are
      used if present, and only in their absence will the profile's
      source_profile and role_arn keys be used to load another set of
      credentials. This var is intended to yield compatible behaviour in this
      sdk.
      */
      var preferStaticCredentialsToRoleArn = Boolean(
        this.preferStaticCredentials
        && profile['aws_access_key_id']
        && profile['aws_secret_access_key']
      );

      if (profile['role_arn'] && !preferStaticCredentialsToRoleArn) {
        this.loadRoleProfile(profiles, profile, function(err, data) {
          if (err) {
            callback(err);
          } else {
            self.expired = false;
            self.accessKeyId = data.Credentials.AccessKeyId;
            self.secretAccessKey = data.Credentials.SecretAccessKey;
            self.sessionToken = data.Credentials.SessionToken;
            self.expireTime = data.Credentials.Expiration;
            callback(null);
          }
        });
        return;
      }

      this.accessKeyId = profile['aws_access_key_id'];
      this.secretAccessKey = profile['aws_secret_access_key'];
      this.sessionToken = profile['aws_session_token'];

      if (!this.accessKeyId || !this.secretAccessKey) {
        throw AWS.util.error(
          new Error('Credentials not set for profile ' + this.profile),
          { code: 'SharedIniFileCredentialsProviderFailure' }
        );
      }
      this.expired = false;
      callback(null);
    } catch (err) {
      callback(err);
    }
  },

  /**
   * Loads the credentials from the shared credentials file
   *
   * @callback callback function(err)
   *   Called after the shared INI file on disk is read and parsed. When this
   *   callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    iniLoader.clearCachedFiles();
    this.coalesceRefresh(
      callback || AWS.util.fn.callback,
      this.disableAssumeRole
    );
  },

  /**
   * @api private
   */
  loadRoleProfile: function loadRoleProfile(creds, roleProfile, callback) {
    if (this.disableAssumeRole) {
      throw AWS.util.error(
        new Error('Role assumption profiles are disabled. ' +
                  'Failed to load profile ' + this.profile +
                  ' from ' + creds.filename),
        { code: 'SharedIniFileCredentialsProviderFailure' }
      );
    }

    var self = this;
    var roleArn = roleProfile['role_arn'];
    var roleSessionName = roleProfile['role_session_name'];
    var externalId = roleProfile['external_id'];
    var mfaSerial = roleProfile['mfa_serial'];
    var sourceProfileName = roleProfile['source_profile'];

    // From experimentation, the following behavior mimics the AWS CLI:
    //
    // 1. Use region from the profile if present.
    // 2. Otherwise fall back to N. Virginia (global endpoint).
    //
    // It is necessary to do the fallback explicitly, because if
    // 'AWS_STS_REGIONAL_ENDPOINTS=regional', the underlying STS client will
    // otherwise throw an error if region is left 'undefined'.
    //
    // Experimentation shows that the AWS CLI (tested at version 1.18.136)
    // ignores the following potential sources of a region for the purposes of
    // this AssumeRole call:
    //
    // - The [default] profile
    // - The AWS_REGION environment variable
    //
    // Ignoring the [default] profile for the purposes of AssumeRole is arguably
    // a bug in the CLI since it does use the [default] region for service
    // calls... but right now we're matching behavior of the other tool.
    var profileRegion = roleProfile['region'] || ASSUME_ROLE_DEFAULT_REGION;

    if (!sourceProfileName) {
      throw AWS.util.error(
        new Error('source_profile is not set using profile ' + this.profile),
        { code: 'SharedIniFileCredentialsProviderFailure' }
      );
    }

    var sourceProfileExistanceTest = creds[sourceProfileName];

    if (typeof sourceProfileExistanceTest !== 'object') {
      throw AWS.util.error(
        new Error('source_profile ' + sourceProfileName + ' using profile '
          + this.profile + ' does not exist'),
        { code: 'SharedIniFileCredentialsProviderFailure' }
      );
    }

    var sourceCredentials = new AWS.SharedIniFileCredentials(
      AWS.util.merge(this.options || {}, {
        profile: sourceProfileName,
        preferStaticCredentials: true
      })
    );

    this.roleArn = roleArn;
    var sts = new STS({
      credentials: sourceCredentials,
      region: profileRegion,
      httpOptions: this.httpOptions
    });

    var roleParams = {
      RoleArn: roleArn,
      RoleSessionName: roleSessionName || 'aws-sdk-js-' + Date.now()
    };

    if (externalId) {
      roleParams.ExternalId = externalId;
    }

    if (mfaSerial && self.tokenCodeFn) {
      roleParams.SerialNumber = mfaSerial;
      self.tokenCodeFn(mfaSerial, function(err, token) {
        if (err) {
          var message;
          if (err instanceof Error) {
            message = err.message;
          } else {
            message = err;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: 'SharedIniFileCredentialsProviderFailure' }
            ));
          return;
        }

        roleParams.TokenCode = token;
        sts.assumeRole(roleParams, callback);
      });
      return;
    }
    sts.assumeRole(roleParams, callback);
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/sso_credentials.js":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/sso_credentials.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var path = __webpack_require__(/*! path */ "path");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var iniLoader = AWS.util.iniLoader;

/**
 *  Represents credentials from sso.getRoleCredentials API for
 * `sso_*` values defined in shared credentials file.
 *
 * ## Using SSO credentials
 *
 * The credentials file must specify the information below to use sso:
 *
 *     [default]
 *     sso_account_id = 012345678901
 *     sso_region = us-east-1
 *     sso_role_name = SampleRole
 *     sso_start_url = https://d-abc123.awsapps.com/start
 *
 * This information will be automatically added to your shared credentials file by running
 * `aws configure sso`.
 *
 * ## Using custom profiles
 *
 * The SDK supports loading credentials for separate profiles. This can be done
 * in two ways:
 *
 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
 *    loading the SDK.
 * 2. Directly load the AWS.SsoCredentials provider:
 *
 * ```javascript
 * var creds = new AWS.SsoCredentials({profile: 'myprofile'});
 * AWS.config.credentials = creds;
 * ```
 *
 * @!macro nobrowser
 */
AWS.SsoCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new SsoCredentials object.
   *
   * @param options [map] a set of options
   * @option options profile [String] (AWS_PROFILE env var or 'default')
   *   the name of the profile to load.
   * @option options filename [String] ('~/.aws/credentials' or defined by
   *   AWS_SHARED_CREDENTIALS_FILE process env var)
   *   the filename to use when loading credentials.
   * @option options callback [Function] (err) Credentials are eagerly loaded
   *   by the constructor. When the callback is called with no error, the
   *   credentials have been loaded successfully.
   */
  constructor: function SsoCredentials(options) {
    AWS.Credentials.call(this);

    options = options || {};
    this.errorCode = 'SsoCredentialsProviderFailure';
    this.expired = true;

    this.filename = options.filename;
    this.profile = options.profile || process.env.AWS_PROFILE || AWS.util.defaultProfile;
    this.service = options.ssoClient;
    this.get(options.callback || AWS.util.fn.noop);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    /**
     * The time window (15 mins) that SDK will treat the SSO token expires in before the defined expiration date in token.
     * This is needed because server side may have invalidated the token before the defined expiration date.
     *
     * @internal
     */
    var EXPIRE_WINDOW_MS = 15 * 60 * 1000;
    var self = this;
    try {
      var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader, this.filename);
      var profile = profiles[this.profile] || {};

      if (Object.keys(profile).length === 0) {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' not found'),
          { code: self.errorCode }
        );
      }

      if (!profile.sso_start_url || !profile.sso_account_id || !profile.sso_region || !profile.sso_role_name) {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' does not have valid SSO credentials. Required parameters "sso_account_id", "sso_region", ' +
          '"sso_role_name", "sso_start_url". Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html'),
          { code: self.errorCode }
        );
      }

      var hasher = crypto.createHash('sha1');
      var fileName = hasher.update(profile.sso_start_url).digest('hex') + '.json';

      var cachePath = path.join(
        iniLoader.getHomeDir(),
        '.aws',
        'sso',
        'cache',
        fileName
      );
      var cacheFile = AWS.util.readFileSync(cachePath);
      var cacheContent = null;
      if (cacheFile) {
        cacheContent = JSON.parse(cacheFile);
      }

      if (!cacheContent) {
        throw AWS.util.error(
          new Error('Cached credentials not found under ' + this.profile + ' profile. Please make sure you log in with aws sso login first'),
          { code: self.errorCode }
        );
      }

      if (!cacheContent.startUrl || !cacheContent.region || !cacheContent.accessToken || !cacheContent.expiresAt) {
        throw AWS.util.error(
          new Error('Cached credentials are missing required properties. Try running aws sso login.')
        );
      }

      if (new Date(cacheContent.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
        throw AWS.util.error(new Error(
          'The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.'
        ));
      }

      if (!self.service || self.service.config.region !== profile.sso_region) {
        self.service = new AWS.SSO({ region: profile.sso_region });
      }
      var request = {
        accessToken: cacheContent.accessToken,
        accountId: profile.sso_account_id,
        roleName: profile.sso_role_name,
      };
      self.service.getRoleCredentials(request, function(err, data) {
        if (err || !data || !data.roleCredentials) {
          callback(AWS.util.error(
            err || new Error('Please log in using "aws sso login"'),
            { code: self.errorCode }
          ), null);
        } else if (!data.roleCredentials.accessKeyId || !data.roleCredentials.secretAccessKey || !data.roleCredentials.sessionToken || !data.roleCredentials.expiration) {
          throw AWS.util.error(new Error(
            'SSO returns an invalid temporary credential.'
          ));
        } else {
          self.expired = false;
          self.accessKeyId = data.roleCredentials.accessKeyId;
          self.secretAccessKey = data.roleCredentials.secretAccessKey;
          self.sessionToken = data.roleCredentials.sessionToken;
          self.expireTime = new Date(data.roleCredentials.expiration);
          callback(null);
        }
      });
    } catch (err) {
      callback(err);
    }
  },

  /**
   * Loads the credentials from the AWS SSO process
   *
   * @callback callback function(err)
   *   Called after the AWS SSO process has been executed. When this
   *   callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    iniLoader.clearCachedFiles();
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/temporary_credentials.js":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/temporary_credentials.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * @note AWS.TemporaryCredentials is deprecated, but remains available for
 *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the
 *   preferred class for temporary credentials.
 *
 * To setup temporary credentials, configure a set of master credentials
 * using the standard credentials providers (environment, EC2 instance metadata,
 * or from the filesystem), then set the global credentials to a new
 * temporary credentials object:
 *
 * ```javascript
 * // Note that environment credentials are loaded by default,
 * // the following line is shown for clarity:
 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
 *
 * // Now set temporary credentials seeded from the master credentials
 * AWS.config.credentials = new AWS.TemporaryCredentials();
 *
 * // subsequent requests will now use temporary credentials from AWS STS.
 * new AWS.S3().listBucket(function(err, data) { ... });
 * ```
 *
 * @!attribute masterCredentials
 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @note In order to create temporary credentials, you first need to have
   *   "master" credentials configured in {AWS.Config.credentials}. These
   *   master credentials are necessary to retrieve the temporary credentials,
   *   as well as refresh the credentials when they expire.
   * @param params [map] a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role.
   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
   *  used to get and refresh temporary credentials from AWS STS.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.TemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.TemporaryCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function TemporaryCredentials(params, masterCredentials) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials(masterCredentials);
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh (callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load (callback) {
    var self = this;
    self.createClients();
    self.masterCredentials.get(function () {
      self.service.config.credentials = self.masterCredentials;
      var operation = self.params.RoleArn ?
        self.service.assumeRole : self.service.getSessionToken;
      operation.call(self.service, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  loadMasterCredentials: function loadMasterCredentials (masterCredentials) {
    this.masterCredentials = masterCredentials || AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }

    if (typeof this.masterCredentials.get !== 'function') {
      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
    }
  },

  /**
   * @api private
   */
  createClients: function () {
    this.service = this.service || new STS({params: this.params});
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js":
/*!***********************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var fs = __webpack_require__(/*! fs */ "fs");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");
var iniLoader = AWS.util.iniLoader;

/**
 * Represents OIDC credentials from a file on disk
 * If the credentials expire, the SDK can {refresh} the credentials
 * from the file.
 *
 * ## Using the web identity token file
 *
 * This provider is checked by default in the Node.js environment. To use
 * the provider simply add your OIDC token to a file (ASCII encoding) and
 * share the filename in either AWS_WEB_IDENTITY_TOKEN_FILE environment
 * variable or web_identity_token_file shared config variable
 *
 * The file contains encoded OIDC token and the characters are
 * ASCII encoded. OIDC tokens are JSON Web Tokens (JWT).
 * JWT's are 3 base64 encoded strings joined by the '.' character.
 *
 * This class will read filename from AWS_WEB_IDENTITY_TOKEN_FILE
 * environment variable or web_identity_token_file shared config variable,
 * and get the OIDC token from filename.
 * It will also read IAM role to be assumed from AWS_ROLE_ARN
 * environment variable or role_arn shared config variable.
 * This provider gets credetials using the {AWS.STS.assumeRoleWithWebIdentity}
 * service operation
 *
 * @!macro nobrowser
 */
AWS.TokenFileWebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {

  /**
   * @example Creating a new credentials object
   *  AWS.config.credentials = new AWS.TokenFileWebIdentityCredentials(
   *   // optionally provide configuration to apply to the underlying AWS.STS service client
   *   // if configuration is not provided, then configuration will be pulled from AWS.config
   *   {
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.Config
   */
  constructor: function TokenFileWebIdentityCredentials(clientConfig) {
    AWS.Credentials.call(this);
    this.data = null;
    this.clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Returns params from environment variables
   *
   * @api private
   */
  getParamsFromEnv: function getParamsFromEnv() {
    var ENV_TOKEN_FILE = 'AWS_WEB_IDENTITY_TOKEN_FILE',
        ENV_ROLE_ARN = 'AWS_ROLE_ARN';
    if (process.env[ENV_TOKEN_FILE] && process.env[ENV_ROLE_ARN]) {
      return [{
        envTokenFile: process.env[ENV_TOKEN_FILE],
        roleArn: process.env[ENV_ROLE_ARN],
        roleSessionName: process.env['AWS_ROLE_SESSION_NAME']
      }];
    }
  },

  /**
   * Returns params from shared config variables
   *
   * @api private
   */
  getParamsFromSharedConfig: function getParamsFromSharedConfig() {
    var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader);
    var profileName = process.env.AWS_PROFILE || AWS.util.defaultProfile;
    var profile = profiles[profileName] || {};

    if (Object.keys(profile).length === 0) {
      throw AWS.util.error(
        new Error('Profile ' + profileName + ' not found'),
        { code: 'TokenFileWebIdentityCredentialsProviderFailure' }
      );
    }

    var paramsArray = [];

    while (!profile['web_identity_token_file'] && profile['source_profile']) {
      paramsArray.unshift({
        roleArn: profile['role_arn'],
        roleSessionName: profile['role_session_name']
      });
      var sourceProfile = profile['source_profile'];
      profile = profiles[sourceProfile];
    }

    paramsArray.unshift({
      envTokenFile: profile['web_identity_token_file'],
      roleArn: profile['role_arn'],
      roleSessionName: profile['role_session_name']
    });

    return paramsArray;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
  */
  assumeRoleChaining: function assumeRoleChaining(paramsArray, callback) {
    var self = this;
    if (paramsArray.length === 0) {
      self.service.credentialsFrom(self.data, self);
      callback();
    } else {
      var params = paramsArray.shift();
      self.service.config.credentials = self.service.credentialsFrom(self.data, self);
      self.service.assumeRole(
        {
          RoleArn: params.roleArn,
          RoleSessionName: params.roleSessionName || 'token-file-web-identity'
        },
        function (err, data) {
          self.data = null;
          if (err) {
            callback(err);
          } else {
            self.data = data;
            self.assumeRoleChaining(paramsArray, callback);
          }
        }
      );
    }
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    try {
      var paramsArray = self.getParamsFromEnv();
      if (!paramsArray) {
        paramsArray = self.getParamsFromSharedConfig();
      }
      if (paramsArray) {
        var params = paramsArray.shift();
        var oidcToken = fs.readFileSync(params.envTokenFile, {encoding: 'ascii'});
        if (!self.service) {
          self.createClients();
        }
        self.service.assumeRoleWithWebIdentity(
          {
            WebIdentityToken: oidcToken,
            RoleArn: params.roleArn,
            RoleSessionName: params.roleSessionName || 'token-file-web-identity'
          },
          function (err, data) {
            self.data = null;
            if (err) {
              callback(err);
            } else {
              self.data = data;
              self.assumeRoleChaining(paramsArray, callback);
            }
          }
        );
      }
    } catch (err) {
      callback(err);
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this.clientConfig);
      this.service = new STS(stsConfig);

      // Retry in case of IDPCommunicationErrorException or InvalidIdentityToken
      this.service.retryableError = function(error) {
        if (error.code === 'IDPCommunicationErrorException' || error.code === 'InvalidIdentityToken') {
          return true;
        } else {
          return AWS.Service.prototype.retryableError.call(this, error);
        }
      };
    }
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/credentials/web_identity_credentials.js":
/*!************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/credentials/web_identity_credentials.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "../../../../node_modules/aws-sdk/clients/sts.js");

/**
 * Represents credentials retrieved from STS Web Identity Federation support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given. In addition, the
 * `WebIdentityToken` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn` and `WebIdentityToken` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 */
AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithWebIdentity)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
   *     RoleSessionName: 'web' // optional name, defaults to web-identity
   *   }, {
   *     // optionally provide configuration to apply to the underlying AWS.STS service client
   *     // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.Config
   */
  constructor: function WebIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this._clientConfig);
      stsConfig.params = this.params;
      this.service = new STS(stsConfig);
    }
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/discover_endpoint.js":
/*!*****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/discover_endpoint.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var util = __webpack_require__(/*! ./util */ "../../../../node_modules/aws-sdk/lib/util.js");
var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];

/**
 * Generate key (except resources and operation part) to index the endpoints in the cache
 * If input shape has endpointdiscoveryid trait then use
 *   accessKey + operation + resources + region + service as cache key
 * If input shape doesn't have endpointdiscoveryid trait then use
 *   accessKey + region + service as cache key
 * @return [map<String,String>] object with keys to index endpoints.
 * @api private
 */
function getCacheKey(request) {
  var service = request.service;
  var api = service.api || {};
  var operations = api.operations;
  var identifiers = {};
  if (service.config.region) {
    identifiers.region = service.config.region;
  }
  if (api.serviceId) {
    identifiers.serviceId = api.serviceId;
  }
  if (service.config.credentials.accessKeyId) {
    identifiers.accessKeyId = service.config.credentials.accessKeyId;
  }
  return identifiers;
}

/**
 * Recursive helper for marshallCustomIdentifiers().
 * Looks for required string input members that have 'endpointdiscoveryid' trait.
 * @api private
 */
function marshallCustomIdentifiersHelper(result, params, shape) {
  if (!shape || params === undefined || params === null) return;
  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
    util.arrayEach(shape.required, function(name) {
      var memberShape = shape.members[name];
      if (memberShape.endpointDiscoveryId === true) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        result[locationName] = String(params[name]);
      } else {
        marshallCustomIdentifiersHelper(result, params[name], memberShape);
      }
    });
  }
}

/**
 * Get custom identifiers for cache key.
 * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
 * @param [object] request object
 * @param [object] input shape of the given operation's api
 * @api private
 */
function marshallCustomIdentifiers(request, shape) {
  var identifiers = {};
  marshallCustomIdentifiersHelper(identifiers, request.params, shape);
  return identifiers;
}

/**
 * Call endpoint discovery operation when it's optional.
 * When endpoint is available in cache then use the cached endpoints. If endpoints
 * are unavailable then use regional endpoints and call endpoint discovery operation
 * asynchronously. This is turned off by default.
 * @param [object] request object
 * @api private
 */
function optionalDiscoverEndpoint(request) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var endpoints = AWS.endpointCache.get(cacheKey);
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //or endpoint operation just failed in 1 minute
    return;
  } else if (endpoints && endpoints.length > 0) {
    //found endpoint record from cache
    request.httpRequest.updateEndpoint(endpoints[0].Address);
  } else {
    //endpoint record not in cache or outdated. make discovery operation
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    addApiVersionHeader(endpointRequest);
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);
    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKey, [{
      Address: '',
      CachePeriodInMinutes: 1
    }]);
    endpointRequest.send(function(err, data) {
      if (data && data.Endpoints) {
        AWS.endpointCache.put(cacheKey, data.Endpoints);
      } else if (err) {
        AWS.endpointCache.put(cacheKey, [{
          Address: '',
          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute
        }]);
      }
    });
  }
}

var requestQueue = {};

/**
 * Call endpoint discovery operation when it's required.
 * When endpoint is available in cache then use cached ones. If endpoints are
 * unavailable then SDK should call endpoint operation then use returned new
 * endpoint for the api call. SDK will automatically attempt to do endpoint
 * discovery. This is turned off by default
 * @param [object] request object
 * @api private
 */
function requiredDiscoverEndpoint(request, done) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //push request object to a pending queue
    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
    requestQueue[cacheKeyStr].push({request: request, callback: done});
    return;
  } else if (endpoints && endpoints.length > 0) {
    request.httpRequest.updateEndpoint(endpoints[0].Address);
    done();
  } else {
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    addApiVersionHeader(endpointRequest);

    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKeyStr, [{
      Address: '',
      CachePeriodInMinutes: 60 //long-live cache
    }]);
    endpointRequest.send(function(err, data) {
      if (err) {
        request.response.error = util.error(err, { retryable: false });
        AWS.endpointCache.remove(cacheKey);

        //fail all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.response.error = util.error(err, { retryable: false });
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      } else if (data) {
        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);

        //update the endpoint for all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      }
      done();
    });
  }
}

/**
 * add api version header to endpoint operation
 * @api private
 */
function addApiVersionHeader(endpointRequest) {
  var api = endpointRequest.service.api;
  var apiVersion = api.apiVersion;
  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
  }
}

/**
 * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
 * endpoint from cache.
 * @api private
 */
function invalidateCachedEndpoints(response) {
  var error = response.error;
  var httpResponse = response.httpResponse;
  if (error &&
    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)
  ) {
    var request = response.request;
    var operations = request.service.api.operations || {};
    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
    var identifiers = marshallCustomIdentifiers(request, inputShape);
    var cacheKey = getCacheKey(request);
    if (Object.keys(identifiers).length > 0) {
      cacheKey = util.update(cacheKey, identifiers);
      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
    }
    AWS.endpointCache.remove(cacheKey);
  }
}

/**
 * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
 * @param [object] client Service client object.
 * @api private
 */
function hasCustomEndpoint(client) {
  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
    throw util.error(new Error(), {
      code: 'ConfigurationException',
      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
    });
  };
  var svcConfig = AWS.config[client.serviceIdentifier] || {};
  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));
}

/**
 * @api private
 */
function isFalsy(value) {
  return ['false', '0'].indexOf(value) >= 0;
}

/**
 * If endpoint discovery should perform for this request when no operation requires endpoint
 * discovery for the given service.
 * SDK performs config resolution in order like below:
 * 1. If set in client configuration.
 * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.
 * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.
 * @param [object] request request object.
 * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this
 *  function returns undefined
 * @api private
 */
function resolveEndpointDiscoveryConfig(request) {
  var service = request.service || {};
  if (service.config.endpointDiscoveryEnabled !== undefined) {
    return service.config.endpointDiscoveryEnabled;
  }

  //shared ini file is only available in Node
  //not to check env in browser
  if (util.isBrowser()) return undefined;

  // If any of recognized endpoint discovery config env is set
  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
    var env = endpointDiscoveryEnabledEnvs[i];
    if (Object.prototype.hasOwnProperty.call(process.env, env)) {
      if (process.env[env] === '' || process.env[env] === undefined) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'environmental variable ' + env + ' cannot be set to nothing'
        });
      }
      return !isFalsy(process.env[env]);
    }
  }

  var configFile = {};
  try {
    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || AWS.util.defaultProfile
  ] || {};
  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
      throw util.error(new Error(), {
        code: 'ConfigurationException',
        message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
      });
    }
    return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
  }
  return undefined;
}

/**
 * attach endpoint discovery logic to request object
 * @param [object] request
 * @api private
 */
function discoverEndpoint(request, done) {
  var service = request.service || {};
  if (hasCustomEndpoint(service) || request.isPresigned()) return done();

  var operations = service.api.operations || {};
  var operationModel = operations[request.operation];
  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
  var isEnabled = resolveEndpointDiscoveryConfig(request);
  var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
  if (isEnabled || hasRequiredEndpointDiscovery) {
    // Once a customer enables endpoint discovery, the SDK should start appending
    // the string endpoint-discovery to the user-agent on all requests.
    request.httpRequest.appendToUserAgent('endpoint-discovery');
  }
  switch (isEndpointDiscoveryRequired) {
    case 'OPTIONAL':
      if (isEnabled || hasRequiredEndpointDiscovery) {
        // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery
        // by default for all operations of that service, including operations where endpoint discovery is optional.
        optionalDiscoverEndpoint(request);
        request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      }
      done();
      break;
    case 'REQUIRED':
      if (isEnabled === false) {
        // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,
        // then the SDK must return a clear and actionable exception.
        request.response.error = util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation +
                    '() requires it. Please check your configurations.'
        });
        done();
        break;
      }
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      requiredDiscoverEndpoint(request, done);
      break;
    case 'NULL':
    default:
      done();
      break;
  }
}

module.exports = {
  discoverEndpoint: discoverEndpoint,
  requiredDiscoverEndpoint: requiredDiscoverEndpoint,
  optionalDiscoverEndpoint: optionalDiscoverEndpoint,
  marshallCustomIdentifiers: marshallCustomIdentifiers,
  getCacheKey: getCacheKey,
  invalidateCachedEndpoint: invalidateCachedEndpoints,
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/dynamodb/converter.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/dynamodb/converter.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var util = AWS.util;
var typeOf = (__webpack_require__(/*! ./types */ "../../../../node_modules/aws-sdk/lib/dynamodb/types.js").typeOf);
var DynamoDBSet = __webpack_require__(/*! ./set */ "../../../../node_modules/aws-sdk/lib/dynamodb/set.js");
var NumberValue = __webpack_require__(/*! ./numberValue */ "../../../../node_modules/aws-sdk/lib/dynamodb/numberValue.js");

AWS.DynamoDB.Converter = {
  /**
   * Convert a JavaScript value to its equivalent DynamoDB AttributeValue type
   *
   * @param data [any] The data to convert to a DynamoDB AttributeValue
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   * @return [map] An object in the Amazon DynamoDB AttributeValue format
   *
   * @see AWS.DynamoDB.Converter.marshall AWS.DynamoDB.Converter.marshall to
   *    convert entire records (rather than individual attributes)
   */
  input: function convertInput(data, options) {
    options = options || {};
    var type = typeOf(data);
    if (type === 'Object') {
      return formatMap(data, options);
    } else if (type === 'Array') {
      return formatList(data, options);
    } else if (type === 'Set') {
      return formatSet(data, options);
    } else if (type === 'String') {
      if (data.length === 0 && options.convertEmptyValues) {
        return convertInput(null);
      }
      return { S: data };
    } else if (type === 'Number' || type === 'NumberValue') {
      return { N: data.toString() };
    } else if (type === 'Binary') {
      if (data.length === 0 && options.convertEmptyValues) {
        return convertInput(null);
      }
      return { B: data };
    } else if (type === 'Boolean') {
      return { BOOL: data };
    } else if (type === 'null') {
      return { NULL: true };
    } else if (type !== 'undefined' && type !== 'Function') {
      // this value has a custom constructor
      return formatMap(data, options);
    }
  },

  /**
   * Convert a JavaScript object into a DynamoDB record.
   *
   * @param data [any] The data to convert to a DynamoDB record
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   *
   * @return [map] An object in the DynamoDB record format.
   *
   * @example Convert a JavaScript object into a DynamoDB record
   *  var marshalled = AWS.DynamoDB.Converter.marshall({
   *    string: 'foo',
   *    list: ['fizz', 'buzz', 'pop'],
   *    map: {
   *      nestedMap: {
   *        key: 'value',
   *      }
   *    },
   *    number: 123,
   *    nullValue: null,
   *    boolValue: true,
   *    stringSet: new DynamoDBSet(['foo', 'bar', 'baz'])
   *  });
   */
  marshall: function marshallItem(data, options) {
    return AWS.DynamoDB.Converter.input(data, options).M;
  },

  /**
   * Convert a DynamoDB AttributeValue object to its equivalent JavaScript type.
   *
   * @param data [map] An object in the Amazon DynamoDB AttributeValue format
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   *
   * @return [Object|Array|String|Number|Boolean|null]
   *
   * @see AWS.DynamoDB.Converter.unmarshall AWS.DynamoDB.Converter.unmarshall to
   *    convert entire records (rather than individual attributes)
   */
  output: function convertOutput(data, options) {
    options = options || {};
    var list, map, i;
    for (var type in data) {
      var values = data[type];
      if (type === 'M') {
        map = {};
        for (var key in values) {
          map[key] = convertOutput(values[key], options);
        }
        return map;
      } else if (type === 'L') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(convertOutput(values[i], options));
        }
        return list;
      } else if (type === 'SS') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(values[i] + '');
        }
        return new DynamoDBSet(list);
      } else if (type === 'NS') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(convertNumber(values[i], options.wrapNumbers));
        }
        return new DynamoDBSet(list);
      } else if (type === 'BS') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(AWS.util.buffer.toBuffer(values[i]));
        }
        return new DynamoDBSet(list);
      } else if (type === 'S') {
        return values + '';
      } else if (type === 'N') {
        return convertNumber(values, options.wrapNumbers);
      } else if (type === 'B') {
        return util.buffer.toBuffer(values);
      } else if (type === 'BOOL') {
        return (values === 'true' || values === 'TRUE' || values === true);
      } else if (type === 'NULL') {
        return null;
      }
    }
  },

  /**
   * Convert a DynamoDB record into a JavaScript object.
   *
   * @param data [any] The DynamoDB record
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   *
   * @return [map] An object whose properties have been converted from
   *    DynamoDB's AttributeValue format into their corresponding native
   *    JavaScript types.
   *
   * @example Convert a record received from a DynamoDB stream
   *  var unmarshalled = AWS.DynamoDB.Converter.unmarshall({
   *    string: {S: 'foo'},
   *    list: {L: [{S: 'fizz'}, {S: 'buzz'}, {S: 'pop'}]},
   *    map: {
   *      M: {
   *        nestedMap: {
   *          M: {
   *            key: {S: 'value'}
   *          }
   *        }
   *      }
   *    },
   *    number: {N: '123'},
   *    nullValue: {NULL: true},
   *    boolValue: {BOOL: true}
   *  });
   */
  unmarshall: function unmarshall(data, options) {
    return AWS.DynamoDB.Converter.output({M: data}, options);
  }
};

/**
 * @api private
 * @param data [Array]
 * @param options [map]
 */
function formatList(data, options) {
  var list = {L: []};
  for (var i = 0; i < data.length; i++) {
    list['L'].push(AWS.DynamoDB.Converter.input(data[i], options));
  }
  return list;
}

/**
 * @api private
 * @param value [String]
 * @param wrapNumbers [Boolean]
 */
function convertNumber(value, wrapNumbers) {
  return wrapNumbers ? new NumberValue(value) : Number(value);
}

/**
 * @api private
 * @param data [map]
 * @param options [map]
 */
function formatMap(data, options) {
  var map = {M: {}};
  for (var key in data) {
    var formatted = AWS.DynamoDB.Converter.input(data[key], options);
    if (formatted !== void 0) {
      map['M'][key] = formatted;
    }
  }
  return map;
}

/**
 * @api private
 */
function formatSet(data, options) {
  options = options || {};
  var values = data.values;
  if (options.convertEmptyValues) {
    values = filterEmptySetValues(data);
    if (values.length === 0) {
      return AWS.DynamoDB.Converter.input(null);
    }
  }

  var map = {};
  switch (data.type) {
    case 'String': map['SS'] = values; break;
    case 'Binary': map['BS'] = values; break;
    case 'Number': map['NS'] = values.map(function (value) {
      return value.toString();
    });
  }
  return map;
}

/**
 * @api private
 */
function filterEmptySetValues(set) {
    var nonEmptyValues = [];
    var potentiallyEmptyTypes = {
        String: true,
        Binary: true,
        Number: false
    };
    if (potentiallyEmptyTypes[set.type]) {
        for (var i = 0; i < set.values.length; i++) {
            if (set.values[i].length === 0) {
                continue;
            }
            nonEmptyValues.push(set.values[i]);
        }

        return nonEmptyValues;
    }

    return set.values;
}

/**
 * @api private
 */
module.exports = AWS.DynamoDB.Converter;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/dynamodb/document_client.js":
/*!************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/dynamodb/document_client.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var Translator = __webpack_require__(/*! ./translator */ "../../../../node_modules/aws-sdk/lib/dynamodb/translator.js");
var DynamoDBSet = __webpack_require__(/*! ./set */ "../../../../node_modules/aws-sdk/lib/dynamodb/set.js");

/**
 * The document client simplifies working with items in Amazon DynamoDB
 * by abstracting away the notion of attribute values. This abstraction
 * annotates native JavaScript types supplied as input parameters, as well
 * as converts annotated response data to native JavaScript types.
 *
 * ## Marshalling Input and Unmarshalling Response Data
 *
 * The document client affords developers the use of native JavaScript types
 * instead of `AttributeValue`s to simplify the JavaScript development
 * experience with Amazon DynamoDB. JavaScript objects passed in as parameters
 * are marshalled into `AttributeValue` shapes required by Amazon DynamoDB.
 * Responses from DynamoDB are unmarshalled into plain JavaScript objects
 * by the `DocumentClient`. The `DocumentClient`, does not accept
 * `AttributeValue`s in favor of native JavaScript types.
 *
 * |                             JavaScript Type                            | DynamoDB AttributeValue |
 * |:----------------------------------------------------------------------:|-------------------------|
 * | String                                                                 | S                       |
 * | Number                                                                 | N                       |
 * | Boolean                                                                | BOOL                    |
 * | null                                                                   | NULL                    |
 * | Array                                                                  | L                       |
 * | Object                                                                 | M                       |
 * | Buffer, File, Blob, ArrayBuffer, DataView, and JavaScript typed arrays | B                       |
 *
 * ## Support for Sets
 *
 * The `DocumentClient` offers a convenient way to create sets from
 * JavaScript Arrays. The type of set is inferred from the first element
 * in the array. DynamoDB supports string, number, and binary sets. To
 * learn more about supported types see the
 * [Amazon DynamoDB Data Model Documentation](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html)
 * For more information see {AWS.DynamoDB.DocumentClient.createSet}
 *
 */
AWS.DynamoDB.DocumentClient = AWS.util.inherit({

  /**
   * Creates a DynamoDB document client with a set of configuration options.
   *
   * @option options params [map] An optional map of parameters to bind to every
   *   request sent by this service object.
   * @option options service [AWS.DynamoDB] An optional pre-configured instance
   *  of the AWS.DynamoDB service object to use for requests. The object may
   *  bound parameters used by the document client.
   * @option options convertEmptyValues [Boolean] set to true if you would like
   *  the document client to convert empty values (0-length strings, binary
   *  buffers, and sets) to be converted to NULL types when persisting to
   *  DynamoDB.
   * @option options wrapNumbers [Boolean] Set to true to return numbers as a
   *  NumberValue object instead of converting them to native JavaScript numbers.
   *  This allows for the safe round-trip transport of numbers of arbitrary size.
   * @see AWS.DynamoDB.constructor
   *
   */
  constructor: function DocumentClient(options) {
    var self = this;
    self.options = options || {};
    self.configure(self.options);
  },

  /**
   * @api private
   */
  configure: function configure(options) {
    var self = this;
    self.service = options.service;
    self.bindServiceObject(options);
    self.attrValue = options.attrValue =
      self.service.api.operations.putItem.input.members.Item.value.shape;
  },

  /**
   * @api private
   */
  bindServiceObject: function bindServiceObject(options) {
    var self = this;
    options = options || {};

    if (!self.service) {
      self.service = new AWS.DynamoDB(options);
    } else {
      var config = AWS.util.copy(self.service.config);
      self.service = new self.service.constructor.__super__(config);
      self.service.config.params =
        AWS.util.merge(self.service.config.params || {}, options.params);
    }
  },

  /**
   * @api private
   */
  makeServiceRequest: function(operation, params, callback) {
    var self = this;
    var request = self.service[operation](params);
    self.setupRequest(request);
    self.setupResponse(request);
    if (typeof callback === 'function') {
      request.send(callback);
    }
    return request;
  },

  /**
   * @api private
   */
  serviceClientOperationsMap: {
    batchGet: 'batchGetItem',
    batchWrite: 'batchWriteItem',
    delete: 'deleteItem',
    get: 'getItem',
    put: 'putItem',
    query: 'query',
    scan: 'scan',
    update: 'updateItem',
    transactGet: 'transactGetItems',
    transactWrite: 'transactWriteItems'
  },

  /**
   * Returns the attributes of one or more items from one or more tables
   * by delegating to `AWS.DynamoDB.batchGetItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.batchGetItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.batchGetItem
   * @example Get items from multiple tables
   *  var params = {
   *    RequestItems: {
   *      'Table-1': {
   *        Keys: [
   *          {
   *             HashKey: 'haskey',
   *             NumberRangeKey: 1
   *          }
   *        ]
   *      },
   *      'Table-2': {
   *        Keys: [
   *          { foo: 'bar' },
   *        ]
   *      }
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.batchGet(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  batchGet: function(params, callback) {
    var operation = this.serviceClientOperationsMap['batchGet'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Puts or deletes multiple items in one or more tables by delegating
   * to `AWS.DynamoDB.batchWriteItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.batchWriteItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.batchWriteItem
   * @example Write to and delete from a table
   *  var params = {
   *    RequestItems: {
   *      'Table-1': [
   *        {
   *          DeleteRequest: {
   *            Key: { HashKey: 'someKey' }
   *          }
   *        },
   *        {
   *          PutRequest: {
   *            Item: {
   *              HashKey: 'anotherKey',
   *              NumAttribute: 1,
   *              BoolAttribute: true,
   *              ListAttribute: [1, 'two', false],
   *              MapAttribute: { foo: 'bar' }
   *            }
   *          }
   *        }
   *      ]
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.batchWrite(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  batchWrite: function(params, callback) {
    var operation = this.serviceClientOperationsMap['batchWrite'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Deletes a single item in a table by primary key by delegating to
   * `AWS.DynamoDB.deleteItem()`
   *
   * Supply the same parameters as {AWS.DynamoDB.deleteItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.deleteItem
   * @example Delete an item from a table
   *  var params = {
   *    TableName : 'Table',
   *    Key: {
   *      HashKey: 'hashkey',
   *      NumberRangeKey: 1
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.delete(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  delete: function(params, callback) {
    var operation = this.serviceClientOperationsMap['delete'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Returns a set of attributes for the item with the given primary key
   * by delegating to `AWS.DynamoDB.getItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.getItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.getItem
   * @example Get an item from a table
   *  var params = {
   *    TableName : 'Table',
   *    Key: {
   *      HashKey: 'hashkey'
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.get(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  get: function(params, callback) {
    var operation = this.serviceClientOperationsMap['get'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Creates a new item, or replaces an old item with a new item by
   * delegating to `AWS.DynamoDB.putItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.putItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.putItem
   * @example Create a new item in a table
   *  var params = {
   *    TableName : 'Table',
   *    Item: {
   *       HashKey: 'haskey',
   *       NumAttribute: 1,
   *       BoolAttribute: true,
   *       ListAttribute: [1, 'two', false],
   *       MapAttribute: { foo: 'bar'},
   *       NullAttribute: null
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.put(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  put: function(params, callback) {
    var operation = this.serviceClientOperationsMap['put'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Edits an existing item's attributes, or adds a new item to the table if
   * it does not already exist by delegating to `AWS.DynamoDB.updateItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.updateItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.updateItem
   * @example Update an item with expressions
   *  var params = {
   *    TableName: 'Table',
   *    Key: { HashKey : 'hashkey' },
   *    UpdateExpression: 'set #a = :x + :y',
   *    ConditionExpression: '#a < :MAX',
   *    ExpressionAttributeNames: {'#a' : 'Sum'},
   *    ExpressionAttributeValues: {
   *      ':x' : 20,
   *      ':y' : 45,
   *      ':MAX' : 100,
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.update(params, function(err, data) {
   *     if (err) console.log(err);
   *     else console.log(data);
   *  });
   *
   */
  update: function(params, callback) {
    var operation = this.serviceClientOperationsMap['update'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Returns one or more items and item attributes by accessing every item
   * in a table or a secondary index.
   *
   * Supply the same parameters as {AWS.DynamoDB.scan} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.scan
   * @example Scan the table with a filter expression
   *  var params = {
   *    TableName : 'Table',
   *    FilterExpression : 'Year = :this_year',
   *    ExpressionAttributeValues : {':this_year' : 2015}
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.scan(params, function(err, data) {
   *     if (err) console.log(err);
   *     else console.log(data);
   *  });
   *
   */
  scan: function(params, callback) {
    var operation = this.serviceClientOperationsMap['scan'];
    return this.makeServiceRequest(operation, params, callback);
  },

   /**
    * Directly access items from a table by primary key or a secondary index.
    *
    * Supply the same parameters as {AWS.DynamoDB.query} with
    * `AttributeValue`s substituted by native JavaScript types.
    *
    * @see AWS.DynamoDB.query
    * @example Query an index
    *  var params = {
    *    TableName: 'Table',
    *    IndexName: 'Index',
    *    KeyConditionExpression: 'HashKey = :hkey and RangeKey > :rkey',
    *    ExpressionAttributeValues: {
    *      ':hkey': 'key',
    *      ':rkey': 2015
    *    }
    *  };
    *
    *  var documentClient = new AWS.DynamoDB.DocumentClient();
    *
    *  documentClient.query(params, function(err, data) {
    *     if (err) console.log(err);
    *     else console.log(data);
    *  });
    *
    */
  query: function(params, callback) {
    var operation = this.serviceClientOperationsMap['query'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Synchronous write operation that groups up to 25 action requests.
   *
   * Supply the same parameters as {AWS.DynamoDB.transactWriteItems} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.transactWriteItems
   * @example Get items from multiple tables
   *  var params = {
   *    TransactItems: [{
   *      Put: {
   *        TableName : 'Table0',
   *        Item: {
   *          HashKey: 'haskey',
   *          NumAttribute: 1,
   *          BoolAttribute: true,
   *          ListAttribute: [1, 'two', false],
   *          MapAttribute: { foo: 'bar'},
   *          NullAttribute: null
   *        }
   *      }
   *    }, {
   *      Update: {
   *        TableName: 'Table1',
   *        Key: { HashKey : 'hashkey' },
   *        UpdateExpression: 'set #a = :x + :y',
   *        ConditionExpression: '#a < :MAX',
   *        ExpressionAttributeNames: {'#a' : 'Sum'},
   *        ExpressionAttributeValues: {
   *          ':x' : 20,
   *          ':y' : 45,
   *          ':MAX' : 100,
   *        }
   *      }
   *    }]
   *  };
   *
   *  documentClient.transactWrite(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   */
  transactWrite: function(params, callback) {
    var operation = this.serviceClientOperationsMap['transactWrite'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Atomically retrieves multiple items from one or more tables (but not from indexes)
   * in a single account and region.
   *
   * Supply the same parameters as {AWS.DynamoDB.transactGetItems} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.transactGetItems
   * @example Get items from multiple tables
   *  var params = {
   *    TransactItems: [{
   *      Get: {
   *        TableName : 'Table0',
   *        Key: {
   *          HashKey: 'hashkey0'
   *        }
   *      }
   *    }, {
   *      Get: {
   *        TableName : 'Table1',
   *        Key: {
   *          HashKey: 'hashkey1'
   *        }
   *      }
   *    }]
   *  };
   *
   *  documentClient.transactGet(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   */
  transactGet: function(params, callback) {
    var operation = this.serviceClientOperationsMap['transactGet'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Creates a set of elements inferring the type of set from
   * the type of the first element. Amazon DynamoDB currently supports
   * the number sets, string sets, and binary sets. For more information
   * about DynamoDB data types see the documentation on the
   * [Amazon DynamoDB Data Model](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModel.DataTypes).
   *
   * @param list [Array] Collection to represent your DynamoDB Set
   * @param options [map]
   *  * **validate** [Boolean] set to true if you want to validate the type
   *    of each element in the set. Defaults to `false`.
   * @example Creating a number set
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  var params = {
   *    Item: {
   *      hashkey: 'hashkey'
   *      numbers: documentClient.createSet([1, 2, 3]);
   *    }
   *  };
   *
   *  documentClient.put(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  createSet: function(list, options) {
    options = options || {};
    return new DynamoDBSet(list, options);
  },

  /**
   * @api private
   */
  getTranslator: function() {
    return new Translator(this.options);
  },

  /**
   * @api private
   */
  setupRequest: function setupRequest(request) {
    var self = this;
    var translator = self.getTranslator();
    var operation = request.operation;
    var inputShape = request.service.api.operations[operation].input;
    request._events.validate.unshift(function(req) {
      req.rawParams = AWS.util.copy(req.params);
      req.params = translator.translateInput(req.rawParams, inputShape);
    });
  },

  /**
   * @api private
   */
  setupResponse: function setupResponse(request) {
    var self = this;
    var translator = self.getTranslator();
    var outputShape = self.service.api.operations[request.operation].output;
    request.on('extractData', function(response) {
      response.data = translator.translateOutput(response.data, outputShape);
    });

    var response = request.response;
    response.nextPage = function(cb) {
      var resp = this;
      var req = resp.request;
      var config;
      var service = req.service;
      var operation = req.operation;
      try {
        config = service.paginationConfig(operation, true);
      } catch (e) { resp.error = e; }

      if (!resp.hasNextPage()) {
        if (cb) cb(resp.error, null);
        else if (resp.error) throw resp.error;
        return null;
      }

      var params = AWS.util.copy(req.rawParams);
      if (!resp.nextPageTokens) {
        return cb ? cb(null, null) : null;
      } else {
        var inputTokens = config.inputToken;
        if (typeof inputTokens === 'string') inputTokens = [inputTokens];
        for (var i = 0; i < inputTokens.length; i++) {
          params[inputTokens[i]] = resp.nextPageTokens[i];
        }
        return self[operation](params, cb);
      }
    };
  }

});

/**
 * @api private
 */
module.exports = AWS.DynamoDB.DocumentClient;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/dynamodb/numberValue.js":
/*!********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/dynamodb/numberValue.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);

/**
 * An object recognizable as a numeric value that stores the underlying number
 * as a string.
 *
 * Intended to be a deserialization target for the DynamoDB Document Client when
 * the `wrapNumbers` flag is set. This allows for numeric values that lose
 * precision when converted to JavaScript's `number` type.
 */
var DynamoDBNumberValue = util.inherit({
  constructor: function NumberValue(value) {
    this.wrapperName = 'NumberValue';
    this.value = value.toString();
  },

  /**
   * Render the underlying value as a number when converting to JSON.
   */
  toJSON: function () {
    return this.toNumber();
  },

  /**
   * Convert the underlying value to a JavaScript number.
   */
  toNumber: function () {
    return Number(this.value);
  },

  /**
   * Return a string representing the unaltered value provided to the
   * constructor.
   */
  toString: function () {
    return this.value;
  }
});

/**
 * @api private
 */
module.exports = DynamoDBNumberValue;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/dynamodb/set.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/dynamodb/set.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);
var typeOf = (__webpack_require__(/*! ./types */ "../../../../node_modules/aws-sdk/lib/dynamodb/types.js").typeOf);

/**
 * @api private
 */
var memberTypeToSetType = {
  'String': 'String',
  'Number': 'Number',
  'NumberValue': 'Number',
  'Binary': 'Binary'
};

/**
 * @api private
 */
var DynamoDBSet = util.inherit({

  constructor: function Set(list, options) {
    options = options || {};
    this.wrapperName = 'Set';
    this.initialize(list, options.validate);
  },

  initialize: function(list, validate) {
    var self = this;
    self.values = [].concat(list);
    self.detectType();
    if (validate) {
      self.validate();
    }
  },

  detectType: function() {
    this.type = memberTypeToSetType[typeOf(this.values[0])];
    if (!this.type) {
      throw util.error(new Error(), {
        code: 'InvalidSetType',
        message: 'Sets can contain string, number, or binary values'
      });
    }
  },

  validate: function() {
    var self = this;
    var length = self.values.length;
    var values = self.values;
    for (var i = 0; i < length; i++) {
      if (memberTypeToSetType[typeOf(values[i])] !== self.type) {
        throw util.error(new Error(), {
          code: 'InvalidType',
          message: self.type + ' Set contains ' + typeOf(values[i]) + ' value'
        });
      }
    }
  },

  /**
   * Render the underlying values only when converting to JSON.
   */
  toJSON: function() {
    var self = this;
    return self.values;
  }

});

/**
 * @api private
 */
module.exports = DynamoDBSet;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/dynamodb/translator.js":
/*!*******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/dynamodb/translator.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);
var convert = __webpack_require__(/*! ./converter */ "../../../../node_modules/aws-sdk/lib/dynamodb/converter.js");

var Translator = function(options) {
  options = options || {};
  this.attrValue = options.attrValue;
  this.convertEmptyValues = Boolean(options.convertEmptyValues);
  this.wrapNumbers = Boolean(options.wrapNumbers);
};

Translator.prototype.translateInput = function(value, shape) {
  this.mode = 'input';
  return this.translate(value, shape);
};

Translator.prototype.translateOutput = function(value, shape) {
  this.mode = 'output';
  return this.translate(value, shape);
};

Translator.prototype.translate = function(value, shape) {
  var self = this;
  if (!shape || value === undefined) return undefined;

  if (shape.shape === self.attrValue) {
    return convert[self.mode](value, {
      convertEmptyValues: self.convertEmptyValues,
      wrapNumbers: self.wrapNumbers,
    });
  }
  switch (shape.type) {
    case 'structure': return self.translateStructure(value, shape);
    case 'map': return self.translateMap(value, shape);
    case 'list': return self.translateList(value, shape);
    default: return self.translateScalar(value, shape);
  }
};

Translator.prototype.translateStructure = function(structure, shape) {
  var self = this;
  if (structure == null) return undefined;

  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      var result = self.translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
};

Translator.prototype.translateList = function(list, shape) {
  var self = this;
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = self.translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
};

Translator.prototype.translateMap = function(map, shape) {
  var self = this;
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = self.translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
};

Translator.prototype.translateScalar = function(value, shape) {
  return shape.toType(value);
};

/**
 * @api private
 */
module.exports = Translator;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/dynamodb/types.js":
/*!**************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/dynamodb/types.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);

function typeOf(data) {
  if (data === null && typeof data === 'object') {
    return 'null';
  } else if (data !== undefined && isBinary(data)) {
    return 'Binary';
  } else if (data !== undefined && data.constructor) {
    return data.wrapperName || util.typeName(data.constructor);
  } else if (data !== undefined && typeof data === 'object') {
    // this object is the result of Object.create(null), hence the absence of a
    // defined constructor
    return 'Object';
  } else {
    return 'undefined';
  }
}

function isBinary(data) {
  var types = [
    'Buffer', 'File', 'Blob', 'ArrayBuffer', 'DataView',
    'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
    'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array',
    'Float32Array', 'Float64Array'
  ];
  if (util.isNode()) {
    var Stream = util.stream.Stream;
    if (util.Buffer.isBuffer(data) || data instanceof Stream) {
      return true;
    }
  }

  for (var i = 0; i < types.length; i++) {
    if (data !== undefined && data.constructor) {
      if (util.isType(data, types[i])) return true;
      if (util.typeName(data.constructor) === types[i]) return true;
    }
  }

  return false;
}

/**
 * @api private
 */
module.exports = {
  typeOf: typeOf,
  isBinary: isBinary
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js":
/*!*****************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eventMessageChunker = (__webpack_require__(/*! ../event-stream/event-message-chunker */ "../../../../node_modules/aws-sdk/lib/event-stream/event-message-chunker.js").eventMessageChunker);
var parseEvent = (__webpack_require__(/*! ./parse-event */ "../../../../node_modules/aws-sdk/lib/event-stream/parse-event.js").parseEvent);

function createEventStream(body, parser, model) {
    var eventMessages = eventMessageChunker(body);

    var events = [];

    for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
    }

    return events;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js":
/*!*****************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);
var Transform = (__webpack_require__(/*! stream */ "stream").Transform);
var allocBuffer = util.buffer.alloc;

/** @type {Transform} */
function EventMessageChunkerStream(options) {
    Transform.call(this, options);

    this.currentMessageTotalLength = 0;
    this.currentMessagePendingLength = 0;
    /** @type {Buffer} */
    this.currentMessage = null;

    /** @type {Buffer} */
    this.messageLengthBuffer = null;
}

EventMessageChunkerStream.prototype = Object.create(Transform.prototype);

/**
 *
 * @param {Buffer} chunk
 * @param {string} encoding
 * @param {*} callback
 */
EventMessageChunkerStream.prototype._transform = function(chunk, encoding, callback) {
    var chunkLength = chunk.length;
    var currentOffset = 0;

    while (currentOffset < chunkLength) {
        // create new message if necessary
        if (!this.currentMessage) {
            // working on a new message, determine total length
            var bytesRemaining = chunkLength - currentOffset;
            // prevent edge case where total length spans 2 chunks
            if (!this.messageLengthBuffer) {
                this.messageLengthBuffer = allocBuffer(4);
            }
            var numBytesForTotal = Math.min(
                4 - this.currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer
                bytesRemaining // bytes left in chunk
            );

            chunk.copy(
                this.messageLengthBuffer,
                this.currentMessagePendingLength,
                currentOffset,
                currentOffset + numBytesForTotal
            );

            this.currentMessagePendingLength += numBytesForTotal;
            currentOffset += numBytesForTotal;

            if (this.currentMessagePendingLength < 4) {
                // not enough information to create the current message
                break;
            }
            this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));
            this.messageLengthBuffer = null;
        }

        // write data into current message
        var numBytesToWrite = Math.min(
            this.currentMessageTotalLength - this.currentMessagePendingLength, // number of bytes left to complete message
            chunkLength - currentOffset // number of bytes left in the original chunk
        );
        chunk.copy(
            this.currentMessage, // target buffer
            this.currentMessagePendingLength, // target offset
            currentOffset, // chunk offset
            currentOffset + numBytesToWrite // chunk end to write
        );
        this.currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;

        // check if a message is ready to be pushed
        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {
            // push out the message
            this.push(this.currentMessage);
            // cleanup
            this.currentMessage = null;
            this.currentMessageTotalLength = 0;
            this.currentMessagePendingLength = 0;
        }
    }

    callback();
};

EventMessageChunkerStream.prototype._flush = function(callback) {
    if (this.currentMessageTotalLength) {
        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {
            callback(null, this.currentMessage);
        } else {
            callback(new Error('Truncated event message received.'));
        }
    } else {
        callback();
    }
};

/**
 * @param {number} size Size of the message to be allocated.
 * @api private
 */
EventMessageChunkerStream.prototype.allocateMessage = function(size) {
    if (typeof size !== 'number') {
        throw new Error('Attempted to allocate an event message where size was not a number: ' + size);
    }
    this.currentMessageTotalLength = size;
    this.currentMessagePendingLength = 4;
    this.currentMessage = allocBuffer(size);
    this.currentMessage.writeUInt32BE(size, 0);
};

/**
 * @api private
 */
module.exports = {
    EventMessageChunkerStream: EventMessageChunkerStream
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/event-message-chunker.js":
/*!**********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/event-message-chunker.js ***!
  \**********************************************************************************/
/***/ ((module) => {

/**
 * Takes in a buffer of event messages and splits them into individual messages.
 * @param {Buffer} buffer
 * @api private
 */
function eventMessageChunker(buffer) {
    /** @type Buffer[] */
    var messages = [];
    var offset = 0;

    while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);

        // create new buffer for individual message (shares memory with original)
        var message = buffer.slice(offset, totalLength + offset);
        // increment offset to it starts at the next message
        offset += totalLength;

        messages.push(message);
    }

    return messages;
}

/**
 * @api private
 */
module.exports = {
    eventMessageChunker: eventMessageChunker
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js":
/*!**********************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Transform = (__webpack_require__(/*! stream */ "stream").Transform);
var parseEvent = (__webpack_require__(/*! ./parse-event */ "../../../../node_modules/aws-sdk/lib/event-stream/parse-event.js").parseEvent);

/** @type {Transform} */
function EventUnmarshallerStream(options) {
    options = options || {};
    // set output to object mode
    options.readableObjectMode = true;
    Transform.call(this, options);
    this._readableState.objectMode = true;

    this.parser = options.parser;
    this.eventStreamModel = options.eventStreamModel;
}

EventUnmarshallerStream.prototype = Object.create(Transform.prototype);

/**
 *
 * @param {Buffer} chunk
 * @param {string} encoding
 * @param {*} callback
 */
EventUnmarshallerStream.prototype._transform = function(chunk, encoding, callback) {
    try {
        var event = parseEvent(this.parser, chunk, this.eventStreamModel);
        this.push(event);
        return callback();
    } catch (err) {
        callback(err);
    }
};

/**
 * @api private
 */
module.exports = {
    EventUnmarshallerStream: EventUnmarshallerStream
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/int64.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/int64.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);
var toBuffer = util.buffer.toBuffer;

/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 * @param {Buffer} bytes
 *
 * @api private
 */
function Int64(bytes) {
    if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
    }
    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);

    this.bytes = bytes;
}

/**
 * @param {number} number
 * @returns {Int64}
 *
 * @api private
 */
Int64.fromNumber = function(number) {
    if (number > 9223372036854775807 || number < -9223372036854775808) {
        throw new Error(
            number + ' is too large (or, if negative, too small) to represent as an Int64'
        );
    }

    var bytes = new Uint8Array(8);
    for (
        var i = 7, remaining = Math.abs(Math.round(number));
        i > -1 && remaining > 0;
        i--, remaining /= 256
    ) {
        bytes[i] = remaining;
    }

    if (number < 0) {
        negate(bytes);
    }

    return new Int64(bytes);
};

/**
 * @returns {number}
 *
 * @api private
 */
Int64.prototype.valueOf = function() {
    var bytes = this.bytes.slice(0);
    var negative = bytes[0] & 128;
    if (negative) {
        negate(bytes);
    }

    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
};

Int64.prototype.toString = function() {
    return String(this.valueOf());
};

/**
 * @param {Buffer} bytes
 *
 * @api private
 */
function negate(bytes) {
    for (var i = 0; i < 8; i++) {
        bytes[i] ^= 0xFF;
    }
    for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
            break;
        }
    }
}

/**
 * @api private
 */
module.exports = {
    Int64: Int64
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/parse-event.js":
/*!************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/parse-event.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parseMessage = (__webpack_require__(/*! ./parse-message */ "../../../../node_modules/aws-sdk/lib/event-stream/parse-message.js").parseMessage);

/**
 *
 * @param {*} parser
 * @param {Buffer} message
 * @param {*} shape
 * @api private
 */
function parseEvent(parser, message, shape) {
    var parsedMessage = parseMessage(message);

    // check if message is an event or error
    var messageType = parsedMessage.headers[':message-type'];
    if (messageType) {
        if (messageType.value === 'error') {
            throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
            // not sure how to parse non-events/non-errors, ignore for now
            return;
        }
    }

    // determine event type
    var eventType = parsedMessage.headers[':event-type'];
    // check that the event type is modeled
    var eventModel = shape.members[eventType.value];
    if (!eventModel) {
        return;
    }

    var result = {};
    // check if an event payload exists
    var eventPayloadMemberName = eventModel.eventPayloadMemberName;
    if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        // if the shape is binary, return the byte array
        if (payloadShape.type === 'binary') {
            result[eventPayloadMemberName] = parsedMessage.body;
        } else {
            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
    }

    // read event headers
    var eventHeaderNames = eventModel.eventHeaderMemberNames;
    for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
            // parse the header!
            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
    }

    var output = {};
    output[eventType.value] = result;
    return output;
}

function parseError(message) {
    var errorCode = message.headers[':error-code'];
    var errorMessage = message.headers[':error-message'];
    var error = new Error(errorMessage.value || errorMessage);
    error.code = error.name = errorCode.value || errorCode;
    return error;
}

/**
 * @api private
 */
module.exports = {
    parseEvent: parseEvent
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/parse-message.js":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/parse-message.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Int64 = (__webpack_require__(/*! ./int64 */ "../../../../node_modules/aws-sdk/lib/event-stream/int64.js").Int64);

var splitMessage = (__webpack_require__(/*! ./split-message */ "../../../../node_modules/aws-sdk/lib/event-stream/split-message.js").splitMessage);

var BOOLEAN_TAG = 'boolean';
var BYTE_TAG = 'byte';
var SHORT_TAG = 'short';
var INT_TAG = 'integer';
var LONG_TAG = 'long';
var BINARY_TAG = 'binary';
var STRING_TAG = 'string';
var TIMESTAMP_TAG = 'timestamp';
var UUID_TAG = 'uuid';

/**
 * @api private
 *
 * @param {Buffer} headers
 */
function parseHeaders(headers) {
    var out = {};
    var position = 0;
    while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
            case 0 /* boolTrue */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: true
                };
                break;
            case 1 /* boolFalse */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: false
                };
                break;
            case 2 /* byte */:
                out[name] = {
                    type: BYTE_TAG,
                    value: headers.readInt8(position++)
                };
                break;
            case 3 /* short */:
                out[name] = {
                    type: SHORT_TAG,
                    value: headers.readInt16BE(position)
                };
                position += 2;
                break;
            case 4 /* integer */:
                out[name] = {
                    type: INT_TAG,
                    value: headers.readInt32BE(position)
                };
                position += 4;
                break;
            case 5 /* long */:
                out[name] = {
                    type: LONG_TAG,
                    value: new Int64(headers.slice(position, position + 8))
                };
                position += 8;
                break;
            case 6 /* byteArray */:
                var binaryLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: BINARY_TAG,
                    value: headers.slice(position, position + binaryLength)
                };
                position += binaryLength;
                break;
            case 7 /* string */:
                var stringLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: STRING_TAG,
                    value: headers.slice(
                        position,
                        position + stringLength
                    ).toString()
                };
                position += stringLength;
                break;
            case 8 /* timestamp */:
                out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(
                        new Int64(headers.slice(position, position + 8))
                            .valueOf()
                    )
                };
                position += 8;
                break;
            case 9 /* uuid */:
                var uuidChars = headers.slice(position, position + 16)
                    .toString('hex');
                position += 16;
                out[name] = {
                    type: UUID_TAG,
                    value: uuidChars.substr(0, 8) + '-' +
                        uuidChars.substr(8, 4) + '-' +
                        uuidChars.substr(12, 4) + '-' +
                        uuidChars.substr(16, 4) + '-' +
                        uuidChars.substr(20)
                };
                break;
            default:
                throw new Error('Unrecognized header type tag');
        }
    }
    return out;
}

function parseMessage(message) {
    var parsed = splitMessage(message);
    return { headers: parseHeaders(parsed.headers), body: parsed.body };
}

/**
 * @api private
 */
module.exports = {
    parseMessage: parseMessage
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/split-message.js":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/split-message.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);
var toBuffer = util.buffer.toBuffer;

// All prelude components are unsigned, 32-bit integers
var PRELUDE_MEMBER_LENGTH = 4;
// The prelude consists of two components
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
// Checksums are always CRC32 hashes.
var CHECKSUM_LENGTH = 4;
// Messages must include a full prelude, a prelude checksum, and a message checksum
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

/**
 * @api private
 *
 * @param {Buffer} message
 */
function splitMessage(message) {
    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

    if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
    }

    if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
    }

    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

    if (
        expectedPreludeChecksum !== util.crypto.crc32(
            message.slice(0, PRELUDE_LENGTH)
        )
    ) {
        throw new Error(
            'The prelude checksum specified in the message (' +
            expectedPreludeChecksum +
            ') does not match the calculated CRC32 checksum.'
        );
    }

    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

    if (
        expectedMessageChecksum !== util.crypto.crc32(
            message.slice(0, message.length - CHECKSUM_LENGTH)
        )
    ) {
        throw new Error(
            'The message checksum did not match the expected value of ' +
                expectedMessageChecksum
        );
    }

    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);

    return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
    };
}

/**
 * @api private
 */
module.exports = {
    splitMessage: splitMessage
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js":
/*!******************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * What is necessary to create an event stream in node?
 *  - http response stream
 *  - parser
 *  - event stream model
 */

var EventMessageChunkerStream = (__webpack_require__(/*! ../event-stream/event-message-chunker-stream */ "../../../../node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js").EventMessageChunkerStream);
var EventUnmarshallerStream = (__webpack_require__(/*! ../event-stream/event-message-unmarshaller-stream */ "../../../../node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js").EventUnmarshallerStream);

function createEventStream(stream, parser, model) {
    var eventStream = new EventUnmarshallerStream({
        parser: parser,
        eventStreamModel: model
    });

    var eventMessageChunker = new EventMessageChunkerStream();

    stream.pipe(
        eventMessageChunker
    ).pipe(eventStream);

    stream.on('error', function(err) {
        eventMessageChunker.emit('error', err);
    });

    eventMessageChunker.on('error', function(err) {
        eventStream.emit('error', err);
    });

    return eventStream;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/event_listeners.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/event_listeners.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var SequentialExecutor = __webpack_require__(/*! ./sequential_executor */ "../../../../node_modules/aws-sdk/lib/sequential_executor.js");
var DISCOVER_ENDPOINT = (__webpack_require__(/*! ./discover_endpoint */ "../../../../node_modules/aws-sdk/lib/discover_endpoint.js").discoverEndpoint);
/**
 * The namespace used to register global event listeners for request building
 * and sending.
 */
AWS.EventListeners = {
  /**
   * @!attribute VALIDATE_CREDENTIALS
   *   A request listener that validates whether the request is being
   *   sent with credentials.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating credentials
   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_REGION
   *   A request listener that validates whether the region is set
   *   for a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating region configuration
   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_PARAMETERS
   *   A request listener that validates input parameters in a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating parameters
   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
   *     request.removeListener('validate', listener);
   *   @example Disable parameter validation globally
   *     AWS.EventListeners.Core.removeListener('validate',
   *       AWS.EventListeners.Core.VALIDATE_REGION);
   *   @readonly
   *   @return [Function]
   * @!attribute SEND
   *   A request listener that initiates the HTTP connection for a
   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
   *   @example Replacing the HTTP handler
   *     var listener = AWS.EventListeners.Core.SEND;
   *     request.removeListener('send', listener);
   *     request.on('send', function(response) {
   *       customHandler.send(response);
   *     });
   *   @return [Function]
   *   @readonly
   * @!attribute HTTP_DATA
   *   A request listener that reads data from the HTTP connection in order
   *   to build the response data.
   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
   *   Remove this handler if you are overriding the 'httpData' event and
   *   do not want extra data processing and buffering overhead.
   *   @example Disabling default data processing
   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
   *     request.removeListener('httpData', listener);
   *   @return [Function]
   *   @readonly
   */
  Core: {} /* doc hack */
};

/**
 * @api private
 */
function getOperationAuthtype(req) {
  if (!req.service.api.operations) {
    return '';
  }
  var operation = req.service.api.operations[req.operation];
  return operation ? operation.authtype : '';
}

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.isGlobalEndpoint) {
        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!req.service.config.region) {
          req.response.error = AWS.util.error(new Error(),
            {code: 'ConfigError', message: 'Missing region in config'});
        } else if (!dnsHostRegex.test(req.service.config.region)) {
          req.response.error = AWS.util.error(new Error(),
            {code: 'ConfigError', message: 'Invalid region in config'});
        }
      }
    });

    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var idempotentMembers = operation.idempotentMembers;
      if (!idempotentMembers.length) {
        return;
      }
      // creates a copy of params so user's param object isn't mutated
      var params = AWS.util.copy(req.params);
      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
        if (!params[idempotentMembers[i]]) {
          // add the member
          params[idempotentMembers[i]] = AWS.util.uuid.v4();
        }
      }
      req.params = params;
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    add('COMPUTE_CHECKSUM', 'afterBuild', function COMPUTE_CHECKSUM(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var body = req.httpRequest.body;
      var isNonStreamingPayload = body && (AWS.util.Buffer.isBuffer(body) || typeof body === 'string');
      var headers = req.httpRequest.headers;
      if (
        operation.httpChecksumRequired &&
        req.service.config.computeChecksums &&
        isNonStreamingPayload &&
        !headers['Content-MD5']
      ) {
        var md5 = AWS.util.crypto.md5(body, 'base64');
        headers['Content-MD5'] = md5;
      }
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        if (authtype.indexOf('unsigned-body') >= 0) {
          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
          return done();
        }
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      var authtype = getOperationAuthtype(req);
      var payloadMember = AWS.util.getRequestPayloadShape(req);
      if (req.httpRequest.headers['Content-Length'] === undefined) {
        try {
          var length = AWS.util.string.byteLength(req.httpRequest.body);
          req.httpRequest.headers['Content-Length'] = length;
        } catch (err) {
          if (payloadMember && payloadMember.isStreaming) {
            if (payloadMember.requiresLength) {
              //streaming payload requires length(s3, glacier)
              throw err;
            } else if (authtype.indexOf('unsigned-body') >= 0) {
              //unbounded streaming payload(lex, mediastore)
              req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
              return;
            } else {
              throw err;
            }
          }
          throw err;
        }
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    var addToHead = true;
    addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      var operations = req.service.api.operations || {};
      var operation = operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

      service.config.getCredentials(function (err, credentials) {
        if (err) {
          req.response.error = err;
          return done();
        }

        try {
          var date = service.getSkewCorrectedDate();
          var SignerClass = service.getSignerClass(req);
          var signer = new SignerClass(req.httpRequest,
            service.getSigningName(req),
            {
              signatureCache: service.config.signatureCache,
              operation: operation,
              signatureVersion: service.api.signatureVersion
            });
          signer.setServiceClientId(service._clientId);

          // clear old authorization headers
          delete req.httpRequest.headers['Authorization'];
          delete req.httpRequest.headers['Date'];
          delete req.httpRequest.headers['X-Amz-Date'];

          // add new authorization
          signer.addAuthorization(credentials, date);
          req.signedAt = date;
        } catch (e) {
          req.response.error = e;
        }
        done();
      });
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;
        var stream = resp.request.httpRequest.stream;
        var service = resp.request.service;
        var api = service.api;
        var operationName = resp.request.operation;
        var operation = api.operations[operationName] || {};

        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
          resp.request.emit(
            'httpHeaders',
            [statusCode, headers, resp, statusMessage]
          );

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              // if we detect event streams, we're going to have to
              // return the stream immediately
              if (operation.hasEventOutput && service.successfulResponse(resp)) {
                // skip reading the IncomingStream
                resp.request.emit('httpDone');
                done();
                return;
              }

              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          if (!stream || !stream.didCallback) {
            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
              // don't concatenate response chunks when streaming event stream data when response is successful
              return;
            }
            resp.request.emit('httpDone');
            done();
          }
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        if (err.code !== 'RequestAbortedError') {
          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
          err = AWS.util.error(err, {
            code: errCode,
            region: resp.request.httpRequest.region,
            hostname: resp.request.httpRequest.endpoint.hostname,
            retryable: true
          });
        }
        resp.error = err;
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }
      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.statusMessage = statusMessage;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = AWS.util.buffer.toBuffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      var service = resp.request.service;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (service.config.correctClockSkew
            && service.isClockSkewed(serverTime)) {
          service.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      // convert buffers array into single buffer
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      // delay < 0 is a signal from customBackoff to skip retries
      if (willRetry && delay >= 0) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      function isDNSError(err) {
        return err.errno === 'ENOTFOUND' ||
          typeof err.errno === 'number' &&
          typeof AWS.util.getSystemErrorName === 'function' &&
          ['EAI_NONAME', 'EAI_NODATA'].indexOf(AWS.util.getSystemErrorName(err.errno) >= 0);
      }
      if (err.code === 'NetworkingError' && isDNSError(err)) {
        var message = 'Inaccessible host: `' + err.hostname + '\' at port `' + err.port +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;
      function filterSensitiveLog(inputShape, shape) {
        if (!shape) {
          return shape;
        }
        if (inputShape.isSensitive) {
          return '***SensitiveInformation***';
        }
        switch (inputShape.type) {
          case 'structure':
            var struct = {};
            AWS.util.each(shape, function(subShapeName, subShape) {
              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
              } else {
                struct[subShapeName] = subShape;
              }
            });
            return struct;
          case 'list':
            var list = [];
            AWS.util.arrayEach(shape, function(subShape, index) {
              list.push(filterSensitiveLog(inputShape.member, subShape));
            });
            return list;
          case 'map':
            var map = {};
            AWS.util.each(shape, function(key, value) {
              map[key] = filterSensitiveLog(inputShape.value, value);
            });
            return map;
          default:
            return shape;
        }
      }

      function buildMessage() {
        var time = resp.request.service.getSkewCorrectedDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var censoredParams = req.params;
        if (
          req.service.api.operations &&
              req.service.api.operations[req.operation] &&
              req.service.api.operations[req.operation].input
        ) {
          var inputShape = req.service.api.operations[req.operation].input;
          censoredParams = filterSensitiveLog(inputShape, req.params);
        }
        var params = (__webpack_require__(/*! util */ "util").inspect)(censoredParams, true, null);
        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/json */ "../../../../node_modules/aws-sdk/lib/protocol/json.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/rest */ "../../../../node_modules/aws-sdk/lib/protocol/rest.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/rest_json */ "../../../../node_modules/aws-sdk/lib/protocol/rest_json.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/rest_xml */ "../../../../node_modules/aws-sdk/lib/protocol/rest_xml.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/query */ "../../../../node_modules/aws-sdk/lib/protocol/query.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/http.js":
/*!****************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/http.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * The endpoint that a service will talk to, for example,
 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
 * you need to override an endpoint for a service, you can
 * set the endpoint on a service by passing the endpoint
 * object with the `endpoint` option key:
 *
 * ```javascript
 * var ep = new AWS.Endpoint('awsproxy.example.com');
 * var s3 = new AWS.S3({endpoint: ep});
 * s3.service.endpoint.hostname == 'awsproxy.example.com'
 * ```
 *
 * Note that if you do not specify a protocol, the protocol will
 * be selected based on your current {AWS.config} configuration.
 *
 * @!attribute protocol
 *   @return [String] the protocol (http or https) of the endpoint
 *     URL
 * @!attribute hostname
 *   @return [String] the host portion of the endpoint, e.g.,
 *     example.com
 * @!attribute host
 *   @return [String] the host portion of the endpoint including
 *     the port, e.g., example.com:80
 * @!attribute port
 *   @return [Integer] the port of the endpoint
 * @!attribute href
 *   @return [String] the full URL of the endpoint
 */
AWS.Endpoint = inherit({

  /**
   * @overload Endpoint(endpoint)
   *   Constructs a new endpoint given an endpoint URL. If the
   *   URL omits a protocol (http or https), the default protocol
   *   set in the global {AWS.config} will be used.
   *   @param endpoint [String] the URL to construct an endpoint from
   */
  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    // Ensure the port property is set as an integer
    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});

/**
 * The low level HTTP request object, encapsulating all HTTP header
 * and body data sent by a service request.
 *
 * @!attribute method
 *   @return [String] the HTTP method of the request
 * @!attribute path
 *   @return [String] the path portion of the URI, e.g.,
 *     "/list/?start=5&num=10"
 * @!attribute headers
 *   @return [map<String,String>]
 *     a map of header keys and their respective values
 * @!attribute body
 *   @return [String] the request body payload
 * @!attribute endpoint
 *   @return [AWS.Endpoint] the endpoint for the request
 * @!attribute region
 *   @api private
 *   @return [String] the region, for signing purposes only.
 */
AWS.HttpRequest = inherit({

  /**
   * @api private
   */
  constructor: function HttpRequest(endpoint, region) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this._userAgent = '';
    this.setUserAgent();
  },

  /**
   * @api private
   */
  setUserAgent: function setUserAgent() {
    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
  },

  getUserAgentHeaderName: function getUserAgentHeaderName() {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    return prefix + 'User-Agent';
  },

  /**
   * @api private
   */
  appendToUserAgent: function appendToUserAgent(agentPartial) {
    if (typeof agentPartial === 'string' && agentPartial) {
      this._userAgent += ' ' + agentPartial;
    }
    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
  },

  /**
   * @api private
   */
  getUserAgent: function getUserAgent() {
    return this._userAgent;
  },

  /**
   * @return [String] the part of the {path} excluding the
   *   query string
   */
  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },

  /**
   * @return [String] the query string portion of the {path}
   */
  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  },

  /**
   * @api private
   * update httpRequest endpoint with endpoint string
   */
  updateEndpoint: function updateEndpoint(endpointStr) {
    var newEndpoint = new AWS.Endpoint(endpointStr);
    this.endpoint = newEndpoint;
    this.path = newEndpoint.path || '/';
    if (this.headers['Host']) {
      this.headers['Host'] = newEndpoint.host;
    }
  }
});

/**
 * The low level HTTP response object, encapsulating all HTTP header
 * and body data returned from the request.
 *
 * @!attribute statusCode
 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
 * @!attribute headers
 *   @return [map<String,String>]
 *      a map of response header keys and their respective values
 * @!attribute body
 *   @return [String] the response body payload
 * @!attribute [r] streaming
 *   @return [Boolean] whether this response is being streamed at a low-level.
 *     Defaults to `false` (buffered reads). Do not modify this manually, use
 *     {createUnbufferedStream} to convert the stream to unbuffered mode
 *     instead.
 */
AWS.HttpResponse = inherit({

  /**
   * @api private
   */
  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },

  /**
   * Disables buffering on the HTTP response and returns the stream for reading.
   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
   *   Use this object to directly read data off of the stream.
   * @note This object is only available after the {AWS.Request~httpHeaders}
   *   event has fired. This method must be called prior to
   *   {AWS.Request~httpData}.
   * @example Taking control of a stream
   *   request.on('httpHeaders', function(statusCode, headers) {
   *     if (statusCode < 300) {
   *       if (headers.etag === 'xyz') {
   *         // pipe the stream, disabling buffering
   *         var stream = this.response.httpResponse.createUnbufferedStream();
   *         stream.pipe(process.stdout);
   *       } else { // abort this request and set a better error message
   *         this.abort();
   *         this.response.error = new Error('Invalid ETag');
   *       }
   *     }
   *   }).send(console.log);
   */
  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});

/**
 * @api private
 */
AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/http/node.js":
/*!*********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/http/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var Stream = AWS.util.stream.Stream;
var TransformStream = AWS.util.stream.Transform;
var ReadableStream = AWS.util.stream.Readable;
__webpack_require__(/*! ../http */ "../../../../node_modules/aws-sdk/lib/http.js");
var CONNECTION_REUSE_ENV_NAME = 'AWS_NODEJS_CONNECTION_REUSE_ENABLED';

/**
 * @api private
 */
AWS.NodeHttpClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var pathPrefix = '';
    if (!httpOptions) httpOptions = {};
    if (httpOptions.proxy) {
      pathPrefix = endpoint.protocol + '//' + endpoint.hostname;
      if (endpoint.port !== 80 && endpoint.port !== 443) {
        pathPrefix += ':' + endpoint.port;
      }
      endpoint = new AWS.Endpoint(httpOptions.proxy);
    }

    var useSSL = endpoint.protocol === 'https:';
    var http = useSSL ? __webpack_require__(/*! https */ "https") : __webpack_require__(/*! http */ "http");
    var options = {
      host: endpoint.hostname,
      port: endpoint.port,
      method: httpRequest.method,
      headers: httpRequest.headers,
      path: pathPrefix + httpRequest.path
    };

    if (!httpOptions.agent) {
      options.agent = this.getAgent(useSSL, {
        keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === '1' ? true : false
      });
    }

    AWS.util.update(options, httpOptions);
    delete options.proxy; // proxy isn't an HTTP option
    delete options.timeout; // timeout isn't an HTTP option

    var stream = http.request(options, function (httpResp) {
      if (stream.didCallback) return;

      callback(httpResp);
      httpResp.emit(
        'headers',
        httpResp.statusCode,
        httpResp.headers,
        httpResp.statusMessage
      );
    });
    httpRequest.stream = stream; // attach stream to httpRequest
    stream.didCallback = false;

    // connection timeout support
    if (httpOptions.connectTimeout) {
      var connectTimeoutId;
      stream.on('socket', function(socket) {
        if (socket.connecting) {
          connectTimeoutId = setTimeout(function connectTimeout() {
            if (stream.didCallback) return; stream.didCallback = true;

            stream.abort();
            errCallback(AWS.util.error(
              new Error('Socket timed out without establishing a connection'),
              {code: 'TimeoutError'}
            ));
          }, httpOptions.connectTimeout);
          socket.on('connect', function() {
            clearTimeout(connectTimeoutId);
            connectTimeoutId = null;
          });
        }
      });
    }

    // timeout support
    stream.setTimeout(httpOptions.timeout || 0, function() {
      if (stream.didCallback) return; stream.didCallback = true;

      var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';
      errCallback(AWS.util.error(new Error(msg), {code: 'TimeoutError'}));
      stream.abort();
    });

    stream.on('error', function(err) {
      if (connectTimeoutId) {
        clearTimeout(connectTimeoutId);
        connectTimeoutId = null;
      }
      if (stream.didCallback) return; stream.didCallback = true;
      if ('ECONNRESET' === err.code || 'EPIPE' === err.code || 'ETIMEDOUT' === err.code) {
        errCallback(AWS.util.error(err, {code: 'TimeoutError'}));
      } else {
        errCallback(err);
      }
    });

    var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
    if (expect === '100-continue') {
      stream.once('continue', function() {
        self.writeBody(stream, httpRequest);
      });
    } else {
      this.writeBody(stream, httpRequest);
    }

    return stream;
  },

  writeBody: function writeBody(stream, httpRequest) {
    var body = httpRequest.body;
    var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);

    if (body instanceof Stream) {
      // For progress support of streaming content -
      // pipe the data through a transform stream to emit 'sendProgress' events
      var progressStream = this.progressStream(stream, totalBytes);
      if (progressStream) {
        body.pipe(progressStream).pipe(stream);
      } else {
        body.pipe(stream);
      }
    } else if (body) {
      // The provided body is a buffer/string and is already fully available in memory -
      // For performance it's best to send it as a whole by calling stream.end(body),
      // Callers expect a 'sendProgress' event which is best emitted once
      // the http request stream has been fully written and all data flushed.
      // The use of totalBytes is important over body.length for strings where
      // length is char length and not byte length.
      stream.once('finish', function() {
        stream.emit('sendProgress', {
          loaded: totalBytes,
          total: totalBytes
        });
      });
      stream.end(body);
    } else {
      // no request body
      stream.end();
    }
  },

  /**
   * Create the https.Agent or http.Agent according to the request schema.
   */
  getAgent: function getAgent(useSSL, agentOptions) {
    var http = useSSL ? __webpack_require__(/*! https */ "https") : __webpack_require__(/*! http */ "http");
    if (useSSL) {
      if (!AWS.NodeHttpClient.sslAgent) {
        AWS.NodeHttpClient.sslAgent = new http.Agent(AWS.util.merge({
          rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0' ? false : true
        }, agentOptions || {}));
        AWS.NodeHttpClient.sslAgent.setMaxListeners(0);

        // delegate maxSockets to globalAgent, set a default limit of 50 if current value is Infinity.
        // Users can bypass this default by supplying their own Agent as part of SDK configuration.
        Object.defineProperty(AWS.NodeHttpClient.sslAgent, 'maxSockets', {
          enumerable: true,
          get: function() {
            var defaultMaxSockets = 50;
            var globalAgent = http.globalAgent;
            if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {
              return globalAgent.maxSockets;
            }
            return defaultMaxSockets;
          }
        });
      }
      return AWS.NodeHttpClient.sslAgent;
    } else {
      if (!AWS.NodeHttpClient.agent) {
        AWS.NodeHttpClient.agent = new http.Agent(agentOptions);
      }
      return AWS.NodeHttpClient.agent;
    }
  },

  progressStream: function progressStream(stream, totalBytes) {
    if (typeof TransformStream === 'undefined') {
      // for node 0.8 there is no streaming progress
      return;
    }
    var loadedBytes = 0;
    var reporter = new TransformStream();
    reporter._transform = function(chunk, encoding, callback) {
      if (chunk) {
        loadedBytes += chunk.length;
        stream.emit('sendProgress', {
          loaded: loadedBytes,
          total: totalBytes
        });
      }
      callback(null, chunk);
    };
    return reporter;
  },

  emitter: null
});

/**
 * @!ignore
 */

/**
 * @api private
 */
AWS.HttpClient.prototype = AWS.NodeHttpClient.prototype;

/**
 * @api private
 */
AWS.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/json/builder.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/json/builder.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (shape.isDocument) {
    return structure;
  }
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

/**
 * @api private
 */
module.exports = JsonBuilder;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/json/parser.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/json/parser.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;
  if (shape.isDocument) return structure;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

/**
 * @api private
 */
module.exports = JsonParser;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/metadata_service.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/metadata_service.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ./http */ "../../../../node_modules/aws-sdk/lib/http.js");
var inherit = AWS.util.inherit;
var getMetadataServiceEndpoint = __webpack_require__(/*! ./metadata_service/get_metadata_service_endpoint */ "../../../../node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js");
var URL = (__webpack_require__(/*! url */ "url").URL);

/**
 * Represents a metadata service available on EC2 instances. Using the
 * {request} method, you can receieve metadata about any available resource
 * on the metadata service.
 *
 * You can disable the use of the IMDS by setting the AWS_EC2_METADATA_DISABLED
 * environment variable to a truthy value.
 *
 * @!attribute [r] httpOptions
 *   @return [map] a map of options to pass to the underlying HTTP request:
 *
 *     * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
 *       before aborting the connection. Set to 0 for no timeout.
 *
 * @!macro nobrowser
 */
AWS.MetadataService = inherit({
  /**
   * @return [String] the endpoint of the instance metadata service
   */
  endpoint: getMetadataServiceEndpoint(),

  /**
   * @!ignore
   */

  /**
   * Default HTTP options. By default, the metadata service is set to not
   * timeout on long requests. This means that on non-EC2 machines, this
   * request will never return. If you are calling this operation from an
   * environment that may not always run on EC2, set a `timeout` value so
   * the SDK will abort the request after a given number of milliseconds.
   */
  httpOptions: { timeout: 0 },

  /**
   * when enabled, metadata service will not fetch token
   */
  disableFetchToken: false,

  /**
   * Creates a new MetadataService object with a given set of options.
   *
   * @option options host [String] the hostname of the instance metadata
   *   service
   * @option options httpOptions [map] a map of options to pass to the
   *   underlying HTTP request:
   *
   *   * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
   *     before aborting the connection. Set to 0 for no timeout.
   * @option options maxRetries [Integer] the maximum number of retries to
   *   perform for timeout errors
   * @option options retryDelayOptions [map] A set of options to configure the
   *   retry delay on retryable errors. See AWS.Config for details.
   */
  constructor: function MetadataService(options) {
    if (options && options.host) {
      options.endpoint = 'http://' + options.host;
      delete options.host;
    }
    AWS.util.update(this, options);
  },

  /**
   * Sends a request to the instance metadata service for a given resource.
   *
   * @param path [String] the path of the resource to get
   *
   * @param options [map] an optional map used to make request
   *
   *   * **method** (String) &mdash; HTTP request method
   *
   *   * **headers** (map<String,String>) &mdash; a map of response header keys and their respective values
   *
   * @callback callback function(err, data)
   *   Called when a response is available from the service.
   *   @param err [Error, null] if an error occurred, this value will be set
   *   @param data [String, null] if the request was successful, the body of
   *     the response
   */
  request: function request(path, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }

    if (process.env[AWS.util.imdsDisabledEnv]) {
      callback(new Error('EC2 Instance Metadata Service access disabled'));
      return;
    }

    path = path || '/';

    // Verify that host is a valid URL
    if (URL) { new URL(this.endpoint); }

    var httpRequest = new AWS.HttpRequest(this.endpoint + path);
    httpRequest.method = options.method || 'GET';
    if (options.headers) {
      httpRequest.headers = options.headers;
    }
    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
  },

  /**
  * @api private
  */
  loadCredentialsCallbacks: [],

  /**
   * Fetches metadata token used for getting credentials
   *
   * @api private
   * @callback callback function(err, token)
   *   Called when token is loaded from the resource
   */
  fetchMetadataToken: function fetchMetadataToken(callback) {
    var self = this;
    var tokenFetchPath = '/latest/api/token';
    self.request(
      tokenFetchPath,
      {
        'method': 'PUT',
        'headers': {
          'x-aws-ec2-metadata-token-ttl-seconds': '21600'
        }
      },
      callback
    );
  },

  /**
   * Fetches credentials
   *
   * @api private
   * @callback cb function(err, creds)
   *   Called when credentials are loaded from the resource
   */
  fetchCredentials: function fetchCredentials(options, cb) {
    var self = this;
    var basePath = '/latest/meta-data/iam/security-credentials/';

    self.request(basePath, options, function (err, roleName) {
      if (err) {
        self.disableFetchToken = !(err.statusCode === 401);
        cb(AWS.util.error(
          err,
          {
            message: 'EC2 Metadata roleName request returned error'
          }
        ));
        return;
      }
      roleName = roleName.split('\n')[0]; // grab first (and only) role
      self.request(basePath + roleName, options, function (credErr, credData) {
        if (credErr) {
          self.disableFetchToken = !(credErr.statusCode === 401);
          cb(AWS.util.error(
            credErr,
            {
              message: 'EC2 Metadata creds request returned error'
            }
          ));
          return;
        }
        try {
          var credentials = JSON.parse(credData);
          cb(null, credentials);
        } catch (parseError) {
          cb(parseError);
        }
      });
    });
  },

  /**
   * Loads a set of credentials stored in the instance metadata service
   *
   * @api private
   * @callback callback function(err, credentials)
   *   Called when credentials are loaded from the resource
   *   @param err [Error] if an error occurred, this value will be set
   *   @param credentials [Object] the raw JSON object containing all
   *     metadata from the credentials resource
   */
  loadCredentials: function loadCredentials(callback) {
    var self = this;
    self.loadCredentialsCallbacks.push(callback);
    if (self.loadCredentialsCallbacks.length > 1) { return; }

    function callbacks(err, creds) {
      var cb;
      while ((cb = self.loadCredentialsCallbacks.shift()) !== undefined) {
        cb(err, creds);
      }
    }

    if (self.disableFetchToken) {
      self.fetchCredentials({}, callbacks);
    } else {
      self.fetchMetadataToken(function(tokenError, token) {
        if (tokenError) {
          if (tokenError.code === 'TimeoutError') {
            self.disableFetchToken = true;
          } else if (tokenError.retryable === true) {
            callbacks(AWS.util.error(
              tokenError,
              {
                message: 'EC2 Metadata token request returned error'
              }
            ));
            return;
          } else if (tokenError.statusCode === 400) {
            callbacks(AWS.util.error(
              tokenError,
              {
                message: 'EC2 Metadata token request returned 400'
              }
            ));
            return;
          }
        }
        var options = {};
        if (token) {
          options.headers = {
            'x-aws-ec2-metadata-token': token
          };
        }
        self.fetchCredentials(options, callbacks);
      });

    }
  }
});

/**
 * @api private
 */
module.exports = AWS.MetadataService;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint.js":
/*!*****************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint.js ***!
  \*****************************************************************************/
/***/ ((module) => {

var getEndpoint = function() {
  return {
    IPv4: 'http://169.254.169.254',
    IPv6: 'http://[fd00:ec2::254]',
  };
};

module.exports = getEndpoint;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js":
/*!********************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js ***!
  \********************************************************************************************/
/***/ ((module) => {

var ENV_ENDPOINT_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT';
var CONFIG_ENDPOINT_NAME = 'ec2_metadata_service_endpoint';

var getEndpointConfigOptions = function() {
  return {
    environmentVariableSelector: function(env) { return env[ENV_ENDPOINT_NAME]; },
    configFileSelector: function(profile) { return profile[CONFIG_ENDPOINT_NAME]; },
    default: undefined,
  };
};

module.exports = getEndpointConfigOptions;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js":
/*!**********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js ***!
  \**********************************************************************************/
/***/ ((module) => {

var getEndpointMode = function() {
  return {
    IPv4: 'IPv4',
    IPv6: 'IPv6',
  };
};

module.exports = getEndpointMode;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js":
/*!*************************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EndpointMode = __webpack_require__(/*! ./get_endpoint_mode */ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js")();

var ENV_ENDPOINT_MODE_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE';
var CONFIG_ENDPOINT_MODE_NAME = 'ec2_metadata_service_endpoint_mode';

var getEndpointModeConfigOptions = function() {
  return {
    environmentVariableSelector: function(env) { return env[ENV_ENDPOINT_MODE_NAME]; },
    configFileSelector: function(profile) { return profile[CONFIG_ENDPOINT_MODE_NAME]; },
    default: EndpointMode.IPv4,
  };
};

module.exports = getEndpointModeConfigOptions;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js":
/*!**********************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

var Endpoint = __webpack_require__(/*! ./get_endpoint */ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint.js")();
var EndpointMode = __webpack_require__(/*! ./get_endpoint_mode */ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js")();

var ENDPOINT_CONFIG_OPTIONS = __webpack_require__(/*! ./get_endpoint_config_options */ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js")();
var ENDPOINT_MODE_CONFIG_OPTIONS = __webpack_require__(/*! ./get_endpoint_mode_config_options */ "../../../../node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js")();

var getMetadataServiceEndpoint = function() {
  var endpoint = AWS.util.loadConfig(ENDPOINT_CONFIG_OPTIONS);
  if (endpoint !== undefined) return endpoint;

  var endpointMode = AWS.util.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS);
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint.IPv4;
    case EndpointMode.IPv6:
      return Endpoint.IPv6;
    default:
      throw new Error('Unsupported endpoint mode: ' + endpointMode);
  }
};

module.exports = getMetadataServiceEndpoint;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/model/api.js":
/*!*********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/model/api.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Collection = __webpack_require__(/*! ./collection */ "../../../../node_modules/aws-sdk/lib/model/collection.js");
var Operation = __webpack_require__(/*! ./operation */ "../../../../node_modules/aws-sdk/lib/model/operation.js");
var Shape = __webpack_require__(/*! ./shape */ "../../../../node_modules/aws-sdk/lib/model/shape.js");
var Paginator = __webpack_require__(/*! ./paginator */ "../../../../node_modules/aws-sdk/lib/model/paginator.js");
var ResourceWaiter = __webpack_require__(/*! ./resource_waiter */ "../../../../node_modules/aws-sdk/lib/model/resource_waiter.js");
var metadata = __webpack_require__(/*! ../../apis/metadata.json */ "../../../../node_modules/aws-sdk/apis/metadata.json");

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  var self = this;
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  var serviceIdentifier = options.serviceIdentifier;
  delete options.serviceIdentifier;

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);
  property(this, 'serviceId', api.metadata.serviceId);
  if (serviceIdentifier && metadata[serviceIdentifier]) {
      property(this, 'xmlNoDefaultLists', metadata[serviceIdentifier].xmlNoDefaultLists, false);
  }

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  function addEndpointOperation(name, operation) {
    if (operation.endpointoperation === true) {
      property(self, 'endpointOperation', util.string.lowerFirst(name));
    }
    if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
      property(
        self,
        'hasRequiredEndpointDiscovery',
        operation.endpointdiscovery.required === true
      );
    }
  }

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst, addEndpointOperation));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
}

/**
 * @api private
 */
module.exports = Api;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/model/collection.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/model/collection.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizedProperty = (__webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js").memoizedProperty);

function memoize(name, value, factory, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return factory(name, value);
  });
}

function Collection(iterable, options, factory, nameTr, callback) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], factory, nameTr);
      if (callback) callback(id, iterable[id]);
    }
  }
}

/**
 * @api private
 */
module.exports = Collection;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/model/operation.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/model/operation.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Shape = __webpack_require__(/*! ./shape */ "../../../../node_modules/aws-sdk/lib/model/shape.js");

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  var self = this;
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'endpoint', operation.endpoint);
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');
  property(
    this,
    'endpointDiscoveryRequired',
    operation.endpointdiscovery ?
      (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') :
    'NULL'
  );

  // httpChecksum replaces usage of httpChecksumRequired, but some APIs
  // (s3control) still uses old trait.
  var httpChecksumRequired = operation.httpChecksumRequired
    || (operation.httpChecksum && operation.httpChecksum.requestChecksumRequired);
  property(this, 'httpChecksumRequired', httpChecksumRequired, false);

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }

  // idempotentMembers only tracks top-level input shapes
  memoizedProperty(this, 'idempotentMembers', function() {
    var idempotentMembers = [];
    var input = self.input;
    var members = input.members;
    if (!input.members) {
      return idempotentMembers;
    }
    for (var name in members) {
      if (!members.hasOwnProperty(name)) {
        continue;
      }
      if (members[name].isIdempotent === true) {
        idempotentMembers.push(name);
      }
    }
    return idempotentMembers;
  });

  memoizedProperty(this, 'hasEventOutput', function() {
    var output = self.output;
    return hasEventStream(output);
  });
}

function hasEventStream(topLevelShape) {
  var members = topLevelShape.members;
  var payload = topLevelShape.payload;

  if (!topLevelShape.members) {
    return false;
  }

  if (payload) {
    var payloadMember = members[payload];
    return payloadMember.isEventStream;
  }

  // check if any member is an event stream
  for (var name in members) {
    if (!members.hasOwnProperty(name)) {
      if (members[name].isEventStream === true) {
        return true;
      }
    }
  }
  return false;
}

/**
 * @api private
 */
module.exports = Operation;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/model/paginator.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/model/paginator.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var property = (__webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js").property);

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

/**
 * @api private
 */
module.exports = Paginator;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/model/resource_waiter.js":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/model/resource_waiter.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

/**
 * @api private
 */
module.exports = ResourceWaiter;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/model/shape.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/model/shape.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Collection = __webpack_require__(/*! ./collection */ "../../../../node_modules/aws-sdk/lib/model/collection.js");

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'requiresLength', shape.requiresLength, false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', Boolean(shape.queryName), false);
  property(this, 'isLocationName', Boolean(shape.locationName), false);
  property(this, 'isIdempotent', shape.idempotencyToken === true);
  property(this, 'isJsonValue', shape.jsonvalue === true);
  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
  property(this, 'isEventStream', Boolean(shape.eventstream), false);
  property(this, 'isEvent', Boolean(shape.event), false);
  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
  property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
  property(this, 'hostLabel', Boolean(shape.hostLabel), false);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  // type conversion and parsing
  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}

/**
 * @api private
 */
Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};

/**
 * @api private
 */
Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }

    // create an inline shape with extra members
    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    // set type if not set
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    // normalize types
    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var self = this;
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
    property(this, 'isDocument', Boolean(shape.document));
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });

    if (shape.event) {
      memoizedProperty(this, 'eventPayloadMemberName', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        // iterate over members to find ones that are event payloads
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventPayload) {
            return memberNames[i];
          }
        }
      });

      memoizedProperty(this, 'eventHeaderMemberNames', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        var eventHeaderMemberNames = [];
        // iterate over members to find ones that are event headers
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventHeader) {
            eventHeaderMemberNames.push(memberNames[i]);
          }
        }
        return eventHeaderMemberNames;
      });
    }
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (self.isTimestampFormatSet && this.timestampFormat) {
    property(this, 'timestampFormat', this.timestampFormat);
  } else if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (this.location === 'querystring') {
    property(this, 'timestampFormat', 'iso8601');
  } else if (this.api) {
    switch (this.api.protocol) {
      case 'json':
      case 'rest-json':
        property(this, 'timestampFormat', 'unixTimestamp');
        break;
      case 'rest-xml':
      case 'query':
      case 'ec2':
        property(this, 'timestampFormat', 'iso8601');
        break;
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
  this.toType = function(value) {
    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
      value || '' : value;
    if (this.isJsonValue) {
      return JSON.parse(value);
    }

    return value && typeof value.toString === 'function' ?
      value.toString() : value;
  };

  this.toWireFormat = function(value) {
    return this.isJsonValue ? JSON.stringify(value) : value;
  };
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = function(value) {
    var buf = util.base64.decode(value);
    if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
  /* Node.js can create a Buffer that is not isolated.
   * i.e. buf.byteLength !== buf.buffer.byteLength
   * This means that the sensitive data is accessible to anyone with access to buf.buffer.
   * If this is the node shared Buffer, then other code within this process _could_ find this secret.
   * Copy sensitive data to an isolated Buffer and zero the sensitive data.
   * While this is safe to do here, copying this code somewhere else may produce unexpected results.
   */
      var secureBuf = util.Buffer.alloc(buf.length, buf);
      buf.fill(0);
      buf = secureBuf;
    }
    return buf;
  };
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}

/**
 * @api private
 */
Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

/**
 * @api private
 */
module.exports = Shape;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/node_loader.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/node_loader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "../../../../node_modules/aws-sdk/lib/util.js");

var region_utils = __webpack_require__(/*! ./region/utils */ "../../../../node_modules/aws-sdk/lib/region/utils.js");
var isFipsRegion = region_utils.isFipsRegion;
var getRealRegion = region_utils.getRealRegion;

util.isBrowser = function() { return false; };
util.isNode = function() { return true; };

// node.js specific modules
util.crypto.lib = __webpack_require__(/*! crypto */ "crypto");
util.Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);
util.domain = __webpack_require__(/*! domain */ "domain");
util.stream = __webpack_require__(/*! stream */ "stream");
util.url = __webpack_require__(/*! url */ "url");
util.querystring = __webpack_require__(/*! querystring */ "querystring");
util.environment = 'nodejs';
util.createEventStream = util.stream.Readable ?
  (__webpack_require__(/*! ./event-stream/streaming-create-event-stream */ "../../../../node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js").createEventStream) : (__webpack_require__(/*! ./event-stream/buffered-create-event-stream */ "../../../../node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js").createEventStream);
util.realClock = __webpack_require__(/*! ./realclock/nodeClock */ "../../../../node_modules/aws-sdk/lib/realclock/nodeClock.js");
util.clientSideMonitoring = {
  Publisher: (__webpack_require__(/*! ./publisher */ "../../../../node_modules/aws-sdk/lib/publisher/index.js").Publisher),
  configProvider: __webpack_require__(/*! ./publisher/configuration */ "../../../../node_modules/aws-sdk/lib/publisher/configuration.js"),
};
util.iniLoader = (__webpack_require__(/*! ./shared-ini */ "../../../../node_modules/aws-sdk/lib/shared-ini/index.js").iniLoader);
util.getSystemErrorName = (__webpack_require__(/*! util */ "util").getSystemErrorName);

util.loadConfig = function(options) {
  var envValue = options.environmentVariableSelector(process.env);
  if (envValue !== undefined) {
    return envValue;
  }

  var configFile = {};
  try {
    configFile = util.iniLoader ? util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || util.defaultProfile
  ] || {};
  var configValue = options.configFileSelector(sharedFileConfig);
  if (configValue !== undefined) {
    return configValue;
  }

  if (typeof options.default === 'function') {
    return options.default();
  }
  return options.default;
};

var AWS;

/**
 * @api private
 */
module.exports = AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");

__webpack_require__(/*! ./credentials */ "../../../../node_modules/aws-sdk/lib/credentials.js");
__webpack_require__(/*! ./credentials/credential_provider_chain */ "../../../../node_modules/aws-sdk/lib/credentials/credential_provider_chain.js");
__webpack_require__(/*! ./credentials/temporary_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/temporary_credentials.js");
__webpack_require__(/*! ./credentials/chainable_temporary_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js");
__webpack_require__(/*! ./credentials/web_identity_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/web_identity_credentials.js");
__webpack_require__(/*! ./credentials/cognito_identity_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js");
__webpack_require__(/*! ./credentials/saml_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/saml_credentials.js");
__webpack_require__(/*! ./credentials/process_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/process_credentials.js");

// Load the xml2js XML parser
AWS.XML.Parser = __webpack_require__(/*! ./xml/node_parser */ "../../../../node_modules/aws-sdk/lib/xml/node_parser.js");

// Load Node HTTP client
__webpack_require__(/*! ./http/node */ "../../../../node_modules/aws-sdk/lib/http/node.js");

__webpack_require__(/*! ./shared-ini/ini-loader */ "../../../../node_modules/aws-sdk/lib/shared-ini/ini-loader.js");

// Load custom credential providers
__webpack_require__(/*! ./credentials/token_file_web_identity_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js");
__webpack_require__(/*! ./credentials/ec2_metadata_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js");
__webpack_require__(/*! ./credentials/remote_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/remote_credentials.js");
__webpack_require__(/*! ./credentials/ecs_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/ecs_credentials.js");
__webpack_require__(/*! ./credentials/environment_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/environment_credentials.js");
__webpack_require__(/*! ./credentials/file_system_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/file_system_credentials.js");
__webpack_require__(/*! ./credentials/shared_ini_file_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js");
__webpack_require__(/*! ./credentials/process_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/process_credentials.js");
__webpack_require__(/*! ./credentials/sso_credentials */ "../../../../node_modules/aws-sdk/lib/credentials/sso_credentials.js");

// Setup default chain providers
// If this changes, please update documentation for
// AWS.CredentialProviderChain.defaultProviders in
// credentials/credential_provider_chain.js
AWS.CredentialProviderChain.defaultProviders = [
  function () { return new AWS.EnvironmentCredentials('AWS'); },
  function () { return new AWS.EnvironmentCredentials('AMAZON'); },
  function () { return new AWS.SsoCredentials(); },
  function () { return new AWS.SharedIniFileCredentials(); },
  function () { return new AWS.ECSCredentials(); },
  function () { return new AWS.ProcessCredentials(); },
  function () { return new AWS.TokenFileWebIdentityCredentials(); },
  function () { return new AWS.EC2MetadataCredentials(); }
];

var getRegion = function() {
  var env = process.env;
  var region = env.AWS_REGION || env.AMAZON_REGION;
  if (env[AWS.util.configOptInEnv]) {
    var toCheck = [
      {filename: env[AWS.util.sharedCredentialsFileEnv]},
      {isConfig: true, filename: env[AWS.util.sharedConfigFileEnv]}
    ];
    var iniLoader = AWS.util.iniLoader;
    while (!region && toCheck.length) {
      var configFile = {};
      var fileInfo = toCheck.shift();
      try {
        configFile = iniLoader.loadFrom(fileInfo);
      } catch (err) {
        if (fileInfo.isConfig) throw err;
      }
      var profile = configFile[env.AWS_PROFILE || AWS.util.defaultProfile];
      region = profile && profile.region;
    }
  }
  return region;
};

var getBooleanValue = function(value) {
  return value === 'true' ? true: value === 'false' ? false: undefined;
};

var USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: function(env) {
    return getBooleanValue(env['AWS_USE_FIPS_ENDPOINT']);
  },
  configFileSelector: function(profile) {
    return getBooleanValue(profile['use_fips_endpoint']);
  },
  default: false,
};

var USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: function(env) {
    return getBooleanValue(env['AWS_USE_DUALSTACK_ENDPOINT']);
  },
  configFileSelector: function(profile) {
    return getBooleanValue(profile['use_dualstack_endpoint']);
  },
  default: false,
};

// Update configuration keys
AWS.util.update(AWS.Config.prototype.keys, {
  credentials: function () {
    var credentials = null;
    new AWS.CredentialProviderChain([
      function () { return new AWS.EnvironmentCredentials('AWS'); },
      function () { return new AWS.EnvironmentCredentials('AMAZON'); },
      function () { return new AWS.SharedIniFileCredentials({ disableAssumeRole: true }); }
    ]).resolve(function(err, creds) {
      if (!err) credentials = creds;
    });
    return credentials;
  },
  credentialProvider: function() {
    return new AWS.CredentialProviderChain();
  },
  logger: function () {
    return process.env.AWSJS_DEBUG ? console : null;
  },
  region: function() {
    var region = getRegion();
    return region ? getRealRegion(region): undefined;
  },
  useFipsEndpoint: function() {
    var region = getRegion();
    return isFipsRegion(region)
      ? true
      : util.loadConfig(USE_FIPS_ENDPOINT_CONFIG_OPTIONS);
  },
  useDualstackEndpoint: function() {
    return util.loadConfig(USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS);
  }
});

// Reset configuration
AWS.config = new AWS.Config();


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/param_validator.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/param_validator.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * @api private
 */
AWS.ParamValidator = AWS.util.inherit({
  /**
   * Create a new validator object.
   *
   * @param validation [Boolean|map] whether input parameters should be
   *     validated against the operation description before sending the
   *     request. Pass a map to enable any of the following specific
   *     validation features:
   *
   *     * **min** [Boolean] &mdash; Validates that a value meets the min
   *       constraint. This is enabled by default when paramValidation is set
   *       to `true`.
   *     * **max** [Boolean] &mdash; Validates that a value meets the max
   *       constraint.
   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *       regular expression.
   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
   *       of the allowable enum values.
   */
  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    if (shape.isDocument) return true;

    this.validateType(params, context, ['object'], 'structure');
    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    // validate hash members
    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else if (paramValue !== undefined && paramValue !== null) {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      // validate array members
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      // Build up a count of map members to validate range traits.
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        // Validate any map key trait constraints
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']');
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    var validTypes = ['string'];
    if (shape.isJsonValue) {
      validTypes = validTypes.concat(['number', 'object', 'boolean']);
    }
    if (value !== null && this.validateType(value, context, validTypes)) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
      this.validateUri(shape, value, context);
    }
  },

  validateUri: function validateUri(shape, value, context) {
    if (shape['location'] === 'uri') {
      if (value.length === 0) {
        this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,'
          + ' but found "' + value +'" for ' + context);
      }
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      // Fail if the string value is not present in the enum list
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    // We will not log an error for null or undefined, but we will return
    // false so that callers know that the expected type was not strictly met.
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    } else {
      if (typeof Blob !== void 0 && value instanceof Blob) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/protocol/helpers.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/protocol/helpers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util =  __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Prepend prefix defined by API model to endpoint that's already
 * constructed. This feature does not apply to operations using
 * endpoint discovery and can be disabled.
 * @api private
 */
function populateHostPrefix(request)  {
  var enabled = request.service.config.hostPrefixEnabled;
  if (!enabled) return request;
  var operationModel = request.service.api.operations[request.operation];
  //don't marshal host prefix when operation has endpoint discovery traits
  if (hasEndpointDiscover(request)) return request;
  if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
    var hostPrefixNotation = operationModel.endpoint.hostPrefix;
    var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
    prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
    validateHostname(request.httpRequest.endpoint.hostname);
  }
  return request;
}

/**
 * @api private
 */
function hasEndpointDiscover(request) {
  var api = request.service.api;
  var operationModel = api.operations[request.operation];
  var isEndpointOperation = api.endpointOperation && (api.endpointOperation === util.string.lowerFirst(operationModel.name));
  return (operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true);
}

/**
 * @api private
 */
function expandHostPrefix(hostPrefixNotation, params, shape) {
  util.each(shape.members, function(name, member) {
    if (member.hostLabel === true) {
      if (typeof params[name] !== 'string' || params[name] === '') {
        throw util.error(new Error(), {
          message: 'Parameter ' + name + ' should be a non-empty string.',
          code: 'InvalidParameter'
        });
      }
      var regex = new RegExp('\\{' + name + '\\}', 'g');
      hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
    }
  });
  return hostPrefixNotation;
}

/**
 * @api private
 */
function prependEndpointPrefix(endpoint, prefix) {
  if (endpoint.host) {
    endpoint.host = prefix + endpoint.host;
  }
  if (endpoint.hostname) {
    endpoint.hostname = prefix + endpoint.hostname;
  }
}

/**
 * @api private
 */
function validateHostname(hostname) {
  var labels = hostname.split('.');
  //Reference: https://tools.ietf.org/html/rfc1123#section-2
  var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
  util.arrayEach(labels, function(label) {
    if (!label.length || label.length < 1 || label.length > 63) {
      throw util.error(new Error(), {
        code: 'ValidationError',
        message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
      });
    }
    if (!hostPattern.test(label)) {
      throw AWS.util.error(new Error(),
        {code: 'ValidationError', message: label + ' is not hostname compatible.'});
    }
  });
}

module.exports = {
  populateHostPrefix: populateHostPrefix
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/protocol/json.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/protocol/json.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var JsonBuilder = __webpack_require__(/*! ../json/builder */ "../../../../node_modules/aws-sdk/lib/json/builder.js");
var JsonParser = __webpack_require__(/*! ../json/parser */ "../../../../node_modules/aws-sdk/lib/json/parser.js");
var populateHostPrefix = (__webpack_require__(/*! ./helpers */ "../../../../node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix);

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;

  populateHostPrefix(req);
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    try {
      var e = JSON.parse(httpResponse.body.toString());
      var code = e.__type || e.code || e.Code;
      if (code) {
        error.code = code.split('#').pop();
      }
      if (error.code === 'RequestEntityTooLarge') {
        error.message = 'Request body must be less than 1 MB';
      } else {
        error.message = (e.message || e.Message || null);
      }
    } catch (e) {
      error.statusCode = httpResponse.statusCode;
      error.message = httpResponse.statusMessage;
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/protocol/query.js":
/*!**************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/protocol/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var QueryParamSerializer = __webpack_require__(/*! ../query/query_param_serializer */ "../../../../node_modules/aws-sdk/lib/query/query_param_serializer.js");
var Shape = __webpack_require__(/*! ../model/shape */ "../../../../node_modules/aws-sdk/lib/model/shape.js");
var populateHostPrefix = (__webpack_require__(/*! ./helpers */ "../../../../node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix);

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  // convert the request parameters into a list of query params,
  // e.g. Deeply.NestedParam.0.Name=value
  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);

  populateHostPrefix(req);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    try {
      data = new AWS.XML.Parser().parse(body);
    } catch (e) {
      data = {
        Code: resp.httpResponse.statusCode,
        Message: resp.httpResponse.statusMessage
      };
    }
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  // TODO: Refactor XML Parser to parse RequestId from response.
  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/protocol/rest.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/protocol/rest.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var populateHostPrefix = (__webpack_require__(/*! ./helpers */ "../../../../node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix);

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function generateURI(endpointPath, operationPath, input, params) {
  var uri = [endpointPath, operationPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(member.member.toWireFormat(val).toString());
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  return uri;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      if (member.isJsonValue) {
        value = util.base64.encode(value);
      }
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
  populateHostPrefix(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  // normalize headers names to lower-cased keys for matching
  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        var value = member.isJsonValue ?
          util.base64.decode(headers[header]) :
          headers[header];
        data[name] = member.toType(value);
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData,
  generateURI: generateURI
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/protocol/rest_json.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/protocol/rest_json.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var Rest = __webpack_require__(/*! ./rest */ "../../../../node_modules/aws-sdk/lib/protocol/rest.js");
var Json = __webpack_require__(/*! ./json */ "../../../../node_modules/aws-sdk/lib/protocol/json.js");
var JsonBuilder = __webpack_require__(/*! ../json/builder */ "../../../../node_modules/aws-sdk/lib/json/builder.js");
var JsonParser = __webpack_require__(/*! ../json/parser */ "../../../../node_modules/aws-sdk/lib/json/parser.js");

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params || {}, payloadShape);
      applyContentTypeHeader(req);
    } else if (params !== undefined) {
      // non-JSON payload
      req.httpRequest.body = params;
      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
        applyContentTypeHeader(req, true);
      }
    }
  } else {
    req.httpRequest.body = builder.build(req.params, input);
    applyContentTypeHeader(req);
  }
}

function applyContentTypeHeader(req, isBinary) {
  if (!req.httpRequest.headers['Content-Type']) {
    var type = isBinary ? 'binary/octet-stream' : 'application/json';
    req.httpRequest.headers['Content-Type'] = type;
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD/DELETE
  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var rules = req.service.api.operations[req.operation].output || {};
  var parser;
  var hasEventOutput = operation.hasEventOutput;

  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.isEventStream) {
      parser = new JsonParser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else {
      resp.data[rules.payload] = payloadMember.toType(body);
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/protocol/rest_xml.js":
/*!*****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/protocol/rest_xml.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var Rest = __webpack_require__(/*! ./rest */ "../../../../node_modules/aws-sdk/lib/protocol/rest.js");

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD
  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data;
  try {
    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  } catch (e) {
    data = {
      Code: resp.httpResponse.statusCode,
      Message: resp.httpResponse.statusMessage
    };
  }

  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var hasEventOutput = operation.hasEventOutput;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.isEventStream) {
      parser = new AWS.XML.Parser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else {
      resp.data[payload] = payloadMember.toType(body);
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/publisher/configuration.js":
/*!***********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/publisher/configuration.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * Resolve client-side monitoring configuration from either environmental variables
 * or shared config file. Configurations from environmental variables have higher priority
 * than those from shared config file. The resolver will try to read the shared config file
 * no matter whether the AWS_SDK_LOAD_CONFIG variable is set.
 * @api private
 */
function resolveMonitoringConfig() {
  var config = {
    port: undefined,
    clientId: undefined,
    enabled: undefined,
    host: undefined
  };
  if (fromEnvironment(config) || fromConfigFile(config)) return toJSType(config);
  return toJSType(config);
}

/**
 * Resolve configurations from environmental variables.
 * @param {object} client side monitoring config object needs to be resolved
 * @returns {boolean} whether resolving configurations is done
 * @api private
 */
function fromEnvironment(config) {
  config.port = config.port || process.env.AWS_CSM_PORT;
  config.enabled = config.enabled || process.env.AWS_CSM_ENABLED;
  config.clientId = config.clientId || process.env.AWS_CSM_CLIENT_ID;
  config.host = config.host || process.env.AWS_CSM_HOST;
  return config.port && config.enabled && config.clientId && config.host ||
    ['false', '0'].indexOf(config.enabled) >= 0; //no need to read shared config file if explicitely disabled
}

/**
 * Resolve cofigurations from shared config file with specified role name
 * @param {object} client side monitoring config object needs to be resolved
 * @returns {boolean} whether resolving configurations is done
 * @api private
 */
function fromConfigFile(config) {
  var sharedFileConfig;
  try {
    var configFile = AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    });
    var sharedFileConfig = configFile[
      process.env.AWS_PROFILE || AWS.util.defaultProfile
    ];
  } catch (err) {
    return false;
  }
  if (!sharedFileConfig) return config;
  config.port = config.port || sharedFileConfig.csm_port;
  config.enabled = config.enabled || sharedFileConfig.csm_enabled;
  config.clientId = config.clientId || sharedFileConfig.csm_client_id;
  config.host = config.host || sharedFileConfig.csm_host;
  return config.port && config.enabled && config.clientId && config.host;
}

/**
 * Transfer the resolved configuration value to proper types: port as number, enabled
 * as boolean and clientId as string. The 'enabled' flag is valued to false when set
 * to 'false' or '0'.
 * @param {object} resolved client side monitoring config
 * @api private
 */
function toJSType(config) {
    //config.XXX is either undefined or string
  var falsyNotations = ['false', '0', undefined];
  if (!config.enabled || falsyNotations.indexOf(config.enabled.toLowerCase()) >= 0) {
    config.enabled = false;
  } else {
    config.enabled = true;
  }
  config.port = config.port ? parseInt(config.port, 10) : undefined;
  return config;
}

module.exports = resolveMonitoringConfig;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/publisher/index.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/publisher/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js").util);
var dgram = __webpack_require__(/*! dgram */ "dgram");
var stringToBuffer = util.buffer.toBuffer;

var MAX_MESSAGE_SIZE = 1024 * 8; // 8 KB

/**
 * Publishes metrics via udp.
 * @param {object} options Paramters for Publisher constructor
 * @param {number} [options.port = 31000] Port number
 * @param {string} [options.clientId = ''] Client Identifier
 * @param {boolean} [options.enabled = false] enable sending metrics datagram
 * @api private
 */
function Publisher(options) {
    // handle configuration
    options = options || {};
    this.enabled = options.enabled || false;
    this.port = options.port || 31000;
    this.clientId = options.clientId || '';
    this.address = options.host || '127.0.0.1';
    if (this.clientId.length > 255) {
        // ClientId has a max length of 255
        this.clientId = this.clientId.substr(0, 255);
    }
    this.messagesInFlight = 0;
}

Publisher.prototype.fieldsToTrim = {
    UserAgent: 256,
    SdkException: 128,
    SdkExceptionMessage: 512,
    AwsException: 128,
    AwsExceptionMessage: 512,
    FinalSdkException: 128,
    FinalSdkExceptionMessage: 512,
    FinalAwsException: 128,
    FinalAwsExceptionMessage: 512

};

/**
 * Trims fields that have a specified max length.
 * @param {object} event ApiCall or ApiCallAttempt event.
 * @returns {object}
 * @api private
 */
Publisher.prototype.trimFields = function(event) {
    var trimmableFields = Object.keys(this.fieldsToTrim);
    for (var i = 0, iLen = trimmableFields.length; i < iLen; i++) {
        var field = trimmableFields[i];
        if (event.hasOwnProperty(field)) {
            var maxLength = this.fieldsToTrim[field];
            var value = event[field];
            if (value && value.length > maxLength) {
                event[field] = value.substr(0, maxLength);
            }
        }
    }
    return event;
};

/**
 * Handles ApiCall and ApiCallAttempt events.
 * @param {Object} event apiCall or apiCallAttempt event.
 * @api private
 */
Publisher.prototype.eventHandler = function(event) {
    // set the clientId
    event.ClientId = this.clientId;

    this.trimFields(event);

    var message = stringToBuffer(JSON.stringify(event));
    if (!this.enabled || message.length > MAX_MESSAGE_SIZE) {
        // drop the message if publisher not enabled or it is too large
        return;
    }

    this.publishDatagram(message);
};

/**
 * Publishes message to an agent.
 * @param {Buffer} message JSON message to send to agent.
 * @api private
 */
Publisher.prototype.publishDatagram = function(message) {
    var self = this;
    var client = this.getClient();

    this.messagesInFlight++;
    this.client.send(message, 0, message.length, this.port, this.address, function(err, bytes) {
        if (--self.messagesInFlight <= 0) {
            // destroy existing client so the event loop isn't kept open
            self.destroyClient();
        }
    });
};

/**
 * Returns an existing udp socket, or creates one if it doesn't already exist.
 * @api private
 */
Publisher.prototype.getClient = function() {
    if (!this.client) {
        this.client = dgram.createSocket('udp4');
    }
    return this.client;
};

/**
 * Destroys the udp socket.
 * @api private
 */
Publisher.prototype.destroyClient = function() {
    if (this.client) {
        this.client.close();
        this.client = void 0;
    }
};

module.exports = {
    Publisher: Publisher
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/query/query_param_serializer.js":
/*!****************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/query/query_param_serializer.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      // Do nothing for EC2
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

/**
 * @api private
 */
module.exports = QueryParamSerializer;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/realclock/nodeClock.js":
/*!*******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/realclock/nodeClock.js ***!
  \*******************************************************************/
/***/ ((module) => {

module.exports = {
  //provide realtime clock for performance measurement
  now: function now() {
    var second = process.hrtime();
    return second[0] * 1000 + (second[1] / 1000000);
  }
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/region/utils.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/region/utils.js ***!
  \************************************************************/
/***/ ((module) => {

function isFipsRegion(region) {
  return typeof region === 'string' && (region.startsWith('fips-') || region.endsWith('-fips'));
}

function isGlobalRegion(region) {
  return typeof region === 'string' && ['aws-global', 'aws-us-gov-global'].includes(region);
}

function getRealRegion(region) {
  return ['fips-aws-global', 'aws-fips', 'aws-global'].includes(region)
      ? 'us-east-1'
      : ['fips-aws-us-gov-global', 'aws-us-gov-global'].includes(region)
      ? 'us-gov-west-1'
      : region.replace(/fips-(dkr-|prod-)?|-fips/, '');
}

module.exports = {
  isFipsRegion: isFipsRegion,
  isGlobalRegion: isGlobalRegion,
  getRealRegion: getRealRegion
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/region_config.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/region_config.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "../../../../node_modules/aws-sdk/lib/util.js");
var regionConfig = __webpack_require__(/*! ./region_config_data.json */ "../../../../node_modules/aws-sdk/lib/region_config_data.json");

function generateRegionPrefix(region) {
  if (!region) return null;
  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  var useFipsEndpoint = service.config.useFipsEndpoint;
  var useDualstackEndpoint = service.config.useDualstackEndpoint;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    var rules = useFipsEndpoint
      ? useDualstackEndpoint
        ? regionConfig.dualstackFipsRules
        : regionConfig.fipsRules
      : useDualstackEndpoint
      ? regionConfig.dualstackRules
      : regionConfig.rules;

    if (Object.prototype.hasOwnProperty.call(rules, key)) {
      var config = rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      // set global endpoint
      service.isGlobalEndpoint = !!config.globalEndpoint;
      if (config.signingRegion) {
        service.signingRegion = config.signingRegion;
      }

      // signature version
      if (!config.signatureVersion) config.signatureVersion = 'v4';

      // merge config
      applyConfig(service, config);
      return;
    }
  }
}

function getEndpointSuffix(region) {
  var regionRegexes = {
    '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
    '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
    '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
  };
  var defaultSuffix = 'amazonaws.com';
  var regexes = Object.keys(regionRegexes);
  for (var i = 0; i < regexes.length; i++) {
    var regionPattern = RegExp(regexes[i]);
    var dnsSuffix = regionRegexes[regexes[i]];
    if (regionPattern.test(region)) return dnsSuffix;
  }
  return defaultSuffix;
}

/**
 * @api private
 */
module.exports = {
  configureEndpoint: configureEndpoint,
  getEndpointSuffix: getEndpointSuffix,
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/request.js":
/*!*******************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/request.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var AcceptorStateMachine = __webpack_require__(/*! ./state_machine */ "../../../../node_modules/aws-sdk/lib/state_machine.js");
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = __webpack_require__(/*! jmespath */ "../../../../node_modules/jmespath/jmespath.js");

/**
 * @api private
 */
var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();

/**
 * ## Asynchronous Requests
 *
 * All requests made through the SDK are asynchronous and use a
 * callback interface. Each service method that kicks off a request
 * returns an `AWS.Request` object that you can use to register
 * callbacks.
 *
 * For example, the following service method returns the request
 * object as "request", which can be used to register callbacks:
 *
 * ```javascript
 * // request is an AWS.Request object
 * var request = ec2.describeInstances();
 *
 * // register callbacks on request to retrieve response data
 * request.on('success', function(response) {
 *   console.log(response.data);
 * });
 * ```
 *
 * When a request is ready to be sent, the {send} method should
 * be called:
 *
 * ```javascript
 * request.send();
 * ```
 *
 * Since registered callbacks may or may not be idempotent, requests should only
 * be sent once. To perform the same operation multiple times, you will need to
 * create multiple request objects, each with its own registered callbacks.
 *
 * ## Removing Default Listeners for Events
 *
 * Request objects are built with default listeners for the various events,
 * depending on the service type. In some cases, you may want to remove
 * some built-in listeners to customize behaviour. Doing this requires
 * access to the built-in listener functions, which are exposed through
 * the {AWS.EventListeners.Core} namespace. For instance, you may
 * want to customize the HTTP handler used when sending a request. In this
 * case, you can remove the built-in listener associated with the 'send'
 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
 *
 * ## Multiple Callbacks and Chaining
 *
 * You can register multiple callbacks on any request object. The
 * callbacks can be registered for different events, or all for the
 * same event. In addition, you can chain callback registration, for
 * example:
 *
 * ```javascript
 * request.
 *   on('success', function(response) {
 *     console.log("Success!");
 *   }).
 *   on('error', function(error, response) {
 *     console.log("Error!");
 *   }).
 *   on('complete', function(response) {
 *     console.log("Always!");
 *   }).
 *   send();
 * ```
 *
 * The above example will print either "Success! Always!", or "Error! Always!",
 * depending on whether the request succeeded or not.
 *
 * @!attribute httpRequest
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpRequest] the raw HTTP request object
 *     containing request headers and body information
 *     sent by the service.
 *
 * @!attribute startTime
 *   @readonly
 *   @!group Operation Properties
 *   @return [Date] the time that the request started
 *
 * @!group Request Building Events
 *
 * @!event validate(request)
 *   Triggered when a request is being validated. Listeners
 *   should throw an error if the request should not be sent.
 *   @param request [Request] the request object being sent
 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
 *   @see AWS.EventListeners.Core.VALIDATE_REGION
 *   @example Ensuring that a certain parameter is set before sending a request
 *     var req = s3.putObject(params);
 *     req.on('validate', function() {
 *       if (!req.params.Body.match(/^Hello\s/)) {
 *         throw new Error('Body must start with "Hello "');
 *       }
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event build(request)
 *   Triggered when the request payload is being built. Listeners
 *   should fill the necessary information to send the request
 *   over HTTP.
 *   @param (see AWS.Request~validate)
 *   @example Add a custom HTTP header to a request
 *     var req = s3.putObject(params);
 *     req.on('build', function() {
 *       req.httpRequest.headers['Custom-Header'] = 'value';
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event sign(request)
 *   Triggered when the request is being signed. Listeners should
 *   add the correct authentication headers and/or adjust the body,
 *   depending on the authentication mechanism being used.
 *   @param (see AWS.Request~validate)
 *
 * @!group Request Sending Events
 *
 * @!event send(response)
 *   Triggered when the request is ready to be sent. Listeners
 *   should call the underlying transport layer to initiate
 *   the sending of the request.
 *   @param response [Response] the response object
 *   @context [Request] the request object that was sent
 *   @see AWS.EventListeners.Core.SEND
 *
 * @!event retry(response)
 *   Triggered when a request failed and might need to be retried or redirected.
 *   If the response is retryable, the listener should set the
 *   `response.error.retryable` property to `true`, and optionally set
 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
 *   In the case of a redirect, `response.error.redirect` should be set to
 *   `true` with `retryDelay` set to an optional delay on the next request.
 *
 *   If a listener decides that a request should not be retried,
 *   it should set both `retryable` and `redirect` to false.
 *
 *   Note that a retryable error will be retried at most
 *   {AWS.Config.maxRetries} times (based on the service object's config).
 *   Similarly, a request that is redirected will only redirect at most
 *   {AWS.Config.maxRedirects} times.
 *
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @example Adding a custom retry for a 404 response
 *     request.on('retry', function(response) {
 *       // this resource is not yet available, wait 10 seconds to get it again
 *       if (response.httpResponse.statusCode === 404 && response.error) {
 *         response.error.retryable = true;   // retry this error
 *         response.error.retryDelay = 10000; // wait 10 seconds
 *       }
 *     });
 *
 * @!group Data Parsing Events
 *
 * @!event extractError(response)
 *   Triggered on all non-2xx requests so that listeners can extract
 *   error details from the response body. Listeners to this event
 *   should set the `response.error` property.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event extractData(response)
 *   Triggered in successful requests to allow listeners to
 *   de-serialize the response body into `response.data`.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group Completion Events
 *
 * @!event success(response)
 *   Triggered when the request completed successfully.
 *   `response.data` will contain the response data and
 *   `response.error` will be null.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event error(error, response)
 *   Triggered when an error occurs at any point during the
 *   request. `response.error` will contain details about the error
 *   that occurred. `response.data` will be null.
 *   @param error [Error] the error object containing details about
 *     the error that occurred.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event complete(response)
 *   Triggered whenever a request cycle completes. `response.error`
 *   should be checked, since the request may have failed.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group HTTP Events
 *
 * @!event httpHeaders(statusCode, headers, response, statusMessage)
 *   Triggered when headers are sent by the remote server
 *   @param statusCode [Integer] the HTTP response code
 *   @param headers [map<String,String>] the response headers
 *   @param (see AWS.Request~send)
 *   @param statusMessage [String] A status message corresponding to the HTTP
 *                                 response code
 *   @context (see AWS.Request~send)
 *
 * @!event httpData(chunk, response)
 *   Triggered when data is sent by the remote server
 *   @param chunk [Buffer] the buffer data containing the next data chunk
 *     from the server
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @see AWS.EventListeners.Core.HTTP_DATA
 *
 * @!event httpUploadProgress(progress, response)
 *   Triggered when the HTTP request has uploaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpDownloadProgress(progress, response)
 *   Triggered when the HTTP request has downloaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpError(error, response)
 *   Triggered when the HTTP request failed
 *   @param error [Error] the error object that was thrown
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event httpDone(response)
 *   Triggered when the server is finished sending data
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @see AWS.Response
 */
AWS.Request = inherit({

  /**
   * Creates a request for an operation on a given service with
   * a set of input parameters.
   *
   * @param service [AWS.Service] the service to perform the operation on
   * @param operation [String] the operation to perform on the service
   * @param params [Object] parameters to send to the operation.
   *   See the operation's documentation for the format of the
   *   parameters.
   */
  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    if (service.signingRegion) {
      region = service.signingRegion;
    } else if (service.isGlobalEndpoint) {
      region = 'us-east-1';
    }

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region);
    this.httpRequest.appendToUserAgent(customUserAgent);
    this.startTime = service.getSkewCorrectedDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },

  /**
   * @!group Sending a Request
   */

  /**
   * @overload send(callback = null)
   *   Sends the request object.
   *
   *   @callback callback function(err, data)
   *     If a callback is supplied, it is called when a response is returned
   *     from the service.
   *     @context [AWS.Request] the request object being sent.
   *     @param err [Error] the error object returned from the request.
   *       Set to `null` if the request is successful.
   *     @param data [Object] the de-serialized data returned from
   *       the request. Set to `null` if a request error occurs.
   *   @example Sending a request with a callback
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.send(function(err, data) { console.log(err, data); });
   *   @example Sending a request with no callback (using event handlers)
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.on('complete', function(response) { ... }); // register a callback
   *     request.send();
   */
  send: function send(callback) {
    if (callback) {
      // append to user agent
      this.httpRequest.appendToUserAgent('callback');
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },

  /**
   * @!method  promise()
   *   Sends the request and returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [Object] the de-serialized data returned from the request.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param error [Error] the error object returned from the request.
   *   @return [Promise] A promise that represents the state of the request.
   *   @example Sending a request using promises.
   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     var result = request.promise();
   *     result.then(function(data) { ... }, function(error) { ... });
   */

  /**
   * @api private
   */
  build: function build(callback) {
    return this.runTo('send', callback);
  },

  /**
   * @api private
   */
  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },

  /**
   * Aborts a request, emitting the error and complete events.
   *
   * @!macro nobrowser
   * @example Aborting a request after sending
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
   *   };
   *   var request = s3.putObject(params);
   *   request.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(request.abort.bind(request), 1000);
   *
   *   // prints "Error: RequestAbortedError Request aborted by user"
   * @return [AWS.Request] the same request object, for chaining.
   * @since v1.4.0
   */
  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },

  /**
   * Iterates over each page of results given a pageable request, calling
   * the provided callback with each page of data. After all pages have been
   * retrieved, the callback is called with `null` data.
   *
   * @note This operation can generate multiple requests to a service.
   * @example Iterating over multiple pages of objects in an S3 bucket
   *   var pages = 1;
   *   s3.listObjects().eachPage(function(err, data) {
   *     if (err) return;
   *     console.log("Page", pages++);
   *     console.log(data);
   *   });
   * @example Iterating over multiple pages with an asynchronous callback
   *   s3.listObjects(params).eachPage(function(err, data, done) {
   *     doSomethingAsyncAndOrExpensive(function() {
   *       // The next page of results isn't fetched until done is called
   *       done();
   *     });
   *   });
   * @callback callback function(err, data, [doneCallback])
   *   Called with each page of resulting data from the request. If the
   *   optional `doneCallback` is provided in the function, it must be called
   *   when the callback is complete.
   *
   *   @param err [Error] an error object, if an error occurred.
   *   @param data [Object] a single page of response data. If there is no
   *     more data, this object will be `null`.
   *   @param doneCallback [Function] an optional done callback. If this
   *     argument is defined in the function declaration, it should be called
   *     when the next page is ready to be retrieved. This is useful for
   *     controlling serial pagination across asynchronous operations.
   *   @return [Boolean] if the callback returns `false`, pagination will
   *     stop.
   *
   * @see AWS.Request.eachItem
   * @see AWS.Response.nextPage
   * @since v1.4.0
   */
  eachPage: function eachPage(callback) {
    // Make all callbacks async-ish
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },

  /**
   * Enumerates over individual items of a request, paging the responses if
   * necessary.
   *
   * @api experimental
   * @since v1.4.0
   */
  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },

  /**
   * @return [Boolean] whether the operation can return multiple pages of
   *   response data.
   * @see AWS.Response.eachPage
   * @since v1.4.0
   */
  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },

  /**
   * Sends the request and converts the request object into a readable stream
   * that can be read from or piped into a writable stream.
   *
   * @note The data read from a readable stream contains only
   *   the raw HTTP body contents.
   * @example Manually reading from a stream
   *   request.createReadStream().on('data', function(data) {
   *     console.log("Got data:", data.toString());
   *   });
   * @example Piping a request body into a file
   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
   *   s3.service.getObject(params).createReadStream().pipe(out);
   * @return [Stream] the readable stream object that can be piped
   *   or read from (by registering 'data' event listeners).
   * @!macro nobrowser
   */
  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      process.nextTick(function() { req.send(); });
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end');
          }
        };

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            stream.on('error', function(err) {
              shouldCheckContentLength = false;
              httpStream.unpipe(lengthAccumulator);
              lengthAccumulator.emit('end');
              lengthAccumulator.end();
            });
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    return stream;
  },

  /**
   * @param [Array,Response] args This should be the response object,
   *   or an array of args to send to the event.
   * @api private
   */
  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },

  /**
   * @api private
   */
  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },

  /**
   * @api private
   */
  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },

  /**
   * @api private
   */
  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },

  /**
   * @api private
   */
  toUnauthenticated: function toUnauthenticated() {
    this._unAuthenticated = true;
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },

  /**
   * @api private
   */
  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },

  /**
   * @api private
   */
  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    // don't need these headers on a GET request
    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },

  /**
   * @api private
   */
  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});

/**
 * @api private
 */
AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    // append to user agent
    this.httpRequest.appendToUserAgent('promise');
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          // define $response property so that it is not enumerable
          // this prevents circular reference errors when stringifying the JSON object
          resolve(Object.defineProperty(
            resp.data || {},
            '$response',
            {value: resp}
          ));
        }
      });
      self.runTo();
    });
  };
};

/**
 * @api private
 */
AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/resource_waiter.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/resource_waiter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not use this file except in compliance with the License. A copy of
 * the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;
var jmespath = __webpack_require__(/*! jmespath */ "../../../../node_modules/jmespath/jmespath.js");

/**
 * @api private
 */
function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}

/**
 * @api private
 */
AWS.ResourceWaiter = inherit({
  /**
   * Waits for a given state on a service object
   * @param service [Service] the service object to wait on
   * @param state [String] the state (defined in waiter configuration) to wait
   *   for.
   * @example Create a waiter for running EC2 instances
   *   var ec2 = new AWS.EC2;
   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
   */
  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      try {
        var result = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      // if expected is not string, can be boolean indicating presence of error
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),

  /**
   * @return [AWS.Request]
   */
  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    if (params && params.$waiter) {
      params = AWS.util.copy(params);
      if (typeof params.$waiter.delay === 'number') {
        this.config.delay = params.$waiter.delay;
      }
      if (typeof params.$waiter.maxAttempts === 'number') {
        this.config.maxAttempts = params.$waiter.maxAttempts;
      }
      delete params.$waiter;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },

  /**
   * Loads waiter configuration from API configuration
   *
   * @api private
   */
  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = AWS.util.copy(this.service.api.waiters[state]);
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/response.js":
/*!********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/response.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;
var jmespath = __webpack_require__(/*! jmespath */ "../../../../node_modules/jmespath/jmespath.js");

/**
 * This class encapsulates the response information
 * from a service request operation sent through {AWS.Request}.
 * The response object has two main properties for getting information
 * back from a request:
 *
 * ## The `data` property
 *
 * The `response.data` property contains the serialized object data
 * retrieved from the service request. For instance, for an
 * Amazon DynamoDB `listTables` method call, the response data might
 * look like:
 *
 * ```
 * > resp.data
 * { TableNames:
 *    [ 'table1', 'table2', ... ] }
 * ```
 *
 * The `data` property can be null if an error occurs (see below).
 *
 * ## The `error` property
 *
 * In the event of a service error (or transfer error), the
 * `response.error` property will be filled with the given
 * error data in the form:
 *
 * ```
 * { code: 'SHORT_UNIQUE_ERROR_CODE',
 *   message: 'Some human readable error message' }
 * ```
 *
 * In the case of an error, the `data` property will be `null`.
 * Note that if you handle events that can be in a failure state,
 * you should always check whether `response.error` is set
 * before attempting to access the `response.data` property.
 *
 * @!attribute data
 *   @readonly
 *   @!group Data Properties
 *   @note Inside of a {AWS.Request~httpData} event, this
 *     property contains a single raw packet instead of the
 *     full de-serialized service response.
 *   @return [Object] the de-serialized response data
 *     from the service.
 *
 * @!attribute error
 *   An structure containing information about a service
 *   or networking error.
 *   @readonly
 *   @!group Data Properties
 *   @note This attribute is only filled if a service or
 *     networking error occurs.
 *   @return [Error]
 *     * code [String] a unique short code representing the
 *       error that was emitted.
 *     * message [String] a longer human readable error message
 *     * retryable [Boolean] whether the error message is
 *       retryable.
 *     * statusCode [Numeric] in the case of a request that reached the service,
 *       this value contains the response status code.
 *     * time [Date] the date time object when the error occurred.
 *     * hostname [String] set when a networking error occurs to easily
 *       identify the endpoint of the request.
 *     * region [String] set when a networking error occurs to easily
 *       identify the region of the request.
 *
 * @!attribute requestId
 *   @readonly
 *   @!group Data Properties
 *   @return [String] the unique request ID associated with the response.
 *     Log this value when debugging requests for AWS support.
 *
 * @!attribute retryCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of retries that were
 *     attempted before the request was completed.
 *
 * @!attribute redirectCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of redirects that were
 *     followed before the request was completed.
 *
 * @!attribute httpResponse
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpResponse] the raw HTTP response object
 *     containing the response headers and body information
 *     from the server.
 *
 * @see AWS.Request
 */
AWS.Response = inherit({

  /**
   * @api private
   */
  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },

  /**
   * Creates a new request for the next page of response data, calling the
   * callback with the page data if a callback is provided.
   *
   * @callback callback function(err, data)
   *   Called when a page of data is returned from the next request.
   *
   *   @param err [Error] an error object, if an error occurred in the request
   *   @param data [Object] the next page of data, or null, if there are no
   *     more pages left.
   * @return [AWS.Request] the request object for the next page of data
   * @return [null] if no callback is provided and there are no pages left
   *   to retrieve.
   * @since v1.4.0
   */
  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },

  /**
   * @return [Boolean] whether more pages of data can be returned by further
   *   requests
   * @since v1.4.0
   */
  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },

  /**
   * @api private
   */
  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/sequential_executor.js":
/*!*******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/sequential_executor.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * @api private
 * @!method on(eventName, callback)
 *   Registers an event listener callback for the event given by `eventName`.
 *   Parameters passed to the callback function depend on the individual event
 *   being triggered. See the event documentation for those parameters.
 *
 *   @param eventName [String] the event name to register the listener for
 *   @param callback [Function] the listener callback function
 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
 *     Default to be false.
 *   @return [AWS.SequentialExecutor] the same object for chaining
 */
AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },

  /**
   * @api private
   */
  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener, toHead) {
    if (this._events[eventName]) {
      toHead ?
        this._events[eventName].unshift(listener) :
        this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },

  onAsync: function onAsync(eventName, listener, toHead) {
    listener._isAsync = true;
    return this.on(eventName, listener, toHead);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },

  /**
   * @api private
   */
  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },

  /**
   * @api private
   */
  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },

  /**
   * Adds or copies a set of listeners from another list of
   * listeners or SequentialExecutor object.
   *
   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
   *   a list of events and callbacks, or an event emitter object
   *   containing listeners to add to this emitter object.
   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
   * @example Adding listeners from a map of listeners
   *   emitter.addListeners({
   *     event1: [function() { ... }, function() { ... }],
   *     event2: [function() { ... }]
   *   });
   *   emitter.emit('event1'); // emitter has event1
   *   emitter.emit('event2'); // emitter has event2
   * @example Adding listeners from another emitter object
   *   var emitter1 = new AWS.SequentialExecutor();
   *   emitter1.on('event1', function() { ... });
   *   emitter1.on('event2', function() { ... });
   *   var emitter2 = new AWS.SequentialExecutor();
   *   emitter2.addListeners(emitter1);
   *   emitter2.emit('event1'); // emitter2 has event1
   *   emitter2.emit('event2'); // emitter2 has event2
   */
  addListeners: function addListeners(listeners) {
    var self = this;

    // extract listeners if parameter is an SequentialExecutor object
    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },

  /**
   * Registers an event with {on} and saves the callback handle function
   * as a property on the emitter object using a given `name`.
   *
   * @param name [String] the property name to set on this object containing
   *   the callback function handle so that the listener can be removed in
   *   the future.
   * @param (see on)
   * @return (see on)
   * @example Adding a named listener DATA_CALLBACK
   *   var listener = function() { doSomething(); };
   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
   *
   *   // the following prints: true
   *   console.log(emitter.DATA_CALLBACK == listener);
   */
  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
    this[name] = callback;
    this.addListener(eventName, callback, toHead);
    return this;
  },

  /**
   * @api private
   */
  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback, toHead);
  },

  /**
   * Helper method to add a set of named listeners using
   * {addNamedListener}. The callback contains a parameter
   * with a handle to the `addNamedListener` method.
   *
   * @callback callback function(add)
   *   The callback function is called immediately in order to provide
   *   the `add` function to the block. This simplifies the addition of
   *   a large group of named listeners.
   *   @param add [Function] the {addNamedListener} function to call
   *     when registering listeners.
   * @example Adding a set of named listeners
   *   emitter.addNamedListeners(function(add) {
   *     add('DATA_CALLBACK', 'data', function() { ... });
   *     add('OTHER', 'otherEvent', function() { ... });
   *     add('LAST', 'lastEvent', function() { ... });
   *   });
   *
   *   // these properties are now set:
   *   emitter.DATA_CALLBACK;
   *   emitter.OTHER;
   *   emitter.LAST;
   */
  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});

/**
 * {on} is the prefered method.
 * @api private
 */
AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

/**
 * @api private
 */
module.exports = AWS.SequentialExecutor;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/service.js":
/*!*******************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/service.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
var Api = __webpack_require__(/*! ./model/api */ "../../../../node_modules/aws-sdk/lib/model/api.js");
var regionConfig = __webpack_require__(/*! ./region_config */ "../../../../node_modules/aws-sdk/lib/region_config.js");

var inherit = AWS.util.inherit;
var clientCount = 0;
var region_utils = __webpack_require__(/*! ./region/utils */ "../../../../node_modules/aws-sdk/lib/region/utils.js");

/**
 * The service class representing an AWS service.
 *
 * @class_abstract This class is an abstract class.
 *
 * @!attribute apiVersions
 *   @return [Array<String>] the list of API versions supported by this service.
 *   @readonly
 */
AWS.Service = inherit({
  /**
   * Create a new service object with a configuration object
   *
   * @param config [map] a map of configuration options
   */
  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }

    if (config) {
      if (config.region) {
        var region = config.region;
        if (region_utils.isFipsRegion(region)) {
          config.region = region_utils.getRealRegion(region);
          config.useFipsEndpoint = true;
        }
        if (region_utils.isGlobalRegion(region)) {
          config.region = region_utils.getRealRegion(region);
        }
      }
      if (typeof config.useDualstack === 'boolean'
        && typeof config.useDualstackEndpoint !== 'boolean') {
        config.useDualstackEndpoint = config.useDualstack;
      }
    }

    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },

  /**
   * @api private
   */
  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];
    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig.configureEndpoint(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
    //enable attaching listeners to service client
    AWS.SequentialExecutor.call(this);
    AWS.Service.addDefaultMonitoringListeners(this);
    if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
      var publisher = this.publisher;
      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
    }
  },

  /**
   * @api private
   */
  validateService: function validateService() {
  },

  /**
   * @api private
   */
  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },

  /**
   * @api private
   */
  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },

  /**
   * @api private
   */
  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      // versions that end in "*" are not available on disk and can be
      // skipped, so do not choose these as selectedVersions
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },

  /**
   * @api private
   */
  api: {},

  /**
   * @api private
   */
  defaultRetryCount: 3,

  /**
   * @api private
   */
  customizeRequests: function customizeRequests(callback) {
    if (!callback) {
      this.customRequestHandler = null;
    } else if (typeof callback === 'function') {
      this.customRequestHandler = callback;
    } else {
      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
    }
  },

  /**
   * Calls an operation on a service with the given input parameters.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);
    this.attachMonitoringEmitter(request);
    if (callback) request.send(callback);
    return request;
  },

  /**
   * Calls an operation on a service with the given input parameters, without
   * any authentication data. This method is useful for "public" API operations.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },

  /**
   * Waits for a given state
   *
   * @param state [String] the state on the service to wait for
   * @param params [map] a map of parameters to pass with each request
   * @option params $waiter [map] a map of configuration options for the waiter
   * @option params $waiter.delay [Number] The number of seconds to wait between
   *                                       requests
   * @option params $waiter.maxAttempts [Number] The maximum number of requests
   *                                             to send while waiting
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },

  /**
   * @api private
   */
  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    // disable parameter validation
    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
    // call prototype's customRequestHandler
    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
      this.constructor.prototype.customRequestHandler(request);
    }
    // call instance's customRequestHandler
    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
      this.customRequestHandler(request);
    }
  },

  /**
   * Event recording metrics for a whole API call.
   * @returns {object} a subset of api call metrics
   * @api private
   */
  apiCallEvent: function apiCallEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCall',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Region: request.httpRequest.region,
      MaxRetriesExceeded: 0,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
    }
    if (response.error) {
      var error = response.error;
      var statusCode = response.httpResponse.statusCode;
      if (statusCode > 299) {
        if (error.code) monitoringEvent.FinalAwsException = error.code;
        if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
      } else {
        if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
        if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
      }
    }
    return monitoringEvent;
  },

  /**
   * Event recording metrics for an API call attempt.
   * @returns {object} a subset of api call attempt metrics
   * @api private
   */
  apiAttemptEvent: function apiAttemptEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCallAttempt',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Fqdn: request.httpRequest.endpoint.hostname,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
    }
    if (
      !request._unAuthenticated &&
      request.service.config.credentials &&
      request.service.config.credentials.accessKeyId
    ) {
      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
    }
    if (!response.httpResponse.headers) return monitoringEvent;
    if (request.httpRequest.headers['x-amz-security-token']) {
      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
    }
    if (response.httpResponse.headers['x-amzn-requestid']) {
      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
    }
    if (response.httpResponse.headers['x-amz-request-id']) {
      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
    }
    if (response.httpResponse.headers['x-amz-id-2']) {
      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
    }
    return monitoringEvent;
  },

  /**
   * Add metrics of failed request.
   * @api private
   */
  attemptFailEvent: function attemptFailEvent(request) {
    var monitoringEvent = this.apiAttemptEvent(request);
    var response = request.response;
    var error = response.error;
    if (response.httpResponse.statusCode > 299 ) {
      if (error.code) monitoringEvent.AwsException = error.code;
      if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
    } else {
      if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
      if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
    }
    return monitoringEvent;
  },

  /**
   * Attach listeners to request object to fetch metrics of each request
   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
   * @api private
   */
  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
    var attemptTimestamp; //timestamp marking the beginning of a request attempt
    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
    var attemptLatency; //latency from request sent out to http response reaching SDK
    var callStartRealTime; //Start time of API call. Used to calculating API call latency
    var attemptCount = 0; //request.retryCount is not reliable here
    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
    var callTimestamp; //timestamp when the request is created
    var self = this;
    var addToHead = true;

    request.on('validate', function () {
      callStartRealTime = AWS.util.realClock.now();
      callTimestamp = Date.now();
    }, addToHead);
    request.on('sign', function () {
      attemptStartRealTime = AWS.util.realClock.now();
      attemptTimestamp = Date.now();
      region = request.httpRequest.region;
      attemptCount++;
    }, addToHead);
    request.on('validateResponse', function() {
      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
    });
    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
      var apiAttemptEvent = self.apiAttemptEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
      var apiAttemptEvent = self.attemptFailEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      //attemptLatency may not be available if fail before response
      attemptLatency = attemptLatency ||
        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
      var apiCallEvent = self.apiCallEvent(request);
      apiCallEvent.AttemptCount = attemptCount;
      if (apiCallEvent.AttemptCount <= 0) return;
      apiCallEvent.Timestamp = callTimestamp;
      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
      apiCallEvent.Latency = latency >= 0 ? latency : 0;
      var response = request.response;
      if (
        response.error &&
        response.error.retryable &&
        typeof response.retryCount === 'number' &&
        typeof response.maxRetries === 'number' &&
        (response.retryCount >= response.maxRetries)
      ) {
        apiCallEvent.MaxRetriesExceeded = 1;
      }
      self.emit('apiCall', [apiCallEvent]);
    });
  },

  /**
   * Override this method to setup any custom request listeners for each
   * new request to the service.
   *
   * @method_abstract This is an abstract method.
   */
  setupRequestListeners: function setupRequestListeners(request) {
  },

  /**
   * Gets the signing name for a given request
   * @api private
   */
  getSigningName: function getSigningName() {
    return this.api.signingName || this.api.endpointPrefix;
  },

  /**
   * Gets the signer class for a given request
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var version;
    // get operation authtype if present
    var operation = null;
    var authtype = '';
    if (request) {
      var operations = request.service.api.operations || {};
      operation = operations[request.operation] || null;
      authtype = operation ? operation.authtype : '';
    }
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
      version = 'v4';
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },

  /**
   * @api private
   */
  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },

  /**
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },

  /**
   * How many times a failed request should be retried before giving up.
   * the defaultRetryCount can be overriden by service classes.
   *
   * @api private
   */
  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
  },

  /**
   * @api private
   */
  retryableError: function retryableError(error) {
    if (this.timeoutError(error)) return true;
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },

  /**
   * @api private
   */
  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },

  /**
   * @api private
   */
  timeoutError: function timeoutError(error) {
    return error.code === 'TimeoutError';
  },

  /**
   * @api private
   */
  expiredCredentialsError: function expiredCredentialsError(error) {
    // TODO : this only handles *one* of the expired credential codes
    return (error.code === 'ExpiredTokenException');
  },

  /**
   * @api private
   */
  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },

  /**
   * @api private
   */
  getSkewCorrectedDate: function getSkewCorrectedDate() {
    return new Date(Date.now() + this.config.systemClockOffset);
  },

  /**
   * @api private
   */
  applyClockOffset: function applyClockOffset(newServerTime) {
    if (newServerTime) {
      this.config.systemClockOffset = newServerTime - Date.now();
    }
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(newServerTime) {
    if (newServerTime) {
      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
    }
  },

  /**
   * @api private
   */
  throttledError: function throttledError(error) {
    // this logic varies between services
    if (error.statusCode === 429) return true;
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
      case 'RequestThrottledException':
      case 'TooManyRequestsException':
      case 'TransactionInProgressException': //dynamodb
      case 'EC2ThrottledException':
        return true;
      default:
        return false;
    }
  },

  /**
   * @api private
   */
  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },

  /**
   * @api private
   */
  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },

  /**
   * @api private
   */
  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {

  /**
   * Adds one method for each operation described in the api configuration
   *
   * @api private
   */
  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },

  /**
   * Defines a new Service class using a service identifier and list of versions
   * including an optional set of features (functions) to apply to the class
   * prototype.
   *
   * @param serviceIdentifier [String] the identifier for the service
   * @param versions [Array<String>] a list of versions that work with this
   *   service
   * @param features [Object] an object to attach to the prototype
   * @return [Class<Service>] the service class defined by this function.
   */
  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }
    AWS.SequentialExecutor.call(this.prototype);
    //util.clientSideMonitoring is only available in node
    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
      var Publisher = AWS.util.clientSideMonitoring.Publisher;
      var configProvider = AWS.util.clientSideMonitoring.configProvider;
      var publisherConfig = configProvider();
      this.prototype.publisher = new Publisher(publisherConfig);
      if (publisherConfig.enabled) {
        //if csm is enabled in environment, SDK should send all metrics
        AWS.Service._clientSideMonitoring = true;
      }
    }
    AWS.SequentialExecutor.call(svc.prototype);
    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
    return svc;
  },

  /**
   * @api private
   */
  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },

  /**
   * @api private
   */
  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api, {
          serviceIdentifier: superclass.serviceIdentifier
        });
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },

  /**
   * @api private
   */
  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },

  /**
   * @param attachOn attach default monitoring listeners to object
   *
   * Each monitoring event should be emitted from service client to service constructor prototype and then
   * to global service prototype like bubbling up. These default monitoring events listener will transfer
   * the monitoring events to the upper layer.
   * @api private
   */
  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
    });
    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCall', [event]);
    });
  },

  /**
   * @api private
   */
  _serviceMap: {}
});

AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

/**
 * @api private
 */
module.exports = AWS.Service;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/services/dynamodb.js":
/*!*****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/services/dynamodb.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ../dynamodb/document_client */ "../../../../node_modules/aws-sdk/lib/dynamodb/document_client.js");

AWS.util.update(AWS.DynamoDB.prototype, {
  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    if (request.service.config.dynamoDbCrc32) {
      request.removeListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
      request.addListener('extractData', this.checkCrc32);
      request.addListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
    }
  },

  /**
   * @api private
   */
  checkCrc32: function checkCrc32(resp) {
    if (!resp.httpResponse.streaming && !resp.request.service.crc32IsValid(resp)) {
      resp.data = null;
      resp.error = AWS.util.error(new Error(), {
        code: 'CRC32CheckFailed',
        message: 'CRC32 integrity check failed',
        retryable: true
      });
      resp.request.haltHandlersOnError();
      throw (resp.error);
    }
  },

  /**
   * @api private
   */
  crc32IsValid: function crc32IsValid(resp) {
    var crc = resp.httpResponse.headers['x-amz-crc32'];
    if (!crc) return true; // no (valid) CRC32 header
    return parseInt(crc, 10) === AWS.util.crypto.crc32(resp.httpResponse.body);
  },

  /**
   * @api private
   */
  defaultRetryCount: 10,

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    var retryDelayOptions = AWS.util.copy(this.config.retryDelayOptions);

    if (typeof retryDelayOptions.base !== 'number') {
        retryDelayOptions.base = 50; // default for dynamodb
    }
    var delay = AWS.util.calculateRetryDelay(retryCount, retryDelayOptions, err);
    return delay;
  }
});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/services/sts.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/services/sts.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var resolveRegionalEndpointsFlag = __webpack_require__(/*! ../config_regional_endpoint */ "../../../../node_modules/aws-sdk/lib/config_regional_endpoint.js");
var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';

AWS.util.update(AWS.STS.prototype, {
  /**
   * @overload credentialsFrom(data, credentials = null)
   *   Creates a credentials object from STS response data containing
   *   credentials information. Useful for quickly setting AWS credentials.
   *
   *   @note This is a low-level utility function. If you want to load temporary
   *     credentials into your process for subsequent requests to AWS resources,
   *     you should use {AWS.TemporaryCredentials} instead.
   *   @param data [map] data retrieved from a call to {getFederatedToken},
   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
   *   @param credentials [AWS.Credentials] an optional credentials object to
   *     fill instead of creating a new object. Useful when modifying an
   *     existing credentials object from a refresh call.
   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
   *     loaded from a raw STS operation response.
   *   @example Using credentialsFrom to load global AWS credentials
   *     var sts = new AWS.STS();
   *     sts.getSessionToken(function (err, data) {
   *       if (err) console.log("Error getting credentials");
   *       else {
   *         AWS.config.credentials = sts.credentialsFrom(data);
   *       }
   *     });
   *   @see AWS.TemporaryCredentials
   */
  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    request.addListener('validate', this.optInRegionalEndpoint, true);
  },

  /**
   * @api private
   */
  optInRegionalEndpoint: function optInRegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: ENV_REGIONAL_ENDPOINT_ENABLED,
      sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
      clientConfig: 'stsRegionalEndpoints'
    });
    if (
      config.stsRegionalEndpoints === 'regional' &&
      service.isGlobalEndpoint
    ) {
      //client will throw if region is not supplied; request will be signed with specified region
      if (!config.region) {
        throw AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      var regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.' + config.region + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
      req.httpRequest.region = config.region;
    }
  }

});


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/shared-ini/index.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/shared-ini/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IniLoader = (__webpack_require__(/*! ./ini-loader */ "../../../../node_modules/aws-sdk/lib/shared-ini/ini-loader.js").IniLoader);
/**
 * Singleton object to load specified config/credentials files.
 * It will cache all the files ever loaded;
 */
module.exports.iniLoader = new IniLoader();


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/shared-ini/ini-loader.js":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/shared-ini/ini-loader.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var os = __webpack_require__(/*! os */ "os");
var path = __webpack_require__(/*! path */ "path");

function parseFile(filename, isConfig) {
    var content = AWS.util.ini.parse(AWS.util.readFileSync(filename));
    var tmpContent = {};
    Object.keys(content).forEach(function(profileName) {
      var profileContent = content[profileName];
      profileName = isConfig ? profileName.replace(/^profile\s/, '') : profileName;
      Object.defineProperty(tmpContent, profileName, {
        value: profileContent,
        enumerable: true
      });
    });
    return tmpContent;
}

/**
 * Ini file loader class the same as that used in the SDK. It loads and
 * parses config and credentials files in .ini format and cache the content
 * to assure files are only read once.
 * Note that calling operations on the instance instantiated from this class
 * won't affect the behavior of SDK since SDK uses an internal singleton of
 * this class.
 * @!macro nobrowser
 */
AWS.IniLoader = AWS.util.inherit({
  constructor: function IniLoader() {
    this.resolvedProfiles = {};
  },

  /** Remove all cached files. Used after config files are updated. */
  clearCachedFiles: function clearCachedFiles() {
    this.resolvedProfiles = {};
  },

/**
 * Load configurations from config/credentials files and cache them
 * for later use. If no file is specified it will try to load default
 * files.
 * @param options [map] information describing the file
 * @option options filename [String] ('~/.aws/credentials' or defined by
 *   AWS_SHARED_CREDENTIALS_FILE process env var or '~/.aws/config' if
 *   isConfig is set to true)
 *   path to the file to be read.
 * @option options isConfig [Boolean] (false) True to read config file.
 * @return [map<String,String>] object containing contents from file in key-value
 *   pairs.
 */
  loadFrom: function loadFrom(options) {
    options = options || {};
    var isConfig = options.isConfig === true;
    var filename = options.filename || this.getDefaultFilePath(isConfig);
    if (!this.resolvedProfiles[filename]) {
      var fileContent = this.parseFile(filename, isConfig);
      Object.defineProperty(this.resolvedProfiles, filename, { value: fileContent });
    }
    return this.resolvedProfiles[filename];
  },

  /**
   * @api private
   */
  parseFile: parseFile,

  /**
   * @api private
   */
  getDefaultFilePath: function getDefaultFilePath(isConfig) {
    return path.join(
      this.getHomeDir(),
      '.aws',
      isConfig ? 'config' : 'credentials'
    );
  },

  /**
   * @api private
   */
  getHomeDir: function getHomeDir() {
    var env = process.env;
    var home = env.HOME ||
      env.USERPROFILE ||
      (env.HOMEPATH ? ((env.HOMEDRIVE || 'C:/') + env.HOMEPATH) : null);

    if (home) {
      return home;
    }

    if (typeof os.homedir === 'function') {
      return os.homedir();
    }

    throw AWS.util.error(
      new Error('Cannot load credentials, HOME path not set')
    );
  }
});

var IniLoader = AWS.IniLoader;

module.exports = {
  IniLoader: IniLoader,
  parseFile: parseFile,
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/presign.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/presign.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp(now) + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}

/**
 * @api private
 */
function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  var auth = request.httpRequest.headers['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['Signature'] = auth.pop();
    queryParams['AWSAccessKeyId'] = auth.join(':');

    AWS.util.each(request.httpRequest.headers, function (key, value) {
      if (key === expiresHeader) key = 'Expires';
      if (key.indexOf('x-amz-meta-') === 0) {
        // Delete existing, potentially not normalized key
        delete queryParams[key];
        key = key.toLowerCase();
      }
      queryParams[key] = value;
    });
    delete request.httpRequest.headers[expiresHeader];
    delete queryParams['Authorization'];
    delete queryParams['Host'];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }

  // build URL
  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}

/**
 * @api private
 */
AWS.Signers.Presign = inherit({
  /**
   * @api private
   */
  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.Presign;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/request_signer.js":
/*!**********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/request_signer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 's3v4': return AWS.Signers.V4;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
  }
  throw new Error('Unknown signing version ' + version);
};

__webpack_require__(/*! ./v2 */ "../../../../node_modules/aws-sdk/lib/signers/v2.js");
__webpack_require__(/*! ./v3 */ "../../../../node_modules/aws-sdk/lib/signers/v3.js");
__webpack_require__(/*! ./v3https */ "../../../../node_modules/aws-sdk/lib/signers/v3https.js");
__webpack_require__(/*! ./v4 */ "../../../../node_modules/aws-sdk/lib/signers/v4.js");
__webpack_require__(/*! ./s3 */ "../../../../node_modules/aws-sdk/lib/signers/s3.js");
__webpack_require__(/*! ./presign */ "../../../../node_modules/aws-sdk/lib/signers/presign.js");


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/s3.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/s3.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
  /**
   * When building the stringToSign, these sub resource params should be
   * part of the canonical resource string with their NON-decoded values
   */
  subResources: {
    'acl': 1,
    'accelerate': 1,
    'analytics': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'inventory': 1,
    'location': 1,
    'logging': 1,
    'metrics': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  // when building the stringToSign, these querystring params should be
  // part of the canonical resource string with their NON-encoded values
  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      // presigned URLs require this header to be lowercased
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    // This is the "Date" header, but we use X-Amz-Date.
    // The S3 signing mechanism requires us to pass an empty
    // string for this Date header regardless.
    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      // collect a list of sub resources and query params that need to be signed
      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.S3;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/v2.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/v2.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V2;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/v3.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/v3.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V3;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/v3https.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/v3https.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

__webpack_require__(/*! ./v3 */ "../../../../node_modules/aws-sdk/lib/signers/v3.js");

/**
 * @api private
 */
AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.V3Https;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/v4.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/v4.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var v4Credentials = __webpack_require__(/*! ./v4_credentials */ "../../../../node_modules/aws-sdk/lib/signers/v4_credentials.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, options) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    options = options || {};
    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
    this.operation = options.operation;
    this.signatureVersion = options.signatureVersion;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    // need to pull in any other X-Amz-* headers
    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        // Metadata should be normalized
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var signingKey = v4Credentials.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName,
      this.signatureCache
    );
    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        var value = item[1];
        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
            code: 'InvalidHeader'
          });
        }
        parts.push(key + ':' +
          this.canonicalHeaderValues(value.toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    return v4Credentials.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    var request = this.request;
    if (this.isPresigned() && (['s3', 's3-object-lambda'].indexOf(this.serviceName) > -1) && !request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (request.headers['X-Amz-Content-Sha256']) {
      return request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    expiresHeader,
    'expect',
    'x-amzn-trace-id'
  ],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V4;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/signers/v4_credentials.js":
/*!**********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/signers/v4_credentials.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");

/**
 * @api private
 */
var cachedSecret = {};

/**
 * @api private
 */
var cacheQueue = [];

/**
 * @api private
 */
var maxCacheEntries = 50;

/**
 * @api private
 */
var v4Identifier = 'aws4_request';

/**
 * @api private
 */
module.exports = {
  /**
   * @api private
   *
   * @param date [String]
   * @param region [String]
   * @param serviceName [String]
   * @return [String]
   */
  createScope: function createScope(date, region, serviceName) {
    return [
      date.substr(0, 8),
      region,
      serviceName,
      v4Identifier
    ].join('/');
  },

  /**
   * @api private
   *
   * @param credentials [Credentials]
   * @param date [String]
   * @param region [String]
   * @param service [String]
   * @param shouldCache [Boolean]
   * @return [String]
   */
  getSigningKey: function getSigningKey(
    credentials,
    date,
    region,
    service,
    shouldCache
  ) {
    var credsIdentifier = AWS.util.crypto
      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
    var cacheKey = [credsIdentifier, date, region, service].join('_');
    shouldCache = shouldCache !== false;
    if (shouldCache && (cacheKey in cachedSecret)) {
      return cachedSecret[cacheKey];
    }

    var kDate = AWS.util.crypto.hmac(
      'AWS4' + credentials.secretAccessKey,
      date,
      'buffer'
    );
    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
    if (shouldCache) {
      cachedSecret[cacheKey] = signingKey;
      cacheQueue.push(cacheKey);
      if (cacheQueue.length > maxCacheEntries) {
        // remove the oldest entry (not the least recently used)
        delete cachedSecret[cacheQueue.shift()];
      }
    }

    return signingKey;
  },

  /**
   * @api private
   *
   * Empties the derived signing key cache. Made available for testing purposes
   * only.
   */
  emptyCache: function emptyCache() {
    cachedSecret = {};
    cacheQueue = [];
  }
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/state_machine.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/state_machine.js ***!
  \*************************************************************/
/***/ ((module) => {

function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

/**
 * @api private
 */
module.exports = AcceptorStateMachine;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/util.js":
/*!****************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/util.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint guard-for-in:0 */
var AWS;

/**
 * A set of utility methods for use with the AWS SDK.
 *
 * @!attribute abort
 *   Return this value from an iterator function {each} or {arrayEach}
 *   to break out of the iteration.
 *   @example Breaking out of an iterator function
 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
 *       if (key == 'b') return AWS.util.abort;
 *     });
 *   @see each
 *   @see arrayEach
 * @api private
 */
var util = {
  environment: 'nodejs',
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      var engine = process.platform + '/' + process.version;
      if (process.env.AWS_EXECUTION_ENV) {
        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
      }
      return engine;
    }
  },

  userAgent: function userAgent() {
    var name = util.environment;
    var agent = 'aws-sdk-' + name + '/' + (__webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js").VERSION);
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    // AWS percent-encodes some extra non-standard characters in a URI
    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return (__webpack_require__(/*! fs */ "fs").readFileSync)(path, 'utf-8');
  },

  base64: {
    encode: function encode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 encode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      var buf = util.buffer.toBuffer(string);
      return buf.toString('base64');
    },

    decode: function decode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 decode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      return util.buffer.toBuffer(string, 'base64');
    }

  },

  buffer: {
    /**
     * Buffer constructor for Node buffer and buffer pollyfill
     */
    toBuffer: function(data, encoding) {
      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ?
        util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
    },

    alloc: function(size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new Error('size passed to alloc must be a number.');
      }
      if (typeof util.Buffer.alloc === 'function') {
        return util.Buffer.alloc(size, fill, encoding);
      } else {
        var buf = new util.Buffer(size);
        if (fill !== undefined && typeof buf.fill === 'function') {
          buf.fill(fill, undefined, undefined, encoding);
        }
        return buf;
      }
    },

    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer =  util.buffer.toBuffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },

    /**
     * Concatenates a list of Buffer objects.
     */
    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = util.buffer.alloc(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = util.buffer.toBuffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return (__webpack_require__(/*! fs */ "fs").lstatSync)(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
        if (section) {
          currentSection = section[1];
          if (currentSection === '__proto__' || currentSection.split(/\s/)[1] === '__proto__') {
            throw util.error(
              new Error('Cannot load profile name \'' + currentSection + '\' from shared ini file.')
            );
          }
        } else if (currentSection) {
          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
          if (item) {
            map[currentSection] = map[currentSection] || {};
            map[currentSection][item[1]] = item[2];
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},
    callback: function (err) { if (err) throw err; },

    /**
     * Turn a synchronous function into as "async" function by making it call
     * a callback. The underlying function is called with all but the last argument,
     * which is treated as the callback. The callback is passed passed a first argument
     * of null on success to mimick standard node callbacks.
     */
    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },

  /**
   * Date and time utility functions.
   */
  date: {

    /**
     * @return [Date] the current JavaScript date object. Since all
     *   AWS services rely on this date object, you can override
     *   this function to provide a special time value to AWS service
     *   requests.
     */
    getDate: function getDate() {
      if (!AWS) AWS = __webpack_require__(/*! ./core */ "../../../../node_modules/aws-sdk/lib/core.js");
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },

    /**
     * @return [String] the date in ISO-8601 format
     */
    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },

    /**
     * @return [String] the date in RFC 822 format
     */
    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },

    /**
     * @return [Integer] the UNIX timestamp value for the current time
     */
    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },

    /**
     * @param [String,number,Date] date
     * @return [Date]
     */
    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },

    /**
     * Given a Date or date-like value, this function formats the
     * date into a string of the requested value.
     * @param [String,number,Date] date
     * @param [String] formatter Valid formats are:
     #   * 'iso8601'
     #   * 'rfc822'
     #   * 'unixTimestamp'
     * @return [String]
     */
    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = util.buffer.toBuffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = util.buffer.toBuffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = util.buffer.toBuffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      //Identifying objects with an ArrayBuffer as buffers
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        // this might be a File/Blob
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },

  /** @!ignore */

  /* Abort constant */
  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    // jshint forin:false
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    // handle cross-"frame" objects
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = String(options && options.name || err.name || err.code || 'Error');
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },

  /**
   * @api private
   */
  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    // constructor not supplied, create pass-through ctor
    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },

  /**
   * @api private
   */
  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      // jshint forin:false
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },

  /**
   * @api private
   */
  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },

  /**
   * @api private
   */
  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },

  /**
   * @api private
   */
  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    // build enumerable attribute for each value with lazy accessor.
    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },

  /**
   * TODO Remove in major version revision
   * This backfill populates response data without the
   * top-level payload name.
   *
   * @api private
   */
  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operationName = req.operation;
    var operation = req.service.api.operations[operationName];
    var output = operation.output;
    if (output.payload && !operation.hasEventOutput) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },

  /**
   * Compute SHA-256 checksums of streams
   *
   * @api private
   */
  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = __webpack_require__(/*! fs */ "fs");
      if (typeof Stream === 'function' && body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },

  /**
   * @api private
   */
  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },

  /**
   * @api private
   */
  addPromises: function addPromises(constructors, PromiseDependency) {
    var deletePromises = false;
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },

  /**
   * @api private
   * Return a function that will return a promise whose fate is decided by the
   * callback behavior of the given method with `methodName`. The method to be
   * promisified should conform to node.js convention of accepting a callback as
   * last argument and calling that callback with error as the first argument
   * and success value on the second argument.
   */
  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      return new PromiseDependency(function(resolve, reject) {
        args.push(function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        self[methodName].apply(self, args);
      });
    };
  },

  /**
   * @api private
   */
  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = __webpack_require__(/*! ../apis/metadata.json */ "../../../../node_modules/aws-sdk/apis/metadata.json");
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },

  /**
   * @api private
   */
  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount, err);
    }
    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },

  /**
   * @api private
   */
  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;

      // Call `calculateRetryDelay()` only when relevant, see #3401
      if (err && err.retryable && retryCount < maxRetries) {
        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
        if (delay >= 0) {
          retryCount++;
          setTimeout(sendRequest, delay + (err.retryAfter || 0));
          return;
        }
      }
      cb(err);
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              {
                statusCode: statusCode,
                retryable: statusCode >= 500 || statusCode === 429
              }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    AWS.util.defer(sendRequest);
  },

  /**
   * @api private
   */
  uuid: {
    v4: function uuidV4() {
      return (__webpack_require__(/*! uuid */ "../../../../node_modules/aws-sdk/node_modules/uuid/index.js").v4)();
    }
  },

  /**
   * @api private
   */
  convertPayloadToString: function convertPayloadToString(resp) {
    var req = resp.request;
    var operation = req.operation;
    var rules = req.service.api.operations[operation].output || {};
    if (rules.payload && resp.data[rules.payload]) {
      resp.data[rules.payload] = resp.data[rules.payload].toString();
    }
  },

  /**
   * @api private
   */
  defer: function defer(callback) {
    if (typeof process === 'object' && typeof process.nextTick === 'function') {
      process.nextTick(callback);
    } else if (typeof setImmediate === 'function') {
      setImmediate(callback);
    } else {
      setTimeout(callback, 0);
    }
  },

  /**
   * @api private
   */
  getRequestPayloadShape: function getRequestPayloadShape(req) {
    var operations = req.service.api.operations;
    if (!operations) return undefined;
    var operation = (operations || {})[req.operation];
    if (!operation || !operation.input || !operation.input.payload) return undefined;
    return operation.input.members[operation.input.payload];
  },

  getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
    var profiles = {};
    var profilesFromConfig = {};
    if (process.env[util.configOptInEnv]) {
      var profilesFromConfig = iniLoader.loadFrom({
        isConfig: true,
        filename: process.env[util.sharedConfigFileEnv]
      });
    }
    var profilesFromCreds= {};
    try {
      var profilesFromCreds = iniLoader.loadFrom({
        filename: filename ||
          (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv])
      });
    } catch (error) {
      // if using config, assume it is fully descriptive without a credentials file:
      if (!process.env[util.configOptInEnv]) throw error;
    }
    for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
    }
    for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
    }
    return profiles;

    /**
     * Roughly the semantics of `Object.assign(target, source)`
     */
    function objectAssign(target, source) {
      for (var i = 0, keys = Object.keys(source); i < keys.length; i++) {
        target[keys[i]] = source[keys[i]];
      }
      return target;
    }
  },

  /**
   * @api private
   */
  ARN: {
    validate: function validateARN(str) {
      return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
    },
    parse: function parseARN(arn) {
      var matched = arn.split(':');
      return {
        partition: matched[1],
        service: matched[2],
        region: matched[3],
        accountId: matched[4],
        resource: matched.slice(5).join(':')
      };
    },
    build: function buildARN(arnObject) {
      if (
        arnObject.service === undefined ||
        arnObject.region === undefined ||
        arnObject.accountId === undefined ||
        arnObject.resource === undefined
      ) throw util.error(new Error('Input ARN object is invalid'));
      return 'arn:'+ (arnObject.partition || 'aws') + ':' + arnObject.service +
        ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
    }
  },

  /**
   * @api private
   */
  defaultProfile: 'default',

  /**
   * @api private
   */
  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

  /**
   * @api private
   */
  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

  /**
   * @api private
   */
  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

  /**
   * @api private
   */
  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
};

/**
 * @api private
 */
module.exports = util;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/xml/builder.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/xml/builder.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "../../../../node_modules/aws-sdk/lib/util.js");
var XmlNode = (__webpack_require__(/*! ./xml-node */ "../../../../node_modules/aws-sdk/lib/xml/xml-node.js").XmlNode);
var XmlText = (__webpack_require__(/*! ./xml-text */ "../../../../node_modules/aws-sdk/lib/xml/xml-text.js").XmlText);

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = new XmlNode(rootElement);
  applyNamespaces(xml, shape, true);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.addAttribute(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = new XmlNode(name);
        xml.addChildNode(element);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
    xml.addChildNode(entry);

    var entryKey = new XmlNode(xmlKey);
    var entryValue = new XmlNode(xmlValue);
    entry.addChildNode(entryKey);
    entry.addChildNode(entryValue);

    serialize(entryKey, key, shape.key);
    serialize(entryValue, value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.addChildNode(
    new XmlText(shape.toWireFormat(value))
  );
}

function applyNamespaces(xml, shape, isRoot) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.addAttribute(prefix, uri);
}

/**
 * @api private
 */
module.exports = XmlBuilder;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/xml/escape-attribute.js":
/*!********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/xml/escape-attribute.js ***!
  \********************************************************************/
/***/ ((module) => {

/**
 * Escapes characters that can not be in an XML attribute.
 */
function escapeAttribute(value) {
    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/**
 * @api private
 */
module.exports = {
    escapeAttribute: escapeAttribute
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/xml/escape-element.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/xml/escape-element.js ***!
  \******************************************************************/
/***/ ((module) => {

/**
 * Escapes characters that can not be in an XML element.
 */
function escapeElement(value) {
    return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\r/g, '&#x0D;')
                .replace(/\n/g, '&#x0A;')
                .replace(/\u0085/g, '&#x85;')
                .replace(/\u2028/, '&#x2028;');
}

/**
 * @api private
 */
module.exports = {
    escapeElement: escapeElement
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/xml/node_parser.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/xml/node_parser.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "../../../../node_modules/aws-sdk/lib/core.js");
var util = AWS.util;
var Shape = AWS.Model.Shape;

var xml2js = __webpack_require__(/*! xml2js */ "../../../../node_modules/xml2js/lib/xml2js.js");

/**
 * @api private
 */
var options = {  // options passed to xml2js parser
  explicitCharkey: false, // undocumented
  trim: false,            // trim the leading/trailing whitespace from text nodes
  normalize: false,       // trim interior whitespace inside text nodes
  explicitRoot: false,    // return the root node in the resulting object?
  emptyTag: null,         // the default value for empty nodes
  explicitArray: true,    // always put child nodes in an array
  ignoreAttrs: false,     // ignore attributes, only create text nodes
  mergeAttrs: false,      // merge attributes and child elements
  validator: null         // a callable validator
};

function NodeXmlParser() { }

NodeXmlParser.prototype.parse = function(xml, shape) {
  shape = shape || {};

  var result = null;
  var error = null;

  var parser = new xml2js.Parser(options);
  parser.parseString(xml, function (e, r) {
    error = e;
    result = r;
  });

  if (result) {
    var data = parseXml(result, shape);
    if (result.ResponseMetadata) {
      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
    }
    return data;
  } else if (error) {
    throw util.error(error, {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return parseXml({}, shape);
  }
};

function parseXml(xml, shape) {
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    var xmlName = memberShape.name;
    if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
      var xmlChild = xml[xmlName];
      if (!memberShape.flattened) xmlChild = xmlChild[0];

      data[memberName] = parseXml(xmlChild, memberShape);
    } else if (memberShape.isXmlAttribute &&
               xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
      data[memberName] = parseScalar(xml.$[xmlName], memberShape);
    } else if (memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {
      data[memberName] = memberShape.defaultValue;
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  if (xml === null) return data;

  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var iterable = shape.flattened ? xml : xml.entry;

  if (Array.isArray(iterable)) {
    util.arrayEach(iterable, function(child) {
      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
    });
  }

  return data;
}

function parseList(xml, shape) {
  var data = [];
  var name = shape.member.name || 'member';
  if (shape.flattened) {
    util.arrayEach(xml, function(xmlChild) {
      data.push(parseXml(xmlChild, shape.member));
    });
  } else if (xml && Array.isArray(xml[name])) {
    util.arrayEach(xml[name], function(child) {
      data.push(parseXml(child, shape.member));
    });
  }

  return data;
}

function parseScalar(text, shape) {
  if (text && text.$ && text.$.encoding === 'base64') {
    shape = new Shape.create({type: text.$.encoding});
  }
  if (text && text._) text = text._;

  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';
  if (typeof xml === 'string') return xml;

  // parse a list
  if (Array.isArray(xml)) {
    var arr = [];
    for (i = 0; i < xml.length; i++) {
      arr.push(parseXml(xml[i], {}));
    }
    return arr;
  }

  // empty object
  var keys = Object.keys(xml), i;
  if (keys.length === 0 || (keys.length === 1 && keys[0] === '$')) {
    return {};
  }

  // object, parse as structure
  var data = {};
  for (i = 0; i < keys.length; i++) {
    var key = keys[i], value = xml[key];
    if (key === '$') continue;
    if (value.length > 1) { // this member is a list
      data[key] = parseList(value, {member: {}});
    } else { // this member is a single item
      data[key] = parseXml(value[0], {});
    }
  }
  return data;
}

/**
 * @api private
 */
module.exports = NodeXmlParser;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/xml/xml-node.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/xml/xml-node.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeAttribute = (__webpack_require__(/*! ./escape-attribute */ "../../../../node_modules/aws-sdk/lib/xml/escape-attribute.js").escapeAttribute);

/**
 * Represents an XML node.
 * @api private
 */
function XmlNode(name, children) {
    if (children === void 0) { children = []; }
    this.name = name;
    this.children = children;
    this.attributes = {};
}
XmlNode.prototype.addAttribute = function (name, value) {
    this.attributes[name] = value;
    return this;
};
XmlNode.prototype.addChildNode = function (child) {
    this.children.push(child);
    return this;
};
XmlNode.prototype.removeAttribute = function (name) {
    delete this.attributes[name];
    return this;
};
XmlNode.prototype.toString = function () {
    var hasChildren = Boolean(this.children.length);
    var xmlText = '<' + this.name;
    // add attributes
    var attributes = this.attributes;
    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== 'undefined' && attribute !== null) {
            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
        }
    }
    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
};

/**
 * @api private
 */
module.exports = {
    XmlNode: XmlNode
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/xml/xml-text.js":
/*!************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/xml/xml-text.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeElement = (__webpack_require__(/*! ./escape-element */ "../../../../node_modules/aws-sdk/lib/xml/escape-element.js").escapeElement);

/**
 * Represents an XML text value.
 * @api private
 */
function XmlText(value) {
    this.value = value;
}

XmlText.prototype.toString = function () {
    return escapeElement('' + this.value);
};

/**
 * @api private
 */
module.exports = {
    XmlText: XmlText
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/node_modules/uuid/index.js":
/*!*******************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/node_modules/uuid/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "../../../../node_modules/aws-sdk/node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "../../../../node_modules/aws-sdk/node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js":
/*!*****************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js ***!
  \*****************************************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/node_modules/uuid/lib/rng.js":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/node_modules/uuid/lib/rng.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ "../../../../node_modules/aws-sdk/node_modules/uuid/v1.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/node_modules/uuid/v1.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../../../node_modules/aws-sdk/node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../../../node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/node_modules/uuid/v4.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/node_modules/uuid/v4.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../../../node_modules/aws-sdk/node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../../../node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "../../../../node_modules/aws-sdk/vendor/endpoint-cache/index.js":
/*!***********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/vendor/endpoint-cache/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LRU_1 = __webpack_require__(/*! ./utils/LRU */ "../../../../node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js");
var CACHE_SIZE = 1000;
/**
 * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
 */
var EndpointCache = /** @class */ (function () {
    function EndpointCache(maxSize) {
        if (maxSize === void 0) { maxSize = CACHE_SIZE; }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
    }
    ;
    Object.defineProperty(EndpointCache.prototype, "size", {
        get: function () {
            return this.cache.length;
        },
        enumerable: true,
        configurable: true
    });
    EndpointCache.prototype.put = function (key, value) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
    };
    EndpointCache.prototype.get = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
            for (var i = records.length-1; i >= 0; i--) {
                var record = records[i];
                if (record.Expire < now) {
                    records.splice(i, 1);
                }
            }
            if (records.length === 0) {
                this.cache.remove(keyString);
                return undefined;
            }
        }
        return records;
    };
    EndpointCache.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
            var identifierName = identifierNames[i];
            if (key[identifierName] === undefined)
                continue;
            identifiers.push(key[identifierName]);
        }
        return identifiers.join(' ');
    };
    EndpointCache.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) { return ({
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
        }); });
    };
    EndpointCache.prototype.empty = function () {
        this.cache.empty();
    };
    EndpointCache.prototype.remove = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        this.cache.remove(keyString);
    };
    return EndpointCache;
}());
exports.EndpointCache = EndpointCache;

/***/ }),

/***/ "../../../../node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LinkedListNode = /** @class */ (function () {
    function LinkedListNode(key, value) {
        this.key = key;
        this.value = value;
    }
    return LinkedListNode;
}());
var LRUCache = /** @class */ (function () {
    function LRUCache(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== 'number' || size < 1) {
            throw new Error('Cache size can only be positive number');
        }
        this.sizeLimit = size;
    }
    Object.defineProperty(LRUCache.prototype, "length", {
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    LRUCache.prototype.prependToList = function (node) {
        if (!this.headerNode) {
            this.tailNode = node;
        }
        else {
            this.headerNode.prev = node;
            node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
    };
    LRUCache.prototype.removeFromTail = function () {
        if (!this.tailNode) {
            return undefined;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
            prevNode.next = undefined;
        }
        node.prev = undefined;
        this.tailNode = prevNode;
        this.size--;
        return node;
    };
    LRUCache.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
            this.headerNode = node.next;
        }
        if (this.tailNode === node) {
            this.tailNode = node.prev;
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        node.next = undefined;
        node.prev = undefined;
        this.size--;
    };
    LRUCache.prototype.get = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            this.prependToList(node);
            return node.value;
        }
    };
    LRUCache.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    LRUCache.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
            this.remove(key);
        }
        else if (this.size === this.sizeLimit) {
            var tailNode = this.removeFromTail();
            var key_1 = tailNode.key;
            delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
    };
    LRUCache.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    return LRUCache;
}());
exports.LRUCache = LRUCache;

/***/ }),

/***/ "../../../../node_modules/jmespath/jmespath.js":
/*!*****************************************************!*\
  !*** ../../../../node_modules/jmespath/jmespath.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;
  var TYPE_NAME_TABLE = {
    0: 'number',
    1: 'any',
    2: 'string',
    3: 'array',
    4: 'object',
    5: 'boolean',
    6: 'expression',
    7: 'null',
    8: 'Array<number>',
    9: 'Array<string>'
  };

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            }
            return node;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            }
            return this._parseMultiselectList();
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            }
            // Creating a projection.
            this._advance();
            right = this._parseProjectionRHS(rbp);
            return {type: "ValueProjection", children: [left, right]};
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            }
            this._match(TOK_STAR);
            this._match(TOK_RBRACKET);
            right = this._parseProjectionRHS(bindingPower.Star);
            return {type: "Projection", children: [left, right]};
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              }
              return null;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                var expected = currentSpec
                    .map(function(typeIdentifier) {
                        return TYPE_NAME_TABLE[typeIdentifier];
                    })
                    .join(',');
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + expected +
                                " but received type " +
                                TYPE_NAME_TABLE[actualType] + " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})( false ? 0 : exports);


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Compiler.js":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Compiler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ServiceCircularReferenceException = _interopRequireDefault(__webpack_require__(/*! ./Exception/ServiceCircularReferenceException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceCircularReferenceException.js"));

var _PassConfig = _interopRequireDefault(__webpack_require__(/*! ./PassConfig */ "../../../../node_modules/node-dependency-injection/dist/lib/PassConfig.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Compiler = /*#__PURE__*/function () {
  /**
   * @param {ContainerBuilder} container
   */
  function Compiler(container) {
    _classCallCheck(this, Compiler);

    this._container = container;
  }

  _createClass(Compiler, [{
    key: "run",
    value: function run() {
      try {
        if (!this._container.frozen) {
          this._loadExtensions();

          this._optimize();

          this._remove();
        }
      } catch (error) {
        if (error instanceof RangeError) {
          throw new _ServiceCircularReferenceException["default"]();
        }

        throw error;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_loadExtensions",
    value: function _loadExtensions() {
      var _iterator = _createForOfIteratorHelper(this._container.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var extension = _step.value;
          extension.load(this);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_optimize",
    value: function _optimize() {
      this._container._compilerPass.process(_PassConfig["default"].TYPE_BEFORE_OPTIMIZATION);

      this._container._compilerPass.process(_PassConfig["default"].TYPE_OPTIMIZE);
    }
    /**
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove() {
      this._container._compilerPass.process(_PassConfig["default"].TYPE_BEFORE_REMOVING);

      this._container._compilerPass.process(_PassConfig["default"].TYPE_REMOVE);

      this._container._compilerPass.process(_PassConfig["default"].TYPE_AFTER_REMOVING);
    }
  }]);

  return Compiler;
}();

exports["default"] = Compiler;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/DecoratePass.js":
/*!************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/DecoratePass.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DecoratePass = /*#__PURE__*/function () {
  function DecoratePass() {
    _classCallCheck(this, DecoratePass);
  }

  _createClass(DecoratePass, [{
    key: "_processDefinitionKeys",
    value:
    /**
     * @param {string} definitionId
     * @private
     */
    function _processDefinitionKeys(definitionId) {
      var definition = this._container.definitions.get(definitionId);

      if (definition.decorationPriority) {
        this._priority[definition.decorationPriority] = {
          name: definitionId,
          definition: definition
        };
      } else if (definition.decoratedService && !definitionId.includes(DecoratePass.POSTFIX_INNER)) {
        this._priority.push({
          name: definitionId,
          definition: definition
        });
      }
    }
    /**
     * @param {object} decorate
     * @private
     */

  }, {
    key: "_processDecorates",
    value: function _processDecorates(decorate) {
      this._container.setDefinition("".concat(decorate.name, ".").concat(DecoratePass.POSTFIX_INNER), this._container.definitions.get(decorate.definition.decoratedService));

      decorate.definition["public"] = true;

      this._container.setDefinition(decorate.definition.decoratedService, decorate.definition);
    }
    /**
     * @param {ContainerBuilder} container
     */

  }, {
    key: "process",
    value: function process(container) {
      this._container = container;
      this._priority = [];

      var _iterator = _createForOfIteratorHelper(container.definitions.keys()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var definitionId = _step.value;

          this._processDefinitionKeys(definitionId);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var decorates = this._priority.filter(function (item) {
        return item !== null;
      });

      var _iterator2 = _createForOfIteratorHelper(decorates),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var decorate = _step2.value;

          this._processDecorates(decorate);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }], [{
    key: "POSTFIX_INNER",
    get:
    /**
     * @return {string}
     */
    function get() {
      return 'inner';
    }
  }]);

  return DecoratePass;
}();

exports["default"] = DecoratePass;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/OptimizePass.js":
/*!************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/OptimizePass.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var OptimizePass = /*#__PURE__*/function () {
  function OptimizePass() {
    _classCallCheck(this, OptimizePass);
  }

  _createClass(OptimizePass, [{
    key: "process",
    value:
    /**
     * @param {ContainerBuilder} container
     */
    function process(container) {
      var _iterator = _createForOfIteratorHelper(container.definitions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              id = _step$value[0],
              definition = _step$value[1];

          if (!container.isSet(id) && !definition.lazy && !definition["abstract"]) {
            var instance = container.instanceManager.getInstanceFromDefinition(definition);
            container.set(id, instance);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      container.frozen = true;
    }
  }]);

  return OptimizePass;
}();

exports["default"] = OptimizePass;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/RemovePass.js":
/*!**********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/RemovePass.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RemovePass = /*#__PURE__*/function () {
  function RemovePass() {
    _classCallCheck(this, RemovePass);
  }

  _createClass(RemovePass, [{
    key: "process",
    value:
    /**
     * @param {ContainerBuilder} container
     */
    function process(container) {
      var _iterator = _createForOfIteratorHelper(container.definitions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              id = _step$value[0],
              definition = _step$value[1];

          if (definition["public"] === false) {
            container.remove(id);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);

  return RemovePass;
}();

exports["default"] = RemovePass;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _PassConfig = _interopRequireDefault(__webpack_require__(/*! ../PassConfig */ "../../../../node_modules/node-dependency-injection/dist/lib/PassConfig.js"));

var _OptimizePass = _interopRequireDefault(__webpack_require__(/*! ./OptimizePass */ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/OptimizePass.js"));

var _RemovePass = _interopRequireDefault(__webpack_require__(/*! ./RemovePass */ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/RemovePass.js"));

var _DecoratePass = _interopRequireDefault(__webpack_require__(/*! ./DecoratePass */ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/DecoratePass.js"));

var _ProcessMethodNotFoundException = _interopRequireDefault(__webpack_require__(/*! ../Exception/ProcessMethodNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ProcessMethodNotFoundException.js"));

var _WrongCompilerPassTypeException = _interopRequireDefault(__webpack_require__(/*! ../Exception/WrongCompilerPassTypeException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/WrongCompilerPassTypeException.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CompilerPass = /*#__PURE__*/function () {
  /**
   * @param {ContainerBuilder} container
   */
  function CompilerPass(container) {
    _classCallCheck(this, CompilerPass);

    this._container = container;
    this.beforeOptimization = [];
    this.optimize = [];
    this.beforeRemoving = [];
    this.remove = [];
    this.afterRemoving = [];
  }
  /**
   * @param {string} type
   * @param {number} priority
   * @returns {number}
   */


  _createClass(CompilerPass, [{
    key: "_getCompilerPassPriorityNumber",
    value: function _getCompilerPassPriorityNumber(type, priority) {
      if (this[type][priority]) {
        return this._getCompilerPassPriorityNumber(type, priority + 1);
      }

      return priority;
    }
    /**
     * @param {*} compilerPass
     * @param {string} type
     * @param {number} priority
     */

  }, {
    key: "register",
    value: function register(compilerPass, type, priority) {
      if (typeof compilerPass.process !== 'function') {
        throw new _ProcessMethodNotFoundException["default"](compilerPass.constructor.name);
      }

      if (!_PassConfig["default"].isValidType(type)) {
        throw new _WrongCompilerPassTypeException["default"](type);
      }

      var arrayLevel = this._getCompilerPassPriorityNumber(type, priority);

      this[type][arrayLevel] = compilerPass;
    }
    /**
     * @param {string} type
     * @private
     */

  }, {
    key: "_checkAndAdd",
    value: function _checkAndAdd(type) {
      if (this._container._compilerPass[type].length === 0) {
        if (type === _PassConfig["default"].TYPE_BEFORE_OPTIMIZATION) {
          this.register(new _DecoratePass["default"](), type, 0);
        } else if (type === _PassConfig["default"].TYPE_OPTIMIZE) {
          this.register(new _OptimizePass["default"](), type, 0);
        } else if (type === _PassConfig["default"].TYPE_REMOVE) {
          this.register(new _RemovePass["default"](), type, 0);
        }
      }
    }
    /**
     * @param {string} type
     */

  }, {
    key: "process",
    value: function process(type) {
      this._checkAndAdd(type);

      this[type] = this[type].filter(function (i) {
        return i !== null;
      });

      var _iterator = _createForOfIteratorHelper(this[type]),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var compilerPass = _step.value;
          compilerPass.process(this._container);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);

  return CompilerPass;
}();

exports["default"] = CompilerPass;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/ContainerBuilder.js":
/*!***************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/ContainerBuilder.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Definition = _interopRequireDefault(__webpack_require__(/*! ./Definition */ "../../../../node_modules/node-dependency-injection/dist/lib/Definition.js"));

var _PassConfig = _interopRequireDefault(__webpack_require__(/*! ./PassConfig */ "../../../../node_modules/node-dependency-injection/dist/lib/PassConfig.js"));

var _Compiler = _interopRequireDefault(__webpack_require__(/*! ./Compiler */ "../../../../node_modules/node-dependency-injection/dist/lib/Compiler.js"));

var _CompilerPass = _interopRequireDefault(__webpack_require__(/*! ./CompilerPass */ "../../../../node_modules/node-dependency-injection/dist/lib/CompilerPass/index.js"));

var _InstanceManager = _interopRequireDefault(__webpack_require__(/*! ./InstanceManager */ "../../../../node_modules/node-dependency-injection/dist/lib/InstanceManager.js"));

var _DefinitionNotFoundException = _interopRequireDefault(__webpack_require__(/*! ./Exception/DefinitionNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/DefinitionNotFoundException.js"));

var _LoadMethodNotFoundException = _interopRequireDefault(__webpack_require__(/*! ./Exception/LoadMethodNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/LoadMethodNotFoundException.js"));

var _LoggerWarnMethodNotFoundException = _interopRequireDefault(__webpack_require__(/*! ./Exception/LoggerWarnMethodNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/LoggerWarnMethodNotFoundException.js"));

var _WrongDefinitionException = _interopRequireDefault(__webpack_require__(/*! ./Exception/WrongDefinitionException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/WrongDefinitionException.js"));

var _FrozenContainerException = _interopRequireDefault(__webpack_require__(/*! ./Exception/FrozenContainerException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/FrozenContainerException.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ContainerBuilder = /*#__PURE__*/function () {
  /**
   * @param {boolean} containerReferenceAsService
   * @param {String} defaultDir
   */
  function ContainerBuilder() {
    var containerReferenceAsService = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var defaultDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, ContainerBuilder);

    this._definitions = new Map();
    this._parameters = new Map();
    this._alias = new Map();
    this._container = new Map();
    this._frozen = false;
    this._compilerPass = new _CompilerPass["default"](this);
    this._extensions = [];
    this._logger = console;
    this._instanceManager = undefined;
    this._containerReferenceAsService = containerReferenceAsService;
    this._defaultDir = defaultDir;
  }
  /**
   * @returns {String}
   */


  _createClass(ContainerBuilder, [{
    key: "defaultDir",
    get: function get() {
      return this._defaultDir;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "containerReferenceAsService",
    get: function get() {
      return this._containerReferenceAsService;
    }
    /**
     * @returns {Map}
     */

  }, {
    key: "definitions",
    get: function get() {
      return this._definitions;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "frozen",
    get: function get() {
      return this._frozen;
    }
    /**
     * @param {boolean} value
     */
    ,
    set: function set(value) {
      this._frozen = value;
    }
    /**
     * @return {InstanceManager}
     */

  }, {
    key: "instanceManager",
    get: function get() {
      if (!this._instanceManager) {
        this._instanceManager = new _InstanceManager["default"](this, this._definitions, this._alias);
      }

      return this._instanceManager;
    }
    /**
     * @returns {Array}
     */

  }, {
    key: "extensions",
    get: function get() {
      return this._extensions;
    }
    /**
     * @returns {Console|*}
     */

  }, {
    key: "logger",
    get: function get() {
      return this._logger;
    }
    /**
     * @param {Console|*} value
     */
    ,
    set: function set(value) {
      if (typeof value.warn !== 'function') {
        throw new _LoggerWarnMethodNotFoundException["default"]();
      }

      this._logger = value;
    }
    /**
     * @return {Map}
     */

  }, {
    key: "services",
    get: function get() {
      return this._container;
    }
    /**
     * @param {string} id
     * @param {*|null} object
     * @param {Array} args
     * @returns {Definition}
     */

  }, {
    key: "register",
    value: function register(id) {
      var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      if (!this.frozen) {
        var definition = new _Definition["default"]();
        definition.Object = object;
        definition.args = args;

        if (!object) {
          definition.synthetic = true;
        }

        return this.setDefinition(id, definition);
      }

      throw new _FrozenContainerException["default"]();
    }
    /**
     * @param {string} id
     */

  }, {
    key: "get",
    value: function get(id) {
      return this.instanceManager.getInstance(id);
    }
  }, {
    key: "compile",
    value: function compile() {
      new _Compiler["default"](this).run();
    }
    /**
     * @param {*} compilerPass
     * @param {string} type
     * @param {number} priority
     */

  }, {
    key: "addCompilerPass",
    value: function addCompilerPass(compilerPass) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _PassConfig["default"].TYPE_BEFORE_OPTIMIZATION;
      var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      this._compilerPass.register(compilerPass, type, priority);
    }
    /**
     * @param {string} alias
     * @param {string} id
     */

  }, {
    key: "setAlias",
    value: function setAlias(alias, id) {
      this._alias.set(alias, id);
    }
    /**
     * @param {string} id
     * @param {Definition} definition
     * @returns {Definition}
     */

  }, {
    key: "setDefinition",
    value: function setDefinition(id, definition) {
      if (definition instanceof _Definition["default"]) {
        this._definitions.set(id, definition);

        return definition;
      }

      throw new _WrongDefinitionException["default"]();
    }
    /**
     * @param {string} name
     * @returns {Map}
     */

  }, {
    key: "findTaggedServiceIds",
    value: function findTaggedServiceIds(name) {
      var taggedServices = new Map();

      var _iterator = _createForOfIteratorHelper(this._definitions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              id = _step$value[0],
              definition = _step$value[1];

          if (definition.tags.some(function (tag) {
            return tag.name === name;
          })) {
            taggedServices.set(id, definition);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return taggedServices;
    }
    /**
     * @param {string} key
     * @param {string||Array|boolean|Object} value
     */

  }, {
    key: "setParameter",
    value: function setParameter(key, value) {
      if (typeof value !== 'string' && !Array.isArray(value) && typeof value !== 'boolean' && _typeof(value) !== 'object') {
        throw new TypeError('The expected value is not a flat string, an array, a boolean or an object');
      }

      this._parameters.set(key, value);
    }
    /**
     * @param {string} key
     * @returns {string|Array}
     */

  }, {
    key: "getParameter",
    value: function getParameter(key) {
      return this._parameters.get(key);
    }
    /**
     * @param {string} key
     * @returns {boolean}
     */

  }, {
    key: "hasParameter",
    value: function hasParameter(key) {
      return this._parameters.has(key);
    }
    /**
     * @param {string} key
     * @returns {boolean}
     */

  }, {
    key: "hasDefinition",
    value: function hasDefinition(key) {
      return this._definitions.has(key);
    }
    /**
     * @param {string} key
     * @returns {boolean}
     */

  }, {
    key: "has",
    value: function has(key) {
      return this._definitions.has(key) || this._parameters.has(key) || this._alias.has(key);
    }
    /**
     * @param {string} method
     * @param {string} key
     * @returns {Definition|boolean}
     * @private
     */

  }, {
    key: "_definition",
    value: function _definition(method, key) {
      if (this._definitions.has(key)) {
        return this._definitions[method](key);
      }

      throw new _DefinitionNotFoundException["default"](key);
    }
    /**
     * @param {string} key
     * @returns {Definition}
     */

  }, {
    key: "getDefinition",
    value: function getDefinition(key) {
      return this._definition('get', key);
    }
    /**
     * @param {string} key
     * @returns {boolean}
     */

  }, {
    key: "removeDefinition",
    value: function removeDefinition(key) {
      return this._definition('delete', key);
    }
    /**
     * @param {string} key
     * @returns {Definition}
     */

  }, {
    key: "findDefinition",
    value: function findDefinition(key) {
      key = this._alias.get(key) || key;

      if (this._definitions.has(key)) {
        return this._definitions.get(key);
      }

      throw new _DefinitionNotFoundException["default"](key);
    }
    /**
     * @param {*} extension
     */

  }, {
    key: "registerExtension",
    value: function registerExtension(extension) {
      if (typeof extension.load !== 'function') {
        throw new _LoadMethodNotFoundException["default"](extension.constructor.name);
      }

      this._extensions.push(extension);
    }
    /**
     * @param {string} id
     * @param {*} instance
     */

  }, {
    key: "set",
    value: function set(id, instance) {
      this._container.set(id, instance);
    }
    /**
     * @param {string} id
     */

  }, {
    key: "remove",
    value: function remove(id) {
      this._container["delete"](id);
    }
    /**
     * @param {string} id
     * @returns {boolean}
     */

  }, {
    key: "isSet",
    value: function isSet(id) {
      return this._container.has(id);
    }
  }]);

  return ContainerBuilder;
}();

var _default = ContainerBuilder;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Definition.js":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Definition.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MethodCallEmptyException = _interopRequireDefault(__webpack_require__(/*! ./Exception/MethodCallEmptyException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/MethodCallEmptyException.js"));

var _AttributesMapException = _interopRequireDefault(__webpack_require__(/*! ./Exception/AttributesMapException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/AttributesMapException.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Definition = /*#__PURE__*/function () {
  /**
   * @param {*|null} Object
   * @param {Array} args
   */
  function Definition() {
    var Object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, Definition);

    this._Object = Object;
    this._args = args;
    this._calls = [];
    this._tags = [];
    this._properties = new Map();
    this._lazy = false;
    this._deprecated = null;
    this._factory = null;
    this._public = true;
    this._synthetic = false;
    this._decoratedService = null;
    this._decorationPriority = null;
    this._shared = true;
    this._abstract = false;
    this._appendArgs = [];
    this._parent = null;
  }
  /**
   * @return {boolean}
   */


  _createClass(Definition, [{
    key: "abstract",
    get: function get() {
      return this._abstract;
    }
    /**
     * @param {boolean} value
     */
    ,
    set: function set(value) {
      this._abstract = value;
    }
    /**
     * @returns {string}
     */

  }, {
    key: "decoratedService",
    get: function get() {
      return this._decoratedService;
    }
    /**
     * @param {string} value
     */
    ,
    set: function set(value) {
      this._decoratedService = value;
    }
    /**
     * @return {number}
     */

  }, {
    key: "decorationPriority",
    get: function get() {
      return this._decorationPriority;
    }
    /**
     * @param {number} value
     */
    ,
    set: function set(value) {
      this._decorationPriority = value;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "public",
    get: function get() {
      return this._public;
    }
    /**
     * @param {boolean} value
     */
    ,
    set: function set(value) {
      this._public = value;
    }
    /**
     * @returns {null|{Object: (Object|Reference), method: string}|*}
     */

  }, {
    key: "factory",
    get: function get() {
      return this._factory;
    }
    /**
     * @returns {null|string}
     */

  }, {
    key: "deprecated",
    get: function get() {
      return this._deprecated;
    }
    /**
     * @param {null|string} value
     */
    ,
    set: function set(value) {
      this._deprecated = value;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "lazy",
    get: function get() {
      return this._lazy;
    }
    /**
     * @param {boolean} value
     */
    ,
    set: function set(value) {
      this._lazy = value;
    }
    /**
     * @returns {*}
     */

  }, {
    key: "Object",
    get: function get() {
      return this._Object;
    }
    /**
     * @param {*} value
     */
    ,
    set: function set(value) {
      this._Object = value;
    }
    /**
     * @returns {Array}
     */

  }, {
    key: "args",
    get: function get() {
      return this._args;
    }
    /**
     * @param {Array} args
     */
    ,
    set: function set(args) {
      this._args = args;
    }
    /**
     * @returns {Array}
     */

  }, {
    key: "calls",
    get: function get() {
      return this._calls;
    }
    /**
     * @returns {Array}
     */

  }, {
    key: "tags",
    get: function get() {
      return this._tags;
    }
    /**
     * @returns {Map}
     */

  }, {
    key: "properties",
    get: function get() {
      return this._properties;
    }
    /**
     * @return {Array}
     */

  }, {
    key: "appendArgs",
    get: function get() {
      return this._appendArgs;
    }
    /**
     * @param {Array} appendArgs
     */
    ,
    set: function set(appendArgs) {
      this._appendArgs = appendArgs;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "synthetic",
    get: function get() {
      return this._synthetic;
    }
    /**
     * @param {boolean} value
     */
    ,
    set: function set(value) {
      this._synthetic = value;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "shared",
    get: function get() {
      return this._shared;
    }
    /**
     * @param {boolean} value
     */
    ,
    set: function set(value) {
      this._shared = value;
    }
    /**
     * @return {string}
     */

  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
    /**
     * @param {string} value
     */
    ,
    set: function set(value) {
      this._parent = value;
    }
    /**
     * @param {Object|Reference} Object
     * @param {string} method
     */

  }, {
    key: "setFactory",
    value: function setFactory(Object, method) {
      this._factory = {
        Object: Object,
        method: method
      };
    }
    /**
     * @param {*} argument
     * @returns {Definition}
     */

  }, {
    key: "addArgument",
    value: function addArgument(argument) {
      this._args.push(argument);

      return this;
    }
    /**
     * @param {string} method
     * @param {Array} args
     */

  }, {
    key: "addMethodCall",
    value: function addMethodCall(method) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (method.length === 0) {
        throw new _MethodCallEmptyException["default"]();
      }

      this._calls.push({
        method: method,
        args: args
      });

      return this;
    }
    /**
     * @param {string} name
     * @param {Map} attributes
     * @returns {Definition}
     */

  }, {
    key: "addTag",
    value: function addTag(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();

      if (attributes instanceof Map) {
        this._tags.push({
          name: name,
          attributes: attributes
        });

        return this;
      }

      throw new _AttributesMapException["default"]();
    }
    /**
     * @param {string} key
     * @param {*} value
     * @returns {Definition}
     */

  }, {
    key: "addProperty",
    value: function addProperty(key, value) {
      this._properties.set(key, value);

      return this;
    }
    /**
     * @param {boolean} bypassPublic
     * @return {boolean}
     */

  }, {
    key: "isPublic",
    value: function isPublic() {
      var bypassPublic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this["public"] || !bypassPublic && this["public"];
    }
  }]);

  return Definition;
}();

var _default = Definition;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/AbstractServiceException.js":
/*!*********************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/AbstractServiceException.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AbstractServiceException = /*#__PURE__*/function (_Error) {
  _inherits(AbstractServiceException, _Error);

  var _super = _createSuper(AbstractServiceException);

  /**
   * @param {string} id
   */
  function AbstractServiceException(id) {
    var _this;

    _classCallCheck(this, AbstractServiceException);

    _this = _super.call(this, "The service ".concat(id, " is abstract"));
    _this.name = 'AbstractServiceException';
    _this.stack = new Error().stack;
    return _this;
  }

  return AbstractServiceException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = AbstractServiceException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/AttributesMapException.js":
/*!*******************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/AttributesMapException.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AttributesMapException = /*#__PURE__*/function (_Error) {
  _inherits(AttributesMapException, _Error);

  var _super = _createSuper(AttributesMapException);

  function AttributesMapException() {
    var _this;

    _classCallCheck(this, AttributesMapException);

    _this = _super.call(this, 'Attributes is not type Map');
    _this.name = 'AttributesMapException';
    _this.stack = new Error().stack;
    return _this;
  }

  return AttributesMapException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = AttributesMapException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ConfigurationFileNotFoundException.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/ConfigurationFileNotFoundException.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ConfigurationFileNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(ConfigurationFileNotFoundException, _Error);

  var _super = _createSuper(ConfigurationFileNotFoundException);

  /**
   * @param {string} path
   */
  function ConfigurationFileNotFoundException(path) {
    var _this;

    _classCallCheck(this, ConfigurationFileNotFoundException);

    _this = _super.call(this, "File ".concat(path, " not found"));
    _this.name = 'ConfigurationFileNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return ConfigurationFileNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = ConfigurationFileNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/DefinitionNotFoundException.js":
/*!************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/DefinitionNotFoundException.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var DefinitionNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(DefinitionNotFoundException, _Error);

  var _super = _createSuper(DefinitionNotFoundException);

  /**
   * @param {string} id
   */
  function DefinitionNotFoundException(id) {
    var _this;

    _classCallCheck(this, DefinitionNotFoundException);

    _this = _super.call(this, "".concat(id, " definition not found"));
    _this.name = 'DefinitionNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return DefinitionNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = DefinitionNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/FrozenContainerException.js":
/*!*********************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/FrozenContainerException.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var FrozenContainerException = /*#__PURE__*/function (_Error) {
  _inherits(FrozenContainerException, _Error);

  var _super = _createSuper(FrozenContainerException);

  function FrozenContainerException() {
    var _this;

    _classCallCheck(this, FrozenContainerException);

    _this = _super.call(this, 'You cannot register more services when the container is frozen');
    _this.name = 'FrozenContainerException';
    _this.stack = new Error().stack;
    return _this;
  }

  return FrozenContainerException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = FrozenContainerException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/LoadMethodNotFoundException.js":
/*!************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/LoadMethodNotFoundException.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var LoadMethodNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(LoadMethodNotFoundException, _Error);

  var _super = _createSuper(LoadMethodNotFoundException);

  /**
   * @param {string} extension
   */
  function LoadMethodNotFoundException(extension) {
    var _this;

    _classCallCheck(this, LoadMethodNotFoundException);

    _this = _super.call(this, "The extension ".concat(extension, " does not have the load method"));
    _this.name = 'LoadMethodNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return LoadMethodNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = LoadMethodNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/LoggerWarnMethodNotFoundException.js":
/*!******************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/LoggerWarnMethodNotFoundException.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var LoggerWarnMethodNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(LoggerWarnMethodNotFoundException, _Error);

  var _super = _createSuper(LoggerWarnMethodNotFoundException);

  function LoggerWarnMethodNotFoundException() {
    var _this;

    _classCallCheck(this, LoggerWarnMethodNotFoundException);

    _this = _super.call(this, 'The logger instance does not implements the warn method');
    _this.name = 'LoggerWarnMethodNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return LoggerWarnMethodNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = LoggerWarnMethodNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/MethodCallEmptyException.js":
/*!*********************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/MethodCallEmptyException.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var MethodCallEmptyException = /*#__PURE__*/function (_Error) {
  _inherits(MethodCallEmptyException, _Error);

  var _super = _createSuper(MethodCallEmptyException);

  function MethodCallEmptyException() {
    var _this;

    _classCallCheck(this, MethodCallEmptyException);

    _this = _super.call(this, 'Method name cannot be empty');
    _this.name = 'MethodCallEmptyException';
    _this.stack = new Error().stack;
    return _this;
  }

  return MethodCallEmptyException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = MethodCallEmptyException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/MethodCallNotFoundException.js":
/*!************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/MethodCallNotFoundException.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var MethodCallNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(MethodCallNotFoundException, _Error);

  var _super = _createSuper(MethodCallNotFoundException);

  /**
   * @param {string} method
   */
  function MethodCallNotFoundException(method) {
    var _this;

    _classCallCheck(this, MethodCallNotFoundException);

    _this = _super.call(this, "Method ".concat(method, " not found"));
    _this.name = 'MethodCallNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return MethodCallNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = MethodCallNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/NotAbstractServiceException.js":
/*!************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/NotAbstractServiceException.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var NotAbstractServiceException = /*#__PURE__*/function (_Error) {
  _inherits(NotAbstractServiceException, _Error);

  var _super = _createSuper(NotAbstractServiceException);

  /**
   * @param {string} id
   */
  function NotAbstractServiceException(id) {
    var _this;

    _classCallCheck(this, NotAbstractServiceException);

    _this = _super.call(this, "The parent service ".concat(id, " is not abstract"));
    _this.name = 'NotAbstractServiceException';
    _this.stack = new Error().stack;
    return _this;
  }

  return NotAbstractServiceException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = NotAbstractServiceException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/PrivateServiceException.js":
/*!********************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/PrivateServiceException.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var PrivateServiceException = /*#__PURE__*/function (_Error) {
  _inherits(PrivateServiceException, _Error);

  var _super = _createSuper(PrivateServiceException);

  /**
   * @param {string} id
   */
  function PrivateServiceException(id) {
    var _this;

    _classCallCheck(this, PrivateServiceException);

    _this = _super.call(this, "The service ".concat(id, " is private"));
    _this.name = 'PrivateServiceException';
    _this.stack = new Error().stack;
    return _this;
  }

  return PrivateServiceException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = PrivateServiceException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ProcessMethodNotFoundException.js":
/*!***************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/ProcessMethodNotFoundException.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ProcessMethodNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(ProcessMethodNotFoundException, _Error);

  var _super = _createSuper(ProcessMethodNotFoundException);

  /**
   * @param {string} compilerPass
   */
  function ProcessMethodNotFoundException(compilerPass) {
    var _this;

    _classCallCheck(this, ProcessMethodNotFoundException);

    _this = _super.call(this, "The compiler pass ".concat(compilerPass, " does not have the process method"));
    _this.name = 'ProcessMethodNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return ProcessMethodNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = ProcessMethodNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceCircularReferenceException.js":
/*!******************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceCircularReferenceException.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ServiceCircularReferenceException = /*#__PURE__*/function (_Error) {
  _inherits(ServiceCircularReferenceException, _Error);

  var _super = _createSuper(ServiceCircularReferenceException);

  function ServiceCircularReferenceException() {
    var _this;

    _classCallCheck(this, ServiceCircularReferenceException);

    _this = _super.call(this, 'Circular reference detected');
    _this.name = 'ServiceCircularReferenceException';
    _this.stack = new Error().stack;
    return _this;
  }

  return ServiceCircularReferenceException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = ServiceCircularReferenceException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceFileNotFoundException.js":
/*!*************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceFileNotFoundException.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ServiceFileNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(ServiceFileNotFoundException, _Error);

  var _super = _createSuper(ServiceFileNotFoundException);

  /**
   * @param {string} fileName
   */
  function ServiceFileNotFoundException(fileName) {
    var _this;

    _classCallCheck(this, ServiceFileNotFoundException);

    _this = _super.call(this, "Service file ".concat(fileName, " not found"));
    _this.name = 'ServiceFileNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return ServiceFileNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = ServiceFileNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceFileNotLoadedException.js":
/*!**************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceFileNotLoadedException.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ServiceFileNotLoadedException = /*#__PURE__*/function (_Error) {
  _inherits(ServiceFileNotLoadedException, _Error);

  var _super = _createSuper(ServiceFileNotLoadedException);

  /**
   * @param {string} fileName
   */
  function ServiceFileNotLoadedException(reason) {
    var _this;

    _classCallCheck(this, ServiceFileNotLoadedException);

    _this = _super.call(this, "Service file could not be loaded. ".concat(reason));
    _this.name = 'ServiceFileNotLoadedException';
    _this.stack = new Error().stack;
    return _this;
  }

  return ServiceFileNotLoadedException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = ServiceFileNotLoadedException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceNotFoundException.js":
/*!*********************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceNotFoundException.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ServiceNotFoundException = /*#__PURE__*/function (_Error) {
  _inherits(ServiceNotFoundException, _Error);

  var _super = _createSuper(ServiceNotFoundException);

  /**
   * @param {string} id
   */
  function ServiceNotFoundException(id) {
    var _this;

    _classCallCheck(this, ServiceNotFoundException);

    _this = _super.call(this, "The service ".concat(id, " is not registered"));
    _this.name = 'ServiceNotFoundException';
    _this.stack = new Error().stack;
    return _this;
  }

  return ServiceNotFoundException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = ServiceNotFoundException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/WrongCompilerPassTypeException.js":
/*!***************************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/WrongCompilerPassTypeException.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var WrongCompilerPassTypeException = /*#__PURE__*/function (_Error) {
  _inherits(WrongCompilerPassTypeException, _Error);

  var _super = _createSuper(WrongCompilerPassTypeException);

  /**
   * @param {string} type
   */
  function WrongCompilerPassTypeException(type) {
    var _this;

    _classCallCheck(this, WrongCompilerPassTypeException);

    _this = _super.call(this, "".concat(type, " is a wrong compiler pass config type"));
    _this.name = 'WrongCompilerPassTypeException';
    _this.stack = new Error().stack;
    return _this;
  }

  return WrongCompilerPassTypeException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = WrongCompilerPassTypeException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/WrongDefinitionException.js":
/*!*********************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Exception/WrongDefinitionException.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var WrongDefinitionException = /*#__PURE__*/function (_Error) {
  _inherits(WrongDefinitionException, _Error);

  var _super = _createSuper(WrongDefinitionException);

  function WrongDefinitionException() {
    var _this;

    _classCallCheck(this, WrongDefinitionException);

    _this = _super.call(this, 'You cannot register not valid definition');
    _this.name = 'WrongDefinitionException';
    _this.stack = new Error().stack;
    return _this;
  }

  return WrongDefinitionException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports["default"] = WrongDefinitionException;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/InstanceManager.js":
/*!**************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/InstanceManager.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Reference = _interopRequireDefault(__webpack_require__(/*! ./Reference */ "../../../../node_modules/node-dependency-injection/dist/lib/Reference.js"));

var _TagReference = _interopRequireDefault(__webpack_require__(/*! ./TagReference */ "../../../../node_modules/node-dependency-injection/dist/lib/TagReference.js"));

var _PackageReference = _interopRequireDefault(__webpack_require__(/*! ./PackageReference */ "../../../../node_modules/node-dependency-injection/dist/lib/PackageReference.js"));

var _PrivateServiceException = _interopRequireDefault(__webpack_require__(/*! ./Exception/PrivateServiceException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/PrivateServiceException.js"));

var _ServiceNotFoundException = _interopRequireDefault(__webpack_require__(/*! ./Exception/ServiceNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceNotFoundException.js"));

var _NotAbstractServiceException = _interopRequireDefault(__webpack_require__(/*! ./Exception/NotAbstractServiceException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/NotAbstractServiceException.js"));

var _MethodCallNotFoundException = _interopRequireDefault(__webpack_require__(/*! ./Exception/MethodCallNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/MethodCallNotFoundException.js"));

var _AbstractServiceException = _interopRequireDefault(__webpack_require__(/*! ./Exception/AbstractServiceException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/AbstractServiceException.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var InstanceManager = /*#__PURE__*/function () {
  /**
   * @param {ContainerBuilder} containerBuilder
   * @param {Map} definitions
   * @param {Map} alias
   */
  function InstanceManager(containerBuilder, definitions, alias) {
    _classCallCheck(this, InstanceManager);

    this._containerBuilder = containerBuilder;
    this._definitions = definitions;
    this._alias = alias;
  }
  /**
   * @param {string} id
   * @param {boolean} bypassPublic
   * @returns {*}
   */


  _createClass(InstanceManager, [{
    key: "getInstance",
    value: function getInstance(id) {
      var bypassPublic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      id = this._alias.get(id) || id;

      if (id === 'service_container' && this._containerBuilder.containerReferenceAsService) {
        return this._containerBuilder;
      }

      if (this._definitions.has(id)) {
        return this._getInstanceFromId(id, bypassPublic);
      }

      this._containerBuilder.logger.warn("The service ".concat(id, " is not registered"));

      throw new _ServiceNotFoundException["default"](id);
    }
    /**
     * @param {string} id
     * @param {boolean} bypassPublic
     * @returns {*}
     * @private
     */

  }, {
    key: "_getInstanceFromId",
    value: function _getInstanceFromId(id) {
      var bypassPublic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var definition = this._definitions.get(id);

      if (!definition["public"] && !bypassPublic) {
        throw new _PrivateServiceException["default"](id);
      }

      if (definition["abstract"]) {
        throw new _AbstractServiceException["default"](id);
      }

      if (definition.deprecated) {
        this._containerBuilder.logger.warn('DEPRECATED', definition.deprecated);
      }

      if (definition.Object || definition.factory || !definition.Object && definition.synthetic) {
        return this._getExistingInstanceFromId(id, bypassPublic);
      }

      this._containerBuilder.logger.warn("The service ".concat(id, " is not registered"));

      throw new _ServiceNotFoundException["default"](id);
    }
    /**
     * @param {string} id
     * @param {boolean} bypassPublic
     * @returns {*}
     * @private
     */

  }, {
    key: "_getExistingInstanceFromId",
    value: function _getExistingInstanceFromId(id) {
      var bypassPublic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var definition = this._definitions.get(id);

      if (definition.shared === false) {
        return this.getInstanceFromDefinition(definition);
      }

      if (this._containerBuilder.services.has(id) && definition.isPublic(bypassPublic)) {
        return this._containerBuilder.services.get(id);
      }

      var instance = this.getInstanceFromDefinition(definition);

      this._containerBuilder.services.set(id, instance);

      return instance;
    }
    /**
     * @param {Definition} definition
     * @returns {*}
     */

  }, {
    key: "getInstanceFromDefinition",
    value: function getInstanceFromDefinition(definition) {
      if (definition.factory) {
        return this._getInstanceFromFactory(definition);
      }

      if (!definition.synthetic) {
        return this._getNotSyntheticInstanceFromDefinition(definition);
      }
    }
    /**
     * @param {Definition} definition
     * @return {*}
     * @private
     */

  }, {
    key: "_getNotSyntheticInstanceFromDefinition",
    value: function _getNotSyntheticInstanceFromDefinition(definition) {
      var args = this._resolveArguments(definition.args);

      if (definition.parent) {
        args = this._appendParentArgumentsFromDefinition(definition, args);
      }

      var instance = _construct(definition.Object, _toConsumableArray(args));

      var _iterator = _createForOfIteratorHelper(definition.properties),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          instance[key] = this._resolveServices(value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(definition.calls),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var call = _step2.value;

          this._callMethod(instance, call);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return instance;
    }
    /**
     * @param {Definition} definition
     * @returns {*}
     *
     * @private
     */

  }, {
    key: "_getInstanceFromFactory",
    value: function _getInstanceFromFactory(definition) {
      var _definition$factory$O;

      var args = this._resolveArguments(definition.args);

      if (definition.factory.Object instanceof _Reference["default"]) {
        var _factoryService$const;

        var factoryService = this._containerBuilder.get(definition.factory.Object.id);

        return (_factoryService$const = factoryService.constructor)[definition.factory.method].apply(_factoryService$const, _toConsumableArray(args));
      }

      return (_definition$factory$O = definition.factory.Object)[definition.factory.method].apply(_definition$factory$O, _toConsumableArray(args));
    }
    /**
     * @param {Array} args
     * @returns {Array}
     *
     * @private
     */

  }, {
    key: "_resolveArguments",
    value: function _resolveArguments() {
      var _this = this;

      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var resolvedArgument = [];
      args.forEach(function (argument) {
        resolvedArgument.push(_this._resolveServices(argument));
      });
      return resolvedArgument;
    }
    /**
     * @param {Definition} definition
     * @param {Array} args
     * @return {Array}
     * @private
     */

  }, {
    key: "_appendParentArgumentsFromDefinition",
    value: function _appendParentArgumentsFromDefinition(definition) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var parentDefinition = this._definitions.get(definition.parent);

      if (!parentDefinition["abstract"]) {
        throw new _NotAbstractServiceException["default"](definition.parent);
      }

      return args.concat(this._resolveArguments(parentDefinition.appendArgs));
    }
    /**
     * @param {Reference|PackageReference|*} value
     * @returns {*}
     *
     * @private
     */

  }, {
    key: "_resolveServices",
    value: function _resolveServices(value) {
      if (value instanceof _Reference["default"]) {
        if (!value.nullable || value.nullable && this._containerBuilder.hasDefinition(value.id)) {
          return this.getInstance(value.id, true);
        }
      } else if (value instanceof _PackageReference["default"]) {
        return __webpack_require__("../../../../node_modules/node-dependency-injection/dist/lib sync recursive")(value.id);
      } else if (value instanceof _TagReference["default"]) {
        return this._findTaggedServices(value.name);
      } else {
        return value;
      }

      return null;
    }
  }, {
    key: "_findTaggedServices",
    value: function _findTaggedServices(tagName) {
      var taggedServices = [];

      var _iterator3 = _createForOfIteratorHelper(this._definitions),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              id = _step3$value[0],
              definition = _step3$value[1];

          if (definition.tags.some(function (tag) {
            return tag.name === tagName;
          })) {
            var serviceInstance = this.getInstance(id);
            taggedServices.push(serviceInstance);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return taggedServices;
    }
    /**
     * @param {*} service
     * @param {{method, args}} call
     *
     * @private
     */

  }, {
    key: "_callMethod",
    value: function _callMethod(service, call) {
      if (typeof service[call.method] !== 'function') {
        throw new _MethodCallNotFoundException["default"](call.method);
      }

      var args = this._resolveArguments(call.args);

      service[call.method].apply(service, _toConsumableArray(args));
    }
  }]);

  return InstanceManager;
}();

exports["default"] = InstanceManager;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/FileLoader.js":
/*!****************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Loader/FileLoader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _path = _interopRequireDefault(__webpack_require__(/*! path */ "path"));

var _Reference = _interopRequireDefault(__webpack_require__(/*! ./../Reference */ "../../../../node_modules/node-dependency-injection/dist/lib/Reference.js"));

var _PackageReference = _interopRequireDefault(__webpack_require__(/*! ./../PackageReference */ "../../../../node_modules/node-dependency-injection/dist/lib/PackageReference.js"));

var _TagReference = _interopRequireDefault(__webpack_require__(/*! ./../TagReference */ "../../../../node_modules/node-dependency-injection/dist/lib/TagReference.js"));

var _Definition = _interopRequireDefault(__webpack_require__(/*! ./../Definition */ "../../../../node_modules/node-dependency-injection/dist/lib/Definition.js"));

var _validateNpmPackageName = _interopRequireDefault(__webpack_require__(/*! validate-npm-package-name */ "../../../../node_modules/validate-npm-package-name/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FileLoader = /*#__PURE__*/function () {
  /**
   * @param {ContainerBuilder} container
   */
  function FileLoader(container) {
    _classCallCheck(this, FileLoader);

    this._container = container;
  }
  /**
   * @returns {ContainerBuilder}
   */


  _createClass(FileLoader, [{
    key: "container",
    get: function get() {
      return this._container;
    }
    /**
     * @returns {string}
     */

  }, {
    key: "filePath",
    get: function get() {
      return this._filePath;
    }
    /**
     * @param {string} value
     */
    ,
    set: function set(value) {
      this._filePath = value;
    }
    /**
     * @param {*} attributes
     * @returns Map
     * @private
     */

  }, {
    key: "_checkFile",
    value:
    /**
     * @param {string} file
     * @protected
     */
    function _checkFile(file) {
      this.filePath = file;
    }
    /**
     * @param {Array<*>} services
     *
     * @protected
     */

  }, {
    key: "_parseDefinitions",
    value: function _parseDefinitions() {
      var services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (var id in services) {
        this._parseDefinition(services, id);
      }
    }
    /**
     * @param {*} services
     * @param {string} id
     * @private
     */

  }, {
    key: "_parseDefinition",
    value: function _parseDefinition(services, id) {
      var service = services[id];

      if (typeof service === 'string') {
        this.container.setAlias(id, service.slice(1));
      } else if (service.factory) {
        this.container.setDefinition(id, this._getFactoryDefinition(service));
      } else {
        this.container.setDefinition(id, this._getDefinition(service));
      }
    }
    /**
     * @param {*} service
     * @returns {Definition}
     * @private
     */

  }, {
    key: "_getFactoryDefinition",
    value: function _getFactoryDefinition(service) {
      var object = null;

      if (service.factory["class"].includes('@', 0)) {
        object = new _Reference["default"](service.factory["class"].slice(1));
      } else {
        object = this._requireClassNameFromPath(service.factory["class"]);
      }

      var definition = new _Definition["default"]();
      definition.shared = service.shared;
      definition.setFactory(object, service.factory.method);
      definition.args = this._getParsedArguments(service.arguments);
      return definition;
    }
    /**
     * @param {*} service
     * @returns {Definition}
     * @private
     */

  }, {
    key: "_getDefinition",
    value: function _getDefinition(service) {
      var definition;

      if (!service.synthetic) {
        var object = this._requireClassNameFromPath(service["class"], service.main);

        definition = new _Definition["default"](object);
        definition.lazy = service.lazy || false;
        definition["public"] = service["public"] !== false;
        definition["abstract"] = service["abstract"] || false;
        definition.parent = service.parent;
        definition.decoratedService = service.decorates;
        definition.decorationPriority = service.decoration_priority;
        definition.deprecated = service.deprecated;
        definition.shared = service.shared;

        this._parseArguments(definition, service.arguments);

        this._parseProperties(definition, service.properties);

        this._parseCalls(definition, service.calls);

        this._parseTags(definition, service.tags);
      } else {
        definition = new _Definition["default"]();
        definition.synthetic = true;
      }

      return definition;
    }
    /**
     * @param {Definition} definition
     * @param {Array} calls
     * @private
     */

  }, {
    key: "_parseCalls",
    value: function _parseCalls(definition) {
      var _this = this;

      var calls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      calls.forEach(function (call) {
        definition.addMethodCall(call.method, _this._getParsedArguments(call.arguments));
      });
    }
    /**
     * @param {Definition} definition
     * @param {Array} tags
     * @private
     */

  }, {
    key: "_parseTags",
    value: function _parseTags(definition) {
      var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      tags.forEach(function (tag) {
        definition.addTag(tag.name, FileLoader._parseTagAttributes(tag.attributes));
      });
    }
    /**
     * @param {Array} args
     * @returns {Array}
     * @private
     */

  }, {
    key: "_getParsedArguments",
    value: function _getParsedArguments() {
      var _this2 = this;

      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var parsedArguments = [];
      args.forEach(function (argument) {
        parsedArguments.push(_this2._parseArgument(argument));
      });
      return parsedArguments;
    }
    /**
     * @param {Definition} definition
     * @param {Object} properties
     * @private
     */

  }, {
    key: "_parseProperties",
    value: function _parseProperties(definition) {
      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      for (var propertyKey in properties) {
        definition.addProperty(propertyKey, this._parseArgument(properties[propertyKey]));
      }
    }
    /**
     * @param {Array<{resource}>} imports
     *
     * @protected
     */

  }, {
    key: "_parseImports",
    value: function _parseImports() {
      var imports = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var _iterator = _createForOfIteratorHelper(imports),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var file = _step.value;
          var workingPath = this.filePath;
          this.load(_path["default"].join(_path["default"].dirname(this.filePath), file.resource));
          this.filePath = workingPath;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * @param {*} parameters
     *
     * @protected
     */

  }, {
    key: "_parseParameters",
    value: function _parseParameters() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var key in parameters) {
        this._container.setParameter(key, parameters[key]);
      }
    }
    /**
     * @param {Definition} definition
     * @param {Array} args
     *
     * @private
     */

  }, {
    key: "_parseArguments",
    value: function _parseArguments(definition) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var argument = definition["abstract"] ? 'appendArgs' : 'args';
      definition[argument] = this._getParsedArguments(args);
    }
    /**
     * @param {string} argument
     * @returns {*}
     *
     * @private
     */

  }, {
    key: "_parseArgument",
    value: function _parseArgument(argument) {
      if (typeof argument === 'boolean') {
        return argument;
      }

      if (argument.slice(0, 2) === '@?') {
        return new _Reference["default"](argument.slice(2), true);
      } else if (argument.slice(0, 1) === '@') {
        return new _Reference["default"](argument.slice(1));
      } else if (argument.slice(0, 1) === '%' && argument.slice(-1) === '%') {
        return this._getArgumentParameter(argument);
      } else if (argument.slice(0, 1) === '%') {
        return new _PackageReference["default"](argument.slice(1));
      } else if (argument.slice(0, 7) === '!tagged') {
        return new _TagReference["default"](argument.slice(8));
      }

      return argument;
    }
    /**
     * @param {string} argument
     * @returns {*}
     *
     * @private
     */

  }, {
    key: "_getArgumentParameter",
    value: function _getArgumentParameter(argument) {
      if (argument.slice(1, 4) === 'env') {
        return process.env[argument.slice(5, -2)];
      } else {
        return this._container.getParameter(argument.slice(1, -1));
      }
    }
    /**
     * @param {string} classObject
     * @param {string} mainClassName
     * @returns {*}
     *
     * @private
     */

  }, {
    key: "_requireClassNameFromPath",
    value: function _requireClassNameFromPath(classObject, mainClassName) {
      var fromDirectory = !_path["default"].isAbsolute(classObject) ? _path["default"].dirname(this.filePath) : '/';
      fromDirectory = this.container.defaultDir || fromDirectory;
      var exportedModule = null;

      try {
        exportedModule = __webpack_require__("../../../../node_modules/node-dependency-injection/dist/lib/Loader sync recursive")(_path["default"].join(fromDirectory, classObject));
      } catch (error) {
        // If the path is a valid npm package name,
        // try to import a global package.
        if (error.code === 'MODULE_NOT_FOUND' && (0, _validateNpmPackageName["default"])(classObject)) {
          exportedModule = __webpack_require__("../../../../node_modules/node-dependency-injection/dist/lib/Loader sync recursive")(classObject);
        } else {
          throw error;
        }
      }

      var mainClass = exportedModule[mainClassName];
      var defaultClass = exportedModule["default"];

      var fileNameClass = exportedModule[_path["default"].basename(classObject)];

      return mainClass || defaultClass || fileNameClass || exportedModule;
    }
  }], [{
    key: "_parseTagAttributes",
    value: function _parseTagAttributes(attributes) {
      var map = new Map();

      if (attributes) {
        for (var _i = 0, _Object$keys = Object.keys(attributes); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          map.set(key, attributes[key]);
        }
      }

      return map;
    }
  }]);

  return FileLoader;
}();

var _default = FileLoader;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsFileLoader.js":
/*!******************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsFileLoader.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _FileLoader2 = _interopRequireDefault(__webpack_require__(/*! ./FileLoader */ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/FileLoader.js"));

var _ConfigurationFileNotFoundException = _interopRequireDefault(__webpack_require__(/*! ../Exception/ConfigurationFileNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ConfigurationFileNotFoundException.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var JsFileLoader = /*#__PURE__*/function (_FileLoader) {
  _inherits(JsFileLoader, _FileLoader);

  var _super = _createSuper(JsFileLoader);

  function JsFileLoader() {
    _classCallCheck(this, JsFileLoader);

    return _super.apply(this, arguments);
  }

  _createClass(JsFileLoader, [{
    key: "load",
    value:
    /**
     * @param {string|null} file
     */
    function load() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(JsFileLoader.prototype), "_checkFile", this).call(this, file);

      var content;

      try {
        content = __webpack_require__("../../../../node_modules/node-dependency-injection/dist/lib/Loader sync recursive")(this.filePath);
      } catch (e) {
        throw new _ConfigurationFileNotFoundException["default"](this.filePath);
      }

      this._parseImports(content.imports);

      this._parseParameters(content.parameters);

      this._parseDefinitions(content.services);
    }
  }]);

  return JsFileLoader;
}(_FileLoader2["default"]);

var _default = JsFileLoader;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsonFileLoader.js":
/*!********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsonFileLoader.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _JsFileLoader2 = _interopRequireDefault(__webpack_require__(/*! ./JsFileLoader */ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsFileLoader.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var JsonFileLoader = /*#__PURE__*/function (_JsFileLoader) {
  _inherits(JsonFileLoader, _JsFileLoader);

  var _super = _createSuper(JsonFileLoader);

  function JsonFileLoader() {
    _classCallCheck(this, JsonFileLoader);

    return _super.apply(this, arguments);
  }

  return JsonFileLoader;
}(_JsFileLoader2["default"]);

var _default = JsonFileLoader;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/YamlFileLoader.js":
/*!********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Loader/YamlFileLoader.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _FileLoader2 = _interopRequireDefault(__webpack_require__(/*! ./FileLoader */ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/FileLoader.js"));

var _jsYaml = _interopRequireDefault(__webpack_require__(/*! js-yaml */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/index.js"));

var fs = _interopRequireWildcard(__webpack_require__(/*! fs */ "fs"));

var _ServiceFileNotFoundException = _interopRequireDefault(__webpack_require__(/*! ../Exception/ServiceFileNotFoundException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceFileNotFoundException.js"));

var _ServiceFileNotLoadedException = _interopRequireDefault(__webpack_require__(/*! ../Exception/ServiceFileNotLoadedException */ "../../../../node_modules/node-dependency-injection/dist/lib/Exception/ServiceFileNotLoadedException.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var YamlFileLoader = /*#__PURE__*/function (_FileLoader) {
  _inherits(YamlFileLoader, _FileLoader);

  var _super = _createSuper(YamlFileLoader);

  function YamlFileLoader() {
    _classCallCheck(this, YamlFileLoader);

    return _super.apply(this, arguments);
  }

  _createClass(YamlFileLoader, [{
    key: "load",
    value:
    /**
     * @param {string|null} file
     */
    function load() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(YamlFileLoader.prototype), "_checkFile", this).call(this, file);

      var rawContent;

      try {
        rawContent = fs.readFileSync(this.filePath);
      } catch (e) {
        throw new _ServiceFileNotFoundException["default"](this.filePath);
      }

      var content;

      try {
        content = _jsYaml["default"].load(rawContent);
      } catch (e) {
        throw new _ServiceFileNotLoadedException["default"](e.message);
      }

      this._parseImports(content.imports);

      this._parseParameters(content.parameters);

      this._parseDefinitions(content.services);
    }
  }]);

  return YamlFileLoader;
}(_FileLoader2["default"]);

var _default = YamlFileLoader;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Loader sync recursive":
/*!********************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Loader/ sync ***!
  \********************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../../../node_modules/node-dependency-injection/dist/lib/Loader sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/PackageReference.js":
/*!***************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/PackageReference.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PackageReference = /*#__PURE__*/function () {
  /**
   * @param {string} id
   */
  function PackageReference(id) {
    _classCallCheck(this, PackageReference);

    this._id = id;
  }
  /**
   * @returns {string}
   */


  _createClass(PackageReference, [{
    key: "id",
    get: function get() {
      return this._id;
    }
  }]);

  return PackageReference;
}();

var _default = PackageReference;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/PassConfig.js":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/PassConfig.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PassConfig = /*#__PURE__*/function () {
  function PassConfig() {
    _classCallCheck(this, PassConfig);
  }

  _createClass(PassConfig, null, [{
    key: "TYPE_BEFORE_OPTIMIZATION",
    get:
    /**
     * @returns {string}
     */
    function get() {
      return 'beforeOptimization';
    }
    /**
     * @returns {string}
     */

  }, {
    key: "TYPE_OPTIMIZE",
    get: function get() {
      return 'optimize';
    }
    /**
     * @returns {string}
     */

  }, {
    key: "TYPE_BEFORE_REMOVING",
    get: function get() {
      return 'beforeRemoving';
    }
    /**
     * @returns {string}
     */

  }, {
    key: "TYPE_REMOVE",
    get: function get() {
      return 'remove';
    }
    /**
     * @returns {string}
     */

  }, {
    key: "TYPE_AFTER_REMOVING",
    get: function get() {
      return 'afterRemoving';
    }
    /**
     * @param {string} type
     * @returns {boolean}
     */

  }, {
    key: "isValidType",
    value: function isValidType(type) {
      return this.TYPE_BEFORE_OPTIMIZATION === type || this.TYPE_OPTIMIZE === type || this.TYPE_BEFORE_REMOVING === type || this.TYPE_REMOVE === type || this.TYPE_AFTER_REMOVING === type;
    }
  }]);

  return PassConfig;
}();

exports["default"] = PassConfig;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/Reference.js":
/*!********************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/Reference.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Reference = /*#__PURE__*/function () {
  /**
   * @param {string} id
   * @param {boolean} nullable
   */
  function Reference(id) {
    var nullable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, Reference);

    this._id = id;
    this._nullable = nullable;
  }
  /**
   * @returns {string}
   */


  _createClass(Reference, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "nullable",
    get: function get() {
      return this._nullable;
    }
  }]);

  return Reference;
}();

var _default = Reference;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/TagReference.js":
/*!***********************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/TagReference.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TagReference = /*#__PURE__*/function () {
  /**
   * @param {string} name
   */
  function TagReference(name) {
    _classCallCheck(this, TagReference);

    this._name = name;
  }
  /**
   * @returns {string}
   */


  _createClass(TagReference, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }]);

  return TagReference;
}();

var _default = TagReference;
exports["default"] = _default;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib/index.js":
/*!****************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ContainerBuilder", ({
  enumerable: true,
  get: function get() {
    return _ContainerBuilder["default"];
  }
}));
Object.defineProperty(exports, "JsFileLoader", ({
  enumerable: true,
  get: function get() {
    return _JsFileLoader["default"];
  }
}));
Object.defineProperty(exports, "JsonFileLoader", ({
  enumerable: true,
  get: function get() {
    return _JsonFileLoader["default"];
  }
}));
Object.defineProperty(exports, "YamlFileLoader", ({
  enumerable: true,
  get: function get() {
    return _YamlFileLoader["default"];
  }
}));
Object.defineProperty(exports, "PackageReference", ({
  enumerable: true,
  get: function get() {
    return _PackageReference["default"];
  }
}));
Object.defineProperty(exports, "Reference", ({
  enumerable: true,
  get: function get() {
    return _Reference["default"];
  }
}));
Object.defineProperty(exports, "PassConfig", ({
  enumerable: true,
  get: function get() {
    return _PassConfig["default"];
  }
}));
Object.defineProperty(exports, "Definition", ({
  enumerable: true,
  get: function get() {
    return _Definition["default"];
  }
}));
Object.defineProperty(exports, "TagReference", ({
  enumerable: true,
  get: function get() {
    return _TagReference["default"];
  }
}));

var _ContainerBuilder = _interopRequireDefault(__webpack_require__(/*! ./ContainerBuilder */ "../../../../node_modules/node-dependency-injection/dist/lib/ContainerBuilder.js"));

var _JsFileLoader = _interopRequireDefault(__webpack_require__(/*! ./Loader/JsFileLoader */ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsFileLoader.js"));

var _JsonFileLoader = _interopRequireDefault(__webpack_require__(/*! ./Loader/JsonFileLoader */ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/JsonFileLoader.js"));

var _YamlFileLoader = _interopRequireDefault(__webpack_require__(/*! ./Loader/YamlFileLoader */ "../../../../node_modules/node-dependency-injection/dist/lib/Loader/YamlFileLoader.js"));

var _PackageReference = _interopRequireDefault(__webpack_require__(/*! ./PackageReference */ "../../../../node_modules/node-dependency-injection/dist/lib/PackageReference.js"));

var _Reference = _interopRequireDefault(__webpack_require__(/*! ./Reference */ "../../../../node_modules/node-dependency-injection/dist/lib/Reference.js"));

var _PassConfig = _interopRequireDefault(__webpack_require__(/*! ./PassConfig */ "../../../../node_modules/node-dependency-injection/dist/lib/PassConfig.js"));

var _Definition = _interopRequireDefault(__webpack_require__(/*! ./Definition */ "../../../../node_modules/node-dependency-injection/dist/lib/Definition.js"));

var _TagReference = _interopRequireDefault(__webpack_require__(/*! ./TagReference */ "../../../../node_modules/node-dependency-injection/dist/lib/TagReference.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/dist/lib sync recursive":
/*!*************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/dist/lib/ sync ***!
  \*************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../../../node_modules/node-dependency-injection/dist/lib sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/index.js":
/*!****************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/index.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var loader = __webpack_require__(/*! ./lib/loader */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/loader.js");
var dumper = __webpack_require__(/*! ./lib/dumper */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/dumper.js");


function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
      'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}


module.exports.Type = __webpack_require__(/*! ./lib/type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");
module.exports.Schema = __webpack_require__(/*! ./lib/schema */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema.js");
module.exports.FAILSAFE_SCHEMA = __webpack_require__(/*! ./lib/schema/failsafe */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/failsafe.js");
module.exports.JSON_SCHEMA = __webpack_require__(/*! ./lib/schema/json */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/json.js");
module.exports.CORE_SCHEMA = __webpack_require__(/*! ./lib/schema/core */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/core.js");
module.exports.DEFAULT_SCHEMA = __webpack_require__(/*! ./lib/schema/default */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/default.js");
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.dump                = dumper.dump;
module.exports.YAMLException = __webpack_require__(/*! ./lib/exception */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js");

// Re-export all types in case user wants to create custom schema
module.exports.types = {
  binary:    __webpack_require__(/*! ./lib/type/binary */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/binary.js"),
  float:     __webpack_require__(/*! ./lib/type/float */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/float.js"),
  map:       __webpack_require__(/*! ./lib/type/map */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/map.js"),
  null:      __webpack_require__(/*! ./lib/type/null */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/null.js"),
  pairs:     __webpack_require__(/*! ./lib/type/pairs */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/pairs.js"),
  set:       __webpack_require__(/*! ./lib/type/set */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/set.js"),
  timestamp: __webpack_require__(/*! ./lib/type/timestamp */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/timestamp.js"),
  bool:      __webpack_require__(/*! ./lib/type/bool */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/bool.js"),
  int:       __webpack_require__(/*! ./lib/type/int */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/int.js"),
  merge:     __webpack_require__(/*! ./lib/type/merge */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/merge.js"),
  omap:      __webpack_require__(/*! ./lib/type/omap */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/omap.js"),
  seq:       __webpack_require__(/*! ./lib/type/seq */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/seq.js"),
  str:       __webpack_require__(/*! ./lib/type/str */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/str.js")
};

// Removed functions from JS-YAML 3.0.x
module.exports.safeLoad            = renamed('safeLoad', 'load');
module.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');
module.exports.safeDump            = renamed('safeDump', 'dump');


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js":
/*!*********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/dumper.js":
/*!*********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/dumper.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js");
var DEFAULT_SCHEMA      = __webpack_require__(/*! ./schema/default */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/default.js");

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || DEFAULT_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out
//                             c = flow-in    ns-plain-safe-in
//                             c = block-key  ns-plain-safe-out
//                             c = flow-key   ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )
//                            | ( /* An ns-char preceding */ # )
//                            | ( : /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | = | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | `)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -
      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #
      //                         | ; | / | ? | : | @ | & | = | + | $ | ,
      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

module.exports.dump = dump;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js":
/*!************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//



function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


module.exports = YAMLException;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/loader.js":
/*!*********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/loader.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js");
var makeSnippet         = __webpack_require__(/*! ./snippet */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/snippet.js");
var DEFAULT_SCHEMA      = __webpack_require__(/*! ./schema/default */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/default.js");


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = makeSnippet(mark);

  return new YAMLException(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


module.exports.loadAll = loadAll;
module.exports.load    = load;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema.js":
/*!*********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable max-len*/

var YAMLException = __webpack_require__(/*! ./exception */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js");
var Type          = __webpack_require__(/*! ./type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");


function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  return this.extend(definition);
}


Schema.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof Type) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type) {
    if (!(type instanceof Type)) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type.multi) {
      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type) {
    if (!(type instanceof Type)) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


module.exports = Schema;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/core.js":
/*!**************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/core.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





module.exports = __webpack_require__(/*! ./json */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/json.js");


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/default.js":
/*!*****************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/default.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





module.exports = (__webpack_require__(/*! ./core */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/core.js").extend)({
  implicit: [
    __webpack_require__(/*! ../type/timestamp */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/timestamp.js"),
    __webpack_require__(/*! ../type/merge */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/merge.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/binary */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/binary.js"),
    __webpack_require__(/*! ../type/omap */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/omap.js"),
    __webpack_require__(/*! ../type/pairs */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/pairs.js"),
    __webpack_require__(/*! ../type/set */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/set.js")
  ]
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/failsafe.js":
/*!******************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/failsafe.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(/*! ../schema */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema.js");


module.exports = new Schema({
  explicit: [
    __webpack_require__(/*! ../type/str */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/str.js"),
    __webpack_require__(/*! ../type/seq */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/seq.js"),
    __webpack_require__(/*! ../type/map */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/map.js")
  ]
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/json.js":
/*!**************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/json.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





module.exports = (__webpack_require__(/*! ./failsafe */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/schema/failsafe.js").extend)({
  implicit: [
    __webpack_require__(/*! ../type/null */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/null.js"),
    __webpack_require__(/*! ../type/bool */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/bool.js"),
    __webpack_require__(/*! ../type/int */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/int.js"),
    __webpack_require__(/*! ../type/float */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/float.js")
  ]
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/snippet.js":
/*!**********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/snippet.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var common = __webpack_require__(/*! ./common */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js");


// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}


function makeSnippet(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


module.exports = makeSnippet;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js":
/*!*******************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var YAMLException = __webpack_require__(/*! ./exception */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/exception.js");

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/binary.js":
/*!**************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/binary.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable no-bitwise*/


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/bool.js":
/*!************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/bool.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/float.js":
/*!*************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/float.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(/*! ../common */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js");
var Type   = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/int.js":
/*!***********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/int.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(/*! ../common */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/common.js");
var Type   = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/map.js":
/*!***********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/map.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/merge.js":
/*!*************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/merge.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/null.js":
/*!************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/null.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/omap.js":
/*!************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/omap.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/pairs.js":
/*!*************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/pairs.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/seq.js":
/*!***********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/seq.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/set.js":
/*!***********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/set.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/str.js":
/*!***********************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/str.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),

/***/ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/timestamp.js":
/*!*****************************************************************************************************!*\
  !*** ../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type/timestamp.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(/*! ../type */ "../../../../node_modules/node-dependency-injection/node_modules/js-yaml/lib/type.js");

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),

/***/ "../../../../node_modules/sax/lib/sax.js":
/*!***********************************************!*\
  !*** ../../../../node_modules/sax/lib/sax.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = (__webpack_require__(/*! stream */ "stream").Stream)
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = (__webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder)
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // character classes and tokens
  var whitespace = '\r\n\t '

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var number = '0124356789'
  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

  // (Letter | "_" | ":")
  var quote = '\'"'
  var attribEnd = whitespace + '>'
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // turn all the string character sets into character class objects.
  whitespace = charClass(whitespace)
  number = charClass(number)
  letter = charClass(letter)

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  quote = charClass(quote)
  attribEnd = charClass(attribEnd)

  function charClass (str) {
    return str.split('').reduce(function (s, c) {
      s[c] = true
      return s
    }, {})
  }

  function isRegExp (c) {
    return Object.prototype.toString.call(c) === '[object RegExp]'
  }

  function is (charclass, c) {
    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
  }

  function not (charclass, c) {
    return !is(charclass, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (not(whitespace, c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c
      if (!c) {
        break
      }
      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }
      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (is(whitespace, c)) {
            // wait for it...
          } else if (is(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (is(quote, c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (is(quote, c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (is(quote, c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (is(whitespace, c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && is(whitespace, c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (is(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (not(whitespace, c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (is(whitespace, c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (is(whitespace, c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (is(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (is(whitespace, c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (is(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (is(whitespace, c)) {
            continue
          } else if (is(quote, c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (is(whitespace, c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (not(attribEnd, c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (is(whitespace, c)) {
              continue
            } else if (not(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (is(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (not(whitespace, c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (is(whitespace, c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? 0 : exports)


/***/ }),

/***/ "./lambda/post-controller/dependencies.di.ts":
/*!***************************************************!*\
  !*** ./lambda/post-controller/dependencies.di.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CREATE_DEFINITIONS = exports.register = void 0;
const node_dependency_injection_1 = __webpack_require__(/*! node-dependency-injection */ "../../../../node_modules/node-dependency-injection/dist/lib/index.js");
const CommerceCreator_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/app/create/CommerceCreator */ "../../../contexts/backoffice/commerces/app/create/CommerceCreator.ts"));
const DynamoCommerceRepository_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/infra/persistence/dynamodb/DynamoCommerceRepository */ "../../../contexts/backoffice/commerces/infra/persistence/dynamodb/DynamoCommerceRepository.ts"));
const dynamodb_1 = __webpack_require__(/*! aws-sdk/clients/dynamodb */ "../../../../node_modules/aws-sdk/clients/dynamodb.js");
const dependencies_di_1 = __webpack_require__(/*! ../shared/dependencies.di */ "./lambda/shared/dependencies.di.ts");
const CommerceCreatorHandler_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/app/create/CommerceCreatorHandler */ "../../../contexts/backoffice/commerces/app/create/CommerceCreatorHandler.ts"));
const CREATE_DEFINITIONS = {
    CommerceCreator: "CommerceCreator",
    CommerceRepository: "CommerceRepository",
    Handler: "CommerceCreatorHandler"
}, register = (container) => {
    container
        .register(CREATE_DEFINITIONS.CommerceRepository, DynamoCommerceRepository_1.default)
        .addArgument(new dynamodb_1.DocumentClient())
        .addArgument(process.env.TABLE_NAME)
        .addArgument("emailIndex");
    container
        .register(CREATE_DEFINITIONS.CommerceCreator, CommerceCreator_1.default)
        .addArgument(new node_dependency_injection_1.Reference(CREATE_DEFINITIONS.CommerceRepository))
        .addArgument(new node_dependency_injection_1.Reference(dependencies_di_1.DEFINITIONS.MemoryBuses.EventBus));
    const definition = new node_dependency_injection_1.Definition(CommerceCreatorHandler_1.default);
    definition.addArgument(new node_dependency_injection_1.Reference(CREATE_DEFINITIONS.CommerceCreator));
    definition.addTag(dependencies_di_1.DEFINITIONS.Tags.CommandHandler);
    container.setDefinition(CREATE_DEFINITIONS.Handler, definition);
};
exports.CREATE_DEFINITIONS = CREATE_DEFINITIONS;
exports.register = register;


/***/ }),

/***/ "./lambda/post-controller/handler.ts":
/*!*******************************************!*\
  !*** ./lambda/post-controller/handler.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handler = void 0;
const core_1 = __importDefault(__webpack_require__(/*! @middy/core */ "../../../../node_modules/@middy/core/index.js"));
const http_cors_1 = __importDefault(__webpack_require__(/*! @middy/http-cors */ "../../../../node_modules/@middy/http-cors/index.js"));
const dependencies_di_1 = __webpack_require__(/*! ../shared/dependencies.di */ "./lambda/shared/dependencies.di.ts");
const dependencies_di_2 = __webpack_require__(/*! ./dependencies.di */ "./lambda/post-controller/dependencies.di.ts");
const node_dependency_injection_1 = __webpack_require__(/*! node-dependency-injection */ "../../../../node_modules/node-dependency-injection/dist/lib/index.js");
const CreateCommerceCommand_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/app/create/CreateCommerceCommand */ "../../../contexts/backoffice/commerces/app/create/CreateCommerceCommand.ts"));
const AlreadyExists_1 = __importDefault(__webpack_require__(/*! @shared/domain/AlreadyExists */ "../../../contexts/shared/domain/AlreadyExists.ts"));
const console = __importStar(__webpack_require__(/*! console */ "console"));
const container = new node_dependency_injection_1.ContainerBuilder();
(0, dependencies_di_1.register)(container);
(0, dependencies_di_2.register)(container);
const logger = container.get(dependencies_di_1.DEFINITIONS.Logger), handlerCreator = container.get(dependencies_di_2.CREATE_DEFINITIONS.Handler), execute = async (event, _context) => {
    logger.info(`REQUEST PATH: ${event.path}`);
    logger.info(`REQUEST BODY: ${event.body}`);
    try {
        const { name, email, description, address, id, phone } = JSON.parse(event.body), createCommerceCommand = new CreateCommerceCommand_1.default(id, name, email, description, phone, address), commerce = await handlerCreator.handle(createCommerceCommand);
        return {
            statusCode: 200,
            body: JSON.stringify(commerce.data.toPrimitives())
        };
    }
    catch (e) {
        console.info(e);
        if (e instanceof AlreadyExists_1.default) {
            return {
                statusCode: 400,
                body: e.message
            };
        }
        else {
            return {
                statusCode: 500,
                body: "Internal server error"
            };
        }
    }
};
exports.handler = (0, core_1.default)(execute)
    .use((0, http_cors_1.default)());


/***/ }),

/***/ "./lambda/shared/dependencies.di.ts":
/*!******************************************!*\
  !*** ./lambda/shared/dependencies.di.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFINITIONS = exports.register = void 0;
const node_dependency_injection_1 = __webpack_require__(/*! node-dependency-injection */ "../../../../node_modules/node-dependency-injection/dist/lib/index.js");
const CommandHandlersInformation_1 = __importDefault(__webpack_require__(/*! @shared/infra/bus/command/CommandHandlersInformation */ "../../../contexts/shared/infra/bus/command/CommandHandlersInformation.ts"));
const InMemoryCommandBus_1 = __importDefault(__webpack_require__(/*! @shared/infra/bus/command/InMemoryCommandBus */ "../../../contexts/shared/infra/bus/command/InMemoryCommandBus.ts"));
const LoggerEventBus_1 = __importDefault(__webpack_require__(/*! @shared/infra/bus/event/LoggerEventBus */ "../../../contexts/shared/infra/bus/event/LoggerEventBus.ts"));
const ConsoleLogger_1 = __importDefault(__webpack_require__(/*! @shared/infra/ConsoleLogger */ "../../../contexts/shared/infra/ConsoleLogger.ts"));
const QueryHandlersInformation_1 = __importDefault(__webpack_require__(/*! @shared/infra/bus/query/QueryHandlersInformation */ "../../../contexts/shared/infra/bus/query/QueryHandlersInformation.ts"));
const InMemoryQueryBus_1 = __importDefault(__webpack_require__(/*! @shared/infra/bus/query/InMemoryQueryBus */ "../../../contexts/shared/infra/bus/query/InMemoryQueryBus.ts"));
const DEFINITIONS = {
    Logger: "Shared.Logger",
    DomainEventMapping: "Shared.DomainEventMapping",
    QueryHandlersInfo: "Shared.QueryHandlersInfo",
    CommandHandlersInfo: "Shared.CommandHandlersInfo",
    Tags: {
        EventHandler: "EventHandler",
        CommandHandler: "CommandHandler",
        QueryHandler: "QueryHandler"
    },
    MemoryBuses: {
        CommandBus: "Shared.CommandBus",
        QueryBus: "Shared.QueryBus",
        EventBus: "Shared.EventBus"
    }
}, register = (container) => {
    container.register(DEFINITIONS.Logger, ConsoleLogger_1.default);
    container
        .register(DEFINITIONS.QueryHandlersInfo, QueryHandlersInformation_1.default)
        .addArgument(new node_dependency_injection_1.TagReference(DEFINITIONS.Tags.QueryHandler));
    container
        .register(DEFINITIONS.MemoryBuses.QueryBus, InMemoryQueryBus_1.default)
        .addArgument(new node_dependency_injection_1.Reference(DEFINITIONS.QueryHandlersInfo));
    container
        .register(DEFINITIONS.CommandHandlersInfo, CommandHandlersInformation_1.default)
        .addArgument(new node_dependency_injection_1.TagReference(DEFINITIONS.Tags.CommandHandler));
    container
        .register(DEFINITIONS.MemoryBuses.CommandBus, InMemoryCommandBus_1.default)
        .addArgument(new node_dependency_injection_1.Reference(DEFINITIONS.CommandHandlersInfo));
    container.register(DEFINITIONS.MemoryBuses.EventBus, LoggerEventBus_1.default);
};
exports.DEFINITIONS = DEFINITIONS;
exports.register = register;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/app/create/CommerceCreator.ts":
/*!****************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/app/create/CommerceCreator.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Commerce_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/Commerce */ "../../../contexts/backoffice/commerces/domain/Commerce.ts"));
const AlreadyExists_1 = __importDefault(__webpack_require__(/*! @shared/domain/AlreadyExists */ "../../../contexts/shared/domain/AlreadyExists.ts"));
class CommerceCreator {
    constructor(repo, eventBus) {
        this.repo = repo;
        this.eventBus = eventBus;
    }
    async run(id, name, email, description, phone, address) {
        const commerce = Commerce_1.default.create(id, name, email, description, phone, address), [commerceByEmail, commerceById] = await Promise.all([
            this.repo.findByEmail(email),
            this.repo.findById(id)
        ]);
        if (commerceByEmail || commerceById) {
            throw new AlreadyExists_1.default("Commerce with id " + id + " or email " + email + " already exists");
        }
        await this.repo.save(commerce);
        await this.eventBus.publish(commerce.pullDomainEvents());
        return commerce;
    }
}
exports["default"] = CommerceCreator;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/app/create/CommerceCreatorHandler.ts":
/*!***********************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/app/create/CommerceCreatorHandler.ts ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const CreateCommerceCommand_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/app/create/CreateCommerceCommand */ "../../../contexts/backoffice/commerces/app/create/CreateCommerceCommand.ts"));
const CreateCommerceResponse_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/app/create/CreateCommerceResponse */ "../../../contexts/backoffice/commerces/app/create/CreateCommerceResponse.ts"));
const UuidVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/UuidVo */ "../../../contexts/shared/domain/UuidVo.ts"));
const CommerceNameVo_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/CommerceNameVo */ "../../../contexts/backoffice/commerces/domain/CommerceNameVo.ts"));
const EmailVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/EmailVo */ "../../../contexts/shared/domain/EmailVo.ts"));
const CommerceDescriptionVo_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/CommerceDescriptionVo */ "../../../contexts/backoffice/commerces/domain/CommerceDescriptionVo.ts"));
const PhoneVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/PhoneVo */ "../../../contexts/shared/domain/PhoneVo.ts"));
const AddressVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/AddressVo */ "../../../contexts/shared/domain/AddressVo.ts"));
class CommerceCreatorHandler {
    constructor(creator) {
        this.creator = creator;
    }
    async handle({ id, description, email, phone, name, address }) {
        const response = await this.creator.run(new UuidVo_1.default(id), new CommerceNameVo_1.default(name), new EmailVo_1.default(email), new CommerceDescriptionVo_1.default(description), new PhoneVo_1.default(phone), new AddressVo_1.default(address));
        return new CreateCommerceResponse_1.default(response);
    }
    subscribedTo() {
        return CreateCommerceCommand_1.default;
    }
}
exports["default"] = CommerceCreatorHandler;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/app/create/CreateCommerceCommand.ts":
/*!**********************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/app/create/CreateCommerceCommand.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class CreateCommerceCommand {
    constructor(id, name, email, description, phone, address) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.description = description;
        this.phone = phone;
        this.address = address;
    }
}
exports["default"] = CreateCommerceCommand;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/app/create/CreateCommerceResponse.ts":
/*!***********************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/app/create/CreateCommerceResponse.ts ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const CommandResponse_1 = __importDefault(__webpack_require__(/*! @shared/domain/bus/command/CommandResponse */ "../../../contexts/shared/domain/bus/command/CommandResponse.ts"));
class CreateCommerceResponse extends CommandResponse_1.default {
}
exports["default"] = CreateCommerceResponse;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/domain/Commerce.ts":
/*!*****************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/domain/Commerce.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Aggregate_1 = __importDefault(__webpack_require__(/*! @shared/domain/Aggregate */ "../../../contexts/shared/domain/Aggregate.ts"));
const UuidVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/UuidVo */ "../../../contexts/shared/domain/UuidVo.ts"));
const PhoneVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/PhoneVo */ "../../../contexts/shared/domain/PhoneVo.ts"));
const CommerceNameVo_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/CommerceNameVo */ "../../../contexts/backoffice/commerces/domain/CommerceNameVo.ts"));
const EmailVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/EmailVo */ "../../../contexts/shared/domain/EmailVo.ts"));
const CommerceDescriptionVo_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/CommerceDescriptionVo */ "../../../contexts/backoffice/commerces/domain/CommerceDescriptionVo.ts"));
const AddressVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/AddressVo */ "../../../contexts/shared/domain/AddressVo.ts"));
const CommerceCreatedEvent_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/CommerceCreatedEvent */ "../../../contexts/backoffice/commerces/domain/CommerceCreatedEvent.ts"));
class Commerce extends Aggregate_1.default {
    constructor(id, name, email, description, phone, address) {
        super();
        this.id = id;
        this.name = name;
        this.email = email;
        this.description = description;
        this.phone = phone;
        this.address = address;
    }
    static create(id, name, email, description, phone, address) {
        const commerce = new Commerce(id, name, email, description, phone, address);
        commerce.record(new CommerceCreatedEvent_1.default(commerce.toPrimitives()));
        return commerce;
    }
    static fromPrimitives({ address, phone, name, description, id, email }) {
        return new Commerce(new UuidVo_1.default(id), new CommerceNameVo_1.default(name), new EmailVo_1.default(email), new CommerceDescriptionVo_1.default(description), new PhoneVo_1.default(phone), new AddressVo_1.default(address));
    }
    toPrimitives() {
        return {
            id: this.id.value,
            name: this.name.value,
            email: this.email.value,
            description: this.description.value,
            phone: this.phone.value,
            address: this.address.value,
        };
    }
}
exports["default"] = Commerce;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/domain/CommerceCreatedEvent.ts":
/*!*****************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/domain/CommerceCreatedEvent.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const DomainEvent_1 = __webpack_require__(/*! @shared/domain/bus/event/DomainEvent */ "../../../contexts/shared/domain/bus/event/DomainEvent.ts");
class CommerceCreatedEvent extends DomainEvent_1.DomainEvent {
    constructor(body) {
        super(CommerceCreatedEvent.EVENT_NAME, body.id);
        this.body = body;
    }
    toPrimitives() {
        return this.body;
    }
}
exports["default"] = CommerceCreatedEvent;
CommerceCreatedEvent.EVENT_NAME = 'backoffice.commerces.CommerceCreatedEvent';


/***/ }),

/***/ "../../../contexts/backoffice/commerces/domain/CommerceDescriptionVo.ts":
/*!******************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/domain/CommerceDescriptionVo.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StringVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/StringVo */ "../../../contexts/shared/domain/StringVo.ts"));
class CommerceDescriptionVo extends StringVo_1.default {
}
exports["default"] = CommerceDescriptionVo;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/domain/CommerceNameVo.ts":
/*!***********************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/domain/CommerceNameVo.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StringVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/StringVo */ "../../../contexts/shared/domain/StringVo.ts"));
class CommerceNameVo extends StringVo_1.default {
}
exports["default"] = CommerceNameVo;


/***/ }),

/***/ "../../../contexts/backoffice/commerces/infra/persistence/dynamodb/DynamoCommerceRepository.ts":
/*!*****************************************************************************************************!*\
  !*** ../../../contexts/backoffice/commerces/infra/persistence/dynamodb/DynamoCommerceRepository.ts ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Commerce_1 = __importDefault(__webpack_require__(/*! @backoffice-contexts/commerces/domain/Commerce */ "../../../contexts/backoffice/commerces/domain/Commerce.ts"));
const composeKey = (id) => "commerce:" + id.toString();
class DynamoCommerceRepository {
    constructor(client, tableName, emailIndex) {
        this.client = client;
        this.tableName = tableName;
        this.emailIndex = emailIndex;
    }
    async findByEmail(email) {
        var _a;
        const resp = await this.client.query({
            TableName: this.tableName,
            IndexName: this.emailIndex,
            KeyConditionExpression: "email = :email",
            ExpressionAttributeValues: {
                ":email": email.value
            }
        })
            .promise();
        return ((_a = resp.Items) === null || _a === void 0 ? void 0 : _a.length) ? Commerce_1.default.fromPrimitives(Object.assign({}, resp.Items[0])) : null;
    }
    async findById(id) {
        const key = composeKey(id), resp = await this.client.get({
            TableName: this.tableName,
            Key: {
                partitionKey: key
            }
        })
            .promise();
        return resp.Item ? Commerce_1.default.fromPrimitives(Object.assign({}, resp.Item)) : null;
    }
    async save(commerce) {
        const key = composeKey(commerce.id);
        await this.client.put({
            TableName: this.tableName,
            Item: Object.assign({ partitionKey: key }, commerce.toPrimitives())
        })
            .promise();
    }
}
exports["default"] = DynamoCommerceRepository;


/***/ }),

/***/ "../../../contexts/shared/domain/AddressVo.ts":
/*!****************************************************!*\
  !*** ../../../contexts/shared/domain/AddressVo.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StringVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/StringVo */ "../../../contexts/shared/domain/StringVo.ts"));
class AddressVo extends StringVo_1.default {
}
exports["default"] = AddressVo;


/***/ }),

/***/ "../../../contexts/shared/domain/Aggregate.ts":
/*!****************************************************!*\
  !*** ../../../contexts/shared/domain/Aggregate.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Aggregate {
    constructor() {
        this.domainEvents = [];
    }
    pullDomainEvents() {
        const events = this.domainEvents;
        this.domainEvents = [];
        return events;
    }
    record(event) {
        this.domainEvents.push(event);
    }
}
exports["default"] = Aggregate;


/***/ }),

/***/ "../../../contexts/shared/domain/AlreadyExists.ts":
/*!********************************************************!*\
  !*** ../../../contexts/shared/domain/AlreadyExists.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AlreadyExists extends Error {
}
exports["default"] = AlreadyExists;


/***/ }),

/***/ "../../../contexts/shared/domain/EmailVo.ts":
/*!**************************************************!*\
  !*** ../../../contexts/shared/domain/EmailVo.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StringVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/StringVo */ "../../../contexts/shared/domain/StringVo.ts"));
class EmailVo extends StringVo_1.default {
}
exports["default"] = EmailVo;


/***/ }),

/***/ "../../../contexts/shared/domain/InvalidArgumentError.ts":
/*!***************************************************************!*\
  !*** ../../../contexts/shared/domain/InvalidArgumentError.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class InvalidArgumentError extends Error {
}
exports["default"] = InvalidArgumentError;


/***/ }),

/***/ "../../../contexts/shared/domain/PhoneVo.ts":
/*!**************************************************!*\
  !*** ../../../contexts/shared/domain/PhoneVo.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StringVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/StringVo */ "../../../contexts/shared/domain/StringVo.ts"));
class PhoneVo extends StringVo_1.default {
}
exports["default"] = PhoneVo;


/***/ }),

/***/ "../../../contexts/shared/domain/StringVo.ts":
/*!***************************************************!*\
  !*** ../../../contexts/shared/domain/StringVo.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ValueObject_1 = __importDefault(__webpack_require__(/*! @shared/domain/ValueObject */ "../../../contexts/shared/domain/ValueObject.ts"));
class StringVo extends ValueObject_1.default {
    toString() {
        return this.value.toString();
    }
}
exports["default"] = StringVo;


/***/ }),

/***/ "../../../contexts/shared/domain/UuidVo.ts":
/*!*************************************************!*\
  !*** ../../../contexts/shared/domain/UuidVo.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const InvalidArgumentError_1 = __importDefault(__webpack_require__(/*! @shared/domain/InvalidArgumentError */ "../../../contexts/shared/domain/InvalidArgumentError.ts"));
const StringVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/StringVo */ "../../../contexts/shared/domain/StringVo.ts"));
const uuid_1 = __webpack_require__(/*! uuid */ "../../../../node_modules/uuid/index.js");
const uuid_validate_1 = __importDefault(__webpack_require__(/*! uuid-validate */ "../../../../node_modules/uuid-validate/index.js"));
class UuidVo extends StringVo_1.default {
    constructor(value) {
        UuidVo.ensureIsValidUuid(value);
        super(value);
    }
    static random() {
        return new UuidVo((0, uuid_1.v4)());
    }
    static ensureIsValidUuid(id) {
        if (!(0, uuid_validate_1.default)(id)) {
            throw new InvalidArgumentError_1.default(`<${this.constructor.name}> does not allow the value <${id}>`);
        }
    }
    equalsTo(other) {
        return super.equalsTo(other);
    }
}
exports["default"] = UuidVo;


/***/ }),

/***/ "../../../contexts/shared/domain/ValueObject.ts":
/*!******************************************************!*\
  !*** ../../../contexts/shared/domain/ValueObject.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ValueObject {
    constructor(value) {
        this.value = value;
    }
    equalsTo(value) {
        return this.value === value.value;
    }
}
exports["default"] = ValueObject;


/***/ }),

/***/ "../../../contexts/shared/domain/bus/command/CommandNotRegistered.ts":
/*!***************************************************************************!*\
  !*** ../../../contexts/shared/domain/bus/command/CommandNotRegistered.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class CommandNotRegisteredError extends Error {
    constructor(command) {
        super(`The command <${command.constructor.name}> hasn't a command handler associated`);
    }
}
exports["default"] = CommandNotRegisteredError;


/***/ }),

/***/ "../../../contexts/shared/domain/bus/command/CommandResponse.ts":
/*!**********************************************************************!*\
  !*** ../../../contexts/shared/domain/bus/command/CommandResponse.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class CommandResponse {
    constructor(data) {
        this.data = data;
    }
}
exports["default"] = CommandResponse;


/***/ }),

/***/ "../../../contexts/shared/domain/bus/event/DomainEvent.ts":
/*!****************************************************************!*\
  !*** ../../../contexts/shared/domain/bus/event/DomainEvent.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomainEvent = void 0;
const UuidVo_1 = __importDefault(__webpack_require__(/*! @shared/domain/UuidVo */ "../../../contexts/shared/domain/UuidVo.ts"));
class DomainEvent {
    constructor(eventName, aggregateId, eventId, occurredOn) {
        this.aggregateId = aggregateId;
        this.eventId = eventId || UuidVo_1.default.random().value;
        this.occurredOn = occurredOn || new Date();
        this.eventName = eventName;
    }
}
exports.DomainEvent = DomainEvent;


/***/ }),

/***/ "../../../contexts/shared/domain/bus/query/QueryNotRegisteredError.ts":
/*!****************************************************************************!*\
  !*** ../../../contexts/shared/domain/bus/query/QueryNotRegisteredError.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class QueryNotRegisteredError extends Error {
    constructor(query) {
        super(`The query <${query.constructor.name}> hasn't a query handler associated`);
    }
}
exports["default"] = QueryNotRegisteredError;


/***/ }),

/***/ "../../../contexts/shared/infra/ConsoleLogger.ts":
/*!*******************************************************!*\
  !*** ../../../contexts/shared/infra/ConsoleLogger.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ConsoleLogger {
    debug(message) {
        console.debug(message);
    }
    error(message) {
        console.error(message);
    }
    info(message) {
        console.info(message);
    }
}
exports["default"] = ConsoleLogger;


/***/ }),

/***/ "../../../contexts/shared/infra/bus/command/CommandHandlersInformation.ts":
/*!********************************************************************************!*\
  !*** ../../../contexts/shared/infra/bus/command/CommandHandlersInformation.ts ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const CommandNotRegistered_1 = __importDefault(__webpack_require__(/*! @shared/domain/bus/command/CommandNotRegistered */ "../../../contexts/shared/domain/bus/command/CommandNotRegistered.ts"));
class CommandHandlersInformation {
    constructor(commandHandlers) {
        this.commandHandlersMap = this.formatHandlers(commandHandlers);
    }
    search(command) {
        const commandHandler = this.commandHandlersMap.get(command.constructor);
        if (!commandHandler) {
            throw new CommandNotRegistered_1.default(command);
        }
        return commandHandler;
    }
    formatHandlers(commandHandlers) {
        const handlersMap = new Map();
        commandHandlers.forEach((commandHandler) => {
            handlersMap.set(commandHandler.subscribedTo(), commandHandler);
        });
        return handlersMap;
    }
}
exports["default"] = CommandHandlersInformation;


/***/ }),

/***/ "../../../contexts/shared/infra/bus/command/InMemoryCommandBus.ts":
/*!************************************************************************!*\
  !*** ../../../contexts/shared/infra/bus/command/InMemoryCommandBus.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class InMemoryCommandBus {
    constructor(commandHandlersInformation) {
        this.commandHandlersInformation = commandHandlersInformation;
    }
    dispatch(command) {
        const handler = this.commandHandlersInformation.search(command);
        return handler.handle(command);
    }
}
exports["default"] = InMemoryCommandBus;


/***/ }),

/***/ "../../../contexts/shared/infra/bus/event/LoggerEventBus.ts":
/*!******************************************************************!*\
  !*** ../../../contexts/shared/infra/bus/event/LoggerEventBus.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class LoggerEventBus {
    async publish(events) {
        console.log("Events to be published:" + JSON.stringify(events));
    }
}
exports["default"] = LoggerEventBus;


/***/ }),

/***/ "../../../contexts/shared/infra/bus/query/InMemoryQueryBus.ts":
/*!********************************************************************!*\
  !*** ../../../contexts/shared/infra/bus/query/InMemoryQueryBus.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class InMemoryQueryBus {
    constructor(queryHandlersInformation) {
        this.queryHandlersInformation = queryHandlersInformation;
    }
    ask(query) {
        const handler = this.queryHandlersInformation.search(query);
        return handler.handle(query);
    }
}
exports["default"] = InMemoryQueryBus;


/***/ }),

/***/ "../../../contexts/shared/infra/bus/query/QueryHandlersInformation.ts":
/*!****************************************************************************!*\
  !*** ../../../contexts/shared/infra/bus/query/QueryHandlersInformation.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const QueryNotRegisteredError_1 = __importDefault(__webpack_require__(/*! @shared/domain/bus/query/QueryNotRegisteredError */ "../../../contexts/shared/domain/bus/query/QueryNotRegisteredError.ts"));
class QueryHandlersInformation {
    constructor(queryHandlers) {
        this.queryHandlersMap = this.formatHandlers(queryHandlers);
    }
    search(query) {
        const queryHandler = this.queryHandlersMap.get(query.constructor);
        if (!queryHandler) {
            throw new QueryNotRegisteredError_1.default(query);
        }
        return queryHandler;
    }
    formatHandlers(queryHandlers) {
        const handlersMap = new Map();
        queryHandlers.forEach((queryHandler) => {
            handlersMap.set(queryHandler.subscribedTo(), queryHandler);
        });
        return handlersMap;
    }
}
exports["default"] = QueryHandlersInformation;


/***/ }),

/***/ "../../../../node_modules/uuid-validate/index.js":
/*!*******************************************************!*\
  !*** ../../../../node_modules/uuid-validate/index.js ***!
  \*******************************************************/
/***/ ((module) => {

// Regular expression used for basic parsing of the uuid.
var pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

/**
 * Unparses a UUID buffer to a string. From node-uuid:
 * https://github.com/defunctzombie/node-uuid/blob/master/uuid.js
 *
 * Copyright (c) 2010-2012 Robert Kieffer
 * MIT License - http://opensource.org/licenses/mit-license.php
 *
 * @param  {Buffer} buf
 * @param  {Number=0} offset
 * @return {String}
 */
var _byteToHex = [];
for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

/**
 * Determines whether the uuid is valid, converting
 * it from a buffer if necessary.
 *
 * @param  {String|Buffer}  uuid
 * @param  {Number=}  version
 * @return {Boolean}
 */
module.exports = function (uuid, version) {
    var parsedUuid;
    // If the uuid is a biffer, parse it...
    if (Buffer.isBuffer(uuid)) {
        parsedUuid = unparse(uuid);
    }
    // If it's a string, it's already good.
    else if (Object.prototype.toString.call(uuid) === '[object String]') {
        parsedUuid = uuid;
    }
    // Otherwise, it's not valid.
    else {
        return false;
    }

    parsedUuid = parsedUuid.toLowerCase();

    // All UUIDs fit a basic schema. Match that.
    if (!pattern.test(parsedUuid)) {
        return false;
    }

    // Now extract the version...
    if (version === undefined) {
        version = extractVersion(parsedUuid);
    } else if (extractVersion(parsedUuid) !== version) {
        return false;
    }

    switch (version) {
        // For certain versions, the checks we did up to this point are fine.
        case 1:
        case 2:
            return true;

        // For versions 3 and 4, they must specify a variant.
        case 3:
        case 4:
        case 5:
            return ['8', '9', 'a', 'b'].indexOf(parsedUuid.charAt(19)) !== -1;

        default:
            // We should only be able to reach this if the consumer explicitly
            // provided an invalid version. Prior to extractVersion we check
            // that it's 1-4 in the regex.
            throw new Error('Invalid version provided.');
    }
};

/**
 * Extracts the version from the UUID, which is (by definition) the M in
 * xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
 *
 * @param  {String} uuid
 * @return {Number}
 */
var extractVersion = module.exports.version = function (uuid) {
    return uuid.charAt(14)|0;
};


/***/ }),

/***/ "../../../../node_modules/uuid/index.js":
/*!**********************************************!*\
  !*** ../../../../node_modules/uuid/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "../../../../node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "../../../../node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "../../../../node_modules/uuid/lib/bytesToUuid.js":
/*!********************************************************!*\
  !*** ../../../../node_modules/uuid/lib/bytesToUuid.js ***!
  \********************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../../../../node_modules/uuid/lib/rng.js":
/*!************************************************!*\
  !*** ../../../../node_modules/uuid/lib/rng.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ "../../../../node_modules/uuid/v1.js":
/*!*******************************************!*\
  !*** ../../../../node_modules/uuid/v1.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../../../node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../../../node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../../../../node_modules/uuid/v4.js":
/*!*******************************************!*\
  !*** ../../../../node_modules/uuid/v4.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../../../node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../../../node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "../../../../node_modules/validate-npm-package-name/index.js":
/*!*******************************************************************!*\
  !*** ../../../../node_modules/validate-npm-package-name/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$')
var builtins = __webpack_require__(/*! builtins */ "../../../../node_modules/builtins/builtins.json")
var blacklist = [
  'node_modules',
  'favicon.ico'
]

var validate = module.exports = function (name) {
  var warnings = []
  var errors = []

  if (name === null) {
    errors.push('name cannot be null')
    return done(warnings, errors)
  }

  if (name === undefined) {
    errors.push('name cannot be undefined')
    return done(warnings, errors)
  }

  if (typeof name !== 'string') {
    errors.push('name must be a string')
    return done(warnings, errors)
  }

  if (!name.length) {
    errors.push('name length must be greater than zero')
  }

  if (name.match(/^\./)) {
    errors.push('name cannot start with a period')
  }

  if (name.match(/^_/)) {
    errors.push('name cannot start with an underscore')
  }

  if (name.trim() !== name) {
    errors.push('name cannot contain leading or trailing spaces')
  }

  // No funny business
  blacklist.forEach(function (blacklistedName) {
    if (name.toLowerCase() === blacklistedName) {
      errors.push(blacklistedName + ' is a blacklisted name')
    }
  })

  // Generate warnings for stuff that used to be allowed

  // core module names like http, events, util, etc
  builtins.forEach(function (builtin) {
    if (name.toLowerCase() === builtin) {
      warnings.push(builtin + ' is a core module name')
    }
  })

  // really-long-package-names-------------------------------such--length-----many---wow
  // the thisisareallyreallylongpackagenameitshouldpublishdowenowhavealimittothelengthofpackagenames-poch.
  if (name.length > 214) {
    warnings.push('name can no longer contain more than 214 characters')
  }

  // mIxeD CaSe nAMEs
  if (name.toLowerCase() !== name) {
    warnings.push('name can no longer contain capital letters')
  }

  if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
    warnings.push('name can no longer contain special characters ("~\'!()*")')
  }

  if (encodeURIComponent(name) !== name) {
    // Maybe it's a scoped package name, like @user/package
    var nameMatch = name.match(scopedPackagePattern)
    if (nameMatch) {
      var user = nameMatch[1]
      var pkg = nameMatch[2]
      if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
        return done(warnings, errors)
      }
    }

    errors.push('name can only contain URL-friendly characters')
  }

  return done(warnings, errors)
}

validate.scopedPackagePattern = scopedPackagePattern

var done = function (warnings, errors) {
  var result = {
    validForNewPackages: errors.length === 0 && warnings.length === 0,
    validForOldPackages: errors.length === 0,
    warnings: warnings,
    errors: errors
  }
  if (!result.warnings.length) delete result.warnings
  if (!result.errors.length) delete result.errors
  return result
}


/***/ }),

/***/ "../../../../node_modules/xml2js/lib/bom.js":
/*!**************************************************!*\
  !*** ../../../../node_modules/xml2js/lib/bom.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xml2js/lib/builder.js":
/*!******************************************************!*\
  !*** ../../../../node_modules/xml2js/lib/builder.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    hasProp = {}.hasOwnProperty;

  builder = __webpack_require__(/*! xmlbuilder */ "../../../../node_modules/xmlbuilder/lib/index.js");

  defaults = (__webpack_require__(/*! ./defaults */ "../../../../node_modules/xml2js/lib/defaults.js").defaults);

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else if (Array.isArray(obj)) {
            for (index in obj) {
              if (!hasProp.call(obj, index)) continue;
              child = obj[index];
              for (key in child) {
                entry = child[key];
                element = render(element.ele(key), entry).up();
              }
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xml2js/lib/defaults.js":
/*!*******************************************************!*\
  !*** ../../../../node_modules/xml2js/lib/defaults.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xml2js/lib/parser.js":
/*!*****************************************************!*\
  !*** ../../../../node_modules/xml2js/lib/parser.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  sax = __webpack_require__(/*! sax */ "../../../../node_modules/sax/lib/sax.js");

  events = __webpack_require__(/*! events */ "events");

  bom = __webpack_require__(/*! ./bom */ "../../../../node_modules/xml2js/lib/bom.js");

  processors = __webpack_require__(/*! ./processors */ "../../../../node_modules/xml2js/lib/processors.js");

  setImmediate = (__webpack_require__(/*! timers */ "timers").setImmediate);

  defaults = (__webpack_require__(/*! ./defaults */ "../../../../node_modules/xml2js/lib/defaults.js").defaults);

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processItem = function(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk, err;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.onend = (function(_this) {
        return function() {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            (function() {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                err = error1;
                return _this.emit("error", err);
              }
            })();
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              if (_this.options.normalize) {
                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
              }
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    return Parser;

  })(events.EventEmitter);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xml2js/lib/processors.js":
/*!*********************************************************!*\
  !*** ../../../../node_modules/xml2js/lib/processors.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function(str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xml2js/lib/xml2js.js":
/*!*****************************************************!*\
  !*** ../../../../node_modules/xml2js/lib/xml2js.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, parser, processors,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  defaults = __webpack_require__(/*! ./defaults */ "../../../../node_modules/xml2js/lib/defaults.js");

  builder = __webpack_require__(/*! ./builder */ "../../../../node_modules/xml2js/lib/builder.js");

  parser = __webpack_require__(/*! ./parser */ "../../../../node_modules/xml2js/lib/parser.js");

  processors = __webpack_require__(/*! ./processors */ "../../../../node_modules/xml2js/lib/processors.js");

  exports.defaults = defaults.defaults;

  exports.processors = processors;

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = builder.Builder;

  exports.Parser = parser.Parser;

  exports.parseString = parser.parseString;

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/Utility.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/Utility.js ***!
  \**********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  assign = function() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \***************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute;

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.options = parent.options;
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return Object.create(this);
    };

    XMLAttribute.prototype.toString = function(options) {
      return this.options.writer.set(options).attribute(this);
    };

    return XMLAttribute;

  })();

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLCData.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLCData.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCData.prototype.toString = function(options) {
      return this.options.writer.set(options).cdata(this);
    };

    return XMLCData;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLComment.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLComment.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLComment, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return Object.create(this);
    };

    XMLComment.prototype.toString = function(options) {
      return this.options.writer.set(options).comment(this);
    };

    return XMLComment;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDAttList = (function(superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdAttList(this);
    };

    return XMLDTDAttList;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDElement, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDElement = (function(superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdElement(this);
    };

    return XMLDTDElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!***************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDEntity, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDEntity = (function(superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdEntity(this);
    };

    return XMLDTDEntity;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!*****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDNotation, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDNotation = (function(superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdNotation(this);
    };

    return XMLDTDNotation;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!*****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDeclaration, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options) {
      return this.options.writer.set(options).declaration(this);
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDocType.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "../../../../node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "../../../../node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "../../../../node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "../../../../node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  module.exports = XMLDocType = (function(superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      XMLDocType.__super__.constructor.call(this, parent);
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function(options) {
      return this.options.writer.set(options).docType(this);
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root() || this.documentObject;
    };

    return XMLDocType;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDocument.js":
/*!**************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDocument.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isPlainObject = (__webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js").isPlainObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "../../../../node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "../../../../node_modules/xmlbuilder/lib/XMLStringWriter.js");

  module.exports = XMLDocument = (function(superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      this.isDocument = true;
    }

    XMLDocument.prototype.end = function(writer) {
      var writerOptions;
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer.set(writerOptions);
      }
      return writer.document(this);
    };

    XMLDocument.prototype.toString = function(options) {
      return this.options.writer.set(options).document(this);
    };

    return XMLDocument;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLDocumentCB.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

  XMLElement = __webpack_require__(/*! ./XMLElement */ "../../../../node_modules/xmlbuilder/lib/XMLElement.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "../../../../node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "../../../../node_modules/xmlbuilder/lib/XMLComment.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "../../../../node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "../../../../node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "../../../../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "../../../../node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "../../../../node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "../../../../node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "../../../../node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "../../../../node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "../../../../node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "../../../../node_modules/xmlbuilder/lib/XMLAttribute.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "../../../../node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "../../../../node_modules/xmlbuilder/lib/XMLStringWriter.js");

  module.exports = XMLDocumentCB = (function() {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter(options);
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter(writerOptions);
      }
      this.options = options;
      this.writer = options.writer;
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.node = function(name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node");
      }
      this.openCurrent();
      name = name.valueOf();
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function(name, attributes, text) {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.dtdElement.apply(this, arguments);
      } else {
        return this.node(name, attributes, text);
      }
    };

    XMLDocumentCB.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode");
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.cdata = function(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.comment = function(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.raw = function(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.entity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.notation = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.up = function() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function(node) {
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
          this.root = node;
        }
        this.onData(this.writer.openNode(node, this.currentLevel));
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function(node) {
      if (!node.isClosed) {
        this.onData(this.writer.closeNode(node, this.currentLevel));
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function(chunk) {
      this.documentStarted = true;
      return this.onDataCallback(chunk);
    };

    XMLDocumentCB.prototype.onEnd = function() {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.ele = function() {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;

  })();

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLElement.js":
/*!*************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLElement.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "../../../../node_modules/xmlbuilder/lib/XMLAttribute.js");

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.isDocument) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, ref1;
      clonedSelf = Object.create(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref1 = this.attributes;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function(options) {
      return this.options.writer.set(options).element(this);
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLNode.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLNode.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.children = [];
      if (!XMLElement) {
        XMLElement = __webpack_require__(/*! ./XMLElement */ "../../../../node_modules/xmlbuilder/lib/XMLElement.js");
        XMLCData = __webpack_require__(/*! ./XMLCData */ "../../../../node_modules/xmlbuilder/lib/XMLCData.js");
        XMLComment = __webpack_require__(/*! ./XMLComment */ "../../../../node_modules/xmlbuilder/lib/XMLComment.js");
        XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "../../../../node_modules/xmlbuilder/lib/XMLDeclaration.js");
        XMLDocType = __webpack_require__(/*! ./XMLDocType */ "../../../../node_modules/xmlbuilder/lib/XMLDocType.js");
        XMLRaw = __webpack_require__(/*! ./XMLRaw */ "../../../../node_modules/xmlbuilder/lib/XMLRaw.js");
        XMLText = __webpack_require__(/*! ./XMLText */ "../../../../node_modules/xmlbuilder/lib/XMLText.js");
        XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "../../../../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
      }
    }

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref1;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref1;
      if (name != null) {
        name = name.valueOf();
      }
      attributes || (attributes = {});
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.instruction = function(target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children[0] instanceof XMLDeclaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref1 = doc.children;
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        child = ref1[i];
        if (child instanceof XMLDocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref2 = doc.children;
      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
        child = ref2[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function(options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function(doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function(doc) {
      return this.importDocument(doc);
    };

    return XMLNode;

  })();

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLProcessingInstruction,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLProcessingInstruction = (function(superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return Object.create(this);
    };

    XMLProcessingInstruction.prototype.toString = function(options) {
      return this.options.writer.set(options).processingInstruction(this);
    };

    return XMLProcessingInstruction;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLRaw.js":
/*!*********************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLRaw,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return Object.create(this);
    };

    XMLRaw.prototype.toString = function(options) {
      return this.options.writer.set(options).raw(this);
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLStreamWriter.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "../../../../node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "../../../../node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "../../../../node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "../../../../node_modules/xmlbuilder/lib/XMLComment.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "../../../../node_modules/xmlbuilder/lib/XMLElement.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "../../../../node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "../../../../node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "../../../../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "../../../../node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "../../../../node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "../../../../node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "../../../../node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "../../../../node_modules/xmlbuilder/lib/XMLWriterBase.js");

  module.exports = XMLStreamWriter = (function(superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      XMLStreamWriter.__super__.constructor.call(this, options);
      this.stream = stream;
    }

    XMLStreamWriter.prototype.document = function(doc) {
      var child, i, j, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.isLastRootNode = false;
      }
      doc.children[doc.children.length - 1].isLastRootNode = true;
      ref1 = doc.children;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        child = ref1[j];
        switch (false) {
          case !(child instanceof XMLDeclaration):
            results.push(this.declaration(child));
            break;
          case !(child instanceof XMLDocType):
            results.push(this.docType(child));
            break;
          case !(child instanceof XMLComment):
            results.push(this.comment(child));
            break;
          case !(child instanceof XMLProcessingInstruction):
            results.push(this.processingInstruction(child));
            break;
          default:
            results.push(this.element(child));
        }
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function(att) {
      return this.stream.write(' ' + att.name + '="' + att.value + '"');
    };

    XMLStreamWriter.prototype.cdata = function(node, level) {
      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
    };

    XMLStreamWriter.prototype.comment = function(node, level) {
      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
    };

    XMLStreamWriter.prototype.declaration = function(node, level) {
      this.stream.write(this.space(level));
      this.stream.write('<?xml version="' + node.version + '"');
      if (node.encoding != null) {
        this.stream.write(' encoding="' + node.encoding + '"');
      }
      if (node.standalone != null) {
        this.stream.write(' standalone="' + node.standalone + '"');
      }
      this.stream.write(this.spacebeforeslash + '?>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.docType = function(node, level) {
      var child, i, len, ref;
      level || (level = 0);
      this.stream.write(this.space(level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node));
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          switch (false) {
            case !(child instanceof XMLDTDAttList):
              this.dtdAttList(child, level + 1);
              break;
            case !(child instanceof XMLDTDElement):
              this.dtdElement(child, level + 1);
              break;
            case !(child instanceof XMLDTDEntity):
              this.dtdEntity(child, level + 1);
              break;
            case !(child instanceof XMLDTDNotation):
              this.dtdNotation(child, level + 1);
              break;
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown DTD node type: " + child.constructor.name);
          }
        }
        this.stream.write(']');
      }
      this.stream.write(this.spacebeforeslash + '>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.element = function(node, level) {
      var att, child, i, len, name, ref, ref1, space;
      level || (level = 0);
      space = this.space(level);
      this.stream.write(space + '<' + node.name);
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          this.stream.write('></' + node.name + '>');
        } else {
          this.stream.write(this.spacebeforeslash + '/>');
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        this.stream.write('>');
        this.stream.write(node.children[0].value);
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.newline);
        ref1 = node.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          switch (false) {
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLElement):
              this.element(child, level + 1);
              break;
            case !(child instanceof XMLRaw):
              this.raw(child, level + 1);
              break;
            case !(child instanceof XMLText):
              this.text(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown XML node type: " + child.constructor.name);
          }
        }
        this.stream.write(space + '</' + node.name + '>');
      }
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
      this.stream.write(this.space(level) + '<?' + node.target);
      if (node.value) {
        this.stream.write(' ' + node.value);
      }
      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
    };

    XMLStreamWriter.prototype.raw = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.text = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
      if (node.defaultValueType !== '#DEFAULT') {
        this.stream.write(' ' + node.defaultValueType);
      }
      if (node.defaultValue) {
        this.stream.write(' "' + node.defaultValue + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdElement = function(node, level) {
      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
      this.stream.write(this.space(level) + '<!ENTITY');
      if (node.pe) {
        this.stream.write(' %');
      }
      this.stream.write(' ' + node.name);
      if (node.value) {
        this.stream.write(' "' + node.value + '"');
      } else {
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.nData) {
          this.stream.write(' NDATA ' + node.nData);
        }
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.pubID) {
        this.stream.write(' PUBLIC "' + node.pubID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.endline = function(node) {
      if (!node.isLastRootNode) {
        return this.newline;
      } else {
        return '';
      }
    };

    return XMLStreamWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLStringWriter.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "../../../../node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "../../../../node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "../../../../node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "../../../../node_modules/xmlbuilder/lib/XMLComment.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "../../../../node_modules/xmlbuilder/lib/XMLElement.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "../../../../node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "../../../../node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "../../../../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "../../../../node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "../../../../node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "../../../../node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "../../../../node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "../../../../node_modules/xmlbuilder/lib/XMLWriterBase.js");

  module.exports = XMLStringWriter = (function(superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function(doc) {
      var child, i, len, r, ref;
      this.textispresent = false;
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += (function() {
          switch (false) {
            case !(child instanceof XMLDeclaration):
              return this.declaration(child);
            case !(child instanceof XMLDocType):
              return this.docType(child);
            case !(child instanceof XMLComment):
              return this.comment(child);
            case !(child instanceof XMLProcessingInstruction):
              return this.processingInstruction(child);
            default:
              return this.element(child, 0);
          }
        }).call(this);
      }
      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
        r = r.slice(0, -this.newline.length);
      }
      return r;
    };

    XMLStringWriter.prototype.attribute = function(att) {
      return ' ' + att.name + '="' + att.value + '"';
    };

    XMLStringWriter.prototype.cdata = function(node, level) {
      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
    };

    XMLStringWriter.prototype.comment = function(node, level) {
      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
    };

    XMLStringWriter.prototype.declaration = function(node, level) {
      var r;
      r = this.space(level);
      r += '<?xml version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      r += this.spacebeforeslash + '?>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.docType = function(node, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      r = this.space(level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.newline;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLDTDAttList):
                return this.dtdAttList(child, level + 1);
              case !(child instanceof XMLDTDElement):
                return this.dtdElement(child, level + 1);
              case !(child instanceof XMLDTDEntity):
                return this.dtdEntity(child, level + 1);
              case !(child instanceof XMLDTDNotation):
                return this.dtdNotation(child, level + 1);
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }).call(this);
        }
        r += ']';
      }
      r += this.spacebeforeslash + '>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.element = function(node, level) {
      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
      level || (level = 0);
      textispresentwasset = false;
      if (this.textispresent) {
        this.newline = '';
        this.pretty = false;
      } else {
        this.newline = this.newlinedefault;
        this.pretty = this.prettydefault;
      }
      space = this.space(level);
      r = '';
      r += space + '<' + node.name;
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          r += '></' + node.name + '>' + this.newline;
        } else {
          r += this.spacebeforeslash + '/>' + this.newline;
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        r += '>';
        r += node.children[0].value;
        r += '</' + node.name + '>' + this.newline;
      } else {
        if (this.dontprettytextnodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if (child.value != null) {
              this.textispresent++;
              textispresentwasset = true;
              break;
            }
          }
        }
        if (this.textispresent) {
          this.newline = '';
          this.pretty = false;
          space = this.space(level);
        }
        r += '>' + this.newline;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLElement):
                return this.element(child, level + 1);
              case !(child instanceof XMLRaw):
                return this.raw(child, level + 1);
              case !(child instanceof XMLText):
                return this.text(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }).call(this);
        }
        if (textispresentwasset) {
          this.textispresent--;
        }
        if (!this.textispresent) {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        r += space + '</' + node.name + '>' + this.newline;
      }
      return r;
    };

    XMLStringWriter.prototype.processingInstruction = function(node, level) {
      var r;
      r = this.space(level) + '<?' + node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      r += this.spacebeforeslash + '?>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.raw = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.text = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.dtdAttList = function(node, level) {
      var r;
      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdElement = function(node, level) {
      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
    };

    XMLStringWriter.prototype.dtdEntity = function(node, level) {
      var r;
      r = this.space(level) + '<!ENTITY';
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdNotation = function(node, level) {
      var r;
      r = this.space(level) + '<!NOTATION ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.openNode = function(node, level) {
      var att, name, r, ref;
      level || (level = 0);
      if (node instanceof XMLElement) {
        r = this.space(level) + '<' + node.name;
        ref = node.attributes;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att);
        }
        r += (node.children ? '>' : '/>') + this.newline;
        return r;
      } else {
        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        r += (node.children ? ' [' : '>') + this.newline;
        return r;
      }
    };

    XMLStringWriter.prototype.closeNode = function(node, level) {
      level || (level = 0);
      switch (false) {
        case !(node instanceof XMLElement):
          return this.space(level) + '</' + node.name + '>' + this.newline;
        case !(node instanceof XMLDocType):
          return this.space(level) + ']>' + this.newline;
      }
    };

    return XMLStringWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!*****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \*****************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.noDoubleEncoding = options.noDoubleEncoding;
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return val = '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var res;
      res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
      if (res) {
        throw new Error("Invalid character in string: " + str + " at index " + res.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLText.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLText.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "../../../../node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return Object.create(this);
    };

    XMLText.prototype.toString = function(options) {
      return this.options.writer.set(options).text(this);
    };

    return XMLText;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/XMLWriterBase.js":
/*!****************************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
  \****************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLWriterBase,
    hasProp = {}.hasOwnProperty;

  module.exports = XMLWriterBase = (function() {
    function XMLWriterBase(options) {
      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
      options || (options = {});
      this.pretty = options.pretty || false;
      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
      if (this.pretty) {
        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref6 = options.writer || {};
      for (key in ref6) {
        if (!hasProp.call(ref6, key)) continue;
        value = ref6[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.set = function(options) {
      var key, ref, value;
      options || (options = {});
      if ("pretty" in options) {
        this.pretty = options.pretty;
      }
      if ("allowEmpty" in options) {
        this.allowEmpty = options.allowEmpty;
      }
      if (this.pretty) {
        this.indent = "indent" in options ? options.indent : '  ';
        this.newline = "newline" in options ? options.newline : '\n';
        this.offset = "offset" in options ? options.offset : 0;
        this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
      return this;
    };

    XMLWriterBase.prototype.space = function(level) {
      var indent;
      if (this.pretty) {
        indent = (level || 0) + this.offset + 1;
        if (indent > 0) {
          return new Array(indent).join(this.indent);
        } else {
          return '';
        }
      } else {
        return '';
      }
    };

    return XMLWriterBase;

  })();

}).call(this);


/***/ }),

/***/ "../../../../node_modules/xmlbuilder/lib/index.js":
/*!********************************************************!*\
  !*** ../../../../node_modules/xmlbuilder/lib/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = __webpack_require__(/*! ./Utility */ "../../../../node_modules/xmlbuilder/lib/Utility.js"), assign = ref.assign, isFunction = ref.isFunction;

  XMLDocument = __webpack_require__(/*! ./XMLDocument */ "../../../../node_modules/xmlbuilder/lib/XMLDocument.js");

  XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ "../../../../node_modules/xmlbuilder/lib/XMLDocumentCB.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "../../../../node_modules/xmlbuilder/lib/XMLStringWriter.js");

  XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ "../../../../node_modules/xmlbuilder/lib/XMLStreamWriter.js");

  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.doctype(options);
      }
    }
    return root;
  };

  module.exports.begin = function(options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

}).call(this);


/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("console");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "dgram":
/*!************************!*\
  !*** external "dgram" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("dgram");

/***/ }),

/***/ "domain":
/*!*************************!*\
  !*** external "domain" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("domain");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "../../../../node_modules/@middy/core/index.js":
/*!*****************************************************!*\
  !*** ../../../../node_modules/@middy/core/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


const middy = (baseHandler = () => {}, plugin) => {
  var _plugin$beforePrefetc;

  plugin === null || plugin === void 0 ? void 0 : (_plugin$beforePrefetc = plugin.beforePrefetch) === null || _plugin$beforePrefetc === void 0 ? void 0 : _plugin$beforePrefetc.call(plugin);
  const beforeMiddlewares = [];
  const afterMiddlewares = [];
  const onErrorMiddlewares = [];

  const instance = (event = {}, context = {}) => {
    var _plugin$requestStart;

    plugin === null || plugin === void 0 ? void 0 : (_plugin$requestStart = plugin.requestStart) === null || _plugin$requestStart === void 0 ? void 0 : _plugin$requestStart.call(plugin);
    const request = {
      event,
      context,
      response: undefined,
      error: undefined,
      internal: {}
    };
    return runRequest(request, [...beforeMiddlewares], baseHandler, [...afterMiddlewares], [...onErrorMiddlewares], plugin);
  };

  instance.use = middlewares => {
    if (Array.isArray(middlewares)) {
      for (const middleware of middlewares) {
        instance.applyMiddleware(middleware);
      }

      return instance;
    }

    return instance.applyMiddleware(middlewares);
  };

  instance.applyMiddleware = middleware => {
    const {
      before,
      after,
      onError
    } = middleware;

    if (!before && !after && !onError) {
      throw new Error('Middleware must be an object containing at least one key among "before", "after", "onError"');
    }

    if (before) instance.before(before);
    if (after) instance.after(after);
    if (onError) instance.onError(onError);
    return instance;
  }; // Inline Middlewares


  instance.before = beforeMiddleware => {
    beforeMiddlewares.push(beforeMiddleware);
    return instance;
  };

  instance.after = afterMiddleware => {
    afterMiddlewares.unshift(afterMiddleware);
    return instance;
  };

  instance.onError = onErrorMiddleware => {
    onErrorMiddlewares.push(onErrorMiddleware);
    return instance;
  };

  instance.__middlewares = {
    before: beforeMiddlewares,
    after: afterMiddlewares,
    onError: onErrorMiddlewares
  };
  return instance;
};

const runRequest = async (request, beforeMiddlewares, baseHandler, afterMiddlewares, onErrorMiddlewares, plugin) => {
  try {
    await runMiddlewares(request, beforeMiddlewares, plugin); // Check if before stack hasn't exit early

    if (request.response === undefined) {
      var _plugin$beforeHandler, _plugin$afterHandler;

      plugin === null || plugin === void 0 ? void 0 : (_plugin$beforeHandler = plugin.beforeHandler) === null || _plugin$beforeHandler === void 0 ? void 0 : _plugin$beforeHandler.call(plugin);
      request.response = await baseHandler(request.event, request.context);
      plugin === null || plugin === void 0 ? void 0 : (_plugin$afterHandler = plugin.afterHandler) === null || _plugin$afterHandler === void 0 ? void 0 : _plugin$afterHandler.call(plugin);
      await runMiddlewares(request, afterMiddlewares, plugin);
    }
  } catch (e) {
    // Reset response changes made by after stack before error thrown
    request.response = undefined;
    request.error = e;

    try {
      await runMiddlewares(request, onErrorMiddlewares, plugin);
    } catch (e) {
      // Save error that wasn't handled
      e.originalError = request.error;
      request.error = e;
      throw request.error;
    } // Catch if onError stack hasn't handled the error


    if (request.response === undefined) throw request.error;
  } finally {
    var _plugin$requestEnd;

    await (plugin === null || plugin === void 0 ? void 0 : (_plugin$requestEnd = plugin.requestEnd) === null || _plugin$requestEnd === void 0 ? void 0 : _plugin$requestEnd.call(plugin, request));
  }

  return request.response;
};

const runMiddlewares = async (request, middlewares, plugin) => {
  for (const nextMiddleware of middlewares) {
    var _plugin$beforeMiddlew, _plugin$afterMiddlewa;

    plugin === null || plugin === void 0 ? void 0 : (_plugin$beforeMiddlew = plugin.beforeMiddleware) === null || _plugin$beforeMiddlew === void 0 ? void 0 : _plugin$beforeMiddlew.call(plugin, nextMiddleware === null || nextMiddleware === void 0 ? void 0 : nextMiddleware.name);
    const res = await (nextMiddleware === null || nextMiddleware === void 0 ? void 0 : nextMiddleware(request));
    plugin === null || plugin === void 0 ? void 0 : (_plugin$afterMiddlewa = plugin.afterMiddleware) === null || _plugin$afterMiddlewa === void 0 ? void 0 : _plugin$afterMiddlewa.call(plugin, nextMiddleware === null || nextMiddleware === void 0 ? void 0 : nextMiddleware.name); // short circuit chaining and respond early

    if (res !== undefined) {
      request.response = res;
      return;
    }
  }
};

module.exports = middy;


/***/ }),

/***/ "../../../../node_modules/@middy/http-cors/index.js":
/*!**********************************************************!*\
  !*** ../../../../node_modules/@middy/http-cors/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  normalizeHttpResponse
} = __webpack_require__(/*! @middy/util */ "../../../../node_modules/@middy/util/index.js");

const getOrigin = (incomingOrigin, options) => {
  if ((options === null || options === void 0 ? void 0 : options.origins.length) > 0) {
    if (incomingOrigin && options.origins.includes(incomingOrigin)) {
      return incomingOrigin;
    } else {
      return options.origins[0];
    }
  } else {
    if (incomingOrigin && options.credentials && options.origin === '*') {
      return incomingOrigin;
    }

    return options.origin;
  }
};

const defaults = {
  getOrigin,
  credentials: undefined,
  headers: undefined,
  methods: undefined,
  origin: '*',
  origins: [],
  exposeHeaders: undefined,
  maxAge: undefined,
  requestHeaders: undefined,
  requestMethods: undefined,
  cacheControl: undefined
};

const httpCorsMiddleware = (opts = {}) => {
  const options = { ...defaults,
    ...opts
  };

  const httpCorsMiddlewareAfter = async request => {
    var _request$event, _request$event2, _request$event2$reque, _request$event2$reque2;

    // API Gateway v1 & v2
    if (!((_request$event = request.event) !== null && _request$event !== void 0 && _request$event.httpMethod) && !((_request$event2 = request.event) !== null && _request$event2 !== void 0 && (_request$event2$reque = _request$event2.requestContext) !== null && _request$event2$reque !== void 0 && (_request$event2$reque2 = _request$event2$reque.http) !== null && _request$event2$reque2 !== void 0 && _request$event2$reque2.method)) return;
    request.response = normalizeHttpResponse(request.response);
    const existingHeaders = Object.keys(request.response.headers); // Check if already setup the header Access-Control-Allow-Credentials

    if (existingHeaders.includes('Access-Control-Allow-Credentials')) {
      options.credentials = request.response.headers['Access-Control-Allow-Credentials'] === 'true';
    }

    if (options.credentials) {
      request.response.headers['Access-Control-Allow-Credentials'] = String(options.credentials);
    } // Check if already setup Access-Control-Allow-Headers


    if (options.headers && !existingHeaders.includes('Access-Control-Allow-Headers')) {
      request.response.headers['Access-Control-Allow-Headers'] = options.headers;
    } // Check if already setup Access-Control-Allow-Methods


    if (options.methods && !existingHeaders.includes('Access-Control-Allow-Methods')) {
      request.response.headers['Access-Control-Allow-Methods'] = options.methods;
    } // Check if already setup the header Access-Control-Allow-Origin


    if (!existingHeaders.includes('Access-Control-Allow-Origin')) {
      var _request$event$header, _request$event3, _eventHeaders$origin;

      const eventHeaders = (_request$event$header = (_request$event3 = request.event) === null || _request$event3 === void 0 ? void 0 : _request$event3.headers) !== null && _request$event$header !== void 0 ? _request$event$header : {};
      const incomingOrigin = (_eventHeaders$origin = eventHeaders.origin) !== null && _eventHeaders$origin !== void 0 ? _eventHeaders$origin : eventHeaders.Origin;
      request.response.headers['Access-Control-Allow-Origin'] = options.getOrigin(incomingOrigin, options);
    } // Check if already setup Access-Control-Expose-Headers


    if (options.exposeHeaders && !existingHeaders.includes('Access-Control-Expose-Headers')) {
      request.response.headers['Access-Control-Expose-Headers'] = options.exposeHeaders;
    }

    if (options.maxAge && !existingHeaders.includes('Access-Control-Max-Age')) {
      request.response.headers['Access-Control-Max-Age'] = String(options.maxAge);
    } // Check if already setup Access-Control-Request-Headers


    if (options.requestHeaders && !existingHeaders.includes('Access-Control-Request-Headers')) {
      request.response.headers['Access-Control-Request-Headers'] = options.requestHeaders;
    } // Check if already setup Access-Control-Request-Methods


    if (options !== null && options !== void 0 && options.requestMethods && !existingHeaders.includes('Access-Control-Request-Methods')) {
      request.response.headers['Access-Control-Request-Methods'] = options.requestMethods;
    }

    if (request.event.httpMethod === 'OPTIONS') {
      if (options.cacheControl && !existingHeaders.includes('Cache-Control')) {
        request.response.headers['Cache-Control'] = String(options.cacheControl);
      }
    }
  };

  const httpCorsMiddlewareOnError = httpCorsMiddlewareAfter;
  return {
    after: httpCorsMiddlewareAfter,
    onError: httpCorsMiddlewareOnError
  };
};

module.exports = httpCorsMiddleware;


/***/ }),

/***/ "../../../../node_modules/@middy/util/index.js":
/*!*****************************************************!*\
  !*** ../../../../node_modules/@middy/util/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Agent
} = __webpack_require__(/*! https */ "https"); // const { NodeHttpHandler } = require('@aws-sdk/node-http-handler') // aws-sdk v3


const awsClientDefaultOptions = {
  // AWS SDK v3
  // Docs: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/enforcing-tls.html

  /* requestHandler: new NodeHttpHandler({
    httpsAgent: new Agent(
      {
        secureProtocol: 'TLSv1_2_method'
      }
    )
  }) */
  // Docs: https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/enforcing-tls.html
  httpOptions: {
    agent: new Agent({
      secureProtocol: 'TLSv1_2_method'
    })
  }
};

const createPrefetchClient = options => {
  const awsClientOptions = { ...awsClientDefaultOptions,
    ...options.awsClientOptions
  };
  const client = new options.AwsClient(awsClientOptions); // AWS XRay

  if (options.awsClientCapture) {
    return options.awsClientCapture(client);
  }

  return client;
};

const createClient = async (options, request) => {
  let awsClientCredentials = {}; // Role Credentials

  if (options.awsClientAssumeRole) {
    if (!request) throw new Error('Request required when assuming role');
    awsClientCredentials = await getInternal({
      credentials: options.awsClientAssumeRole
    }, request);
  }

  awsClientCredentials = { ...awsClientCredentials,
    ...options.awsClientOptions
  };
  return createPrefetchClient({ ...options,
    awsClientOptions: awsClientCredentials
  });
};

const canPrefetch = options => {
  return !(options !== null && options !== void 0 && options.awsClientAssumeRole) && !(options !== null && options !== void 0 && options.disablePrefetch);
}; // Internal Context


const getInternal = async (variables, request) => {
  if (!variables || !request) return {};
  let keys = [];
  let values = [];

  if (variables === true) {
    keys = values = Object.keys(request.internal);
  } else if (typeof variables === 'string') {
    keys = values = [variables];
  } else if (Array.isArray(variables)) {
    keys = values = variables;
  } else if (typeof variables === 'object') {
    keys = Object.keys(variables);
    values = Object.values(variables);
  }

  const promises = [];

  for (const internalKey of values) {
    var _valuePromise;

    // 'internal.key.sub_value' -> { [key]: internal.key.sub_value }
    const pathOptionKey = internalKey.split('.');
    const rootOptionKey = pathOptionKey.shift();
    let valuePromise = request.internal[rootOptionKey];

    if (typeof ((_valuePromise = valuePromise) === null || _valuePromise === void 0 ? void 0 : _valuePromise.then) !== 'function') {
      valuePromise = Promise.resolve(valuePromise);
    }

    promises.push(valuePromise.then(value => pathOptionKey.reduce((p, c) => p === null || p === void 0 ? void 0 : p[c], value)));
  } // ensure promise has resolved by the time it's needed
  // If one of the promises throws it will bubble up to @middy/core


  values = await Promise.allSettled(promises);
  const errors = values.filter(res => res.status === 'rejected').map(res => res.reason.message);
  if (errors.length) throw new Error(JSON.stringify(errors));
  return keys.reduce((obj, key, index) => ({ ...obj,
    [sanitizeKey(key)]: values[index].value
  }), {});
};

const sanitizeKeyPrefixLeadingNumber = /^([0-9])/;
const sanitizeKeyRemoveDisallowedChar = /[^a-zA-Z0-9]+/g;

const sanitizeKey = key => {
  return key.replace(sanitizeKeyPrefixLeadingNumber, '_$1').replace(sanitizeKeyRemoveDisallowedChar, '_');
}; // fetch Cache


const cache = {}; // key: { value:{fetchKey:Promise}, expiry }

const processCache = (options, fetch = () => undefined, request) => {
  const {
    cacheExpiry,
    cacheKey
  } = options;

  if (cacheExpiry) {
    const cached = getCache(cacheKey);
    const unexpired = cached && (cacheExpiry < 0 || cached.expiry > Date.now());

    if (unexpired && cached.modified) {
      const value = fetch(request, cached.value);
      cache[cacheKey] = {
        value: { ...cached.value,
          ...value
        },
        expiry: cached.expiry
      };
      return cache[cacheKey];
    }

    if (unexpired) {
      return { ...cached,
        cache: true
      };
    }
  }

  const value = fetch(request);
  const expiry = Date.now() + cacheExpiry;

  if (cacheExpiry) {
    cache[cacheKey] = {
      value,
      expiry
    };
  }

  return {
    value,
    expiry
  };
};

const getCache = key => {
  return cache[key];
}; // Used to remove parts of a cache


const modifyCache = (cacheKey, value) => {
  if (!cache[cacheKey]) return;
  cache[cacheKey] = { ...cache[cacheKey],
    value,
    modified: true
  };
};

const clearCache = (keys = null) => {
  var _keys;

  keys = (_keys = keys) !== null && _keys !== void 0 ? _keys : Object.keys(cache);
  if (!Array.isArray(keys)) keys = [keys];

  for (const cacheKey of keys) {
    cache[cacheKey] = undefined;
  }
};

const jsonSafeParse = (string, reviver) => {
  if (typeof string !== 'string') return string;
  const firstChar = string[0];
  if (firstChar !== '{' && firstChar !== '[' && firstChar !== '"') return string;

  try {
    return JSON.parse(string, reviver);
  } catch (e) {}

  return string;
};

const normalizeHttpResponse = response => {
  var _response$headers, _response;

  // May require updating to catch other types
  if (response === undefined) {
    response = {};
  } else if (Array.isArray(response) || typeof response !== 'object' || response === null) {
    response = {
      body: response
    };
  }

  response.headers = (_response$headers = (_response = response) === null || _response === void 0 ? void 0 : _response.headers) !== null && _response$headers !== void 0 ? _response$headers : {};
  return response;
}; // smaller version of `http-errors`


const statuses = __webpack_require__(/*! ./codes.json */ "../../../../node_modules/@middy/util/codes.json");

const {
  inherits
} = __webpack_require__(/*! util */ "util");

const createErrorRegexp = /[^a-zA-Z]/g;

const createError = (code, message, properties = {}) => {
  const name = statuses[code].replace(createErrorRegexp, '');
  const className = name.substr(-5) !== 'Error' ? name + 'Error' : name;

  function HttpError(message) {
    // create the error object
    const msg = message !== null && message !== void 0 ? message : statuses[code];
    const err = new Error(msg); // capture a stack trace to the construction point

    Error.captureStackTrace(err, HttpError); // adjust the [[Prototype]]

    Object.setPrototypeOf(err, HttpError.prototype); // redefine the error message

    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    }); // redefine the error name

    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });
    return err;
  }

  inherits(HttpError, Error);
  const desc = Object.getOwnPropertyDescriptor(HttpError, 'name');
  desc.value = className;
  Object.defineProperty(HttpError, 'name', desc);
  Object.assign(HttpError.prototype, {
    status: code,
    statusCode: code,
    expose: code < 500
  }, properties);
  return new HttpError(message);
};

module.exports = {
  createPrefetchClient,
  createClient,
  canPrefetch,
  getInternal,
  sanitizeKey,
  processCache,
  getCache,
  modifyCache,
  clearCache,
  jsonSafeParse,
  normalizeHttpResponse,
  createError
};


/***/ }),

/***/ "../../../../node_modules/@middy/util/codes.json":
/*!*******************************************************!*\
  !*** ../../../../node_modules/@middy/util/codes.json ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","306":"(Unused)","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Unordered Collection","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json":
/*!**********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2014-06-30","endpointPrefix":"cognito-identity","jsonVersion":"1.1","protocol":"json","serviceFullName":"Amazon Cognito Identity","serviceId":"Cognito Identity","signatureVersion":"v4","targetPrefix":"AWSCognitoIdentityService","uid":"cognito-identity-2014-06-30"},"operations":{"CreateIdentityPool":{"input":{"type":"structure","required":["IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"AllowClassicFlow":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S5"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S9"},"CognitoIdentityProviders":{"shape":"Sb"},"SamlProviderARNs":{"shape":"Sg"},"IdentityPoolTags":{"shape":"Sh"}}},"output":{"shape":"Sk"}},"DeleteIdentities":{"input":{"type":"structure","required":["IdentityIdsToDelete"],"members":{"IdentityIdsToDelete":{"type":"list","member":{}}}},"output":{"type":"structure","members":{"UnprocessedIdentityIds":{"type":"list","member":{"type":"structure","members":{"IdentityId":{},"ErrorCode":{}}}}}}},"DeleteIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}}},"DescribeIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{}}},"output":{"shape":"Sv"}},"DescribeIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"shape":"Sk"}},"GetCredentialsForIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"S10"},"CustomRoleArn":{}}},"output":{"type":"structure","members":{"IdentityId":{},"Credentials":{"type":"structure","members":{"AccessKeyId":{},"SecretKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}}}},"authtype":"none"},"GetId":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"AccountId":{},"IdentityPoolId":{},"Logins":{"shape":"S10"}}},"output":{"type":"structure","members":{"IdentityId":{}}},"authtype":"none"},"GetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Roles":{"shape":"S1c"},"RoleMappings":{"shape":"S1e"}}}},"GetOpenIdToken":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"S10"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}},"authtype":"none"},"GetOpenIdTokenForDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId","Logins"],"members":{"IdentityPoolId":{},"IdentityId":{},"Logins":{"shape":"S10"},"PrincipalTags":{"shape":"S1s"},"TokenDuration":{"type":"long"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"GetPrincipalTagAttributeMap":{"input":{"type":"structure","required":["IdentityPoolId","IdentityProviderName"],"members":{"IdentityPoolId":{},"IdentityProviderName":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"IdentityProviderName":{},"UseDefaults":{"type":"boolean"},"PrincipalTags":{"shape":"S1s"}}}},"ListIdentities":{"input":{"type":"structure","required":["IdentityPoolId","MaxResults"],"members":{"IdentityPoolId":{},"MaxResults":{"type":"integer"},"NextToken":{},"HideDisabled":{"type":"boolean"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Identities":{"type":"list","member":{"shape":"Sv"}},"NextToken":{}}}},"ListIdentityPools":{"input":{"type":"structure","required":["MaxResults"],"members":{"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityPools":{"type":"list","member":{"type":"structure","members":{"IdentityPoolId":{},"IdentityPoolName":{}}}},"NextToken":{}}}},"ListTagsForResource":{"input":{"type":"structure","required":["ResourceArn"],"members":{"ResourceArn":{}}},"output":{"type":"structure","members":{"Tags":{"shape":"Sh"}}}},"LookupDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{},"IdentityId":{},"DeveloperUserIdentifier":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityId":{},"DeveloperUserIdentifierList":{"type":"list","member":{}},"NextToken":{}}}},"MergeDeveloperIdentities":{"input":{"type":"structure","required":["SourceUserIdentifier","DestinationUserIdentifier","DeveloperProviderName","IdentityPoolId"],"members":{"SourceUserIdentifier":{},"DestinationUserIdentifier":{},"DeveloperProviderName":{},"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"SetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId","Roles"],"members":{"IdentityPoolId":{},"Roles":{"shape":"S1c"},"RoleMappings":{"shape":"S1e"}}}},"SetPrincipalTagAttributeMap":{"input":{"type":"structure","required":["IdentityPoolId","IdentityProviderName"],"members":{"IdentityPoolId":{},"IdentityProviderName":{},"UseDefaults":{"type":"boolean"},"PrincipalTags":{"shape":"S1s"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"IdentityProviderName":{},"UseDefaults":{"type":"boolean"},"PrincipalTags":{"shape":"S1s"}}}},"TagResource":{"input":{"type":"structure","required":["ResourceArn","Tags"],"members":{"ResourceArn":{},"Tags":{"shape":"Sh"}}},"output":{"type":"structure","members":{}}},"UnlinkDeveloperIdentity":{"input":{"type":"structure","required":["IdentityId","IdentityPoolId","DeveloperProviderName","DeveloperUserIdentifier"],"members":{"IdentityId":{},"IdentityPoolId":{},"DeveloperProviderName":{},"DeveloperUserIdentifier":{}}}},"UnlinkIdentity":{"input":{"type":"structure","required":["IdentityId","Logins","LoginsToRemove"],"members":{"IdentityId":{},"Logins":{"shape":"S10"},"LoginsToRemove":{"shape":"Sw"}}},"authtype":"none"},"UntagResource":{"input":{"type":"structure","required":["ResourceArn","TagKeys"],"members":{"ResourceArn":{},"TagKeys":{"type":"list","member":{}}}},"output":{"type":"structure","members":{}}},"UpdateIdentityPool":{"input":{"shape":"Sk"},"output":{"shape":"Sk"}}},"shapes":{"S5":{"type":"map","key":{},"value":{}},"S9":{"type":"list","member":{}},"Sb":{"type":"list","member":{"type":"structure","members":{"ProviderName":{},"ClientId":{},"ServerSideTokenCheck":{"type":"boolean"}}}},"Sg":{"type":"list","member":{}},"Sh":{"type":"map","key":{},"value":{}},"Sk":{"type":"structure","required":["IdentityPoolId","IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolId":{},"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"AllowClassicFlow":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S5"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S9"},"CognitoIdentityProviders":{"shape":"Sb"},"SamlProviderARNs":{"shape":"Sg"},"IdentityPoolTags":{"shape":"Sh"}}},"Sv":{"type":"structure","members":{"IdentityId":{},"Logins":{"shape":"Sw"},"CreationDate":{"type":"timestamp"},"LastModifiedDate":{"type":"timestamp"}}},"Sw":{"type":"list","member":{}},"S10":{"type":"map","key":{},"value":{}},"S1c":{"type":"map","key":{},"value":{}},"S1e":{"type":"map","key":{},"value":{"type":"structure","required":["Type"],"members":{"Type":{},"AmbiguousRoleResolution":{},"RulesConfiguration":{"type":"structure","required":["Rules"],"members":{"Rules":{"type":"list","member":{"type":"structure","required":["Claim","MatchType","Value","RoleARN"],"members":{"Claim":{},"MatchType":{},"Value":{},"RoleARN":{}}}}}}}}},"S1s":{"type":"map","key":{},"value":{}}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json":
/*!*****************************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"pagination":{"ListIdentityPools":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken","result_key":"IdentityPools"}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.min.json":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.min.json ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2011-12-05","endpointPrefix":"dynamodb","jsonVersion":"1.0","protocol":"json","serviceAbbreviation":"DynamoDB","serviceFullName":"Amazon DynamoDB","serviceId":"DynamoDB","signatureVersion":"v4","targetPrefix":"DynamoDB_20111205","uid":"dynamodb-2011-12-05"},"operations":{"BatchGetItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S2"}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"type":"structure","members":{"Items":{"shape":"Sk"},"ConsumedCapacityUnits":{"type":"double"}}}},"UnprocessedKeys":{"shape":"S2"}}}},"BatchWriteItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"So"}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"type":"structure","members":{"ConsumedCapacityUnits":{"type":"double"}}}},"UnprocessedItems":{"shape":"So"}}}},"CreateTable":{"input":{"type":"structure","required":["TableName","KeySchema","ProvisionedThroughput"],"members":{"TableName":{},"KeySchema":{"shape":"Sy"},"ProvisionedThroughput":{"shape":"S12"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}},"DeleteItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"DeleteTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}},"DescribeTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"Table":{"shape":"S15"}}}},"GetItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributesToGet":{"shape":"Se"},"ConsistentRead":{"type":"boolean"}}},"output":{"type":"structure","members":{"Item":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"ListTables":{"input":{"type":"structure","members":{"ExclusiveStartTableName":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"TableNames":{"type":"list","member":{}},"LastEvaluatedTableName":{}}}},"PutItem":{"input":{"type":"structure","required":["TableName","Item"],"members":{"TableName":{},"Item":{"shape":"Ss"},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"Query":{"input":{"type":"structure","required":["TableName","HashKeyValue"],"members":{"TableName":{},"AttributesToGet":{"shape":"Se"},"Limit":{"type":"integer"},"ConsistentRead":{"type":"boolean"},"Count":{"type":"boolean"},"HashKeyValue":{"shape":"S7"},"RangeKeyCondition":{"shape":"S1u"},"ScanIndexForward":{"type":"boolean"},"ExclusiveStartKey":{"shape":"S6"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sk"},"Count":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacityUnits":{"type":"double"}}}},"Scan":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"AttributesToGet":{"shape":"Se"},"Limit":{"type":"integer"},"Count":{"type":"boolean"},"ScanFilter":{"type":"map","key":{},"value":{"shape":"S1u"}},"ExclusiveStartKey":{"shape":"S6"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sk"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacityUnits":{"type":"double"}}}},"UpdateItem":{"input":{"type":"structure","required":["TableName","Key","AttributeUpdates"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributeUpdates":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S7"},"Action":{}}}},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"UpdateTable":{"input":{"type":"structure","required":["TableName","ProvisionedThroughput"],"members":{"TableName":{},"ProvisionedThroughput":{"shape":"S12"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}}},"shapes":{"S2":{"type":"map","key":{},"value":{"type":"structure","required":["Keys"],"members":{"Keys":{"type":"list","member":{"shape":"S6"}},"AttributesToGet":{"shape":"Se"},"ConsistentRead":{"type":"boolean"}}}},"S6":{"type":"structure","required":["HashKeyElement"],"members":{"HashKeyElement":{"shape":"S7"},"RangeKeyElement":{"shape":"S7"}}},"S7":{"type":"structure","members":{"S":{},"N":{},"B":{"type":"blob"},"SS":{"type":"list","member":{}},"NS":{"type":"list","member":{}},"BS":{"type":"list","member":{"type":"blob"}}}},"Se":{"type":"list","member":{}},"Sk":{"type":"list","member":{"shape":"Sl"}},"Sl":{"type":"map","key":{},"value":{"shape":"S7"}},"So":{"type":"map","key":{},"value":{"type":"list","member":{"type":"structure","members":{"PutRequest":{"type":"structure","required":["Item"],"members":{"Item":{"shape":"Ss"}}},"DeleteRequest":{"type":"structure","required":["Key"],"members":{"Key":{"shape":"S6"}}}}}}},"Ss":{"type":"map","key":{},"value":{"shape":"S7"}},"Sy":{"type":"structure","required":["HashKeyElement"],"members":{"HashKeyElement":{"shape":"Sz"},"RangeKeyElement":{"shape":"Sz"}}},"Sz":{"type":"structure","required":["AttributeName","AttributeType"],"members":{"AttributeName":{},"AttributeType":{}}},"S12":{"type":"structure","required":["ReadCapacityUnits","WriteCapacityUnits"],"members":{"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S15":{"type":"structure","members":{"TableName":{},"KeySchema":{"shape":"Sy"},"TableStatus":{},"CreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"type":"structure","members":{"LastIncreaseDateTime":{"type":"timestamp"},"LastDecreaseDateTime":{"type":"timestamp"},"NumberOfDecreasesToday":{"type":"long"},"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"TableSizeBytes":{"type":"long"},"ItemCount":{"type":"long"}}},"S1b":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S7"},"Exists":{"type":"boolean"}}}},"S1u":{"type":"structure","required":["ComparisonOperator"],"members":{"AttributeValueList":{"type":"list","member":{"shape":"S7"}},"ComparisonOperator":{}}}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.paginators.json":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.paginators.json ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"pagination":{"BatchGetItem":{"input_token":"RequestItems","output_token":"UnprocessedKeys"},"ListTables":{"input_token":"ExclusiveStartTableName","limit_key":"Limit","output_token":"LastEvaluatedTableName","result_key":"TableNames"},"Query":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"},"Scan":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.waiters2.json":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/dynamodb-2011-12-05.waiters2.json ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":2,"waiters":{"TableExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ACTIVE","matcher":"path","state":"success","argument":"Table.TableStatus"},{"expected":"ResourceNotFoundException","matcher":"error","state":"retry"}]},"TableNotExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ResourceNotFoundException","matcher":"error","state":"success"}]}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.min.json":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.min.json ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2012-08-10","endpointPrefix":"dynamodb","jsonVersion":"1.0","protocol":"json","serviceAbbreviation":"DynamoDB","serviceFullName":"Amazon DynamoDB","serviceId":"DynamoDB","signatureVersion":"v4","targetPrefix":"DynamoDB_20120810","uid":"dynamodb-2012-08-10"},"operations":{"BatchExecuteStatement":{"input":{"type":"structure","required":["Statements"],"members":{"Statements":{"type":"list","member":{"type":"structure","required":["Statement"],"members":{"Statement":{},"Parameters":{"shape":"S5"},"ConsistentRead":{"type":"boolean"}}}},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"type":"list","member":{"type":"structure","members":{"Error":{"type":"structure","members":{"Code":{},"Message":{}}},"TableName":{},"Item":{"shape":"Sr"}}}},"ConsumedCapacity":{"shape":"Ss"}}}},"BatchGetItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"Sz"},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"shape":"S19"}},"UnprocessedKeys":{"shape":"Sz"},"ConsumedCapacity":{"shape":"Ss"}}},"endpointdiscovery":{}},"BatchWriteItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S1b"},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{}}},"output":{"type":"structure","members":{"UnprocessedItems":{"shape":"S1b"},"ItemCollectionMetrics":{"shape":"S1j"},"ConsumedCapacity":{"shape":"Ss"}}},"endpointdiscovery":{}},"CreateBackup":{"input":{"type":"structure","required":["TableName","BackupName"],"members":{"TableName":{},"BackupName":{}}},"output":{"type":"structure","members":{"BackupDetails":{"shape":"S1s"}}},"endpointdiscovery":{}},"CreateGlobalTable":{"input":{"type":"structure","required":["GlobalTableName","ReplicationGroup"],"members":{"GlobalTableName":{},"ReplicationGroup":{"shape":"S20"}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S24"}}},"endpointdiscovery":{}},"CreateTable":{"input":{"type":"structure","required":["AttributeDefinitions","TableName","KeySchema"],"members":{"AttributeDefinitions":{"shape":"S2k"},"TableName":{},"KeySchema":{"shape":"S2o"},"LocalSecondaryIndexes":{"shape":"S2r"},"GlobalSecondaryIndexes":{"shape":"S2x"},"BillingMode":{},"ProvisionedThroughput":{"shape":"S2z"},"StreamSpecification":{"shape":"S31"},"SSESpecification":{"shape":"S34"},"Tags":{"shape":"S37"},"TableClass":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"DeleteBackup":{"input":{"type":"structure","required":["BackupArn"],"members":{"BackupArn":{}}},"output":{"type":"structure","members":{"BackupDescription":{"shape":"S40"}}},"endpointdiscovery":{}},"DeleteItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S12"},"Expected":{"shape":"S4d"},"ConditionalOperator":{},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"},"ItemCollectionMetrics":{"shape":"S1l"}}},"endpointdiscovery":{}},"DeleteTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"DescribeBackup":{"input":{"type":"structure","required":["BackupArn"],"members":{"BackupArn":{}}},"output":{"type":"structure","members":{"BackupDescription":{"shape":"S40"}}},"endpointdiscovery":{}},"DescribeContinuousBackups":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"ContinuousBackupsDescription":{"shape":"S4u"}}},"endpointdiscovery":{}},"DescribeContributorInsights":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{}}},"output":{"type":"structure","members":{"TableName":{},"IndexName":{},"ContributorInsightsRuleList":{"type":"list","member":{}},"ContributorInsightsStatus":{},"LastUpdateDateTime":{"type":"timestamp"},"FailureException":{"type":"structure","members":{"ExceptionName":{},"ExceptionDescription":{}}}}}},"DescribeEndpoints":{"input":{"type":"structure","members":{}},"output":{"type":"structure","required":["Endpoints"],"members":{"Endpoints":{"type":"list","member":{"type":"structure","required":["Address","CachePeriodInMinutes"],"members":{"Address":{},"CachePeriodInMinutes":{"type":"long"}}}}}},"endpointoperation":true},"DescribeExport":{"input":{"type":"structure","required":["ExportArn"],"members":{"ExportArn":{}}},"output":{"type":"structure","members":{"ExportDescription":{"shape":"S5e"}}}},"DescribeGlobalTable":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S24"}}},"endpointdiscovery":{}},"DescribeGlobalTableSettings":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{}}},"output":{"type":"structure","members":{"GlobalTableName":{},"ReplicaSettings":{"shape":"S5y"}}},"endpointdiscovery":{}},"DescribeKinesisStreamingDestination":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableName":{},"KinesisDataStreamDestinations":{"type":"list","member":{"type":"structure","members":{"StreamArn":{},"DestinationStatus":{},"DestinationStatusDescription":{}}}}}},"endpointdiscovery":{}},"DescribeLimits":{"input":{"type":"structure","members":{}},"output":{"type":"structure","members":{"AccountMaxReadCapacityUnits":{"type":"long"},"AccountMaxWriteCapacityUnits":{"type":"long"},"TableMaxReadCapacityUnits":{"type":"long"},"TableMaxWriteCapacityUnits":{"type":"long"}}},"endpointdiscovery":{}},"DescribeTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"Table":{"shape":"S3c"}}},"endpointdiscovery":{}},"DescribeTableReplicaAutoScaling":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableAutoScalingDescription":{"shape":"S6k"}}}},"DescribeTimeToLive":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TimeToLiveDescription":{"shape":"S49"}}},"endpointdiscovery":{}},"DisableKinesisStreamingDestination":{"input":{"shape":"S6r"},"output":{"shape":"S6s"},"endpointdiscovery":{}},"EnableKinesisStreamingDestination":{"input":{"shape":"S6r"},"output":{"shape":"S6s"},"endpointdiscovery":{}},"ExecuteStatement":{"input":{"type":"structure","required":["Statement"],"members":{"Statement":{},"Parameters":{"shape":"S5"},"ConsistentRead":{"type":"boolean"},"NextToken":{},"ReturnConsumedCapacity":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"Items":{"shape":"S19"},"NextToken":{},"ConsumedCapacity":{"shape":"St"},"LastEvaluatedKey":{"shape":"S12"}}}},"ExecuteTransaction":{"input":{"type":"structure","required":["TransactStatements"],"members":{"TransactStatements":{"type":"list","member":{"type":"structure","required":["Statement"],"members":{"Statement":{},"Parameters":{"shape":"S5"}}}},"ClientRequestToken":{"idempotencyToken":true},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"shape":"S72"},"ConsumedCapacity":{"shape":"Ss"}}}},"ExportTableToPointInTime":{"input":{"type":"structure","required":["TableArn","S3Bucket"],"members":{"TableArn":{},"ExportTime":{"type":"timestamp"},"ClientToken":{"idempotencyToken":true},"S3Bucket":{},"S3BucketOwner":{},"S3Prefix":{},"S3SseAlgorithm":{},"S3SseKmsKeyId":{},"ExportFormat":{}}},"output":{"type":"structure","members":{"ExportDescription":{"shape":"S5e"}}}},"GetItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S12"},"AttributesToGet":{"shape":"S13"},"ConsistentRead":{"type":"boolean"},"ReturnConsumedCapacity":{},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"S15"}}},"output":{"type":"structure","members":{"Item":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"ListBackups":{"input":{"type":"structure","members":{"TableName":{},"Limit":{"type":"integer"},"TimeRangeLowerBound":{"type":"timestamp"},"TimeRangeUpperBound":{"type":"timestamp"},"ExclusiveStartBackupArn":{},"BackupType":{}}},"output":{"type":"structure","members":{"BackupSummaries":{"type":"list","member":{"type":"structure","members":{"TableName":{},"TableId":{},"TableArn":{},"BackupArn":{},"BackupName":{},"BackupCreationDateTime":{"type":"timestamp"},"BackupExpiryDateTime":{"type":"timestamp"},"BackupStatus":{},"BackupType":{},"BackupSizeBytes":{"type":"long"}}}},"LastEvaluatedBackupArn":{}}},"endpointdiscovery":{}},"ListContributorInsights":{"input":{"type":"structure","members":{"TableName":{},"NextToken":{},"MaxResults":{"type":"integer"}}},"output":{"type":"structure","members":{"ContributorInsightsSummaries":{"type":"list","member":{"type":"structure","members":{"TableName":{},"IndexName":{},"ContributorInsightsStatus":{}}}},"NextToken":{}}}},"ListExports":{"input":{"type":"structure","members":{"TableArn":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"ExportSummaries":{"type":"list","member":{"type":"structure","members":{"ExportArn":{},"ExportStatus":{}}}},"NextToken":{}}}},"ListGlobalTables":{"input":{"type":"structure","members":{"ExclusiveStartGlobalTableName":{},"Limit":{"type":"integer"},"RegionName":{}}},"output":{"type":"structure","members":{"GlobalTables":{"type":"list","member":{"type":"structure","members":{"GlobalTableName":{},"ReplicationGroup":{"shape":"S20"}}}},"LastEvaluatedGlobalTableName":{}}},"endpointdiscovery":{}},"ListTables":{"input":{"type":"structure","members":{"ExclusiveStartTableName":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"TableNames":{"type":"list","member":{}},"LastEvaluatedTableName":{}}},"endpointdiscovery":{}},"ListTagsOfResource":{"input":{"type":"structure","required":["ResourceArn"],"members":{"ResourceArn":{},"NextToken":{}}},"output":{"type":"structure","members":{"Tags":{"shape":"S37"},"NextToken":{}}},"endpointdiscovery":{}},"PutItem":{"input":{"type":"structure","required":["TableName","Item"],"members":{"TableName":{},"Item":{"shape":"S1f"},"Expected":{"shape":"S4d"},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ConditionalOperator":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"},"ItemCollectionMetrics":{"shape":"S1l"}}},"endpointdiscovery":{}},"Query":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{},"Select":{},"AttributesToGet":{"shape":"S13"},"Limit":{"type":"integer"},"ConsistentRead":{"type":"boolean"},"KeyConditions":{"type":"map","key":{},"value":{"shape":"S88"}},"QueryFilter":{"shape":"S89"},"ConditionalOperator":{},"ScanIndexForward":{"type":"boolean"},"ExclusiveStartKey":{"shape":"S12"},"ReturnConsumedCapacity":{},"ProjectionExpression":{},"FilterExpression":{},"KeyConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Items":{"shape":"S19"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S12"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"RestoreTableFromBackup":{"input":{"type":"structure","required":["TargetTableName","BackupArn"],"members":{"TargetTableName":{},"BackupArn":{},"BillingModeOverride":{},"GlobalSecondaryIndexOverride":{"shape":"S2x"},"LocalSecondaryIndexOverride":{"shape":"S2r"},"ProvisionedThroughputOverride":{"shape":"S2z"},"SSESpecificationOverride":{"shape":"S34"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"RestoreTableToPointInTime":{"input":{"type":"structure","required":["TargetTableName"],"members":{"SourceTableArn":{},"SourceTableName":{},"TargetTableName":{},"UseLatestRestorableTime":{"type":"boolean"},"RestoreDateTime":{"type":"timestamp"},"BillingModeOverride":{},"GlobalSecondaryIndexOverride":{"shape":"S2x"},"LocalSecondaryIndexOverride":{"shape":"S2r"},"ProvisionedThroughputOverride":{"shape":"S2z"},"SSESpecificationOverride":{"shape":"S34"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"Scan":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{},"AttributesToGet":{"shape":"S13"},"Limit":{"type":"integer"},"Select":{},"ScanFilter":{"shape":"S89"},"ConditionalOperator":{},"ExclusiveStartKey":{"shape":"S12"},"ReturnConsumedCapacity":{},"TotalSegments":{"type":"integer"},"Segment":{"type":"integer"},"ProjectionExpression":{},"FilterExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ConsistentRead":{"type":"boolean"}}},"output":{"type":"structure","members":{"Items":{"shape":"S19"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S12"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"TagResource":{"input":{"type":"structure","required":["ResourceArn","Tags"],"members":{"ResourceArn":{},"Tags":{"shape":"S37"}}},"endpointdiscovery":{}},"TransactGetItems":{"input":{"type":"structure","required":["TransactItems"],"members":{"TransactItems":{"type":"list","member":{"type":"structure","required":["Get"],"members":{"Get":{"type":"structure","required":["Key","TableName"],"members":{"Key":{"shape":"S12"},"TableName":{},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"S15"}}}}}},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"ConsumedCapacity":{"shape":"Ss"},"Responses":{"shape":"S72"}}},"endpointdiscovery":{}},"TransactWriteItems":{"input":{"type":"structure","required":["TransactItems"],"members":{"TransactItems":{"type":"list","member":{"type":"structure","members":{"ConditionCheck":{"type":"structure","required":["Key","TableName","ConditionExpression"],"members":{"Key":{"shape":"S12"},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}},"Put":{"type":"structure","required":["Item","TableName"],"members":{"Item":{"shape":"S1f"},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}},"Delete":{"type":"structure","required":["Key","TableName"],"members":{"Key":{"shape":"S12"},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}},"Update":{"type":"structure","required":["Key","UpdateExpression","TableName"],"members":{"Key":{"shape":"S12"},"UpdateExpression":{},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}}}}},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ClientRequestToken":{"idempotencyToken":true}}},"output":{"type":"structure","members":{"ConsumedCapacity":{"shape":"Ss"},"ItemCollectionMetrics":{"shape":"S1j"}}},"endpointdiscovery":{}},"UntagResource":{"input":{"type":"structure","required":["ResourceArn","TagKeys"],"members":{"ResourceArn":{},"TagKeys":{"type":"list","member":{}}}},"endpointdiscovery":{}},"UpdateContinuousBackups":{"input":{"type":"structure","required":["TableName","PointInTimeRecoverySpecification"],"members":{"TableName":{},"PointInTimeRecoverySpecification":{"type":"structure","required":["PointInTimeRecoveryEnabled"],"members":{"PointInTimeRecoveryEnabled":{"type":"boolean"}}}}},"output":{"type":"structure","members":{"ContinuousBackupsDescription":{"shape":"S4u"}}},"endpointdiscovery":{}},"UpdateContributorInsights":{"input":{"type":"structure","required":["TableName","ContributorInsightsAction"],"members":{"TableName":{},"IndexName":{},"ContributorInsightsAction":{}}},"output":{"type":"structure","members":{"TableName":{},"IndexName":{},"ContributorInsightsStatus":{}}}},"UpdateGlobalTable":{"input":{"type":"structure","required":["GlobalTableName","ReplicaUpdates"],"members":{"GlobalTableName":{},"ReplicaUpdates":{"type":"list","member":{"type":"structure","members":{"Create":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}},"Delete":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}}}}}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S24"}}},"endpointdiscovery":{}},"UpdateGlobalTableSettings":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{},"GlobalTableBillingMode":{},"GlobalTableProvisionedWriteCapacityUnits":{"type":"long"},"GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate":{"shape":"S9g"},"GlobalTableGlobalSecondaryIndexSettingsUpdate":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedWriteCapacityUnits":{"type":"long"},"ProvisionedWriteCapacityAutoScalingSettingsUpdate":{"shape":"S9g"}}}},"ReplicaSettingsUpdate":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaProvisionedReadCapacityUnits":{"type":"long"},"ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate":{"shape":"S9g"},"ReplicaGlobalSecondaryIndexSettingsUpdate":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedReadCapacityUnits":{"type":"long"},"ProvisionedReadCapacityAutoScalingSettingsUpdate":{"shape":"S9g"}}}},"ReplicaTableClass":{}}}}}},"output":{"type":"structure","members":{"GlobalTableName":{},"ReplicaSettings":{"shape":"S5y"}}},"endpointdiscovery":{}},"UpdateItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S12"},"AttributeUpdates":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S6"},"Action":{}}}},"Expected":{"shape":"S4d"},"ConditionalOperator":{},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"UpdateExpression":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"},"ItemCollectionMetrics":{"shape":"S1l"}}},"endpointdiscovery":{}},"UpdateTable":{"input":{"type":"structure","required":["TableName"],"members":{"AttributeDefinitions":{"shape":"S2k"},"TableName":{},"BillingMode":{},"ProvisionedThroughput":{"shape":"S2z"},"GlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"Update":{"type":"structure","required":["IndexName","ProvisionedThroughput"],"members":{"IndexName":{},"ProvisionedThroughput":{"shape":"S2z"}}},"Create":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"ProvisionedThroughput":{"shape":"S2z"}}},"Delete":{"type":"structure","required":["IndexName"],"members":{"IndexName":{}}}}}},"StreamSpecification":{"shape":"S31"},"SSESpecification":{"shape":"S34"},"ReplicaUpdates":{"type":"list","member":{"type":"structure","members":{"Create":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"KMSMasterKeyId":{},"ProvisionedThroughputOverride":{"shape":"S2b"},"GlobalSecondaryIndexes":{"shape":"Sa5"},"TableClassOverride":{}}},"Update":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"KMSMasterKeyId":{},"ProvisionedThroughputOverride":{"shape":"S2b"},"GlobalSecondaryIndexes":{"shape":"Sa5"},"TableClassOverride":{}}},"Delete":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}}}}},"TableClass":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"UpdateTableReplicaAutoScaling":{"input":{"type":"structure","required":["TableName"],"members":{"GlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"ProvisionedWriteCapacityAutoScalingUpdate":{"shape":"S9g"}}}},"TableName":{},"ProvisionedWriteCapacityAutoScalingUpdate":{"shape":"S9g"},"ReplicaUpdates":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaGlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"ProvisionedReadCapacityAutoScalingUpdate":{"shape":"S9g"}}}},"ReplicaProvisionedReadCapacityAutoScalingUpdate":{"shape":"S9g"}}}}}},"output":{"type":"structure","members":{"TableAutoScalingDescription":{"shape":"S6k"}}}},"UpdateTimeToLive":{"input":{"type":"structure","required":["TableName","TimeToLiveSpecification"],"members":{"TableName":{},"TimeToLiveSpecification":{"shape":"Saj"}}},"output":{"type":"structure","members":{"TimeToLiveSpecification":{"shape":"Saj"}}},"endpointdiscovery":{}}},"shapes":{"S5":{"type":"list","member":{"shape":"S6"}},"S6":{"type":"structure","members":{"S":{},"N":{},"B":{"type":"blob"},"SS":{"type":"list","member":{}},"NS":{"type":"list","member":{}},"BS":{"type":"list","member":{"type":"blob"}},"M":{"type":"map","key":{},"value":{"shape":"S6"}},"L":{"type":"list","member":{"shape":"S6"}},"NULL":{"type":"boolean"},"BOOL":{"type":"boolean"}}},"Sr":{"type":"map","key":{},"value":{"shape":"S6"}},"Ss":{"type":"list","member":{"shape":"St"}},"St":{"type":"structure","members":{"TableName":{},"CapacityUnits":{"type":"double"},"ReadCapacityUnits":{"type":"double"},"WriteCapacityUnits":{"type":"double"},"Table":{"shape":"Sv"},"LocalSecondaryIndexes":{"shape":"Sw"},"GlobalSecondaryIndexes":{"shape":"Sw"}}},"Sv":{"type":"structure","members":{"ReadCapacityUnits":{"type":"double"},"WriteCapacityUnits":{"type":"double"},"CapacityUnits":{"type":"double"}}},"Sw":{"type":"map","key":{},"value":{"shape":"Sv"}},"Sz":{"type":"map","key":{},"value":{"type":"structure","required":["Keys"],"members":{"Keys":{"type":"list","member":{"shape":"S12"}},"AttributesToGet":{"shape":"S13"},"ConsistentRead":{"type":"boolean"},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"S15"}}}},"S12":{"type":"map","key":{},"value":{"shape":"S6"}},"S13":{"type":"list","member":{}},"S15":{"type":"map","key":{},"value":{}},"S19":{"type":"list","member":{"shape":"Sr"}},"S1b":{"type":"map","key":{},"value":{"type":"list","member":{"type":"structure","members":{"PutRequest":{"type":"structure","required":["Item"],"members":{"Item":{"shape":"S1f"}}},"DeleteRequest":{"type":"structure","required":["Key"],"members":{"Key":{"shape":"S12"}}}}}}},"S1f":{"type":"map","key":{},"value":{"shape":"S6"}},"S1j":{"type":"map","key":{},"value":{"type":"list","member":{"shape":"S1l"}}},"S1l":{"type":"structure","members":{"ItemCollectionKey":{"type":"map","key":{},"value":{"shape":"S6"}},"SizeEstimateRangeGB":{"type":"list","member":{"type":"double"}}}},"S1s":{"type":"structure","required":["BackupArn","BackupName","BackupStatus","BackupType","BackupCreationDateTime"],"members":{"BackupArn":{},"BackupName":{},"BackupSizeBytes":{"type":"long"},"BackupStatus":{},"BackupType":{},"BackupCreationDateTime":{"type":"timestamp"},"BackupExpiryDateTime":{"type":"timestamp"}}},"S20":{"type":"list","member":{"type":"structure","members":{"RegionName":{}}}},"S24":{"type":"structure","members":{"ReplicationGroup":{"shape":"S25"},"GlobalTableArn":{},"CreationDateTime":{"type":"timestamp"},"GlobalTableStatus":{},"GlobalTableName":{}}},"S25":{"type":"list","member":{"type":"structure","members":{"RegionName":{},"ReplicaStatus":{},"ReplicaStatusDescription":{},"ReplicaStatusPercentProgress":{},"KMSMasterKeyId":{},"ProvisionedThroughputOverride":{"shape":"S2b"},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"ProvisionedThroughputOverride":{"shape":"S2b"}}}},"ReplicaInaccessibleDateTime":{"type":"timestamp"},"ReplicaTableClassSummary":{"shape":"S2f"}}}},"S2b":{"type":"structure","members":{"ReadCapacityUnits":{"type":"long"}}},"S2f":{"type":"structure","members":{"TableClass":{},"LastUpdateDateTime":{"type":"timestamp"}}},"S2k":{"type":"list","member":{"type":"structure","required":["AttributeName","AttributeType"],"members":{"AttributeName":{},"AttributeType":{}}}},"S2o":{"type":"list","member":{"type":"structure","required":["AttributeName","KeyType"],"members":{"AttributeName":{},"KeyType":{}}}},"S2r":{"type":"list","member":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"}}}},"S2t":{"type":"structure","members":{"ProjectionType":{},"NonKeyAttributes":{"type":"list","member":{}}}},"S2x":{"type":"list","member":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"ProvisionedThroughput":{"shape":"S2z"}}}},"S2z":{"type":"structure","required":["ReadCapacityUnits","WriteCapacityUnits"],"members":{"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S31":{"type":"structure","required":["StreamEnabled"],"members":{"StreamEnabled":{"type":"boolean"},"StreamViewType":{}}},"S34":{"type":"structure","members":{"Enabled":{"type":"boolean"},"SSEType":{},"KMSMasterKeyId":{}}},"S37":{"type":"list","member":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}}},"S3c":{"type":"structure","members":{"AttributeDefinitions":{"shape":"S2k"},"TableName":{},"KeySchema":{"shape":"S2o"},"TableStatus":{},"CreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"shape":"S3e"},"TableSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"TableArn":{},"TableId":{},"BillingModeSummary":{"shape":"S3i"},"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"IndexSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"IndexArn":{}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"IndexStatus":{},"Backfilling":{"type":"boolean"},"ProvisionedThroughput":{"shape":"S3e"},"IndexSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"IndexArn":{}}}},"StreamSpecification":{"shape":"S31"},"LatestStreamLabel":{},"LatestStreamArn":{},"GlobalTableVersion":{},"Replicas":{"shape":"S25"},"RestoreSummary":{"type":"structure","required":["RestoreDateTime","RestoreInProgress"],"members":{"SourceBackupArn":{},"SourceTableArn":{},"RestoreDateTime":{"type":"timestamp"},"RestoreInProgress":{"type":"boolean"}}},"SSEDescription":{"shape":"S3t"},"ArchivalSummary":{"type":"structure","members":{"ArchivalDateTime":{"type":"timestamp"},"ArchivalReason":{},"ArchivalBackupArn":{}}},"TableClassSummary":{"shape":"S2f"}}},"S3e":{"type":"structure","members":{"LastIncreaseDateTime":{"type":"timestamp"},"LastDecreaseDateTime":{"type":"timestamp"},"NumberOfDecreasesToday":{"type":"long"},"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S3i":{"type":"structure","members":{"BillingMode":{},"LastUpdateToPayPerRequestDateTime":{"type":"timestamp"}}},"S3t":{"type":"structure","members":{"Status":{},"SSEType":{},"KMSMasterKeyArn":{},"InaccessibleEncryptionDateTime":{"type":"timestamp"}}},"S40":{"type":"structure","members":{"BackupDetails":{"shape":"S1s"},"SourceTableDetails":{"type":"structure","required":["TableName","TableId","KeySchema","TableCreationDateTime","ProvisionedThroughput"],"members":{"TableName":{},"TableId":{},"TableArn":{},"TableSizeBytes":{"type":"long"},"KeySchema":{"shape":"S2o"},"TableCreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"shape":"S2z"},"ItemCount":{"type":"long"},"BillingMode":{}}},"SourceTableFeatureDetails":{"type":"structure","members":{"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"ProvisionedThroughput":{"shape":"S2z"}}}},"StreamDescription":{"shape":"S31"},"TimeToLiveDescription":{"shape":"S49"},"SSEDescription":{"shape":"S3t"}}}}},"S49":{"type":"structure","members":{"TimeToLiveStatus":{},"AttributeName":{}}},"S4d":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S6"},"Exists":{"type":"boolean"},"ComparisonOperator":{},"AttributeValueList":{"shape":"S4h"}}}},"S4h":{"type":"list","member":{"shape":"S6"}},"S4l":{"type":"map","key":{},"value":{"shape":"S6"}},"S4u":{"type":"structure","required":["ContinuousBackupsStatus"],"members":{"ContinuousBackupsStatus":{},"PointInTimeRecoveryDescription":{"type":"structure","members":{"PointInTimeRecoveryStatus":{},"EarliestRestorableDateTime":{"type":"timestamp"},"LatestRestorableDateTime":{"type":"timestamp"}}}}},"S5e":{"type":"structure","members":{"ExportArn":{},"ExportStatus":{},"StartTime":{"type":"timestamp"},"EndTime":{"type":"timestamp"},"ExportManifest":{},"TableArn":{},"TableId":{},"ExportTime":{"type":"timestamp"},"ClientToken":{},"S3Bucket":{},"S3BucketOwner":{},"S3Prefix":{},"S3SseAlgorithm":{},"S3SseKmsKeyId":{},"FailureCode":{},"FailureMessage":{},"ExportFormat":{},"BilledSizeBytes":{"type":"long"},"ItemCount":{"type":"long"}}},"S5y":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaStatus":{},"ReplicaBillingModeSummary":{"shape":"S3i"},"ReplicaProvisionedReadCapacityUnits":{"type":"long"},"ReplicaProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaProvisionedWriteCapacityUnits":{"type":"long"},"ReplicaProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaGlobalSecondaryIndexSettings":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"IndexStatus":{},"ProvisionedReadCapacityUnits":{"type":"long"},"ProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ProvisionedWriteCapacityUnits":{"type":"long"},"ProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"}}}},"ReplicaTableClassSummary":{"shape":"S2f"}}}},"S60":{"type":"structure","members":{"MinimumUnits":{"type":"long"},"MaximumUnits":{"type":"long"},"AutoScalingDisabled":{"type":"boolean"},"AutoScalingRoleArn":{},"ScalingPolicies":{"type":"list","member":{"type":"structure","members":{"PolicyName":{},"TargetTrackingScalingPolicyConfiguration":{"type":"structure","required":["TargetValue"],"members":{"DisableScaleIn":{"type":"boolean"},"ScaleInCooldown":{"type":"integer"},"ScaleOutCooldown":{"type":"integer"},"TargetValue":{"type":"double"}}}}}}}},"S6k":{"type":"structure","members":{"TableName":{},"TableStatus":{},"Replicas":{"type":"list","member":{"type":"structure","members":{"RegionName":{},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"IndexStatus":{},"ProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"}}}},"ReplicaProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaStatus":{}}}}}},"S6r":{"type":"structure","required":["TableName","StreamArn"],"members":{"TableName":{},"StreamArn":{}}},"S6s":{"type":"structure","members":{"TableName":{},"StreamArn":{},"DestinationStatus":{}}},"S72":{"type":"list","member":{"type":"structure","members":{"Item":{"shape":"Sr"}}}},"S88":{"type":"structure","required":["ComparisonOperator"],"members":{"AttributeValueList":{"shape":"S4h"},"ComparisonOperator":{}}},"S89":{"type":"map","key":{},"value":{"shape":"S88"}},"S9g":{"type":"structure","members":{"MinimumUnits":{"type":"long"},"MaximumUnits":{"type":"long"},"AutoScalingDisabled":{"type":"boolean"},"AutoScalingRoleArn":{},"ScalingPolicyUpdate":{"type":"structure","required":["TargetTrackingScalingPolicyConfiguration"],"members":{"PolicyName":{},"TargetTrackingScalingPolicyConfiguration":{"type":"structure","required":["TargetValue"],"members":{"DisableScaleIn":{"type":"boolean"},"ScaleInCooldown":{"type":"integer"},"ScaleOutCooldown":{"type":"integer"},"TargetValue":{"type":"double"}}}}}}},"Sa5":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedThroughputOverride":{"shape":"S2b"}}}},"Saj":{"type":"structure","required":["Enabled","AttributeName"],"members":{"Enabled":{"type":"boolean"},"AttributeName":{}}}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.paginators.json":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.paginators.json ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"pagination":{"BatchGetItem":{"input_token":"RequestItems","output_token":"UnprocessedKeys"},"ListContributorInsights":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken"},"ListExports":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken"},"ListTables":{"input_token":"ExclusiveStartTableName","limit_key":"Limit","output_token":"LastEvaluatedTableName","result_key":"TableNames"},"Query":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"},"Scan":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.waiters2.json":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/dynamodb-2012-08-10.waiters2.json ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":2,"waiters":{"TableExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ACTIVE","matcher":"path","state":"success","argument":"Table.TableStatus"},{"expected":"ResourceNotFoundException","matcher":"error","state":"retry"}]},"TableNotExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ResourceNotFoundException","matcher":"error","state":"success"}]}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/metadata.json":
/*!***********************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/metadata.json ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"acm":{"name":"ACM","cors":true},"apigateway":{"name":"APIGateway","cors":true},"applicationautoscaling":{"prefix":"application-autoscaling","name":"ApplicationAutoScaling","cors":true},"appstream":{"name":"AppStream"},"autoscaling":{"name":"AutoScaling","cors":true},"batch":{"name":"Batch"},"budgets":{"name":"Budgets"},"clouddirectory":{"name":"CloudDirectory","versions":["2016-05-10*"]},"cloudformation":{"name":"CloudFormation","cors":true},"cloudfront":{"name":"CloudFront","versions":["2013-05-12*","2013-11-11*","2014-05-31*","2014-10-21*","2014-11-06*","2015-04-17*","2015-07-27*","2015-09-17*","2016-01-13*","2016-01-28*","2016-08-01*","2016-08-20*","2016-09-07*","2016-09-29*","2016-11-25*","2017-03-25*","2017-10-30*","2018-06-18*","2018-11-05*","2019-03-26*"],"cors":true},"cloudhsm":{"name":"CloudHSM","cors":true},"cloudsearch":{"name":"CloudSearch"},"cloudsearchdomain":{"name":"CloudSearchDomain"},"cloudtrail":{"name":"CloudTrail","cors":true},"cloudwatch":{"prefix":"monitoring","name":"CloudWatch","cors":true},"cloudwatchevents":{"prefix":"events","name":"CloudWatchEvents","versions":["2014-02-03*"],"cors":true},"cloudwatchlogs":{"prefix":"logs","name":"CloudWatchLogs","cors":true},"codebuild":{"name":"CodeBuild","cors":true},"codecommit":{"name":"CodeCommit","cors":true},"codedeploy":{"name":"CodeDeploy","cors":true},"codepipeline":{"name":"CodePipeline","cors":true},"cognitoidentity":{"prefix":"cognito-identity","name":"CognitoIdentity","cors":true},"cognitoidentityserviceprovider":{"prefix":"cognito-idp","name":"CognitoIdentityServiceProvider","cors":true},"cognitosync":{"prefix":"cognito-sync","name":"CognitoSync","cors":true},"configservice":{"prefix":"config","name":"ConfigService","cors":true},"cur":{"name":"CUR","cors":true},"datapipeline":{"name":"DataPipeline"},"devicefarm":{"name":"DeviceFarm","cors":true},"directconnect":{"name":"DirectConnect","cors":true},"directoryservice":{"prefix":"ds","name":"DirectoryService"},"discovery":{"name":"Discovery"},"dms":{"name":"DMS"},"dynamodb":{"name":"DynamoDB","cors":true},"dynamodbstreams":{"prefix":"streams.dynamodb","name":"DynamoDBStreams","cors":true},"ec2":{"name":"EC2","versions":["2013-06-15*","2013-10-15*","2014-02-01*","2014-05-01*","2014-06-15*","2014-09-01*","2014-10-01*","2015-03-01*","2015-04-15*","2015-10-01*","2016-04-01*","2016-09-15*"],"cors":true},"ecr":{"name":"ECR","cors":true},"ecs":{"name":"ECS","cors":true},"efs":{"prefix":"elasticfilesystem","name":"EFS","cors":true},"elasticache":{"name":"ElastiCache","versions":["2012-11-15*","2014-03-24*","2014-07-15*","2014-09-30*"],"cors":true},"elasticbeanstalk":{"name":"ElasticBeanstalk","cors":true},"elb":{"prefix":"elasticloadbalancing","name":"ELB","cors":true},"elbv2":{"prefix":"elasticloadbalancingv2","name":"ELBv2","cors":true},"emr":{"prefix":"elasticmapreduce","name":"EMR","cors":true},"es":{"name":"ES"},"elastictranscoder":{"name":"ElasticTranscoder","cors":true},"firehose":{"name":"Firehose","cors":true},"gamelift":{"name":"GameLift","cors":true},"glacier":{"name":"Glacier"},"health":{"name":"Health"},"iam":{"name":"IAM","cors":true},"importexport":{"name":"ImportExport"},"inspector":{"name":"Inspector","versions":["2015-08-18*"],"cors":true},"iot":{"name":"Iot","cors":true},"iotdata":{"prefix":"iot-data","name":"IotData","cors":true},"kinesis":{"name":"Kinesis","cors":true},"kinesisanalytics":{"name":"KinesisAnalytics"},"kms":{"name":"KMS","cors":true},"lambda":{"name":"Lambda","cors":true},"lexruntime":{"prefix":"runtime.lex","name":"LexRuntime","cors":true},"lightsail":{"name":"Lightsail"},"machinelearning":{"name":"MachineLearning","cors":true},"marketplacecommerceanalytics":{"name":"MarketplaceCommerceAnalytics","cors":true},"marketplacemetering":{"prefix":"meteringmarketplace","name":"MarketplaceMetering"},"mturk":{"prefix":"mturk-requester","name":"MTurk","cors":true},"mobileanalytics":{"name":"MobileAnalytics","cors":true},"opsworks":{"name":"OpsWorks","cors":true},"opsworkscm":{"name":"OpsWorksCM"},"organizations":{"name":"Organizations"},"pinpoint":{"name":"Pinpoint"},"polly":{"name":"Polly","cors":true},"rds":{"name":"RDS","versions":["2014-09-01*"],"cors":true},"redshift":{"name":"Redshift","cors":true},"rekognition":{"name":"Rekognition","cors":true},"resourcegroupstaggingapi":{"name":"ResourceGroupsTaggingAPI"},"route53":{"name":"Route53","cors":true},"route53domains":{"name":"Route53Domains","cors":true},"s3":{"name":"S3","dualstackAvailable":true,"cors":true},"s3control":{"name":"S3Control","dualstackAvailable":true,"xmlNoDefaultLists":true},"servicecatalog":{"name":"ServiceCatalog","cors":true},"ses":{"prefix":"email","name":"SES","cors":true},"shield":{"name":"Shield"},"simpledb":{"prefix":"sdb","name":"SimpleDB"},"sms":{"name":"SMS"},"snowball":{"name":"Snowball"},"sns":{"name":"SNS","cors":true},"sqs":{"name":"SQS","cors":true},"ssm":{"name":"SSM","cors":true},"storagegateway":{"name":"StorageGateway","cors":true},"stepfunctions":{"prefix":"states","name":"StepFunctions"},"sts":{"name":"STS","cors":true},"support":{"name":"Support"},"swf":{"name":"SWF"},"xray":{"name":"XRay","cors":true},"waf":{"name":"WAF","cors":true},"wafregional":{"prefix":"waf-regional","name":"WAFRegional"},"workdocs":{"name":"WorkDocs","cors":true},"workspaces":{"name":"WorkSpaces"},"codestar":{"name":"CodeStar"},"lexmodelbuildingservice":{"prefix":"lex-models","name":"LexModelBuildingService","cors":true},"marketplaceentitlementservice":{"prefix":"entitlement.marketplace","name":"MarketplaceEntitlementService"},"athena":{"name":"Athena","cors":true},"greengrass":{"name":"Greengrass"},"dax":{"name":"DAX"},"migrationhub":{"prefix":"AWSMigrationHub","name":"MigrationHub"},"cloudhsmv2":{"name":"CloudHSMV2","cors":true},"glue":{"name":"Glue"},"mobile":{"name":"Mobile"},"pricing":{"name":"Pricing","cors":true},"costexplorer":{"prefix":"ce","name":"CostExplorer","cors":true},"mediaconvert":{"name":"MediaConvert"},"medialive":{"name":"MediaLive"},"mediapackage":{"name":"MediaPackage"},"mediastore":{"name":"MediaStore"},"mediastoredata":{"prefix":"mediastore-data","name":"MediaStoreData","cors":true},"appsync":{"name":"AppSync"},"guardduty":{"name":"GuardDuty"},"mq":{"name":"MQ"},"comprehend":{"name":"Comprehend","cors":true},"iotjobsdataplane":{"prefix":"iot-jobs-data","name":"IoTJobsDataPlane"},"kinesisvideoarchivedmedia":{"prefix":"kinesis-video-archived-media","name":"KinesisVideoArchivedMedia","cors":true},"kinesisvideomedia":{"prefix":"kinesis-video-media","name":"KinesisVideoMedia","cors":true},"kinesisvideo":{"name":"KinesisVideo","cors":true},"sagemakerruntime":{"prefix":"runtime.sagemaker","name":"SageMakerRuntime"},"sagemaker":{"name":"SageMaker"},"translate":{"name":"Translate","cors":true},"resourcegroups":{"prefix":"resource-groups","name":"ResourceGroups","cors":true},"alexaforbusiness":{"name":"AlexaForBusiness"},"cloud9":{"name":"Cloud9"},"serverlessapplicationrepository":{"prefix":"serverlessrepo","name":"ServerlessApplicationRepository"},"servicediscovery":{"name":"ServiceDiscovery"},"workmail":{"name":"WorkMail"},"autoscalingplans":{"prefix":"autoscaling-plans","name":"AutoScalingPlans"},"transcribeservice":{"prefix":"transcribe","name":"TranscribeService"},"connect":{"name":"Connect","cors":true},"acmpca":{"prefix":"acm-pca","name":"ACMPCA"},"fms":{"name":"FMS"},"secretsmanager":{"name":"SecretsManager","cors":true},"iotanalytics":{"name":"IoTAnalytics","cors":true},"iot1clickdevicesservice":{"prefix":"iot1click-devices","name":"IoT1ClickDevicesService"},"iot1clickprojects":{"prefix":"iot1click-projects","name":"IoT1ClickProjects"},"pi":{"name":"PI"},"neptune":{"name":"Neptune"},"mediatailor":{"name":"MediaTailor"},"eks":{"name":"EKS"},"macie":{"name":"Macie"},"dlm":{"name":"DLM"},"signer":{"name":"Signer"},"chime":{"name":"Chime"},"pinpointemail":{"prefix":"pinpoint-email","name":"PinpointEmail"},"ram":{"name":"RAM"},"route53resolver":{"name":"Route53Resolver"},"pinpointsmsvoice":{"prefix":"sms-voice","name":"PinpointSMSVoice"},"quicksight":{"name":"QuickSight"},"rdsdataservice":{"prefix":"rds-data","name":"RDSDataService"},"amplify":{"name":"Amplify"},"datasync":{"name":"DataSync"},"robomaker":{"name":"RoboMaker"},"transfer":{"name":"Transfer"},"globalaccelerator":{"name":"GlobalAccelerator"},"comprehendmedical":{"name":"ComprehendMedical","cors":true},"kinesisanalyticsv2":{"name":"KinesisAnalyticsV2"},"mediaconnect":{"name":"MediaConnect"},"fsx":{"name":"FSx"},"securityhub":{"name":"SecurityHub"},"appmesh":{"name":"AppMesh","versions":["2018-10-01*"]},"licensemanager":{"prefix":"license-manager","name":"LicenseManager"},"kafka":{"name":"Kafka"},"apigatewaymanagementapi":{"name":"ApiGatewayManagementApi"},"apigatewayv2":{"name":"ApiGatewayV2"},"docdb":{"name":"DocDB"},"backup":{"name":"Backup"},"worklink":{"name":"WorkLink"},"textract":{"name":"Textract"},"managedblockchain":{"name":"ManagedBlockchain"},"mediapackagevod":{"prefix":"mediapackage-vod","name":"MediaPackageVod"},"groundstation":{"name":"GroundStation"},"iotthingsgraph":{"name":"IoTThingsGraph"},"iotevents":{"name":"IoTEvents"},"ioteventsdata":{"prefix":"iotevents-data","name":"IoTEventsData"},"personalize":{"name":"Personalize","cors":true},"personalizeevents":{"prefix":"personalize-events","name":"PersonalizeEvents","cors":true},"personalizeruntime":{"prefix":"personalize-runtime","name":"PersonalizeRuntime","cors":true},"applicationinsights":{"prefix":"application-insights","name":"ApplicationInsights"},"servicequotas":{"prefix":"service-quotas","name":"ServiceQuotas"},"ec2instanceconnect":{"prefix":"ec2-instance-connect","name":"EC2InstanceConnect"},"eventbridge":{"name":"EventBridge"},"lakeformation":{"name":"LakeFormation"},"forecastservice":{"prefix":"forecast","name":"ForecastService","cors":true},"forecastqueryservice":{"prefix":"forecastquery","name":"ForecastQueryService","cors":true},"qldb":{"name":"QLDB"},"qldbsession":{"prefix":"qldb-session","name":"QLDBSession"},"workmailmessageflow":{"name":"WorkMailMessageFlow"},"codestarnotifications":{"prefix":"codestar-notifications","name":"CodeStarNotifications"},"savingsplans":{"name":"SavingsPlans"},"sso":{"name":"SSO"},"ssooidc":{"prefix":"sso-oidc","name":"SSOOIDC"},"marketplacecatalog":{"prefix":"marketplace-catalog","name":"MarketplaceCatalog"},"dataexchange":{"name":"DataExchange"},"sesv2":{"name":"SESV2"},"migrationhubconfig":{"prefix":"migrationhub-config","name":"MigrationHubConfig"},"connectparticipant":{"name":"ConnectParticipant"},"appconfig":{"name":"AppConfig"},"iotsecuretunneling":{"name":"IoTSecureTunneling"},"wafv2":{"name":"WAFV2"},"elasticinference":{"prefix":"elastic-inference","name":"ElasticInference"},"imagebuilder":{"name":"Imagebuilder"},"schemas":{"name":"Schemas"},"accessanalyzer":{"name":"AccessAnalyzer"},"codegurureviewer":{"prefix":"codeguru-reviewer","name":"CodeGuruReviewer"},"codeguruprofiler":{"name":"CodeGuruProfiler"},"computeoptimizer":{"prefix":"compute-optimizer","name":"ComputeOptimizer"},"frauddetector":{"name":"FraudDetector"},"kendra":{"name":"Kendra"},"networkmanager":{"name":"NetworkManager"},"outposts":{"name":"Outposts"},"augmentedairuntime":{"prefix":"sagemaker-a2i-runtime","name":"AugmentedAIRuntime"},"ebs":{"name":"EBS"},"kinesisvideosignalingchannels":{"prefix":"kinesis-video-signaling","name":"KinesisVideoSignalingChannels","cors":true},"detective":{"name":"Detective"},"codestarconnections":{"prefix":"codestar-connections","name":"CodeStarconnections"},"synthetics":{"name":"Synthetics"},"iotsitewise":{"name":"IoTSiteWise"},"macie2":{"name":"Macie2"},"codeartifact":{"name":"CodeArtifact"},"honeycode":{"name":"Honeycode"},"ivs":{"name":"IVS"},"braket":{"name":"Braket"},"identitystore":{"name":"IdentityStore"},"appflow":{"name":"Appflow"},"redshiftdata":{"prefix":"redshift-data","name":"RedshiftData"},"ssoadmin":{"prefix":"sso-admin","name":"SSOAdmin"},"timestreamquery":{"prefix":"timestream-query","name":"TimestreamQuery"},"timestreamwrite":{"prefix":"timestream-write","name":"TimestreamWrite"},"s3outposts":{"name":"S3Outposts"},"databrew":{"name":"DataBrew"},"servicecatalogappregistry":{"prefix":"servicecatalog-appregistry","name":"ServiceCatalogAppRegistry"},"networkfirewall":{"prefix":"network-firewall","name":"NetworkFirewall"},"mwaa":{"name":"MWAA"},"amplifybackend":{"name":"AmplifyBackend"},"appintegrations":{"name":"AppIntegrations"},"connectcontactlens":{"prefix":"connect-contact-lens","name":"ConnectContactLens"},"devopsguru":{"prefix":"devops-guru","name":"DevOpsGuru"},"ecrpublic":{"prefix":"ecr-public","name":"ECRPUBLIC"},"lookoutvision":{"name":"LookoutVision"},"sagemakerfeaturestoreruntime":{"prefix":"sagemaker-featurestore-runtime","name":"SageMakerFeatureStoreRuntime"},"customerprofiles":{"prefix":"customer-profiles","name":"CustomerProfiles"},"auditmanager":{"name":"AuditManager"},"emrcontainers":{"prefix":"emr-containers","name":"EMRcontainers"},"healthlake":{"name":"HealthLake"},"sagemakeredge":{"prefix":"sagemaker-edge","name":"SagemakerEdge"},"amp":{"name":"Amp"},"greengrassv2":{"name":"GreengrassV2"},"iotdeviceadvisor":{"name":"IotDeviceAdvisor"},"iotfleethub":{"name":"IoTFleetHub"},"iotwireless":{"name":"IoTWireless"},"location":{"name":"Location","cors":true},"wellarchitected":{"name":"WellArchitected"},"lexmodelsv2":{"prefix":"models.lex.v2","name":"LexModelsV2"},"lexruntimev2":{"prefix":"runtime.lex.v2","name":"LexRuntimeV2","cors":true},"fis":{"name":"Fis"},"lookoutmetrics":{"name":"LookoutMetrics"},"mgn":{"name":"Mgn"},"lookoutequipment":{"name":"LookoutEquipment"},"nimble":{"name":"Nimble"},"finspace":{"name":"Finspace"},"finspacedata":{"prefix":"finspace-data","name":"Finspacedata"},"ssmcontacts":{"prefix":"ssm-contacts","name":"SSMContacts"},"ssmincidents":{"prefix":"ssm-incidents","name":"SSMIncidents"},"applicationcostprofiler":{"name":"ApplicationCostProfiler"},"apprunner":{"name":"AppRunner"},"proton":{"name":"Proton"},"route53recoverycluster":{"prefix":"route53-recovery-cluster","name":"Route53RecoveryCluster"},"route53recoverycontrolconfig":{"prefix":"route53-recovery-control-config","name":"Route53RecoveryControlConfig"},"route53recoveryreadiness":{"prefix":"route53-recovery-readiness","name":"Route53RecoveryReadiness"},"chimesdkidentity":{"prefix":"chime-sdk-identity","name":"ChimeSDKIdentity"},"chimesdkmessaging":{"prefix":"chime-sdk-messaging","name":"ChimeSDKMessaging"},"snowdevicemanagement":{"prefix":"snow-device-management","name":"SnowDeviceManagement"},"memorydb":{"name":"MemoryDB"},"opensearch":{"name":"OpenSearch"},"kafkaconnect":{"name":"KafkaConnect"},"voiceid":{"prefix":"voice-id","name":"VoiceID"},"wisdom":{"name":"Wisdom"},"account":{"name":"Account"},"cloudcontrol":{"name":"CloudControl"},"grafana":{"name":"Grafana"},"panorama":{"name":"Panorama"},"chimesdkmeetings":{"prefix":"chime-sdk-meetings","name":"ChimeSDKMeetings"},"resiliencehub":{"name":"Resiliencehub"},"migrationhubstrategy":{"name":"MigrationHubStrategy"},"appconfigdata":{"name":"AppConfigData"},"drs":{"name":"Drs"},"migrationhubrefactorspaces":{"prefix":"migration-hub-refactor-spaces","name":"MigrationHubRefactorSpaces"},"evidently":{"name":"Evidently"},"inspector2":{"name":"Inspector2"},"rbin":{"name":"Rbin"},"rum":{"name":"RUM"},"backupgateway":{"prefix":"backup-gateway","name":"BackupGateway"},"iottwinmaker":{"name":"IoTTwinMaker"},"workspacesweb":{"prefix":"workspaces-web","name":"WorkSpacesWeb"},"amplifyuibuilder":{"name":"AmplifyUIBuilder"},"keyspaces":{"name":"Keyspaces"},"billingconductor":{"name":"Billingconductor"},"gamesparks":{"name":"GameSparks"},"pinpointsmsvoicev2":{"prefix":"pinpoint-sms-voice-v2","name":"PinpointSMSVoiceV2"},"ivschat":{"name":"Ivschat"},"chimesdkmediapipelines":{"prefix":"chime-sdk-media-pipelines","name":"ChimeSDKMediaPipelines"}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/sts-2011-06-15.min.json":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/sts-2011-06-15.min.json ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2011-06-15","endpointPrefix":"sts","globalEndpoint":"sts.amazonaws.com","protocol":"query","serviceAbbreviation":"AWS STS","serviceFullName":"AWS Security Token Service","serviceId":"STS","signatureVersion":"v4","uid":"sts-2011-06-15","xmlNamespace":"https://sts.amazonaws.com/doc/2011-06-15/"},"operations":{"AssumeRole":{"input":{"type":"structure","required":["RoleArn","RoleSessionName"],"members":{"RoleArn":{},"RoleSessionName":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"},"Tags":{"shape":"S8"},"TransitiveTagKeys":{"type":"list","member":{}},"ExternalId":{},"SerialNumber":{},"TokenCode":{},"SourceIdentity":{}}},"output":{"resultWrapper":"AssumeRoleResult","type":"structure","members":{"Credentials":{"shape":"Si"},"AssumedRoleUser":{"shape":"Sn"},"PackedPolicySize":{"type":"integer"},"SourceIdentity":{}}}},"AssumeRoleWithSAML":{"input":{"type":"structure","required":["RoleArn","PrincipalArn","SAMLAssertion"],"members":{"RoleArn":{},"PrincipalArn":{},"SAMLAssertion":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithSAMLResult","type":"structure","members":{"Credentials":{"shape":"Si"},"AssumedRoleUser":{"shape":"Sn"},"PackedPolicySize":{"type":"integer"},"Subject":{},"SubjectType":{},"Issuer":{},"Audience":{},"NameQualifier":{},"SourceIdentity":{}}}},"AssumeRoleWithWebIdentity":{"input":{"type":"structure","required":["RoleArn","RoleSessionName","WebIdentityToken"],"members":{"RoleArn":{},"RoleSessionName":{},"WebIdentityToken":{},"ProviderId":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithWebIdentityResult","type":"structure","members":{"Credentials":{"shape":"Si"},"SubjectFromWebIdentityToken":{},"AssumedRoleUser":{"shape":"Sn"},"PackedPolicySize":{"type":"integer"},"Provider":{},"Audience":{},"SourceIdentity":{}}}},"DecodeAuthorizationMessage":{"input":{"type":"structure","required":["EncodedMessage"],"members":{"EncodedMessage":{}}},"output":{"resultWrapper":"DecodeAuthorizationMessageResult","type":"structure","members":{"DecodedMessage":{}}}},"GetAccessKeyInfo":{"input":{"type":"structure","required":["AccessKeyId"],"members":{"AccessKeyId":{}}},"output":{"resultWrapper":"GetAccessKeyInfoResult","type":"structure","members":{"Account":{}}}},"GetCallerIdentity":{"input":{"type":"structure","members":{}},"output":{"resultWrapper":"GetCallerIdentityResult","type":"structure","members":{"UserId":{},"Account":{},"Arn":{}}}},"GetFederationToken":{"input":{"type":"structure","required":["Name"],"members":{"Name":{},"Policy":{},"PolicyArns":{"shape":"S4"},"DurationSeconds":{"type":"integer"},"Tags":{"shape":"S8"}}},"output":{"resultWrapper":"GetFederationTokenResult","type":"structure","members":{"Credentials":{"shape":"Si"},"FederatedUser":{"type":"structure","required":["FederatedUserId","Arn"],"members":{"FederatedUserId":{},"Arn":{}}},"PackedPolicySize":{"type":"integer"}}}},"GetSessionToken":{"input":{"type":"structure","members":{"DurationSeconds":{"type":"integer"},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"GetSessionTokenResult","type":"structure","members":{"Credentials":{"shape":"Si"}}}}},"shapes":{"S4":{"type":"list","member":{"type":"structure","members":{"arn":{}}}},"S8":{"type":"list","member":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}}},"Si":{"type":"structure","required":["AccessKeyId","SecretAccessKey","SessionToken","Expiration"],"members":{"AccessKeyId":{},"SecretAccessKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}},"Sn":{"type":"structure","required":["AssumedRoleId","Arn"],"members":{"AssumedRoleId":{},"Arn":{}}}}}');

/***/ }),

/***/ "../../../../node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json":
/*!****************************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = {"pagination":{}};

/***/ }),

/***/ "../../../../node_modules/aws-sdk/lib/region_config_data.json":
/*!********************************************************************!*\
  !*** ../../../../node_modules/aws-sdk/lib/region_config_data.json ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"rules":{"*/*":{"endpoint":"{service}.{region}.amazonaws.com"},"cn-*/*":{"endpoint":"{service}.{region}.amazonaws.com.cn"},"us-iso-*/*":"usIso","us-isob-*/*":"usIsob","*/budgets":"globalSSL","*/cloudfront":"globalSSL","*/sts":"globalSSL","*/importexport":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2","globalEndpoint":true},"*/route53":"globalSSL","cn-*/route53":{"endpoint":"{service}.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-northwest-1"},"us-gov-*/route53":"globalGovCloud","us-iso-*/route53":{"endpoint":"{service}.c2s.ic.gov","globalEndpoint":true,"signingRegion":"us-iso-east-1"},"us-isob-*/route53":{"endpoint":"{service}.sc2s.sgov.gov","globalEndpoint":true,"signingRegion":"us-isob-east-1"},"*/waf":"globalSSL","*/iam":"globalSSL","cn-*/iam":{"endpoint":"{service}.cn-north-1.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-north-1"},"us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{"endpoint":"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3signature","us-west-1/s3":"s3signature","us-west-2/s3":"s3signature","eu-west-1/s3":"s3signature","ap-southeast-1/s3":"s3signature","ap-southeast-2/s3":"s3signature","ap-northeast-1/s3":"s3signature","sa-east-1/s3":"s3signature","us-east-1/s3":{"endpoint":"{service}.amazonaws.com","signatureVersion":"s3"},"us-east-1/sdb":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2"},"*/sdb":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"v2"}},"fipsRules":{"*/*":"fipsStandard","us-gov-*/*":"fipsStandard","us-iso-*/*":{"endpoint":"{service}-fips.{region}.c2s.ic.gov"},"us-iso-*/dms":"usIso","us-isob-*/*":{"endpoint":"{service}-fips.{region}.sc2s.sgov.gov"},"us-isob-*/dms":"usIsob","cn-*/*":{"endpoint":"{service}-fips.{region}.amazonaws.com.cn"},"*/api.ecr":"fips.api.ecr","*/api.sagemaker":"fips.api.sagemaker","*/batch":"fipsDotPrefix","*/eks":"fipsDotPrefix","*/models.lex":"fips.models.lex","*/runtime.lex":"fips.runtime.lex","*/runtime.sagemaker":{"endpoint":"runtime-fips.sagemaker.{region}.amazonaws.com"},"*/iam":"fipsWithoutRegion","*/route53":"fipsWithoutRegion","*/transcribe":"fipsDotPrefix","*/waf":"fipsWithoutRegion","us-gov-*/transcribe":"fipsDotPrefix","us-gov-*/api.ecr":"fips.api.ecr","us-gov-*/api.sagemaker":"fips.api.sagemaker","us-gov-*/models.lex":"fips.models.lex","us-gov-*/runtime.lex":"fips.runtime.lex","us-gov-*/acm-pca":"fipsWithServiceOnly","us-gov-*/batch":"fipsWithServiceOnly","us-gov-*/config":"fipsWithServiceOnly","us-gov-*/eks":"fipsWithServiceOnly","us-gov-*/elasticmapreduce":"fipsWithServiceOnly","us-gov-*/identitystore":"fipsWithServiceOnly","us-gov-*/dynamodb":"fipsWithServiceOnly","us-gov-*/elasticloadbalancing":"fipsWithServiceOnly","us-gov-*/guardduty":"fipsWithServiceOnly","us-gov-*/monitoring":"fipsWithServiceOnly","us-gov-*/resource-groups":"fipsWithServiceOnly","us-gov-*/runtime.sagemaker":"fipsWithServiceOnly","us-gov-*/servicecatalog-appregistry":"fipsWithServiceOnly","us-gov-*/servicequotas":"fipsWithServiceOnly","us-gov-*/ssm":"fipsWithServiceOnly","us-gov-*/sts":"fipsWithServiceOnly","us-gov-*/support":"fipsWithServiceOnly","us-gov-west-1/states":"fipsWithServiceOnly","us-iso-east-1/elasticfilesystem":{"endpoint":"elasticfilesystem-fips.{region}.c2s.ic.gov"},"us-gov-west-1/organizations":"fipsWithServiceOnly","us-gov-west-1/route53":{"endpoint":"route53.us-gov.amazonaws.com"}},"dualstackRules":{"*/*":{"endpoint":"{service}.{region}.api.aws"},"cn-*/*":{"endpoint":"{service}.{region}.api.amazonwebservices.com.cn"},"*/s3":"dualstackLegacy","cn-*/s3":"dualstackLegacyCn","*/s3-control":"dualstackLegacy","cn-*/s3-control":"dualstackLegacyCn","ap-south-1/ec2":"dualstackLegacyEc2","eu-west-1/ec2":"dualstackLegacyEc2","sa-east-1/ec2":"dualstackLegacyEc2","us-east-1/ec2":"dualstackLegacyEc2","us-east-2/ec2":"dualstackLegacyEc2","us-west-2/ec2":"dualstackLegacyEc2"},"dualstackFipsRules":{"*/*":{"endpoint":"{service}-fips.{region}.api.aws"},"cn-*/*":{"endpoint":"{service}-fips.{region}.api.amazonwebservices.com.cn"},"*/s3":"dualstackFipsLegacy","cn-*/s3":"dualstackFipsLegacyCn","*/s3-control":"dualstackFipsLegacy","cn-*/s3-control":"dualstackFipsLegacyCn"},"patterns":{"globalSSL":{"endpoint":"https://{service}.amazonaws.com","globalEndpoint":true,"signingRegion":"us-east-1"},"globalGovCloud":{"endpoint":"{service}.us-gov.amazonaws.com","globalEndpoint":true,"signingRegion":"us-gov-west-1"},"s3signature":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"s3"},"usIso":{"endpoint":"{service}.{region}.c2s.ic.gov"},"usIsob":{"endpoint":"{service}.{region}.sc2s.sgov.gov"},"fipsStandard":{"endpoint":"{service}-fips.{region}.amazonaws.com"},"fipsDotPrefix":{"endpoint":"fips.{service}.{region}.amazonaws.com"},"fipsWithoutRegion":{"endpoint":"{service}-fips.amazonaws.com"},"fips.api.ecr":{"endpoint":"ecr-fips.{region}.amazonaws.com"},"fips.api.sagemaker":{"endpoint":"api-fips.sagemaker.{region}.amazonaws.com"},"fips.models.lex":{"endpoint":"models-fips.lex.{region}.amazonaws.com"},"fips.runtime.lex":{"endpoint":"runtime-fips.lex.{region}.amazonaws.com"},"fipsWithServiceOnly":{"endpoint":"{service}.{region}.amazonaws.com"},"dualstackLegacy":{"endpoint":"{service}.dualstack.{region}.amazonaws.com"},"dualstackLegacyCn":{"endpoint":"{service}.dualstack.{region}.amazonaws.com.cn"},"dualstackFipsLegacy":{"endpoint":"{service}-fips.dualstack.{region}.amazonaws.com"},"dualstackFipsLegacyCn":{"endpoint":"{service}-fips.dualstack.{region}.amazonaws.com.cn"},"dualstackLegacyEc2":{"endpoint":"api.ec2.{region}.aws"}}}');

/***/ }),

/***/ "../../../../node_modules/builtins/builtins.json":
/*!*******************************************************!*\
  !*** ../../../../node_modules/builtins/builtins.json ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","process","punycode","querystring","readline","repl","stream","string_decoder","timers","tls","tty","url","util","v8","vm","zlib"]');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lambda/post-controller/handler.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcm5CQSxVQUFVLG1CQUFPLENBQUMsNERBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTSxtQkFBTyxDQUFDLDREQUFROztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGdGQUFrQjtBQUNyQyxVQUFVLG1CQUFPLENBQUMsOEVBQWlCO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLHNGQUFxQjtBQUMxQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBFQUFlO0FBQ3BDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDckMsWUFBWSxtQkFBTyxDQUFDLDBFQUFlO0FBQ25DLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsc0VBQWE7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLGtGQUFtQjtBQUMxQyxXQUFXLG1CQUFPLENBQUMsMEVBQWU7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLGtGQUFtQjtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDckQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsd0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzSUFBaUQ7QUFDbEUsQ0FBQztBQUNELG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsa0VBQVc7QUFDbkIsbUJBQU8sQ0FBQyxnRUFBVTtBQUNsQixtQkFBTyxDQUFDLDREQUFRO0FBQ2hCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsa0VBQVc7QUFDbkIsbUJBQU8sQ0FBQyxvRUFBWTtBQUNwQixtQkFBTyxDQUFDLGtGQUFtQjtBQUMzQixtQkFBTyxDQUFDLGdHQUEwQjtBQUNsQyxtQkFBTyxDQUFDLGtGQUFtQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUM1R0QsVUFBVSxtQkFBTyxDQUFDLDREQUFROztBQUUxQjtBQUNBO0FBQ0EsSUFBSSxZQUFZLEdBQUcsZ0JBQWdCLGdCQUFnQixhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLEtBQUssYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLGtCQUFrQixLQUFLO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLGtCQUFrQixLQUFLO0FBQy9EOztBQUVBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSxHQUFHLGlCQUFpQixjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ3JQQSxVQUFVLG1CQUFPLENBQUMsNkRBQVM7QUFDM0IsVUFBVSxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFckM7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBLElBQUkseUJBQXlCO0FBQzdCLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFFBQVEsb0JBQW9CLElBQUkseUJBQXlCO0FBQ3pEO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3RELE1BQU0sd0JBQXdCO0FBQzlCLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUN2TUQsVUFBVSxtQkFBTyxDQUFDLDZEQUFTO0FBQzNCLHNCQUFzQixtQkFBTyxDQUFDLGtHQUErQjtBQUM3RCxVQUFVLG1CQUFPLENBQUMsMEVBQW1COztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQ0FBK0M7QUFDbkQ7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2Qyx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSxtQ0FBbUM7QUFDM0MsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBOEM7QUFDdEQsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQ0FBbUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0Esa0NBQWtDLDhDQUE4QztBQUNoRixTQUFTLGtDQUFrQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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QUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7QUNsSEQsVUFBVSxtQkFBTyxDQUFDLDREQUFRO0FBQzFCLFdBQVcsbUJBQU8sQ0FBQyw0REFBUTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NB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Q0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSxjQUFjLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLG1CQUFPLENBQUMsd0ZBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0ZBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7QUN4b0JBLFVBQVUsbUJBQU8sQ0FBQyw0REFBUTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLFFBQVEscUJBQXFCO0FB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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUJBQXVCO0FBQzdCO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQscURBQXFELEtBQUssR0FBRztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEU7QUFDQSxzQ0FBc0MsS0FBSyxvQkFBb0IsS0FBSztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7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OUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7OztBQ3hNRCxVQUFVLG1CQUFPLENBQUMsNERBQVE7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUssZUFBZSxLQUFLO0FBQ3hELCtCQUErQixLQUFLO0FBQ3BDLFFBQVE7QUFDUiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQywwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hELGlEQUFpRCxLQUFLO0FBQ3RELCtDQUErQyxLQUFLO0FBQ3BELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMU9BLFVBQVUsbUJBQU8sQ0FBQyw0REFBUTtBQUMxQixVQUFVLG1CQUFPLENBQUMsc0VBQWE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWlCOztBQUU1QztBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0JBQStCO0FBQ3BFLE9BQU87QUFDUDtBQUNBLHFDQUFxQywrQkFBK0I7QUFDcEUsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixxQkFBcUIsUUFBUTtBQUM3QixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7QUFD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O0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEI7QUFDOUIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ROQSxVQUFVLG1CQUFPLENBQUMsNkRBQVM7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RSw2Q0FBNkMsaUJBQWlCO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcGlDQSxXQUFXLG1CQUFPLENBQUMsNkRBQVM7QUFDNUIsY0FBYyx1R0FBNkI7QUFDM0MsY0FBYyx1R0FBNkI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7Ozs7Ozs7Ozs7O0FDdkVSO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjs7Ozs7Ozs7OztBQzFHaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0I7QUFDaEIsK0JBQStCO0FBQy9CO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUUsb0JBQW9CO0FBQ3BCLG1DQUFtQywyQ0FBMkM7QUFDOUU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0NBQXdDO0FBQzNFLG9CQUFvQjtBQUNwQixtQ0FBbUMseUNBQXlDO0FBQzVFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWjtBQUNBLHNCQUFzQjtBQUN0QixZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixnQkFBZ0I7QUFDaEIsd0JBQXdCO0FBQ3hCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFtRDtBQUMxRTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQixpQkFBaUI7QUFDcEU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDLHFCQUFxQixFQUFFO0FBQzdFLGNBQWMsd0NBQXdDLDJCQUEyQixFQUFFO0FBQ25GLGVBQWUseUNBQXlDLHFCQUFxQixFQUFFO0FBQy9FO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNELHlCQUF5QixrQkFBa0IsRUFBRTtBQUM3QztBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixHQUFHLHFCQUFxQixFQUFFO0FBQ3pFLGdCQUFnQiwwQ0FBMEMscUJBQXFCLEVBQUU7QUFDakY7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEMsRUFBRTtBQUMxRTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixHQUFHLG9CQUFvQixFQUFFO0FBQ3hFO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDLEVBQUU7QUFDMUU7QUFDQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CLEdBQUcscUJBQXFCO0FBQ3BFLFNBQVM7QUFDVCxjQUFjLHdDQUF3QywyQkFBMkIsRUFBRTtBQUNuRjtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixHQUFHLHFCQUFxQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDLEVBQUU7QUFDMUU7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0IsR0FBRyxxQkFBcUI7QUFDcEUsU0FBUztBQUNULGVBQWUseUNBQXlDLGtCQUFrQixFQUFFO0FBQzVFLGVBQWUseUNBQXlDLHFCQUFxQixFQUFFO0FBQy9FLGlCQUFpQiwyQ0FBMkMscUJBQXFCLEVBQUU7QUFDbkYsZUFBZSx5Q0FBeUMsOENBQThDLEVBQUU7QUFDeEc7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0IsR0FBRyxxQkFBcUI7QUFDcEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDLEVBQUU7QUFDN0QscUJBQXFCLDRDQUE0QyxrQkFBa0IsRUFBRTtBQUNyRixzQkFBc0IsNkNBQTZDLGtCQUFrQixFQUFFO0FBQ3ZGLHNCQUFzQiw2Q0FBNkMsa0JBQWtCLEVBQUU7QUFDdkY7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxNQUE4QixHQUFHLENBQWtCLENBQUM7Ozs7Ozs7Ozs7OztBQ3ZvRDFDOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsZ0VBQWdFLG1CQUFPLENBQUMsaUtBQStDOztBQUV2SCx5Q0FBeUMsbUJBQU8sQ0FBQywrRkFBYzs7QUFFL0QsdUNBQXVDLHVDQUF1Qzs7QUFFOUUseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRTc4QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUN4R0w7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQix5REFBeUQsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SyxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7Ozs7Ozs7Ozs7O0FDdEhMOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0NBQWtDOztBQUVsQyw4QkFBOEI7O0FBRTlCLHlDQUF5QywwR0FBMEcsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRW5mLGdDQUFnQzs7QUFFaEMseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0IsdUJBQXVCLFlBQVksWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRS84QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7Ozs7Ozs7Ozs7O0FDbEVMOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0NBQWtDOztBQUVsQyw4QkFBOEI7O0FBRTlCLHlDQUF5QywwR0FBMEcsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRW5mLGdDQUFnQzs7QUFFaEMseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0IsdUJBQXVCLFlBQVksWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRS84QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQy9ETDs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHlDQUF5QyxtQkFBTyxDQUFDLGdHQUFlOztBQUVoRSwyQ0FBMkMsbUJBQU8sQ0FBQyxnSEFBZ0I7O0FBRW5FLHlDQUF5QyxtQkFBTyxDQUFDLDRHQUFjOztBQUUvRCwyQ0FBMkMsbUJBQU8sQ0FBQyxnSEFBZ0I7O0FBRW5FLDZEQUE2RCxtQkFBTyxDQUFDLDRKQUE2Qzs7QUFFbEgsNkRBQTZELG1CQUFPLENBQUMsNEpBQTZDOztBQUVsSCx1Q0FBdUMsdUNBQXVDOztBQUU5RSx5REFBeUQsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SyxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ3RJTDs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHlDQUF5QyxtQkFBTyxDQUFDLCtGQUFjOztBQUUvRCx5Q0FBeUMsbUJBQU8sQ0FBQywrRkFBYzs7QUFFL0QsdUNBQXVDLG1CQUFPLENBQUMsMkZBQVk7O0FBRTNELDJDQUEyQyxtQkFBTyxDQUFDLHlHQUFnQjs7QUFFbkUsOENBQThDLG1CQUFPLENBQUMseUdBQW1COztBQUV6RSwwREFBMEQsbUJBQU8sQ0FBQyxxSkFBeUM7O0FBRTNHLDBEQUEwRCxtQkFBTyxDQUFDLHFKQUF5Qzs7QUFFM0csZ0VBQWdFLG1CQUFPLENBQUMsaUtBQStDOztBQUV2SCx1REFBdUQsbUJBQU8sQ0FBQywrSUFBc0M7O0FBRXJHLHVEQUF1RCxtQkFBTyxDQUFDLCtJQUFzQzs7QUFFckcsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLGtDQUFrQzs7QUFFbEMsOEJBQThCOztBQUU5Qix5Q0FBeUMsMEdBQTBHLHdCQUF3QixlQUFlLGVBQWUsZ0JBQWdCLFlBQVksTUFBTSx3QkFBd0IsK0JBQStCLGFBQWEscUJBQXFCLHVDQUF1QyxjQUFjLFdBQVcsWUFBWSxVQUFVLE1BQU0sbURBQW1ELFVBQVUsc0JBQXNCOztBQUVuZixnQ0FBZ0M7O0FBRWhDLHlEQUF5RCxpRkFBaUYsV0FBVyx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHVCQUF1QixZQUFZLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVOztBQUUvOEIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLDhCQUE4QjtBQUM3Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7OztBQ3RiTDs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHVEQUF1RCxtQkFBTyxDQUFDLCtJQUFzQzs7QUFFckcscURBQXFELG1CQUFPLENBQUMsMklBQW9DOztBQUVqRyx1Q0FBdUMsdUNBQXVDOztBQUU5RSxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLDJDQUEyQztBQUNsRTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7OztBQ3RYTDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNyREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ2xETDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNyREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7Ozs7Ozs7Ozs7O0FDckRMOztBQUViLHdCQUF3QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUVwVyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDOztBQUV0dEIsMkNBQTJDLG1DQUFtQyxrQ0FBa0MsT0FBTyx3REFBd0QsZ0JBQWdCLHVCQUF1QixrREFBa0Qsa0NBQWtDLHVEQUF1RCxzQkFBc0I7O0FBRXZYLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsaUNBQWlDOztBQUVqQyxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSw4QkFBOEIsZ0dBQWdHLG1EQUFtRDs7QUFFakw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNsREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7Ozs7Ozs7Ozs7O0FDckRMOztBQUViLHdCQUF3QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUVwVyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDOztBQUV0dEIsMkNBQTJDLG1DQUFtQyxrQ0FBa0MsT0FBTyx3REFBd0QsZ0JBQWdCLHVCQUF1QixrREFBa0Qsa0NBQWtDLHVEQUF1RCxzQkFBc0I7O0FBRXZYLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsaUNBQWlDOztBQUVqQyxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSw4QkFBOEIsZ0dBQWdHLG1EQUFtRDs7QUFFakw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNsREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ2xETDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNyREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7Ozs7Ozs7Ozs7O0FDckRMOztBQUViLHdCQUF3QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUVwVyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDOztBQUV0dEIsMkNBQTJDLG1DQUFtQyxrQ0FBa0MsT0FBTyx3REFBd0QsZ0JBQWdCLHVCQUF1QixrREFBa0Qsa0NBQWtDLHVEQUF1RCxzQkFBc0I7O0FBRXZYLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsaUNBQWlDOztBQUVqQyxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSw4QkFBOEIsZ0dBQWdHLG1EQUFtRDs7QUFFakw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ3JETDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNyREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ2xETDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNyREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7Ozs7Ozs7Ozs7O0FDckRMOztBQUViLHdCQUF3QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUVwVyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDOztBQUV0dEIsMkNBQTJDLG1DQUFtQyxrQ0FBa0MsT0FBTyx3REFBd0QsZ0JBQWdCLHVCQUF1QixrREFBa0Qsa0NBQWtDLHVEQUF1RCxzQkFBc0I7O0FBRXZYLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsaUNBQWlDOztBQUVqQyxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSw4QkFBOEIsZ0dBQWdHLG1EQUFtRDs7QUFFakw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ3JETDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUNyREw7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQ2xETDs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHdDQUF3QyxtQkFBTyxDQUFDLDZGQUFhOztBQUU3RCwyQ0FBMkMsbUJBQU8sQ0FBQyxtR0FBZ0I7O0FBRW5FLCtDQUErQyxtQkFBTyxDQUFDLDJHQUFvQjs7QUFFM0Usc0RBQXNELG1CQUFPLENBQUMsNklBQXFDOztBQUVuRyx1REFBdUQsbUJBQU8sQ0FBQywrSUFBc0M7O0FBRXJHLDBEQUEwRCxtQkFBTyxDQUFDLHFKQUF5Qzs7QUFFM0csMERBQTBELG1CQUFPLENBQUMscUpBQXlDOztBQUUzRyx1REFBdUQsbUJBQU8sQ0FBQywrSUFBc0M7O0FBRXJHLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtDQUFrQzs7QUFFbEMsOEJBQThCOztBQUU5Qix5Q0FBeUMsMEdBQTBHLHdCQUF3QixlQUFlLGVBQWUsZ0JBQWdCLFlBQVksTUFBTSx3QkFBd0IsK0JBQStCLGFBQWEscUJBQXFCLHVDQUF1QyxjQUFjLFdBQVcsWUFBWSxVQUFVLE1BQU0sbURBQW1ELFVBQVUsc0JBQXNCOztBQUVuZixnQ0FBZ0M7O0FBRWhDLHlEQUF5RCxpRkFBaUYsV0FBVyx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHVCQUF1QixZQUFZLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVOztBQUUvOEIsMkNBQTJDLG1DQUFtQyxrQ0FBa0MsT0FBTyx3REFBd0QsZ0JBQWdCLHVCQUF1QixrREFBa0Qsa0NBQWtDLHVEQUF1RCxzQkFBc0I7O0FBRXZYLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksbUNBQW1DOztBQUVuQyxnQ0FBZ0M7O0FBRWhDLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3UyxrQ0FBa0M7O0FBRWxDLG1DQUFtQzs7QUFFbkMsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLGtHQUFRLFFBQVEsQ0FBQztBQUNoQyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7Ozs7Ozs7Ozs7QUM3V0w7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixtQ0FBbUMsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFakQsd0NBQXdDLG1CQUFPLENBQUMsZ0dBQWdCOztBQUVoRSwrQ0FBK0MsbUJBQU8sQ0FBQyw4R0FBdUI7O0FBRTlFLDJDQUEyQyxtQkFBTyxDQUFDLHNHQUFtQjs7QUFFdEUseUNBQXlDLG1CQUFPLENBQUMsa0dBQWlCOztBQUVsRSxxREFBcUQsbUJBQU8sQ0FBQyw4RkFBMkI7O0FBRXhGLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLHlEQUF5RCxpRkFBaUYsV0FBVyx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVOztBQUU3OEIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLFNBQVMsR0FBRztBQUNsQztBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHlHQUFRLGlEQUFpRCxDQUFDO0FBQ25GLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUdBQVEsV0FBVyxDQUFDO0FBQy9DLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSwwQkFBMEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7OztBQzVZTDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQiwwQ0FBMEMsbUJBQU8sQ0FBQyxzR0FBYzs7QUFFaEUsaUVBQWlFLG1CQUFPLENBQUMsb0tBQWlEOztBQUUxSCx1Q0FBdUMsdUNBQXVDOztBQUU5RSxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNLDRDQUE0QyxxREFBcUQsc0JBQXNCLE9BQU8sbURBQW1ELDZDQUE2QyxtQkFBbUIsNERBQTRELGdCQUFnQixrQ0FBa0Msd0JBQXdCOztBQUV2WCw0Q0FBNEMsa0VBQWtFLGtDQUFrQyw4QkFBOEI7O0FBRTlLLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQix5R0FBUSxhQUFhLENBQUM7QUFDeEMsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7OztBQ2pGTDs7QUFFYix3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFcsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQiw0Q0FBNEMsbUJBQU8sQ0FBQywwR0FBZ0I7O0FBRXBFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtCQUFrQjs7Ozs7Ozs7Ozs7QUM1Q0w7O0FBRWIsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsMENBQTBDLG1CQUFPLENBQUMsc0dBQWM7O0FBRWhFLHFDQUFxQyxtQkFBTyxDQUFDLGlHQUFTOztBQUV0RCxpQ0FBaUMsbUJBQU8sQ0FBQyxjQUFJOztBQUU3QywyREFBMkQsbUJBQU8sQ0FBQyx3SkFBMkM7O0FBRTlHLDREQUE0RCxtQkFBTyxDQUFDLDBKQUE0Qzs7QUFFaEgsaURBQWlELGdEQUFnRCx1Q0FBdUMsc0NBQXNDLG9GQUFvRiw0REFBNEQ7O0FBRTlULHFEQUFxRCw2Q0FBNkMsY0FBYyw4RUFBOEUsU0FBUyxvQkFBb0IsbURBQW1ELCtCQUErQix5QkFBeUIsaUJBQWlCLHNGQUFzRix1QkFBdUIsMkVBQTJFLHFGQUFxRixzQ0FBc0MsNENBQTRDLE9BQU8sOEJBQThCLHlCQUF5QixhQUFhLDBCQUEwQjs7QUFFM3hCLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE0sNENBQTRDLHFEQUFxRCxzQkFBc0IsT0FBTyxtREFBbUQsNkNBQTZDLG1CQUFtQiw0REFBNEQsZ0JBQWdCLGtDQUFrQyx3QkFBd0I7O0FBRXZYLDRDQUE0QyxrRUFBa0Usa0NBQWtDLDhCQUE4Qjs7QUFFOUssMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCw4QkFBOEIsZ0dBQWdHLG1EQUFtRDs7QUFFakw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7O0FDbkdsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUmE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQixrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7OztBQ3RDTDs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOzs7Ozs7Ozs7OztBQzlFTDs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQkFBa0I7Ozs7Ozs7Ozs7O0FDbkRMOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtCQUFrQjs7Ozs7Ozs7Ozs7QUN0Q0w7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLCtDQUErQyxtQkFBTyxDQUFDLDJHQUFvQjs7QUFFM0UsMkNBQTJDLG1CQUFPLENBQUMsaUhBQXVCOztBQUUxRSw2Q0FBNkMsbUJBQU8sQ0FBQyxxSEFBeUI7O0FBRTlFLDZDQUE2QyxtQkFBTyxDQUFDLHFIQUF5Qjs7QUFFOUUsK0NBQStDLG1CQUFPLENBQUMsMkdBQW9COztBQUUzRSx3Q0FBd0MsbUJBQU8sQ0FBQyw2RkFBYTs7QUFFN0QseUNBQXlDLG1CQUFPLENBQUMsK0ZBQWM7O0FBRS9ELHlDQUF5QyxtQkFBTyxDQUFDLCtGQUFjOztBQUUvRCwyQ0FBMkMsbUJBQU8sQ0FBQyxtR0FBZ0I7O0FBRW5FLHVDQUF1Qyx1Q0FBdUM7Ozs7Ozs7Ozs7QUM5RTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSYTs7O0FBR2IsYUFBYSxtQkFBTyxDQUFDLDJHQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywyR0FBYzs7O0FBR25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esa0pBQTBEO0FBQzFELHdKQUE0RDtBQUM1RCxtTEFBcUU7QUFDckUsdUtBQWlFO0FBQ2pFLHVLQUFpRTtBQUNqRSxnTEFBb0U7QUFDcEUsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIscUtBQStEOztBQUUvRDtBQUNBLG9CQUFvQjtBQUNwQixhQUFhLG1CQUFPLENBQUMscUhBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxtSEFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLCtHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsaUhBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxtSEFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLCtHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsMkhBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxpSEFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLCtHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsbUhBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxpSEFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLCtHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsK0dBQWdCO0FBQ3JDOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQix1QkFBdUI7Ozs7Ozs7Ozs7OztBQzlDVjs7O0FBR2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLHFCQUFxQjs7Ozs7Ozs7Ozs7O0FDMURSOztBQUViOztBQUVBLDBCQUEwQixtQkFBTyxDQUFDLHVHQUFVO0FBQzVDLDBCQUEwQixtQkFBTyxDQUFDLDZHQUFhO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLHVIQUFrQjs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQyxLQUFLO0FBQzNDLHNDQUFzQztBQUN0QyxzQ0FBc0MsS0FBSzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsZ0JBQWdCOztBQUVqRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGdCQUFnQjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLEdBQUc7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsV0FBVztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjs7Ozs7Ozs7Ozs7O0FDcDhCbkI7QUFDQTtBQUNhOzs7QUFHYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7OztBQ3REYTs7QUFFYjs7QUFFQSwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBVTtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyw2R0FBYTtBQUMvQywwQkFBMEIsbUJBQU8sQ0FBQyx5R0FBVztBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyx1SEFBa0I7OztBQUdwRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFO0FBQy9DO0FBQ0Esb0RBQW9ELEVBQUUsZUFBZSxFQUFFLFlBQVk7OztBQUduRix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBOztBQUVBLGdEQUFnRCxrQkFBa0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0Isc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0EsNkVBQTZFO0FBQzdFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSLDZEQUE2RCxzQkFBc0I7QUFDbkY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Ysb0VBQW9FOztBQUVwRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQSxRQUFRO0FBQ1IsK0RBQStEOztBQUUvRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUEsbUVBQW1FLDBCQUEwQjtBQUM3Rjs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsMEJBQTBCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjtBQUN0QixtQkFBbUI7Ozs7Ozs7Ozs7OztBQzlyRE47O0FBRWI7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMsNkdBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsbUdBQVE7OztBQUdwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBLElBQUk7QUFDSix1QkFBdUIsa0VBQWtFO0FBQ3pGO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHYTs7O0FBR2IsZ0pBQWtDOzs7Ozs7Ozs7Ozs7QUNWbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2E7OztBQUdiLGlCQUFpQix3SUFBd0I7QUFDekM7QUFDQSxJQUFJLG1CQUFPLENBQUMsd0hBQW1CO0FBQy9CLElBQUksbUJBQU8sQ0FBQyxnSEFBZTtBQUMzQjtBQUNBO0FBQ0EsSUFBSSxtQkFBTyxDQUFDLGtIQUFnQjtBQUM1QixJQUFJLG1CQUFPLENBQUMsOEdBQWM7QUFDMUIsSUFBSSxtQkFBTyxDQUFDLGdIQUFlO0FBQzNCLElBQUksbUJBQU8sQ0FBQyw0R0FBYTtBQUN6QjtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3JCRDtBQUNBOzs7QUFHYTs7O0FBR2IsYUFBYSxtQkFBTyxDQUFDLHdHQUFXOzs7QUFHaEM7QUFDQTtBQUNBLElBQUksbUJBQU8sQ0FBQyw0R0FBYTtBQUN6QixJQUFJLG1CQUFPLENBQUMsNEdBQWE7QUFDekIsSUFBSSxtQkFBTyxDQUFDLDRHQUFhO0FBQ3pCO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDaEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2E7OztBQUdiLGlCQUFpQixnSkFBNEI7QUFDN0M7QUFDQSxJQUFJLG1CQUFPLENBQUMsOEdBQWM7QUFDMUIsSUFBSSxtQkFBTyxDQUFDLDhHQUFjO0FBQzFCLElBQUksbUJBQU8sQ0FBQyw0R0FBYTtBQUN6QixJQUFJLG1CQUFPLENBQUMsZ0hBQWU7QUFDM0I7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNsQlk7OztBQUdiLGFBQWEsbUJBQU8sQ0FBQyx1R0FBVTs7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7OztBQ3BHYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyw2R0FBYTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDakVhOztBQUViOzs7QUFHQSxXQUFXLG1CQUFPLENBQUMsb0dBQVM7OztBQUc1QjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDNUhZOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RSxtQ0FBbUMsbUNBQW1DO0FBQ3RFLG1DQUFtQztBQUNuQyxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNsQ1k7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHdHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNoR1k7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHdHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEVBQThFO0FBQ2hILGtDQUFrQyxnRkFBZ0Y7QUFDbEgsa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBLGtDQUFrQztBQUNsQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUMzSlk7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLG9HQUFTOztBQUU1QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLENBQUM7Ozs7Ozs7Ozs7OztBQ1BZOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ1hZOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDLDZCQUE2QixnQkFBZ0I7QUFDN0MsNkJBQTZCLGdCQUFnQjtBQUM3Qyw2QkFBNkIsZ0JBQWdCO0FBQzdDLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNsQ1k7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLG9HQUFTOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQzNDWTs7QUFFYixXQUFXLG1CQUFPLENBQUMsb0dBQVM7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLGdCQUFnQjtBQUMxRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNwRFk7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLG9HQUFTOztBQUU1QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLENBQUM7Ozs7Ozs7Ozs7OztBQ1BZOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFNUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDNUJZOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvR0FBUzs7QUFFNUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixDQUFDOzs7Ozs7Ozs7Ozs7QUNQWTs7QUFFYixXQUFXLG1CQUFPLENBQUMsb0dBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ3ZGRCxDQUFDLGtCQUFrQjtBQUNuQix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSwwQkFBMEIsbUJBQW1CLGFBQWE7QUFDMUQseUJBQXlCLHlCQUF5QjtBQUNsRCx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0RBQXdCO0FBQ3JDLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkVBQXVDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILENBQUM7Ozs7Ozs7Ozs7O0FDL2FEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEIsMkRBQTJELGtCQUFrQiw0QkFBNEIsbUNBQW1DLDhCQUE4QixvQ0FBb0MsZUFBZTtBQUM5UixnQkFBZ0I7O0FBRWhCLFlBQVksbUJBQU8sQ0FBQyxxRUFBVzs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQzs7Ozs7Ozs7Ozs7QUNsQ0Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQiwyREFBMkQsa0JBQWtCLDRCQUE0QixtQ0FBbUMsOEJBQThCLG9DQUFvQyxlQUFlO0FBQzlSLGdCQUFnQjs7QUFFaEIsWUFBWSxtQkFBTyxDQUFDLHFFQUFXOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7Ozs7OztBQy9CRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCLDJEQUEyRCxrQkFBa0IsNEJBQTRCLG1DQUFtQyw4QkFBOEIsb0NBQW9DLGVBQWU7QUFDOVIsZ0JBQWdCOztBQUVoQixtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBa0I7O0FBRTdDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckMsYUFBYSxtQkFBTyxDQUFDLHVFQUFZOztBQUVqQyxlQUFlLG1CQUFPLENBQUMsMkVBQWM7O0FBRXJDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckMsV0FBVyxtQkFBTyxDQUFDLG1FQUFVOztBQUU3QixZQUFZLG1CQUFPLENBQUMscUVBQVc7O0FBRS9CLDZCQUE2QixtQkFBTyxDQUFDLHVHQUE0Qjs7QUFFakUsa0JBQWtCLG1CQUFPLENBQUMsaUZBQWlCOztBQUUzQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRTNDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFnQjs7QUFFekMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQWtCOztBQUU3QyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7Ozs7OztBQ3RSRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCLDJEQUEyRCxrQkFBa0IsNEJBQTRCLG1DQUFtQyw4QkFBOEIsb0NBQW9DLGVBQWU7QUFDOVIsZ0JBQWdCOztBQUVoQixtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBa0I7O0FBRTdDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckMsYUFBYSxtQkFBTyxDQUFDLHVFQUFZOztBQUVqQyxlQUFlLG1CQUFPLENBQUMsMkVBQWM7O0FBRXJDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckMsV0FBVyxtQkFBTyxDQUFDLG1FQUFVOztBQUU3QixZQUFZLG1CQUFPLENBQUMscUVBQVc7O0FBRS9CLDZCQUE2QixtQkFBTyxDQUFDLHVHQUE0Qjs7QUFFakUsa0JBQWtCLG1CQUFPLENBQUMsaUZBQWlCOztBQUUzQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRTNDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFnQjs7QUFFekMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQWtCOztBQUU3QyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQ2xSQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTs7Ozs7VUVBQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvY29nbml0b2lkZW50aXR5LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvZHluYW1vZGIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9zdHMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2FwaV9sb2FkZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NvbmZpZy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29uZmlnX3JlZ2lvbmFsX2VuZHBvaW50LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jb3JlLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY2hhaW5hYmxlX3RlbXBvcmFyeV9jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY29nbml0b19pZGVudGl0eV9jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvZWMyX21ldGFkYXRhX2NyZWRlbnRpYWxzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9lY3NfY3JlZGVudGlhbHMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2Vudmlyb25tZW50X2NyZWRlbnRpYWxzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9maWxlX3N5c3RlbV9jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvcHJvY2Vzc19jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvcmVtb3RlX2NyZWRlbnRpYWxzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9zYW1sX2NyZWRlbnRpYWxzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9zaGFyZWRfaW5pX2ZpbGVfY3JlZGVudGlhbHMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3Nzb19jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvdGVtcG9yYXJ5X2NyZWRlbnRpYWxzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy90b2tlbl9maWxlX3dlYl9pZGVudGl0eV9jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvd2ViX2lkZW50aXR5X2NyZWRlbnRpYWxzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9kaXNjb3Zlcl9lbmRwb2ludC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZHluYW1vZGIvY29udmVydGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9keW5hbW9kYi9kb2N1bWVudF9jbGllbnQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2R5bmFtb2RiL251bWJlclZhbHVlLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9keW5hbW9kYi9zZXQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2R5bmFtb2RiL3RyYW5zbGF0b3IuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2R5bmFtb2RiL3R5cGVzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vYnVmZmVyZWQtY3JlYXRlLWV2ZW50LXN0cmVhbS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlci1zdHJlYW0uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9ldmVudC1tZXNzYWdlLWNodW5rZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9ldmVudC1tZXNzYWdlLXVubWFyc2hhbGxlci1zdHJlYW0uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9pbnQ2NC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3BhcnNlLWV2ZW50LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vcGFyc2UtbWVzc2FnZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3NwbGl0LW1lc3NhZ2UuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9zdHJlYW1pbmctY3JlYXRlLWV2ZW50LXN0cmVhbS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnRfbGlzdGVuZXJzLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwL25vZGUuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2pzb24vYnVpbGRlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvanNvbi9wYXJzZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21ldGFkYXRhX3NlcnZpY2UuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21ldGFkYXRhX3NlcnZpY2UvZ2V0X2VuZHBvaW50LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tZXRhZGF0YV9zZXJ2aWNlL2dldF9lbmRwb2ludF9jb25maWdfb3B0aW9ucy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbWV0YWRhdGFfc2VydmljZS9nZXRfZW5kcG9pbnRfbW9kZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbWV0YWRhdGFfc2VydmljZS9nZXRfZW5kcG9pbnRfbW9kZV9jb25maWdfb3B0aW9ucy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbWV0YWRhdGFfc2VydmljZS9nZXRfbWV0YWRhdGFfc2VydmljZV9lbmRwb2ludC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvYXBpLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9jb2xsZWN0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9vcGVyYXRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3BhZ2luYXRvci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvcmVzb3VyY2Vfd2FpdGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9zaGFwZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbm9kZV9sb2FkZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3BhcmFtX3ZhbGlkYXRvci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvaGVscGVycy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvanNvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcXVlcnkuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3QuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3RfanNvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdF94bWwuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3B1Ymxpc2hlci9jb25maWd1cmF0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wdWJsaXNoZXIvaW5kZXguanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlYWxjbG9jay9ub2RlQ2xvY2suanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlZ2lvbi91dGlscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVnaW9uX2NvbmZpZy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVxdWVzdC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVzb3VyY2Vfd2FpdGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZXNwb25zZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VxdWVudGlhbF9leGVjdXRvci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvZHluYW1vZGIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL3N0cy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2hhcmVkLWluaS9pbmRleC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2hhcmVkLWluaS9pbmktbG9hZGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3ByZXNpZ24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvcmVxdWVzdF9zaWduZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvczMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjNodHRwcy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92NC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92NF9jcmVkZW50aWFscy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc3RhdGVfbWFjaGluZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvdXRpbC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL2J1aWxkZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC9lc2NhcGUtYXR0cmlidXRlLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWVsZW1lbnQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC9ub2RlX3BhcnNlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL3htbC1ub2RlLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwveG1sLXRleHQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmcuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2F3cy1zZGsvdmVuZG9yL2VuZHBvaW50LWNhY2hlL2luZGV4LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9hd3Mtc2RrL3ZlbmRvci9lbmRwb2ludC1jYWNoZS91dGlscy9MUlUuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL2ptZXNwYXRoL2ptZXNwYXRoLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0NvbXBpbGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0NvbXBpbGVyUGFzcy9EZWNvcmF0ZVBhc3MuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvQ29tcGlsZXJQYXNzL09wdGltaXplUGFzcy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9Db21waWxlclBhc3MvUmVtb3ZlUGFzcy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9Db21waWxlclBhc3MvaW5kZXguanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvQ29udGFpbmVyQnVpbGRlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9EZWZpbml0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0V4Y2VwdGlvbi9BYnN0cmFjdFNlcnZpY2VFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL0F0dHJpYnV0ZXNNYXBFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL0NvbmZpZ3VyYXRpb25GaWxlTm90Rm91bmRFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL0RlZmluaXRpb25Ob3RGb3VuZEV4Y2VwdGlvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9FeGNlcHRpb24vRnJvemVuQ29udGFpbmVyRXhjZXB0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0V4Y2VwdGlvbi9Mb2FkTWV0aG9kTm90Rm91bmRFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL0xvZ2dlcldhcm5NZXRob2ROb3RGb3VuZEV4Y2VwdGlvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9FeGNlcHRpb24vTWV0aG9kQ2FsbEVtcHR5RXhjZXB0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0V4Y2VwdGlvbi9NZXRob2RDYWxsTm90Rm91bmRFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL05vdEFic3RyYWN0U2VydmljZUV4Y2VwdGlvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9FeGNlcHRpb24vUHJpdmF0ZVNlcnZpY2VFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL1Byb2Nlc3NNZXRob2ROb3RGb3VuZEV4Y2VwdGlvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9FeGNlcHRpb24vU2VydmljZUNpcmN1bGFyUmVmZXJlbmNlRXhjZXB0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0V4Y2VwdGlvbi9TZXJ2aWNlRmlsZU5vdEZvdW5kRXhjZXB0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0V4Y2VwdGlvbi9TZXJ2aWNlRmlsZU5vdExvYWRlZEV4Y2VwdGlvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9FeGNlcHRpb24vU2VydmljZU5vdEZvdW5kRXhjZXB0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0V4Y2VwdGlvbi9Xcm9uZ0NvbXBpbGVyUGFzc1R5cGVFeGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvRXhjZXB0aW9uL1dyb25nRGVmaW5pdGlvbkV4Y2VwdGlvbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9JbnN0YW5jZU1hbmFnZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvTG9hZGVyL0ZpbGVMb2FkZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvTG9hZGVyL0pzRmlsZUxvYWRlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9Mb2FkZXIvSnNvbkZpbGVMb2FkZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvTG9hZGVyL1lhbWxGaWxlTG9hZGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL0xvYWRlcnxzeW5jIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL1BhY2thZ2VSZWZlcmVuY2UuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvUGFzc0NvbmZpZy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9SZWZlcmVuY2UuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIvVGFnUmVmZXJlbmNlLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGliL2luZGV4LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL2Rpc3QvbGlifHN5bmMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvaW5kZXguanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2NvbW1vbi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvZHVtcGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9leGNlcHRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2xvYWRlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zY2hlbWEvY29yZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2RlZmF1bHQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3NjaGVtYS9mYWlsc2FmZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2pzb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3NuaXBwZXQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvYmluYXJ5LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL2Jvb2wuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvZmxvYXQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvaW50LmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL21hcC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9tZXJnZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9udWxsLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL29tYXAuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvcGFpcnMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvc2VxLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9ub2RlLWRlcGVuZGVuY3ktaW5qZWN0aW9uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL3NldC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9zdHIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvdGltZXN0YW1wLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy9zYXgvbGliL3NheC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvYXBwcy9iYWNrb2ZmaWNlL3NhbS1hcHAvbGFtYmRhL3Bvc3QtY29udHJvbGxlci9kZXBlbmRlbmNpZXMuZGkudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2FwcHMvYmFja29mZmljZS9zYW0tYXBwL2xhbWJkYS9wb3N0LWNvbnRyb2xsZXIvaGFuZGxlci50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvYXBwcy9iYWNrb2ZmaWNlL3NhbS1hcHAvbGFtYmRhL3NoYXJlZC9kZXBlbmRlbmNpZXMuZGkudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL2JhY2tvZmZpY2UvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ29tbWVyY2VDcmVhdG9yLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9iYWNrb2ZmaWNlL2NvbW1lcmNlcy9hcHAvY3JlYXRlL0NvbW1lcmNlQ3JlYXRvckhhbmRsZXIudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL2JhY2tvZmZpY2UvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ3JlYXRlQ29tbWVyY2VDb21tYW5kLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9iYWNrb2ZmaWNlL2NvbW1lcmNlcy9hcHAvY3JlYXRlL0NyZWF0ZUNvbW1lcmNlUmVzcG9uc2UudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL2JhY2tvZmZpY2UvY29tbWVyY2VzL2RvbWFpbi9Db21tZXJjZS50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvYmFja29mZmljZS9jb21tZXJjZXMvZG9tYWluL0NvbW1lcmNlQ3JlYXRlZEV2ZW50LnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9iYWNrb2ZmaWNlL2NvbW1lcmNlcy9kb21haW4vQ29tbWVyY2VEZXNjcmlwdGlvblZvLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9iYWNrb2ZmaWNlL2NvbW1lcmNlcy9kb21haW4vQ29tbWVyY2VOYW1lVm8udHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL2JhY2tvZmZpY2UvY29tbWVyY2VzL2luZnJhL3BlcnNpc3RlbmNlL2R5bmFtb2RiL0R5bmFtb0NvbW1lcmNlUmVwb3NpdG9yeS50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2RvbWFpbi9BZGRyZXNzVm8udHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL3NoYXJlZC9kb21haW4vQWdncmVnYXRlLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9zaGFyZWQvZG9tYWluL0FscmVhZHlFeGlzdHMudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL3NoYXJlZC9kb21haW4vRW1haWxWby50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2RvbWFpbi9JbnZhbGlkQXJndW1lbnRFcnJvci50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2RvbWFpbi9QaG9uZVZvLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9zaGFyZWQvZG9tYWluL1N0cmluZ1ZvLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9zaGFyZWQvZG9tYWluL1V1aWRWby50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2RvbWFpbi9WYWx1ZU9iamVjdC50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2RvbWFpbi9idXMvY29tbWFuZC9Db21tYW5kTm90UmVnaXN0ZXJlZC50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2RvbWFpbi9idXMvY29tbWFuZC9Db21tYW5kUmVzcG9uc2UudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL3NoYXJlZC9kb21haW4vYnVzL2V2ZW50L0RvbWFpbkV2ZW50LnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9zaGFyZWQvZG9tYWluL2J1cy9xdWVyeS9RdWVyeU5vdFJlZ2lzdGVyZWRFcnJvci50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2luZnJhL0NvbnNvbGVMb2dnZXIudHMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvc3JjL2NvbnRleHRzL3NoYXJlZC9pbmZyYS9idXMvY29tbWFuZC9Db21tYW5kSGFuZGxlcnNJbmZvcm1hdGlvbi50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2luZnJhL2J1cy9jb21tYW5kL0luTWVtb3J5Q29tbWFuZEJ1cy50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2luZnJhL2J1cy9ldmVudC9Mb2dnZXJFdmVudEJ1cy50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9zcmMvY29udGV4dHMvc2hhcmVkL2luZnJhL2J1cy9xdWVyeS9Jbk1lbW9yeVF1ZXJ5QnVzLnRzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL3NyYy9jb250ZXh0cy9zaGFyZWQvaW5mcmEvYnVzL3F1ZXJ5L1F1ZXJ5SGFuZGxlcnNJbmZvcm1hdGlvbi50cyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvdXVpZC12YWxpZGF0ZS9pbmRleC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvdXVpZC9pbmRleC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvdmFsaWRhdGUtbnBtLXBhY2thZ2UtbmFtZS9pbmRleC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sMmpzL2xpYi9ib20uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbDJqcy9saWIvYnVpbGRlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sMmpzL2xpYi9kZWZhdWx0cy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sMmpzL2xpYi9wYXJzZXIuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbDJqcy9saWIvcHJvY2Vzc29ycy5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sMmpzL2xpYi94bWwyanMuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1V0aWxpdHkuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEF0dHJpYnV0ZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ0RhdGEuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTENvbW1lbnQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREF0dExpc3QuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVsZW1lbnQuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVudGl0eS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRETm90YXRpb24uanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERlY2xhcmF0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEb2NUeXBlLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEb2N1bWVudC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRG9jdW1lbnRDQi5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRWxlbWVudC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MTm9kZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxSYXcuanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFN0cmVhbVdyaXRlci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MU3RyaW5nV3JpdGVyLmpzIiwiL2hvbWUvcGFibG8vcHJvamVjdHMvbm96b21hL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxTdHJpbmdpZmllci5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MVGV4dC5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MV3JpdGVyQmFzZS5qcyIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvaW5kZXguanMiLCJleHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiYnVmZmVyXCIiLCJleHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY2hpbGRfcHJvY2Vzc1wiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImNvbnNvbGVcIiIsImV4dGVybmFsIG5vZGUtY29tbW9uanMgXCJjcnlwdG9cIiIsImV4dGVybmFsIG5vZGUtY29tbW9uanMgXCJkZ3JhbVwiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImRvbWFpblwiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImV2ZW50c1wiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImZzXCIiLCJleHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cFwiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImh0dHBzXCIiLCJleHRlcm5hbCBub2RlLWNvbW1vbmpzIFwib3NcIiIsImV4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwYXRoXCIiLCJleHRlcm5hbCBub2RlLWNvbW1vbmpzIFwicXVlcnlzdHJpbmdcIiIsImV4dGVybmFsIG5vZGUtY29tbW9uanMgXCJzdHJlYW1cIiIsImV4dGVybmFsIG5vZGUtY29tbW9uanMgXCJzdHJpbmdfZGVjb2RlclwiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInRpbWVyc1wiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInVybFwiIiwiZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInV0aWxcIiIsIi9ob21lL3BhYmxvL3Byb2plY3RzL25vem9tYS9ub2RlX21vZHVsZXMvQG1pZGR5L2NvcmUvaW5kZXguanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL0BtaWRkeS9odHRwLWNvcnMvaW5kZXguanMiLCIvaG9tZS9wYWJsby9wcm9qZWN0cy9ub3pvbWEvbm9kZV9tb2R1bGVzL0BtaWRkeS91dGlsL2luZGV4LmpzIiwid2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2svc3RhcnR1cCIsIndlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ2NvZ25pdG9pZGVudGl0eSddID0ge307XG5BV1MuQ29nbml0b0lkZW50aXR5ID0gU2VydmljZS5kZWZpbmVTZXJ2aWNlKCdjb2duaXRvaWRlbnRpdHknLCBbJzIwMTQtMDYtMzAnXSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpTG9hZGVyLnNlcnZpY2VzWydjb2duaXRvaWRlbnRpdHknXSwgJzIwMTQtMDYtMzAnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5Db2duaXRvSWRlbnRpdHk7XG4iLCJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ2R5bmFtb2RiJ10gPSB7fTtcbkFXUy5EeW5hbW9EQiA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnZHluYW1vZGInLCBbJzIwMTEtMTItMDUnLCAnMjAxMi0wOC0xMCddKTtcbnJlcXVpcmUoJy4uL2xpYi9zZXJ2aWNlcy9keW5hbW9kYicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snZHluYW1vZGInXSwgJzIwMTEtMTItMDUnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvZHluYW1vZGItMjAxMS0xMi0wNS5taW4uanNvbicpO1xuICAgIG1vZGVsLnBhZ2luYXRvcnMgPSByZXF1aXJlKCcuLi9hcGlzL2R5bmFtb2RiLTIwMTEtMTItMDUucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICBtb2RlbC53YWl0ZXJzID0gcmVxdWlyZSgnLi4vYXBpcy9keW5hbW9kYi0yMDExLTEyLTA1LndhaXRlcnMyLmpzb24nKS53YWl0ZXJzO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGlMb2FkZXIuc2VydmljZXNbJ2R5bmFtb2RiJ10sICcyMDEyLTA4LTEwJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL2R5bmFtb2RiLTIwMTItMDgtMTAubWluLmpzb24nKTtcbiAgICBtb2RlbC5wYWdpbmF0b3JzID0gcmVxdWlyZSgnLi4vYXBpcy9keW5hbW9kYi0yMDEyLTA4LTEwLnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgbW9kZWwud2FpdGVycyA9IHJlcXVpcmUoJy4uL2FwaXMvZHluYW1vZGItMjAxMi0wOC0xMC53YWl0ZXJzMi5qc29uJykud2FpdGVycztcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLkR5bmFtb0RCO1xuIiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydzdHMnXSA9IHt9O1xuQVdTLlNUUyA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnc3RzJywgWycyMDExLTA2LTE1J10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL3N0cycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snc3RzJ10sICcyMDExLTA2LTE1Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL3N0cy0yMDExLTA2LTE1Lm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvc3RzLTIwMTEtMDYtMTUucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNUUztcbiIsImZ1bmN0aW9uIGFwaUxvYWRlcihzdmMsIHZlcnNpb24pIHtcbiAgaWYgKCFhcGlMb2FkZXIuc2VydmljZXMuaGFzT3duUHJvcGVydHkoc3ZjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFNlcnZpY2U6IEZhaWxlZCB0byBsb2FkIGFwaSBmb3IgJyArIHN2Yyk7XG4gIH1cbiAgcmV0dXJuIGFwaUxvYWRlci5zZXJ2aWNlc1tzdmNdW3ZlcnNpb25dO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqIFRoaXMgbWVtYmVyIG9mIEFXUy5hcGlMb2FkZXIgaXMgcHJpdmF0ZSwgYnV0IGNoYW5naW5nIGl0IHdpbGwgbmVjZXNzaXRhdGUgYVxuICogY2hhbmdlIHRvIC4uL3NjcmlwdHMvc2VydmljZXMtdGFibGUtZ2VuZXJhdG9yLnRzXG4gKi9cbmFwaUxvYWRlci5zZXJ2aWNlcyA9IHt9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFwaUxvYWRlcjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbicpO1xudmFyIFByb21pc2VzRGVwZW5kZW5jeTtcblxuLyoqXG4gKiBUaGUgbWFpbiBjb25maWd1cmF0aW9uIGNsYXNzIHVzZWQgYnkgYWxsIHNlcnZpY2Ugb2JqZWN0cyB0byBzZXRcbiAqIHRoZSByZWdpb24sIGNyZWRlbnRpYWxzLCBhbmQgb3RoZXIgb3B0aW9ucyBmb3IgcmVxdWVzdHMuXG4gKlxuICogQnkgZGVmYXVsdCwgY3JlZGVudGlhbHMgYW5kIHJlZ2lvbiBzZXR0aW5ncyBhcmUgbGVmdCB1bmNvbmZpZ3VyZWQuXG4gKiBUaGlzIHNob3VsZCBiZSBjb25maWd1cmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBiZWZvcmUgdXNpbmcgYW55XG4gKiBBV1Mgc2VydmljZSBBUElzLlxuICpcbiAqIEluIG9yZGVyIHRvIHNldCBnbG9iYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLCBwcm9wZXJ0aWVzIHNob3VsZFxuICogYmUgYXNzaWduZWQgdG8gdGhlIGdsb2JhbCB7QVdTLmNvbmZpZ30gb2JqZWN0LlxuICpcbiAqIEBzZWUgQVdTLmNvbmZpZ1xuICpcbiAqIEAhZ3JvdXAgR2VuZXJhbCBDb25maWd1cmF0aW9uIE9wdGlvbnNcbiAqXG4gKiBAIWF0dHJpYnV0ZSBjcmVkZW50aWFsc1xuICogICBAcmV0dXJuIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBBV1MgY3JlZGVudGlhbHMgdG8gc2lnbiByZXF1ZXN0cyB3aXRoLlxuICpcbiAqIEAhYXR0cmlidXRlIHJlZ2lvblxuICogICBAZXhhbXBsZSBTZXQgdGhlIGdsb2JhbCByZWdpb24gc2V0dGluZyB0byB1cy13ZXN0LTJcbiAqICAgICBBV1MuY29uZmlnLnVwZGF0ZSh7cmVnaW9uOiAndXMtd2VzdC0yJ30pO1xuICogICBAcmV0dXJuIFtBV1MuQ3JlZGVudGlhbHNdIFRoZSByZWdpb24gdG8gc2VuZCBzZXJ2aWNlIHJlcXVlc3RzIHRvLlxuICogICBAc2VlIGh0dHA6Ly9kb2NzLmFtYXpvbndlYnNlcnZpY2VzLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9yYW5kZS5odG1sXG4gKiAgICAgQSBsaXN0IG9mIGF2YWlsYWJsZSBlbmRwb2ludHMgZm9yIGVhY2ggQVdTIHNlcnZpY2VcbiAqXG4gKiBAIWF0dHJpYnV0ZSBtYXhSZXRyaWVzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZXRyaWVzIHRvIHBlcmZvcm0gZm9yIGFcbiAqICAgICBzZXJ2aWNlIHJlcXVlc3QuIEJ5IGRlZmF1bHQgdGhpcyB2YWx1ZSBpcyBjYWxjdWxhdGVkIGJ5IHRoZSBzcGVjaWZpY1xuICogICAgIHNlcnZpY2Ugb2JqZWN0IHRoYXQgdGhlIHJlcXVlc3QgaXMgYmVpbmcgbWFkZSB0by5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBtYXhSZWRpcmVjdHNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJlZGlyZWN0cyB0byBmb2xsb3cgZm9yIGFcbiAqICAgICBzZXJ2aWNlIHJlcXVlc3QuIERlZmF1bHRzIHRvIDEwLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtVmFsaWRhdGlvblxuICogICBAcmV0dXJuIFtCb29sZWFufG1hcF0gd2hldGhlciBpbnB1dCBwYXJhbWV0ZXJzIHNob3VsZCBiZSB2YWxpZGF0ZWQgYWdhaW5zdFxuICogICAgIHRoZSBvcGVyYXRpb24gZGVzY3JpcHRpb24gYmVmb3JlIHNlbmRpbmcgdGhlIHJlcXVlc3QuIERlZmF1bHRzIHRvIHRydWUuXG4gKiAgICAgUGFzcyBhIG1hcCB0byBlbmFibGUgYW55IG9mIHRoZSBmb2xsb3dpbmcgc3BlY2lmaWMgdmFsaWRhdGlvbiBmZWF0dXJlczpcbiAqXG4gKiAgICAgKiAqKm1pbioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1pblxuICogICAgICAgY29uc3RyYWludC4gVGhpcyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBwYXJhbVZhbGlkYXRpb24gaXMgc2V0XG4gKiAgICAgICB0byBgdHJ1ZWAuXG4gKiAgICAgKiAqKm1heCoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1heFxuICogICAgICAgY29uc3RyYWludC5cbiAqICAgICAqICoqcGF0dGVybioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYVxuICogICAgICAgcmVndWxhciBleHByZXNzaW9uLlxuICogICAgICogKiplbnVtKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBvbmVcbiAqICAgICAgIG9mIHRoZSBhbGxvd2FibGUgZW51bSB2YWx1ZXMuXG4gKlxuICogQCFhdHRyaWJ1dGUgY29tcHV0ZUNoZWNrc3Vtc1xuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbXB1dGUgY2hlY2tzdW1zIGZvciBwYXlsb2FkIGJvZGllcyB3aGVuXG4gKiAgICAgdGhlIHNlcnZpY2UgYWNjZXB0cyBpdCAoY3VycmVudGx5IHN1cHBvcnRlZCBpbiBTMyBhbmQgU1FTIG9ubHkpLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvbnZlcnRSZXNwb25zZVR5cGVzXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdHlwZXMgYXJlIGNvbnZlcnRlZCB3aGVuIHBhcnNpbmcgcmVzcG9uc2UgZGF0YS5cbiAqICAgICBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgZm9yIEpTT04gYmFzZWQgc2VydmljZXMuIFR1cm5pbmcgdGhpcyBvZmYgbWF5XG4gKiAgICAgaW1wcm92ZSBwZXJmb3JtYW5jZSBvbiBsYXJnZSByZXNwb25zZSBwYXlsb2Fkcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvcnJlY3RDbG9ja1NrZXdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBhcHBseSBhIGNsb2NrIHNrZXcgY29ycmVjdGlvbiBhbmQgcmV0cnlcbiAqICAgICByZXF1ZXN0cyB0aGF0IGZhaWwgYmVjYXVzZSBvZiBhbiBza2V3ZWQgY2xpZW50IGNsb2NrLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3NsRW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIFNTTCBpcyBlbmFibGVkIGZvciByZXF1ZXN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHMzRm9yY2VQYXRoU3R5bGVcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBmb3JjZSBwYXRoIHN0eWxlIFVSTHMgZm9yIFMzIG9iamVjdHNcbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM0J1Y2tldEVuZHBvaW50XG4gKiAgIEBub3RlIFNldHRpbmcgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiByZXF1aXJlcyBhbiBgZW5kcG9pbnRgIHRvIGJlXG4gKiAgICAgcHJvdmlkZWQgZXhwbGljaXRseSB0byB0aGUgc2VydmljZSBjb25zdHJ1Y3Rvci5cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgcHJvdmlkZWQgZW5kcG9pbnQgYWRkcmVzc2VzIGFuIGluZGl2aWR1YWxcbiAqICAgICBidWNrZXQgKGZhbHNlIGlmIGl0IGFkZHJlc3NlcyB0aGUgcm9vdCBBUEkgZW5kcG9pbnQpLlxuICpcbiAqIEAhYXR0cmlidXRlIHMzRGlzYWJsZUJvZHlTaWduaW5nXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZGlzYWJsZSBTMyBib2R5IHNpZ25pbmcgd2hlbiB1c2luZyBzaWduYXR1cmUgdmVyc2lvbiBgdjRgLlxuICogICAgIEJvZHkgc2lnbmluZyBjYW4gb25seSBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIGh0dHBzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludFxuICogICBAcmV0dXJuIFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGVuIHJlZ2lvbiBpcyBzZXQgdG8gJ3VzLWVhc3QtMScsIHdoZXRoZXIgdG8gc2VuZCBzM1xuICogICAgIHJlcXVlc3QgdG8gZ2xvYmFsIGVuZHBvaW50cyBvciAndXMtZWFzdC0xJyByZWdpb25hbCBlbmRwb2ludHMuIFRoaXMgY29uZmlnIGlzIG9ubHlcbiAqICAgICBhcHBsaWNhYmxlIHRvIFMzIGNsaWVudDtcbiAqICAgICBEZWZhdWx0cyB0byAnbGVnYWN5J1xuICogQCFhdHRyaWJ1dGUgczNVc2VBcm5SZWdpb25cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBvdmVycmlkZSB0aGUgcmVxdWVzdCByZWdpb24gd2l0aCB0aGUgcmVnaW9uIGluZmVycmVkXG4gKiAgICAgZnJvbSByZXF1ZXN0ZWQgcmVzb3VyY2UncyBBUk4uIE9ubHkgYXZhaWxhYmxlIGZvciBTMyBidWNrZXRzXG4gKiAgICAgRGVmYXVsdHMgdG8gYHRydWVgXG4gKlxuICogQCFhdHRyaWJ1dGUgdXNlQWNjZWxlcmF0ZUVuZHBvaW50XG4gKiAgIEBub3RlIFRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gaXMgb25seSBjb21wYXRpYmxlIHdpdGggUzMgd2hpbGUgYWNjZXNzaW5nXG4gKiAgICAgZG5zLWNvbXBhdGlibGUgYnVja2V0cy5cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gV2hldGhlciB0byB1c2UgdGhlIEFjY2VsZXJhdGUgZW5kcG9pbnQgd2l0aCB0aGUgUzMgc2VydmljZS5cbiAqICAgICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICpcbiAqIEAhYXR0cmlidXRlIHJldHJ5RGVsYXlPcHRpb25zXG4gKiAgIEBleGFtcGxlIFNldCB0aGUgYmFzZSByZXRyeSBkZWxheSBmb3IgYWxsIHNlcnZpY2VzIHRvIDMwMCBtc1xuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZXRyeURlbGF5T3B0aW9uczoge2Jhc2U6IDMwMH19KTtcbiAqICAgICAvLyBEZWxheXMgd2l0aCBtYXhSZXRyaWVzID0gMzogMzAwLCA2MDAsIDEyMDBcbiAqICAgQGV4YW1wbGUgU2V0IGEgY3VzdG9tIGJhY2tvZmYgZnVuY3Rpb24gdG8gcHJvdmlkZSBkZWxheSB2YWx1ZXMgb24gcmV0cmllc1xuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZXRyeURlbGF5T3B0aW9uczoge2N1c3RvbUJhY2tvZmY6IGZ1bmN0aW9uKHJldHJ5Q291bnQsIGVycikge1xuICogICAgICAgLy8gcmV0dXJucyBkZWxheSBpbiBtc1xuICogICAgIH19fSk7XG4gKiAgIEByZXR1cm4gW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHJldHJ5IGRlbGF5IG9uIHJldHJ5YWJsZSBlcnJvcnMuXG4gKiAgICAgQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAgICAgKiAqKmJhc2UqKiBbSW50ZWdlcl0gJm1kYXNoOyBUaGUgYmFzZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBpbiB0aGVcbiAqICAgICAgIGV4cG9uZW50aWFsIGJhY2tvZmYgZm9yIG9wZXJhdGlvbiByZXRyaWVzLiBEZWZhdWx0cyB0byAxMDAgbXMgZm9yIGFsbCBzZXJ2aWNlcyBleGNlcHRcbiAqICAgICAgIER5bmFtb0RCLCB3aGVyZSBpdCBkZWZhdWx0cyB0byA1MG1zLlxuICpcbiAqICAgICAqICoqY3VzdG9tQmFja29mZiAqKiBbZnVuY3Rpb25dICZtZGFzaDsgQSBjdXN0b20gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFcbiAqICAgICAgIHJldHJ5IGNvdW50IGFuZCBlcnJvciBhbmQgcmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgaW5cbiAqICAgICAgIG1pbGxpc2Vjb25kcy4gSWYgdGhlIHJlc3VsdCBpcyBhIG5vbi16ZXJvIG5lZ2F0aXZlIHZhbHVlLCBubyBmdXJ0aGVyXG4gKiAgICAgICByZXRyeSBhdHRlbXB0cyB3aWxsIGJlIG1hZGUuIFRoZSBgYmFzZWAgb3B0aW9uIHdpbGwgYmUgaWdub3JlZCBpZiB0aGlzXG4gKiAgICAgICBvcHRpb24gaXMgc3VwcGxpZWQuIFRoZSBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgcmV0cnlhYmxlIGVycm9ycy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBodHRwT3B0aW9uc1xuICogICBAcmV0dXJuIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbG93LWxldmVsIEhUVFAgcmVxdWVzdC5cbiAqICAgICBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqICAgICAqICoqcHJveHkqKiBbU3RyaW5nXSAmbWRhc2g7IHRoZSBVUkwgdG8gcHJveHkgcmVxdWVzdHMgdGhyb3VnaFxuICogICAgICogKiphZ2VudCoqIFtodHRwLkFnZW50LCBodHRwcy5BZ2VudF0gJm1kYXNoOyB0aGUgQWdlbnQgb2JqZWN0IHRvIHBlcmZvcm1cbiAqICAgICAgIEhUVFAgcmVxdWVzdHMgd2l0aC4gVXNlZCBmb3IgY29ubmVjdGlvbiBwb29saW5nLiBOb3RlIHRoYXQgZm9yXG4gKiAgICAgICBTU0wgY29ubmVjdGlvbnMsIGEgc3BlY2lhbCBBZ2VudCBvYmplY3QgaXMgdXNlZCBpbiBvcmRlciB0byBlbmFibGVcbiAqICAgICAgIHBlZXIgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uLiBUaGlzIGZlYXR1cmUgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlXG4gKiAgICAgICBOb2RlLmpzIGVudmlyb25tZW50LlxuICogICAgICogKipjb25uZWN0VGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyXG4gKiAgICAgICBmYWlsaW5nIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyIGFmdGVyXG4gKiAgICAgICBgY29ubmVjdFRpbWVvdXRgIG1pbGxpc2Vjb25kcy4gVGhpcyB0aW1lb3V0IGhhcyBubyBlZmZlY3Qgb25jZSBhIHNvY2tldFxuICogICAgICAgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqICAgICAqICoqdGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGEgcmVxdWVzdCBjYW5cbiAqICAgICAgIHRha2UgYmVmb3JlIGF1dG9tYXRpY2FsbHkgYmVpbmcgdGVybWluYXRlZC5cbiAqICAgICAgIERlZmF1bHRzIHRvIHR3byBtaW51dGVzICgxMjAwMDApLlxuICogICAgICogKip4aHJBc3luYyoqIFtCb29sZWFuXSAmbWRhc2g7IFdoZXRoZXIgdGhlIFNESyB3aWxsIHNlbmQgYXN5bmNocm9ub3VzXG4gKiAgICAgICBIVFRQIHJlcXVlc3RzLiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9ubHkuIFNldCB0byBmYWxzZSB0b1xuICogICAgICAgc2VuZCByZXF1ZXN0cyBzeW5jaHJvbm91c2x5LiBEZWZhdWx0cyB0byB0cnVlIChhc3luYyBvbikuXG4gKiAgICAgKiAqKnhocldpdGhDcmVkZW50aWFscyoqIFtCb29sZWFuXSAmbWRhc2g7IFNldHMgdGhlIFwid2l0aENyZWRlbnRpYWxzXCJcbiAqICAgICAgIHByb3BlcnR5IG9mIGFuIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICogICAgICAgb25seS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAIWF0dHJpYnV0ZSBsb2dnZXJcbiAqICAgQHJldHVybiBbI3dyaXRlLCNsb2ddIGFuIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIC53cml0ZSgpIChsaWtlIGEgc3RyZWFtKVxuICogICAgIG9yIC5sb2coKSAobGlrZSB0aGUgY29uc29sZSBvYmplY3QpIGluIG9yZGVyIHRvIGxvZyBpbmZvcm1hdGlvbiBhYm91dFxuICogICAgIHJlcXVlc3RzXG4gKlxuICogQCFhdHRyaWJ1dGUgc3lzdGVtQ2xvY2tPZmZzZXRcbiAqICAgQHJldHVybiBbTnVtYmVyXSBhbiBvZmZzZXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzIHRvIGFwcGx5IHRvIGFsbCBzaWduaW5nXG4gKiAgICAgdGltZXMuIFVzZSB0aGlzIHRvIGNvbXBlbnNhdGUgZm9yIGNsb2NrIHNrZXcgd2hlbiB5b3VyIHN5c3RlbSBtYXkgYmVcbiAqICAgICBvdXQgb2Ygc3luYyB3aXRoIHRoZSBzZXJ2aWNlIHRpbWUuIE5vdGUgdGhhdCB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uXG4gKiAgICAgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZ2xvYmFsIGBBV1MuY29uZmlnYCBvYmplY3QgYW5kIGNhbm5vdCBiZVxuICogICAgIG92ZXJyaWRkZW4gaW4gc2VydmljZS1zcGVjaWZpYyBjb25maWd1cmF0aW9uLiBEZWZhdWx0cyB0byAwIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzaWduYXR1cmVWZXJzaW9uXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uIHRvIHNpZ24gcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZ1xuICogICAgIHRoZSBBUEkgY29uZmlndXJhdGlvbikuIFBvc3NpYmxlIHZhbHVlcyBhcmU6ICd2MicsICd2MycsICd2NCcuXG4gKlxuICogQCFhdHRyaWJ1dGUgc2lnbmF0dXJlQ2FjaGVcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgc2lnbmF0dXJlIHRvIHNpZ24gcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZ1xuICogICAgIHRoZSBBUEkgY29uZmlndXJhdGlvbikgaXMgY2FjaGVkLiBPbmx5IGFwcGxpZXMgdG8gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uICd2NCcuXG4gKiAgICAgRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFufHVuZGVmaW5lZF0gd2hldGhlciB0byBjYWxsIG9wZXJhdGlvbnMgd2l0aCBlbmRwb2ludHNcbiAqICAgICBnaXZlbiBieSBzZXJ2aWNlIGR5bmFtaWNhbGx5LiBTZXR0aW5nIHRoaXMgY29uZmlnIHRvIGB0cnVlYCB3aWxsIGVuYWJsZVxuICogICAgIGVuZHBvaW50IGRpc2NvdmVyeSBmb3IgYWxsIGFwcGxpY2FibGUgb3BlcmF0aW9ucy4gU2V0dGluZyBpdCB0byBgZmFsc2VgXG4gKiAgICAgd2lsbCBleHBsaWNpdGx5IGRpc2FibGUgZW5kcG9pbnQgZGlzY292ZXJ5IGV2ZW4gdGhvdWdoIG9wZXJhdGlvbnMgdGhhdFxuICogICAgIHJlcXVpcmUgZW5kcG9pbnQgZGlzY292ZXJ5IHdpbGwgcHJlc3VtYWJseSBmYWlsLiBMZWF2aW5nIGl0IHRvXG4gKiAgICAgYHVuZGVmaW5lZGAgbWVhbnMgU0RLIG9ubHkgZG8gZW5kcG9pbnQgZGlzY292ZXJ5IHdoZW4gaXQncyByZXF1aXJlZC5cbiAqICAgICBEZWZhdWx0cyB0byBgdW5kZWZpbmVkYFxuICpcbiAqIEAhYXR0cmlidXRlIGVuZHBvaW50Q2FjaGVTaXplXG4gKiAgIEByZXR1cm4gW051bWJlcl0gdGhlIHNpemUgb2YgdGhlIGdsb2JhbCBjYWNoZSBzdG9yaW5nIGVuZHBvaW50cyBmcm9tIGVuZHBvaW50XG4gKiAgICAgZGlzY292ZXJ5IG9wZXJhdGlvbnMuIE9uY2UgZW5kcG9pbnQgY2FjaGUgaXMgY3JlYXRlZCwgdXBkYXRpbmcgdGhpcyBzZXR0aW5nXG4gKiAgICAgY2Fubm90IGNoYW5nZSBleGlzdGluZyBjYWNoZSBzaXplLlxuICogICAgIERlZmF1bHRzIHRvIDEwMDBcbiAqXG4gKiBAIWF0dHJpYnV0ZSBob3N0UHJlZml4RW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIG1hcnNoYWwgcmVxdWVzdCBwYXJhbWV0ZXJzIHRvIHRoZSBwcmVmaXggb2ZcbiAqICAgICBob3N0bmFtZS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIHN0c1JlZ2lvbmFsRW5kcG9pbnRzXG4gKiAgIEByZXR1cm4gWydsZWdhY3knfCdyZWdpb25hbCddIHdoZXRoZXIgdG8gc2VuZCBzdHMgcmVxdWVzdCB0byBnbG9iYWwgZW5kcG9pbnRzIG9yXG4gKiAgICAgcmVnaW9uYWwgZW5kcG9pbnRzLlxuICogICAgIERlZmF1bHRzIHRvICdsZWdhY3knLlxuICpcbiAqIEAhYXR0cmlidXRlIHVzZUZpcHNFbmRwb2ludFxuICogICBAcmV0dXJuIFtCb29sZWFuXSBFbmFibGVzIEZJUFMgY29tcGF0aWJsZSBlbmRwb2ludHMuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgdXNlRHVhbHN0YWNrRW5kcG9pbnRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gRW5hYmxlcyBJUHY2IGR1YWxzdGFjayBlbmRwb2ludC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqL1xuQVdTLkNvbmZpZyA9IEFXUy51dGlsLmluaGVyaXQoe1xuICAvKipcbiAgICogQCFlbmRncm91cFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdC4gVGhpcyBpcyB0aGUgb2JqZWN0IHRoYXQgcGFzc2VzXG4gICAqIG9wdGlvbiBkYXRhIGFsb25nIHRvIHNlcnZpY2UgcmVxdWVzdHMsIGluY2x1ZGluZyBjcmVkZW50aWFscywgc2VjdXJpdHksXG4gICAqIHJlZ2lvbiBpbmZvcm1hdGlvbiwgYW5kIHNvbWUgc2VydmljZSBzcGVjaWZpYyBzZXR0aW5ncy5cbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBjcmVkZW50aWFscyBhbmQgcmVnaW9uXG4gICAqICAgdmFyIGNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKHtcbiAgICogICAgIGFjY2Vzc0tleUlkOiAnQUtJRCcsIHNlY3JldEFjY2Vzc0tleTogJ1NFQ1JFVCcsIHJlZ2lvbjogJ3VzLXdlc3QtMidcbiAgICogICB9KTtcbiAgICogQG9wdGlvbiBvcHRpb25zIGFjY2Vzc0tleUlkIFtTdHJpbmddIHlvdXIgQVdTIGFjY2VzcyBrZXkgSUQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzZWNyZXRBY2Nlc3NLZXkgW1N0cmluZ10geW91ciBBV1Mgc2VjcmV0IGFjY2VzcyBrZXkuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzZXNzaW9uVG9rZW4gW0FXUy5DcmVkZW50aWFsc10gdGhlIG9wdGlvbmFsIEFXU1xuICAgKiAgIHNlc3Npb24gdG9rZW4gdG8gc2lnbiByZXF1ZXN0cyB3aXRoLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgIHRvIHNpZ24gcmVxdWVzdHMgd2l0aC4gWW91IGNhbiBlaXRoZXIgc3BlY2lmeSB0aGlzIG9iamVjdCwgb3JcbiAgICogICBzcGVjaWZ5IHRoZSBhY2Nlc3NLZXlJZCBhbmQgc2VjcmV0QWNjZXNzS2V5IG9wdGlvbnMgZGlyZWN0bHkuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjcmVkZW50aWFsUHJvdmlkZXIgW0FXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbl0gdGhlXG4gICAqICAgcHJvdmlkZXIgY2hhaW4gdXNlZCB0byByZXNvbHZlIGNyZWRlbnRpYWxzIGlmIG5vIHN0YXRpYyBgY3JlZGVudGlhbHNgXG4gICAqICAgcHJvcGVydHkgaXMgc2V0LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcmVnaW9uIFtTdHJpbmddIHRoZSByZWdpb24gdG8gc2VuZCBzZXJ2aWNlIHJlcXVlc3RzIHRvLlxuICAgKiAgIFNlZSB7cmVnaW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIG1heFJldHJpZXMgW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZXRyaWVzIHRvXG4gICAqICAgYXR0ZW1wdCB3aXRoIGEgcmVxdWVzdC4gU2VlIHttYXhSZXRyaWVzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIG1heFJlZGlyZWN0cyBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJlZGlyZWN0cyB0b1xuICAgKiAgIGZvbGxvdyB3aXRoIGEgcmVxdWVzdC4gU2VlIHttYXhSZWRpcmVjdHN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc3NsRW5hYmxlZCBbQm9vbGVhbl0gd2hldGhlciB0byBlbmFibGUgU1NMIGZvclxuICAgKiAgIHJlcXVlc3RzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcGFyYW1WYWxpZGF0aW9uIFtCb29sZWFufG1hcF0gd2hldGhlciBpbnB1dCBwYXJhbWV0ZXJzXG4gICAqICAgc2hvdWxkIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvcGVyYXRpb24gZGVzY3JpcHRpb24gYmVmb3JlIHNlbmRpbmdcbiAgICogICB0aGUgcmVxdWVzdC4gRGVmYXVsdHMgdG8gdHJ1ZS4gUGFzcyBhIG1hcCB0byBlbmFibGUgYW55IG9mIHRoZVxuICAgKiAgIGZvbGxvd2luZyBzcGVjaWZpYyB2YWxpZGF0aW9uIGZlYXR1cmVzOlxuICAgKlxuICAgKiAgICogKiptaW4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtaW5cbiAgICogICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICAgKiAgICAgdG8gYHRydWVgLlxuICAgKiAgICogKiptYXgqKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtYXhcbiAgICogICAgIGNvbnN0cmFpbnQuXG4gICAqICAgKiAqKnBhdHRlcm4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGFcbiAgICogICAgIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICogICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gICAqICAgICBvZiB0aGUgYWxsb3dhYmxlIGVudW0gdmFsdWVzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29tcHV0ZUNoZWNrc3VtcyBbQm9vbGVhbl0gd2hldGhlciB0byBjb21wdXRlIGNoZWNrc3Vtc1xuICAgKiAgIGZvciBwYXlsb2FkIGJvZGllcyB3aGVuIHRoZSBzZXJ2aWNlIGFjY2VwdHMgaXQgKGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICogICBpbiBTMyBvbmx5KVxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29udmVydFJlc3BvbnNlVHlwZXMgW0Jvb2xlYW5dIHdoZXRoZXIgdHlwZXMgYXJlIGNvbnZlcnRlZFxuICAgKiAgICAgd2hlbiBwYXJzaW5nIHJlc3BvbnNlIGRhdGEuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBmb3IgSlNPTiBiYXNlZFxuICAgKiAgICAgc2VydmljZXMuIFR1cm5pbmcgdGhpcyBvZmYgbWF5IGltcHJvdmUgcGVyZm9ybWFuY2Ugb24gbGFyZ2UgcmVzcG9uc2VcbiAgICogICAgIHBheWxvYWRzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb3JyZWN0Q2xvY2tTa2V3IFtCb29sZWFuXSB3aGV0aGVyIHRvIGFwcGx5IGEgY2xvY2sgc2tld1xuICAgKiAgICAgY29ycmVjdGlvbiBhbmQgcmV0cnkgcmVxdWVzdHMgdGhhdCBmYWlsIGJlY2F1c2Ugb2YgYW4gc2tld2VkIGNsaWVudFxuICAgKiAgICAgY2xvY2suIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM0ZvcmNlUGF0aFN0eWxlIFtCb29sZWFuXSB3aGV0aGVyIHRvIGZvcmNlIHBhdGhcbiAgICogICBzdHlsZSBVUkxzIGZvciBTMyBvYmplY3RzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNCdWNrZXRFbmRwb2ludCBbQm9vbGVhbl0gd2hldGhlciB0aGUgcHJvdmlkZWQgZW5kcG9pbnRcbiAgICogICBhZGRyZXNzZXMgYW4gaW5kaXZpZHVhbCBidWNrZXQgKGZhbHNlIGlmIGl0IGFkZHJlc3NlcyB0aGUgcm9vdCBBUElcbiAgICogICBlbmRwb2ludCkuIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gcmVxdWlyZXMgYW5cbiAgICogICBgZW5kcG9pbnRgIHRvIGJlIHByb3ZpZGVkIGV4cGxpY2l0bHkgdG8gdGhlIHNlcnZpY2UgY29uc3RydWN0b3IuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM0Rpc2FibGVCb2R5U2lnbmluZyBbQm9vbGVhbl0gd2hldGhlciBTMyBib2R5IHNpZ25pbmdcbiAgICogICBzaG91bGQgYmUgZGlzYWJsZWQgd2hlbiB1c2luZyBzaWduYXR1cmUgdmVyc2lvbiBgdjRgLiBCb2R5IHNpZ25pbmdcbiAgICogICBjYW4gb25seSBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIGh0dHBzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50IFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGVuIHJlZ2lvblxuICAgKiAgIGlzIHNldCB0byAndXMtZWFzdC0xJywgd2hldGhlciB0byBzZW5kIHMzIHJlcXVlc3QgdG8gZ2xvYmFsIGVuZHBvaW50cyBvclxuICAgKiAgICd1cy1lYXN0LTEnIHJlZ2lvbmFsIGVuZHBvaW50cy4gVGhpcyBjb25maWcgaXMgb25seSBhcHBsaWNhYmxlIHRvIFMzIGNsaWVudC5cbiAgICogICBEZWZhdWx0cyB0byBgbGVnYWN5YFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNVc2VBcm5SZWdpb24gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gb3ZlcnJpZGUgdGhlIHJlcXVlc3QgcmVnaW9uXG4gICAqICAgd2l0aCB0aGUgcmVnaW9uIGluZmVycmVkIGZyb20gcmVxdWVzdGVkIHJlc291cmNlJ3MgQVJOLiBPbmx5IGF2YWlsYWJsZSBmb3IgUzMgYnVja2V0c1xuICAgKiAgIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgKlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcmV0cnlEZWxheU9wdGlvbnMgW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBjb25maWd1cmVcbiAgICogICB0aGUgcmV0cnkgZGVsYXkgb24gcmV0cnlhYmxlIGVycm9ycy4gQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogICAqICoqYmFzZSoqIFtJbnRlZ2VyXSAmbWRhc2g7IFRoZSBiYXNlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdXNlIGluIHRoZVxuICAgKiAgICAgZXhwb25lbnRpYWwgYmFja29mZiBmb3Igb3BlcmF0aW9uIHJldHJpZXMuIERlZmF1bHRzIHRvIDEwMCBtcyBmb3IgYWxsXG4gICAqICAgICBzZXJ2aWNlcyBleGNlcHQgRHluYW1vREIsIHdoZXJlIGl0IGRlZmF1bHRzIHRvIDUwbXMuXG4gICAqICAgKiAqKmN1c3RvbUJhY2tvZmYgKiogW2Z1bmN0aW9uXSAmbWRhc2g7IEEgY3VzdG9tIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhXG4gICAqICAgICByZXRyeSBjb3VudCBhbmQgZXJyb3IgYW5kIHJldHVybnMgdGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGluXG4gICAqICAgICBtaWxsaXNlY29uZHMuIElmIHRoZSByZXN1bHQgaXMgYSBub24temVybyBuZWdhdGl2ZSB2YWx1ZSwgbm8gZnVydGhlclxuICAgKiAgICAgcmV0cnkgYXR0ZW1wdHMgd2lsbCBiZSBtYWRlLiBUaGUgYGJhc2VgIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQgaWYgdGhpc1xuICAgKiAgICAgb3B0aW9uIGlzIHN1cHBsaWVkLiBUaGUgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgZm9yIHJldHJ5YWJsZSBlcnJvcnMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBodHRwT3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGxvdy1sZXZlbFxuICAgKiAgIEhUVFAgcmVxdWVzdC4gQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogICAqICoqcHJveHkqKiBbU3RyaW5nXSAmbWRhc2g7IHRoZSBVUkwgdG8gcHJveHkgcmVxdWVzdHMgdGhyb3VnaFxuICAgKiAgICogKiphZ2VudCoqIFtodHRwLkFnZW50LCBodHRwcy5BZ2VudF0gJm1kYXNoOyB0aGUgQWdlbnQgb2JqZWN0IHRvIHBlcmZvcm1cbiAgICogICAgIEhUVFAgcmVxdWVzdHMgd2l0aC4gVXNlZCBmb3IgY29ubmVjdGlvbiBwb29saW5nLiBEZWZhdWx0cyB0byB0aGUgZ2xvYmFsXG4gICAqICAgICBhZ2VudCAoYGh0dHAuZ2xvYmFsQWdlbnRgKSBmb3Igbm9uLVNTTCBjb25uZWN0aW9ucy4gTm90ZSB0aGF0IGZvclxuICAgKiAgICAgU1NMIGNvbm5lY3Rpb25zLCBhIHNwZWNpYWwgQWdlbnQgb2JqZWN0IGlzIHVzZWQgaW4gb3JkZXIgdG8gZW5hYmxlXG4gICAqICAgICBwZWVyIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi4gVGhpcyBmZWF0dXJlIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZVxuICAgKiAgICAgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAgICogICAqICoqY29ubmVjdFRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlclxuICAgKiAgICAgZmFpbGluZyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlciBhZnRlclxuICAgKiAgICAgYGNvbm5lY3RUaW1lb3V0YCBtaWxsaXNlY29uZHMuIFRoaXMgdGltZW91dCBoYXMgbm8gZWZmZWN0IG9uY2UgYSBzb2NrZXRcbiAgICogICAgIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gICAqICAgKiAqKnRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0XG4gICAqICAgICBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiB0aGUgc29ja2V0LiBEZWZhdWx0cyB0byB0d28gbWludXRlc1xuICAgKiAgICAgKDEyMDAwMCkuXG4gICAqICAgKiAqKnhockFzeW5jKiogW0Jvb2xlYW5dICZtZGFzaDsgV2hldGhlciB0aGUgU0RLIHdpbGwgc2VuZCBhc3luY2hyb25vdXNcbiAgICogICAgIEhUVFAgcmVxdWVzdHMuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb25seS4gU2V0IHRvIGZhbHNlIHRvXG4gICAqICAgICBzZW5kIHJlcXVlc3RzIHN5bmNocm9ub3VzbHkuIERlZmF1bHRzIHRvIHRydWUgKGFzeW5jIG9uKS5cbiAgICogICAqICoqeGhyV2l0aENyZWRlbnRpYWxzKiogW0Jvb2xlYW5dICZtZGFzaDsgU2V0cyB0aGUgXCJ3aXRoQ3JlZGVudGlhbHNcIlxuICAgKiAgICAgcHJvcGVydHkgb2YgYW4gWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50XG4gICAqICAgICBvbmx5LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGFwaVZlcnNpb24gW1N0cmluZywgRGF0ZV0gYSBTdHJpbmcgaW4gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICogICAob3IgYSBkYXRlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGxhdGVzdCBwb3NzaWJsZSBBUEkgdmVyc2lvbiB0aGF0IGNhbiBiZVxuICAgKiAgIHVzZWQgaW4gYWxsIHNlcnZpY2VzICh1bmxlc3Mgb3ZlcnJpZGRlbiBieSBgYXBpVmVyc2lvbnNgKS4gU3BlY2lmeVxuICAgKiAgICdsYXRlc3QnIHRvIHVzZSB0aGUgbGF0ZXN0IHBvc3NpYmxlIHZlcnNpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBhcGlWZXJzaW9ucyBbbWFwPFN0cmluZywgU3RyaW5nfERhdGU+XSBhIG1hcCBvZiBzZXJ2aWNlXG4gICAqICAgaWRlbnRpZmllcnMgKHRoZSBsb3dlcmNhc2Ugc2VydmljZSBjbGFzcyBuYW1lKSB3aXRoIHRoZSBBUEkgdmVyc2lvbiB0b1xuICAgKiAgIHVzZSB3aGVuIGluc3RhbnRpYXRpbmcgYSBzZXJ2aWNlLiBTcGVjaWZ5ICdsYXRlc3QnIGZvciBlYWNoIGluZGl2aWR1YWxcbiAgICogICB0aGF0IGNhbiB1c2UgdGhlIGxhdGVzdCBhdmFpbGFibGUgdmVyc2lvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIGxvZ2dlciBbI3dyaXRlLCNsb2ddIGFuIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIC53cml0ZSgpXG4gICAqICAgKGxpa2UgYSBzdHJlYW0pIG9yIC5sb2coKSAobGlrZSB0aGUgY29uc29sZSBvYmplY3QpIGluIG9yZGVyIHRvIGxvZ1xuICAgKiAgIGluZm9ybWF0aW9uIGFib3V0IHJlcXVlc3RzXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzeXN0ZW1DbG9ja09mZnNldCBbTnVtYmVyXSBhbiBvZmZzZXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqICAgdG8gYXBwbHkgdG8gYWxsIHNpZ25pbmcgdGltZXMuIFVzZSB0aGlzIHRvIGNvbXBlbnNhdGUgZm9yIGNsb2NrIHNrZXdcbiAgICogICB3aGVuIHlvdXIgc3lzdGVtIG1heSBiZSBvdXQgb2Ygc3luYyB3aXRoIHRoZSBzZXJ2aWNlIHRpbWUuIE5vdGUgdGhhdFxuICAgKiAgIHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZ2xvYmFsIGBBV1MuY29uZmlnYFxuICAgKiAgIG9iamVjdCBhbmQgY2Fubm90IGJlIG92ZXJyaWRkZW4gaW4gc2VydmljZS1zcGVjaWZpYyBjb25maWd1cmF0aW9uLlxuICAgKiAgIERlZmF1bHRzIHRvIDAgbWlsbGlzZWNvbmRzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2lnbmF0dXJlVmVyc2lvbiBbU3RyaW5nXSB0aGUgc2lnbmF0dXJlIHZlcnNpb24gdG8gc2lnblxuICAgKiAgIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmcgdGhlIEFQSSBjb25maWd1cmF0aW9uKS4gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICogICAndjInLCAndjMnLCAndjQnLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2lnbmF0dXJlQ2FjaGUgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSB0byBzaWduXG4gICAqICAgcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZyB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pIGlzIGNhY2hlZC4gT25seSBhcHBsaWVzXG4gICAqICAgdG8gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uICd2NCcuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGR5bmFtb0RiQ3JjMzIgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gdmFsaWRhdGUgdGhlIENSQzMyXG4gICAqICAgY2hlY2tzdW0gb2YgSFRUUCByZXNwb25zZSBib2RpZXMgcmV0dXJuZWQgYnkgRHluYW1vREIuIERlZmF1bHQ6IGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHVzZUFjY2VsZXJhdGVFbmRwb2ludCBbQm9vbGVhbl0gV2hldGhlciB0byB1c2UgdGhlXG4gICAqICAgUzMgVHJhbnNmZXIgQWNjZWxlcmF0aW9uIGVuZHBvaW50IHdpdGggdGhlIFMzIHNlcnZpY2UuIERlZmF1bHQ6IGBmYWxzZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjbGllbnRTaWRlTW9uaXRvcmluZyBbQm9vbGVhbl0gd2hldGhlciB0byBjb2xsZWN0IGFuZFxuICAgKiAgIHB1Ymxpc2ggdGhpcyBjbGllbnQncyBwZXJmb3JtYW5jZSBtZXRyaWNzIG9mIGFsbCBpdHMgQVBJIHJlcXVlc3RzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkIFtCb29sZWFufHVuZGVmaW5lZF0gd2hldGhlciB0b1xuICAgKiAgIGNhbGwgb3BlcmF0aW9ucyB3aXRoIGVuZHBvaW50cyBnaXZlbiBieSBzZXJ2aWNlIGR5bmFtaWNhbGx5LiBTZXR0aW5nIHRoaXNcbiAgICogY29uZmlnIHRvIGB0cnVlYCB3aWxsIGVuYWJsZSBlbmRwb2ludCBkaXNjb3ZlcnkgZm9yIGFsbCBhcHBsaWNhYmxlIG9wZXJhdGlvbnMuXG4gICAqICAgU2V0dGluZyBpdCB0byBgZmFsc2VgIHdpbGwgZXhwbGljaXRseSBkaXNhYmxlIGVuZHBvaW50IGRpc2NvdmVyeSBldmVuIHRob3VnaFxuICAgKiAgIG9wZXJhdGlvbnMgdGhhdCByZXF1aXJlIGVuZHBvaW50IGRpc2NvdmVyeSB3aWxsIHByZXN1bWFibHkgZmFpbC4gTGVhdmluZyBpdFxuICAgKiAgIHRvIGB1bmRlZmluZWRgIG1lYW5zIFNESyB3aWxsIG9ubHkgZG8gZW5kcG9pbnQgZGlzY292ZXJ5IHdoZW4gaXQncyByZXF1aXJlZC5cbiAgICogICBEZWZhdWx0cyB0byBgdW5kZWZpbmVkYFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZW5kcG9pbnRDYWNoZVNpemUgW051bWJlcl0gdGhlIHNpemUgb2YgdGhlIGdsb2JhbCBjYWNoZSBzdG9yaW5nXG4gICAqICAgZW5kcG9pbnRzIGZyb20gZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbnMuIE9uY2UgZW5kcG9pbnQgY2FjaGUgaXMgY3JlYXRlZCxcbiAgICogICB1cGRhdGluZyB0aGlzIHNldHRpbmcgY2Fubm90IGNoYW5nZSBleGlzdGluZyBjYWNoZSBzaXplLlxuICAgKiAgIERlZmF1bHRzIHRvIDEwMDBcbiAgICogQG9wdGlvbiBvcHRpb25zIGhvc3RQcmVmaXhFbmFibGVkIFtCb29sZWFuXSB3aGV0aGVyIHRvIG1hcnNoYWwgcmVxdWVzdFxuICAgKiAgIHBhcmFtZXRlcnMgdG8gdGhlIHByZWZpeCBvZiBob3N0bmFtZS5cbiAgICogICBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzdHNSZWdpb25hbEVuZHBvaW50cyBbJ2xlZ2FjeSd8J3JlZ2lvbmFsJ10gd2hldGhlciB0byBzZW5kIHN0cyByZXF1ZXN0XG4gICAqICAgdG8gZ2xvYmFsIGVuZHBvaW50cyBvciByZWdpb25hbCBlbmRwb2ludHMuXG4gICAqICAgRGVmYXVsdHMgdG8gJ2xlZ2FjeScuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB1c2VGaXBzRW5kcG9pbnQgW0Jvb2xlYW5dIEVuYWJsZXMgRklQUyBjb21wYXRpYmxlIGVuZHBvaW50cy5cbiAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgdXNlRHVhbHN0YWNrRW5kcG9pbnQgW0Jvb2xlYW5dIEVuYWJsZXMgSVB2NiBkdWFsc3RhY2sgZW5kcG9pbnQuXG4gICAqICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDb25maWcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zID0gdGhpcy5leHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucyk7XG5cbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5rZXlzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBvcHRpb25zW2tleV0sIHZhbHVlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBNYW5hZ2luZyBDcmVkZW50aWFsc1xuICAgKi9cblxuICAvKipcbiAgICogTG9hZHMgY3JlZGVudGlhbHMgZnJvbSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5XG4gICAqIGJ5IHRoZSBTREsgdG8gZW5zdXJlIHRoYXQgcmVmcmVzaGFibGUge0NyZWRlbnRpYWxzfSBvYmplY3RzIGFyZSBwcm9wZXJseVxuICAgKiByZWZyZXNoZWQgYW5kIGxvYWRlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0LiBJZiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdFxuICAgKiB5b3VyIGNyZWRlbnRpYWxzIGFyZSBsb2FkZWQgcHJpb3IgdG8gYSByZXF1ZXN0LCB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZFxuICAgKiBkaXJlY3RseSB0byBwcm92aWRlIGFjY3VyYXRlIGNyZWRlbnRpYWwgZGF0YSBzdG9yZWQgaW4gdGhlIG9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgSWYgeW91IGNvbmZpZ3VyZSB0aGUgU0RLIHdpdGggc3RhdGljIG9yIGVudmlyb25tZW50IGNyZWRlbnRpYWxzLFxuICAgKiAgIHRoZSBjcmVkZW50aWFsIGRhdGEgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudCBpbiB7Y3JlZGVudGlhbHN9IGF0dHJpYnV0ZS5cbiAgICogICBUaGlzIG1ldGhvZCBpcyBwcmltYXJpbHkgbmVjZXNzYXJ5IHRvIGxvYWQgY3JlZGVudGlhbHMgZnJvbSBhc3luY2hyb25vdXNcbiAgICogICBzb3VyY2VzLCBvciBzb3VyY2VzIHRoYXQgY2FuIHJlZnJlc2ggY3JlZGVudGlhbHMgcGVyaW9kaWNhbGx5LlxuICAgKiBAZXhhbXBsZSBHZXR0aW5nIHlvdXIgYWNjZXNzIGtleVxuICAgKiAgIEFXUy5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIuc3RhY2spOyAvLyBjcmVkZW50aWFscyBub3QgbG9hZGVkXG4gICAqICAgICBlbHNlIGNvbnNvbGUubG9nKFwiQWNjZXNzIEtleTpcIiwgQVdTLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCk7XG4gICAqICAgfSlcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUge2NyZWRlbnRpYWxzfSBoYXZlIGJlZW4gcHJvcGVybHkgc2V0IG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAqICAgb2JqZWN0LlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiB0aGlzIGlzIHNldCwgY3JlZGVudGlhbHMgd2VyZSBub3Qgc3VjY2Vzc2Z1bGx5XG4gICAqICAgICBsb2FkZWQgYW5kIHRoaXMgZXJyb3IgcHJvdmlkZXMgaW5mb3JtYXRpb24gd2h5LlxuICAgKiBAc2VlIGNyZWRlbnRpYWxzXG4gICAqIEBzZWUgQ3JlZGVudGlhbHNcbiAgICovXG4gIGdldENyZWRlbnRpYWxzOiBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgZXJyID8gbnVsbCA6IHNlbGYuY3JlZGVudGlhbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWRFcnJvcihtc2csIGVycikge1xuICAgICAgcmV0dXJuIG5ldyBBV1MudXRpbC5lcnJvcihlcnIgfHwgbmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0NyZWRlbnRpYWxzRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG5hbWU6ICdDcmVkZW50aWFsc0Vycm9yJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXN5bmNDcmVkZW50aWFscygpIHtcbiAgICAgIHNlbGYuY3JlZGVudGlhbHMuZ2V0KGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tICcgK1xuICAgICAgICAgICAgc2VsZi5jcmVkZW50aWFscy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgIGVyciA9IGNyZWRFcnJvcihtc2csIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNDcmVkZW50aWFscygpIHtcbiAgICAgIHZhciBlcnIgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkIHx8ICFzZWxmLmNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSkge1xuICAgICAgICBlcnIgPSBjcmVkRXJyb3IoJ01pc3NpbmcgY3JlZGVudGlhbHMnKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaChlcnIpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmNyZWRlbnRpYWxzKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuY3JlZGVudGlhbHMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGdldEFzeW5jQ3JlZGVudGlhbHMoKTtcbiAgICAgIH0gZWxzZSB7IC8vIHN0YXRpYyBjcmVkZW50aWFsc1xuICAgICAgICBnZXRTdGF0aWNDcmVkZW50aWFscygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZi5jcmVkZW50aWFsUHJvdmlkZXIpIHtcbiAgICAgIHNlbGYuY3JlZGVudGlhbFByb3ZpZGVyLnJlc29sdmUoZnVuY3Rpb24oZXJyLCBjcmVkcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyID0gY3JlZEVycm9yKCdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tIGFueSBwcm92aWRlcnMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKGNyZWRFcnJvcignTm8gY3JlZGVudGlhbHMgdG8gbG9hZCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhZ3JvdXAgTG9hZGluZyBhbmQgU2V0dGluZyBDb25maWd1cmF0aW9uIE9wdGlvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZCB1cGRhdGUob3B0aW9ucywgYWxsb3dVbmtub3duS2V5cyA9IGZhbHNlKVxuICAgKiAgIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICpcbiAgICogICBAZXhhbXBsZSBVcGRhdGUgbWF4UmV0cmllcyBwcm9wZXJ0eSBvZiBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqICAgICBjb25maWcudXBkYXRlKHttYXhSZXRyaWVzOiAxMH0pO1xuICAgKiAgIEBwYXJhbSBbT2JqZWN0XSBvcHRpb25zIGEgbWFwIG9mIG9wdGlvbiBrZXlzIGFuZCB2YWx1ZXMuXG4gICAqICAgQHBhcmFtIFtCb29sZWFuXSBhbGxvd1Vua25vd25LZXlzIHdoZXRoZXIgdW5rbm93biBrZXlzIGNhbiBiZSBzZXQgb25cbiAgICogICAgIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogICBAc2VlIGNvbnN0cnVjdG9yXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvcHRpb25zLCBhbGxvd1Vua25vd25LZXlzKSB7XG4gICAgYWxsb3dVbmtub3duS2V5cyA9IGFsbG93VW5rbm93bktleXMgfHwgZmFsc2U7XG4gICAgb3B0aW9ucyA9IHRoaXMuZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGFsbG93VW5rbm93bktleXMgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMua2V5cywga2V5KSB8fFxuICAgICAgICAgIEFXUy5TZXJ2aWNlLmhhc1NlcnZpY2Uoa2V5KSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgY29uZmlndXJhdGlvbiBkYXRhIGZyb20gYSBKU09OIGZpbGUgaW50byB0aGlzIGNvbmZpZyBvYmplY3QuXG4gICAqIEBub3RlIExvYWRpbmcgY29uZmlndXJhdGlvbiB3aWxsIHJlc2V0IGFsbCBleGlzdGluZyBjb25maWd1cmF0aW9uXG4gICAqICAgb24gdGhlIG9iamVjdC5cbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICogQHBhcmFtIHBhdGggW1N0cmluZ10gdGhlIHBhdGggcmVsYXRpdmUgdG8geW91ciBwcm9jZXNzJ3MgY3VycmVudFxuICAgKiAgICB3b3JraW5nIGRpcmVjdG9yeSB0byBsb2FkIGNvbmZpZ3VyYXRpb24gZnJvbS5cbiAgICogQHJldHVybiBbQVdTLkNvbmZpZ10gdGhlIHNhbWUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGxvYWRGcm9tUGF0aDogZnVuY3Rpb24gbG9hZEZyb21QYXRoKHBhdGgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IEpTT04ucGFyc2UoQVdTLnV0aWwucmVhZEZpbGVTeW5jKHBhdGgpKTtcbiAgICB2YXIgZmlsZVN5c3RlbUNyZWRzID0gbmV3IEFXUy5GaWxlU3lzdGVtQ3JlZGVudGlhbHMocGF0aCk7XG4gICAgdmFyIGNoYWluID0gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbigpO1xuICAgIGNoYWluLnByb3ZpZGVycy51bnNoaWZ0KGZpbGVTeXN0ZW1DcmVkcyk7XG4gICAgY2hhaW4ucmVzb2x2ZShmdW5jdGlvbiAoZXJyLCBjcmVkcykge1xuICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgZWxzZSBvcHRpb25zLmNyZWRlbnRpYWxzID0gY3JlZHM7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnN0cnVjdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyBjb25maWd1cmF0aW9uIGRhdGEgb24gdGhpcyBvYmplY3RcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5rZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH0pO1xuXG4gICAgLy8gcmVzZXQgY3JlZGVudGlhbCBwcm92aWRlclxuICAgIHRoaXMuc2V0KCdjcmVkZW50aWFscycsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zZXQoJ2NyZWRlbnRpYWxQcm92aWRlcicsIHVuZGVmaW5lZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9wZXJ0eSBvbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QsIGFsbG93aW5nIGZvciBhXG4gICAqIGRlZmF1bHQgdmFsdWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIHNldChwcm9wZXJ0eSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5rZXlzW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnaHR0cE9wdGlvbnMnICYmIHRoaXNbcHJvcGVydHldKSB7XG4gICAgICAvLyBkZWVwIG1lcmdlIGh0dHBPcHRpb25zXG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IEFXUy51dGlsLm1lcmdlKHRoaXNbcHJvcGVydHldLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGtleXMgd2l0aCB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogQGNvbnN0YW50XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAga2V5czoge1xuICAgIGNyZWRlbnRpYWxzOiBudWxsLFxuICAgIGNyZWRlbnRpYWxQcm92aWRlcjogbnVsbCxcbiAgICByZWdpb246IG51bGwsXG4gICAgbG9nZ2VyOiBudWxsLFxuICAgIGFwaVZlcnNpb25zOiB7fSxcbiAgICBhcGlWZXJzaW9uOiBudWxsLFxuICAgIGVuZHBvaW50OiB1bmRlZmluZWQsXG4gICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgIHRpbWVvdXQ6IDEyMDAwMFxuICAgIH0sXG4gICAgbWF4UmV0cmllczogdW5kZWZpbmVkLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgcGFyYW1WYWxpZGF0aW9uOiB0cnVlLFxuICAgIHNzbEVuYWJsZWQ6IHRydWUsXG4gICAgczNGb3JjZVBhdGhTdHlsZTogZmFsc2UsXG4gICAgczNCdWNrZXRFbmRwb2ludDogZmFsc2UsXG4gICAgczNEaXNhYmxlQm9keVNpZ25pbmc6IHRydWUsXG4gICAgczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludDogJ2xlZ2FjeScsXG4gICAgczNVc2VBcm5SZWdpb246IHVuZGVmaW5lZCxcbiAgICBjb21wdXRlQ2hlY2tzdW1zOiB0cnVlLFxuICAgIGNvbnZlcnRSZXNwb25zZVR5cGVzOiB0cnVlLFxuICAgIGNvcnJlY3RDbG9ja1NrZXc6IGZhbHNlLFxuICAgIGN1c3RvbVVzZXJBZ2VudDogbnVsbCxcbiAgICBkeW5hbW9EYkNyYzMyOiB0cnVlLFxuICAgIHN5c3RlbUNsb2NrT2Zmc2V0OiAwLFxuICAgIHNpZ25hdHVyZVZlcnNpb246IG51bGwsXG4gICAgc2lnbmF0dXJlQ2FjaGU6IHRydWUsXG4gICAgcmV0cnlEZWxheU9wdGlvbnM6IHt9LFxuICAgIHVzZUFjY2VsZXJhdGVFbmRwb2ludDogZmFsc2UsXG4gICAgY2xpZW50U2lkZU1vbml0b3Jpbmc6IGZhbHNlLFxuICAgIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZDogdW5kZWZpbmVkLFxuICAgIGVuZHBvaW50Q2FjaGVTaXplOiAxMDAwLFxuICAgIGhvc3RQcmVmaXhFbmFibGVkOiB0cnVlLFxuICAgIHN0c1JlZ2lvbmFsRW5kcG9pbnRzOiAnbGVnYWN5JyxcbiAgICB1c2VGaXBzRW5kcG9pbnQ6IGZhbHNlLFxuICAgIHVzZUR1YWxzdGFja0VuZHBvaW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBhY2Nlc3NLZXlJZCwgc2VjcmV0QWNjZXNzS2V5IGFuZCBzZXNzaW9uVG9rZW5cbiAgICogZnJvbSBhIGNvbmZpZ3VyYXRpb24gaGFzaC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0Q3JlZGVudGlhbHM6IGZ1bmN0aW9uIGV4dHJhY3RDcmVkZW50aWFscyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzS2V5SWQgJiYgb3B0aW9ucy5zZWNyZXRBY2Nlc3NLZXkpIHtcbiAgICAgIG9wdGlvbnMgPSBBV1MudXRpbC5jb3B5KG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ3JlZGVudGlhbHMob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgdGhlIFNESyB3aWxsIHVzZSB3aGVyZXZlciBQcm9taXNlcyBhcmUgcmV0dXJuZWQuXG4gICAqIFBhc3NpbmcgYG51bGxgIHdpbGwgZm9yY2UgdGhlIFNESyB0byB1c2UgbmF0aXZlIFByb21pc2VzIGlmIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAgICogSWYgbmF0aXZlIFByb21pc2VzIGFyZSBub3QgYXZhaWxhYmxlLCBwYXNzaW5nIGBudWxsYCB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKiBAcGFyYW0gW0NvbnN0cnVjdG9yXSBkZXAgQSByZWZlcmVuY2UgdG8gYSBQcm9taXNlIGNvbnN0cnVjdG9yXG4gICAqL1xuICBzZXRQcm9taXNlc0RlcGVuZGVuY3k6IGZ1bmN0aW9uIHNldFByb21pc2VzRGVwZW5kZW5jeShkZXApIHtcbiAgICBQcm9taXNlc0RlcGVuZGVuY3kgPSBkZXA7XG4gICAgLy8gaWYgbnVsbCB3YXMgcGFzc2VkIGluLCB3ZSBzaG91bGQgdHJ5IHRvIHVzZSBuYXRpdmUgcHJvbWlzZXNcbiAgICBpZiAoZGVwID09PSBudWxsICYmIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBQcm9taXNlc0RlcGVuZGVuY3kgPSBQcm9taXNlO1xuICAgIH1cbiAgICB2YXIgY29uc3RydWN0b3JzID0gW0FXUy5SZXF1ZXN0LCBBV1MuQ3JlZGVudGlhbHMsIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbl07XG4gICAgaWYgKEFXUy5TMykge1xuICAgICAgY29uc3RydWN0b3JzLnB1c2goQVdTLlMzKTtcbiAgICAgIGlmIChBV1MuUzMuTWFuYWdlZFVwbG9hZCkge1xuICAgICAgICBjb25zdHJ1Y3RvcnMucHVzaChBV1MuUzMuTWFuYWdlZFVwbG9hZCk7XG4gICAgICB9XG4gICAgfVxuICAgIEFXUy51dGlsLmFkZFByb21pc2VzKGNvbnN0cnVjdG9ycywgUHJvbWlzZXNEZXBlbmRlbmN5KTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IHNldCBieSBgQVdTLmNvbmZpZy5zZXRQcm9taXNlc0RlcGVuZGVuY3lgLlxuICAgKi9cbiAgZ2V0UHJvbWlzZXNEZXBlbmRlbmN5OiBmdW5jdGlvbiBnZXRQcm9taXNlc0RlcGVuZGVuY3koKSB7XG4gICAgcmV0dXJuIFByb21pc2VzRGVwZW5kZW5jeTtcbiAgfVxufSk7XG5cbi8qKlxuICogQHJldHVybiBbQVdTLkNvbmZpZ10gVGhlIGdsb2JhbCBjb25maWd1cmF0aW9uIG9iamVjdCBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIEByZWFkb25seVxuICogQHNlZSBBV1MuQ29uZmlnXG4gKi9cbkFXUy5jb25maWcgPSBuZXcgQVdTLkNvbmZpZygpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZWdpb25hbEVuZHBvaW50c0ZsYWdWYWx1ZShjb25maWdWYWx1ZSwgZXJyb3JPcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnVmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBlbHNlIGlmIChbJ2xlZ2FjeScsICdyZWdpb25hbCddLmluZGV4T2YoY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuICAgIHJldHVybiBjb25maWdWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCBlcnJvck9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogUmVzb2x2ZSB0aGUgY29uZmlndXJhdGlvbiB2YWx1ZSBmb3IgcmVnaW9uYWwgZW5kcG9pbnQgZnJvbSBkaWZmZXJlbmNlIHNvdXJjZXM6IGNsaWVudFxuICogY29uZmlnLCBlbnZpcm9ubWVudGFsIHZhcmlhYmxlLCBzaGFyZWQgY29uZmlnIGZpbGUuIFZhbHVlIGNhbiBiZSBjYXNlLWluc2Vuc2l0aXZlXG4gKiAnbGVnYWN5JyBvciAncmVnaW5hbCcuXG4gKiBAcGFyYW0gb3JpZ2luYWxDb25maWcgdXNlci1zdXBwbGllZCBjb25maWcgb2JqZWN0IHRvIHJlc29sdmVcbiAqIEBwYXJhbSBvcHRpb25zIGEgbWFwIG9mIGNvbmZpZyBwcm9wZXJ0eSBuYW1lcyBmcm9tIGluZGl2aWR1YWwgY29uZmlndXJhdGlvbiBzb3VyY2VcbiAqICAtIGVudjogbmFtZSBvZiBlbnZpcm9ubWVudGFsIHZhcmlhYmxlIHRoYXQgcmVmZXJzIHRvIHRoZSBjb25maWdcbiAqICAtIHNoYXJlZENvbmZpZzogbmFtZSBvZiBzaGFyZWQgY29uZmlndXJhdGlvbiBmaWxlIHByb3BlcnR5IHRoYXQgcmVmZXJzIHRvIHRoZSBjb25maWdcbiAqICAtIGNsaWVudENvbmZpZzogbmFtZSBvZiBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSB0aGF0IHJlZmVycyB0byB0aGUgY29uZmlnXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcob3JpZ2luYWxDb25maWcsIG9wdGlvbnMpIHtcbiAgb3JpZ2luYWxDb25maWcgPSBvcmlnaW5hbENvbmZpZyB8fCB7fTtcbiAgLy92YWxpZGF0ZSBjb25maWcgdmFsdWVcbiAgdmFyIHJlc29sdmVkO1xuICBpZiAob3JpZ2luYWxDb25maWdbb3B0aW9ucy5jbGllbnRDb25maWddKSB7XG4gICAgcmVzb2x2ZWQgPSB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKG9yaWdpbmFsQ29uZmlnW29wdGlvbnMuY2xpZW50Q29uZmlnXSwge1xuICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIFwiJyArIG9wdGlvbnMuY2xpZW50Q29uZmlnICsgJ1wiIGNvbmZpZ3VyYXRpb24uIEV4cGVjdCBcImxlZ2FjeVwiICcgK1xuICAgICAgJyBvciBcInJlZ2lvbmFsXCIuIEdvdCBcIicgKyBvcmlnaW5hbENvbmZpZ1tvcHRpb25zLmNsaWVudENvbmZpZ10gKyAnXCIuJ1xuICAgIH0pO1xuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkO1xuICB9XG4gIGlmICghQVdTLnV0aWwuaXNOb2RlKCkpIHJldHVybiByZXNvbHZlZDtcbiAgLy92YWxpZGF0ZSBlbnZpcm9ubWVudGFsIHZhcmlhYmxlXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzcy5lbnYsIG9wdGlvbnMuZW52KSkge1xuICAgIHZhciBlbnZGbGFnID0gcHJvY2Vzcy5lbnZbb3B0aW9ucy5lbnZdO1xuICAgIHJlc29sdmVkID0gdmFsaWRhdGVSZWdpb25hbEVuZHBvaW50c0ZsYWdWYWx1ZShlbnZGbGFnLCB7XG4gICAgICBjb2RlOiAnSW52YWxpZEVudmlyb25tZW50YWxWYXJpYWJsZScsXG4gICAgICBtZXNzYWdlOiAnaW52YWxpZCAnICsgb3B0aW9ucy5lbnYgKyAnIGVudmlyb25tZW50YWwgdmFyaWFibGUuIEV4cGVjdCBcImxlZ2FjeVwiICcgK1xuICAgICAgJyBvciBcInJlZ2lvbmFsXCIuIEdvdCBcIicgKyBwcm9jZXNzLmVudltvcHRpb25zLmVudl0gKyAnXCIuJ1xuICAgIH0pO1xuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkO1xuICB9XG4gIC8vdmFsaWRhdGUgc2hhcmVkIGNvbmZpZyBmaWxlXG4gIHZhciBwcm9maWxlID0ge307XG4gIHRyeSB7XG4gICAgdmFyIHByb2ZpbGVzID0gQVdTLnV0aWwuZ2V0UHJvZmlsZXNGcm9tU2hhcmVkQ29uZmlnKEFXUy51dGlsLmluaUxvYWRlcik7XG4gICAgcHJvZmlsZSA9IHByb2ZpbGVzW3Byb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlXTtcbiAgfSBjYXRjaCAoZSkge307XG4gIGlmIChwcm9maWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9maWxlLCBvcHRpb25zLnNoYXJlZENvbmZpZykpIHtcbiAgICB2YXIgZmlsZUZsYWcgPSBwcm9maWxlW29wdGlvbnMuc2hhcmVkQ29uZmlnXTtcbiAgICByZXNvbHZlZCA9IHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUoZmlsZUZsYWcsIHtcbiAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICBtZXNzYWdlOiAnaW52YWxpZCAnICsgb3B0aW9ucy5zaGFyZWRDb25maWcgKyAnIHByb2ZpbGUgY29uZmlnLiBFeHBlY3QgXCJsZWdhY3lcIiAnICtcbiAgICAgICcgb3IgXCJyZWdpb25hbFwiLiBHb3QgXCInICsgcHJvZmlsZVtvcHRpb25zLnNoYXJlZENvbmZpZ10gKyAnXCIuJ1xuICAgIH0pO1xuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkO1xuICB9XG4gIHJldHVybiByZXNvbHZlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnO1xuIiwiLyoqXG4gKiBUaGUgbWFpbiBBV1MgbmFtZXNwYWNlXG4gKi9cbnZhciBBV1MgPSB7IHV0aWw6IHJlcXVpcmUoJy4vdXRpbCcpIH07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAIW1hY3JvIFtuZXddIG5vYnJvd3NlclxuICogICBAbm90ZSBUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvZiB0aGUgU0RLLlxuICovXG52YXIgX2hpZGRlbiA9IHt9OyBfaGlkZGVuLnRvU3RyaW5nKCk7IC8vIGhhY2sgdG8gcGFyc2UgbWFjcm9cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1M7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MsIHtcblxuICAvKipcbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBWRVJTSU9OOiAnMi4xMTI2LjAnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIFNpZ25lcnM6IHt9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIFByb3RvY29sOiB7XG4gICAgSnNvbjogcmVxdWlyZSgnLi9wcm90b2NvbC9qc29uJyksXG4gICAgUXVlcnk6IHJlcXVpcmUoJy4vcHJvdG9jb2wvcXVlcnknKSxcbiAgICBSZXN0OiByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3QnKSxcbiAgICBSZXN0SnNvbjogcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X2pzb24nKSxcbiAgICBSZXN0WG1sOiByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfeG1sJylcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBYTUw6IHtcbiAgICBCdWlsZGVyOiByZXF1aXJlKCcuL3htbC9idWlsZGVyJyksXG4gICAgUGFyc2VyOiBudWxsIC8vIGNvbmRpdGlvbmFsbHkgc2V0IGJhc2VkIG9uIGVudmlyb25tZW50XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgSlNPTjoge1xuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4vanNvbi9idWlsZGVyJyksXG4gICAgUGFyc2VyOiByZXF1aXJlKCcuL2pzb24vcGFyc2VyJylcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBNb2RlbDoge1xuICAgIEFwaTogcmVxdWlyZSgnLi9tb2RlbC9hcGknKSxcbiAgICBPcGVyYXRpb246IHJlcXVpcmUoJy4vbW9kZWwvb3BlcmF0aW9uJyksXG4gICAgU2hhcGU6IHJlcXVpcmUoJy4vbW9kZWwvc2hhcGUnKSxcbiAgICBQYWdpbmF0b3I6IHJlcXVpcmUoJy4vbW9kZWwvcGFnaW5hdG9yJyksXG4gICAgUmVzb3VyY2VXYWl0ZXI6IHJlcXVpcmUoJy4vbW9kZWwvcmVzb3VyY2Vfd2FpdGVyJylcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGlMb2FkZXI6IHJlcXVpcmUoJy4vYXBpX2xvYWRlcicpLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIEVuZHBvaW50Q2FjaGU6IHJlcXVpcmUoJy4uL3ZlbmRvci9lbmRwb2ludC1jYWNoZScpLkVuZHBvaW50Q2FjaGVcbn0pO1xucmVxdWlyZSgnLi9zZXF1ZW50aWFsX2V4ZWN1dG9yJyk7XG5yZXF1aXJlKCcuL3NlcnZpY2UnKTtcbnJlcXVpcmUoJy4vY29uZmlnJyk7XG5yZXF1aXJlKCcuL2h0dHAnKTtcbnJlcXVpcmUoJy4vZXZlbnRfbGlzdGVuZXJzJyk7XG5yZXF1aXJlKCcuL3JlcXVlc3QnKTtcbnJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcbnJlcXVpcmUoJy4vcmVzb3VyY2Vfd2FpdGVyJyk7XG5yZXF1aXJlKCcuL3NpZ25lcnMvcmVxdWVzdF9zaWduZXInKTtcbnJlcXVpcmUoJy4vcGFyYW1fdmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQHJlYWRvbmx5XG4gKiBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSBhIGNvbGxlY3Rpb24gb2YgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyB0aGF0XG4gKiAgIGFyZSBhdHRhY2hlZCB0byBldmVyeSBzZW50IHJlcXVlc3QuXG4gKiBAc2VlIEFXUy5SZXF1ZXN0IEFXUy5SZXF1ZXN0IGZvciBhIGxpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3JcbiAqIEBleGFtcGxlIExvZ2dpbmcgdGhlIHRpbWUgdGFrZW4gdG8gc2VuZCBhIHJlcXVlc3RcbiAqICAgQVdTLmV2ZW50cy5vbignc2VuZCcsIGZ1bmN0aW9uIHN0YXJ0U2VuZChyZXNwKSB7XG4gKiAgICAgcmVzcC5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAqICAgfSkub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gY2FsY3VsYXRlVGltZShyZXNwKSB7XG4gKiAgICAgdmFyIHRpbWUgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSByZXNwLnN0YXJ0VGltZSkgLyAxMDAwO1xuICogICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHRvb2sgJyArIHRpbWUgKyAnIHNlY29uZHMnKTtcbiAqICAgfSk7XG4gKlxuICogICBuZXcgQVdTLlMzKCkubGlzdEJ1Y2tldHMoKTsgLy8gcHJpbnRzICdSZXF1ZXN0IHRvb2sgMC4yODUgc2Vjb25kcydcbiAqL1xuQVdTLmV2ZW50cyA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG5cbi8vY3JlYXRlIGVuZHBvaW50IGNhY2hlIGxhemlseVxuQVdTLnV0aWwubWVtb2l6ZWRQcm9wZXJ0eShBV1MsICdlbmRwb2ludENhY2hlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQVdTLkVuZHBvaW50Q2FjaGUoQVdTLmNvbmZpZy5lbmRwb2ludENhY2hlU2l6ZSk7XG59LCB0cnVlKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHlvdXIgQVdTIHNlY3VyaXR5IGNyZWRlbnRpYWxzLCBzcGVjaWZpY2FsbHkgdGhlXG4gKiB7YWNjZXNzS2V5SWR9LCB7c2VjcmV0QWNjZXNzS2V5fSwgYW5kIG9wdGlvbmFsIHtzZXNzaW9uVG9rZW59LlxuICogQ3JlYXRpbmcgYSBgQ3JlZGVudGlhbHNgIG9iamVjdCBhbGxvd3MgeW91IHRvIHBhc3MgYXJvdW5kIHlvdXJcbiAqIHNlY3VyaXR5IGluZm9ybWF0aW9uIHRvIGNvbmZpZ3VyYXRpb24gYW5kIHNlcnZpY2Ugb2JqZWN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBjbGFzcyB0eXBpY2FsbHkgZG9lcyBub3QgbmVlZCB0byBiZSBjb25zdHJ1Y3RlZCBtYW51YWxseSxcbiAqIGFzIHRoZSB7QVdTLkNvbmZpZ30gYW5kIHtBV1MuU2VydmljZX0gY2xhc3NlcyBib3RoIGFjY2VwdCBzaW1wbGVcbiAqIG9wdGlvbnMgaGFzaGVzIHdpdGggdGhlIHRocmVlIGtleXMuIFRoZXNlIHN0cnVjdHVyZXMgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIGludG8gQ3JlZGVudGlhbHMgb2JqZWN0cyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICMjIEV4cGlyaW5nIGFuZCBSZWZyZXNoaW5nIENyZWRlbnRpYWxzXG4gKlxuICogT2NjYXNpb25hbGx5IGNyZWRlbnRpYWxzIGNhbiBleHBpcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGxvbmctcnVubmluZ1xuICogYXBwbGljYXRpb24uIEluIHRoaXMgY2FzZSwgdGhlIFNESyB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0ZW1wdCB0b1xuICogcmVmcmVzaCB0aGUgY3JlZGVudGlhbHMgZnJvbSB0aGUgc3RvcmFnZSBsb2NhdGlvbiBpZiB0aGUgQ3JlZGVudGlhbHNcbiAqIGNsYXNzIGltcGxlbWVudHMgdGhlIHtyZWZyZXNofSBtZXRob2QuXG4gKlxuICogSWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjcmVkZW50aWFsIHN0b3JhZ2UgbG9jYXRpb24sIHlvdVxuICogd2lsbCB3YW50IHRvIGNyZWF0ZSBhIHN1YmNsYXNzIG9mIHRoZSBgQ3JlZGVudGlhbHNgIGNsYXNzIGFuZFxuICogb3ZlcnJpZGUgdGhlIHtyZWZyZXNofSBtZXRob2QuIFRoaXMgbWV0aG9kIGFsbG93cyBjcmVkZW50aWFscyB0byBiZVxuICogcmV0cmlldmVkIGZyb20gdGhlIGJhY2tpbmcgc3RvcmUsIGJlIGl0IGEgZmlsZSBzeXN0ZW0sIGRhdGFiYXNlLCBvclxuICogc29tZSBuZXR3b3JrIHN0b3JhZ2UuIFRoZSBtZXRob2Qgc2hvdWxkIHJlc2V0IHRoZSBjcmVkZW50aWFsIGF0dHJpYnV0ZXNcbiAqIG9uIHRoZSBvYmplY3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgZXhwaXJlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBjcmVkZW50aWFscyBoYXZlIGJlZW4gZXhwaXJlZCBhbmRcbiAqICAgICByZXF1aXJlIGEgcmVmcmVzaC4gVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHtleHBpcmVUaW1lfS5cbiAqIEAhYXR0cmlidXRlIGV4cGlyZVRpbWVcbiAqICAgQHJldHVybiBbRGF0ZV0gYSB0aW1lIHdoZW4gY3JlZGVudGlhbHMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZXhwaXJlZC4gVXNlZFxuICogICAgIGluIGNvbmp1bmN0aW9uIHdpdGgge2V4cGlyZWR9LlxuICogQCFhdHRyaWJ1dGUgYWNjZXNzS2V5SWRcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQVdTIGFjY2VzcyBrZXkgSURcbiAqIEAhYXR0cmlidXRlIHNlY3JldEFjY2Vzc0tleVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBBV1Mgc2VjcmV0IGFjY2VzcyBrZXlcbiAqIEAhYXR0cmlidXRlIHNlc3Npb25Ub2tlblxuICogICBAcmV0dXJuIFtTdHJpbmddIGFuIG9wdGlvbmFsIEFXUyBzZXNzaW9uIHRva2VuXG4gKi9cbkFXUy5DcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoe1xuICAvKipcbiAgICogQSBjcmVkZW50aWFscyBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgcG9zaXRpb25hbCBhcmd1bWVudHMgb3IgYW4gb3B0aW9uc1xuICAgKiBoYXNoLlxuICAgKlxuICAgKiBAb3ZlcmxvYWQgQVdTLkNyZWRlbnRpYWxzKGFjY2Vzc0tleUlkLCBzZWNyZXRBY2Nlc3NLZXksIHNlc3Npb25Ub2tlbj1udWxsKVxuICAgKiAgIENyZWF0ZXMgYSBDcmVkZW50aWFscyBvYmplY3Qgd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFsIGluZm9ybWF0aW9uXG4gICAqICAgYXMgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gICAqICAgQHBhcmFtIGFjY2Vzc0tleUlkIFtTdHJpbmddIHRoZSBBV1MgYWNjZXNzIGtleSBJRFxuICAgKiAgIEBwYXJhbSBzZWNyZXRBY2Nlc3NLZXkgW1N0cmluZ10gdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleVxuICAgKiAgIEBwYXJhbSBzZXNzaW9uVG9rZW4gW1N0cmluZ10gdGhlIG9wdGlvbmFsIEFXUyBzZXNzaW9uIHRva2VuXG4gICAqICAgQGV4YW1wbGUgQ3JlYXRlIGEgY3JlZGVudGlhbHMgb2JqZWN0IHdpdGggQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgY3JlZHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKCdha2lkJywgJ3NlY3JldCcsICdzZXNzaW9uJyk7XG4gICAqIEBvdmVybG9hZCBBV1MuQ3JlZGVudGlhbHMob3B0aW9ucylcbiAgICogICBDcmVhdGVzIGEgQ3JlZGVudGlhbHMgb2JqZWN0IHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbCBpbmZvcm1hdGlvblxuICAgKiAgIGFzIGFuIG9wdGlvbnMgaGFzaC5cbiAgICogICBAb3B0aW9uIG9wdGlvbnMgYWNjZXNzS2V5SWQgW1N0cmluZ10gdGhlIEFXUyBhY2Nlc3Mga2V5IElEXG4gICAqICAgQG9wdGlvbiBvcHRpb25zIHNlY3JldEFjY2Vzc0tleSBbU3RyaW5nXSB0aGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5XG4gICAqICAgQG9wdGlvbiBvcHRpb25zIHNlc3Npb25Ub2tlbiBbU3RyaW5nXSB0aGUgb3B0aW9uYWwgQVdTIHNlc3Npb24gdG9rZW5cbiAgICogICBAZXhhbXBsZSBDcmVhdGUgYSBjcmVkZW50aWFscyBvYmplY3Qgd2l0aCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBjcmVkcyA9IG5ldyBBV1MuQ3JlZGVudGlhbHMoe1xuICAgKiAgICAgICBhY2Nlc3NLZXlJZDogJ2FraWQnLCBzZWNyZXRBY2Nlc3NLZXk6ICdzZWNyZXQnLCBzZXNzaW9uVG9rZW46ICdzZXNzaW9uJ1xuICAgKiAgICAgfSk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ3JlZGVudGlhbHMoKSB7XG4gICAgLy8gaGlkZSBzZWNyZXRBY2Nlc3NLZXkgZnJvbSBiZWluZyBkaXNwbGF5ZWQgd2l0aCB1dGlsLmluc3BlY3RcbiAgICBBV1MudXRpbC5oaWRlUHJvcGVydGllcyh0aGlzLCBbJ3NlY3JldEFjY2Vzc0tleSddKTtcblxuICAgIHRoaXMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZXhwaXJlVGltZSA9IG51bGw7XG4gICAgdGhpcy5yZWZyZXNoQ2FsbGJhY2tzID0gW107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjcmVkcyA9IGFyZ3VtZW50c1swXS5jcmVkZW50aWFscyB8fCBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IGNyZWRzLnNlY3JldEFjY2Vzc0tleTtcbiAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gY3JlZHMuc2Vzc2lvblRva2VuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2Vzc0tleUlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5zZWNyZXRBY2Nlc3NLZXkgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0ludGVnZXJdIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUge2V4cGlyZVRpbWV9IGR1cmluZyB3aGljaFxuICAgKiAgIHRoZSBjcmVkZW50aWFscyB3aWxsIGJlIGNvbnNpZGVyZWQgZXhwaXJlZC5cbiAgICovXG4gIGV4cGlyeVdpbmRvdzogMTUsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIG9iamVjdCBzaG91bGQgY2FsbCB7cmVmcmVzaH1cbiAgICogQG5vdGUgU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSBjdXN0b20gcmVmcmVzaFxuICAgKiAgIGxvZ2ljLlxuICAgKi9cbiAgbmVlZHNSZWZyZXNoOiBmdW5jdGlvbiBuZWVkc1JlZnJlc2goKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBhZGp1c3RlZFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZSArIHRoaXMuZXhwaXJ5V2luZG93ICogMTAwMCk7XG5cbiAgICBpZiAodGhpcy5leHBpcmVUaW1lICYmIGFkanVzdGVkVGltZSA+IHRoaXMuZXhwaXJlVGltZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGlyZWQgfHwgIXRoaXMuYWNjZXNzS2V5SWQgfHwgIXRoaXMuc2VjcmV0QWNjZXNzS2V5O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgZXhpc3RpbmcgY3JlZGVudGlhbHMsIHJlZnJlc2hpbmcgdGhlbSBpZiB0aGV5IGFyZSBub3QgeWV0IGxvYWRlZFxuICAgKiBvciBoYXZlIGV4cGlyZWQuIFVzZXJzIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyB7cmVmcmVzaH0sXG4gICAqIGFzIHRoaXMgd2lsbCBub3QgYXR0ZW1wdCB0byByZWxvYWQgY3JlZGVudGlhbHMgd2hlbiB0aGV5IGFyZSBhbHJlYWR5XG4gICAqIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyBlaXRoZXIgY3JlZGVudGlhbHNcbiAgICogICBkbyBub3QgbmVlZCB0byBiZSByZWZyZXNoZWQgb3IgcmVmcmVzaGVkIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhc1xuICAgKiAgIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLFxuICAgKiAgIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICovXG4gIGdldDogZnVuY3Rpb24gZ2V0KGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaCgpKSB7XG4gICAgICB0aGlzLnJlZnJlc2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmICghZXJyKSBzZWxmLmV4cGlyZWQgPSBmYWxzZTsgLy8gcmVzZXQgZXhwaXJlZCBmbGFnXG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgZ2V0UHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICogICBHZXRzIHRoZSBleGlzdGluZyBjcmVkZW50aWFscywgcmVmcmVzaGluZyB0aGVtIGlmIHRoZXkgYXJlIG5vdCB5ZXQgbG9hZGVkXG4gICAqICAgb3IgaGF2ZSBleHBpcmVkLiBVc2VycyBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgdXNpbmcge3JlZnJlc2h9LFxuICAgKiAgIGFzIHRoaXMgd2lsbCBub3QgYXR0ZW1wdCB0byByZWxvYWQgY3JlZGVudGlhbHMgd2hlbiB0aGV5IGFyZSBhbHJlYWR5XG4gICAqICAgbG9hZGVkIGludG8gdGhlIG9iamVjdC5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbigpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLiBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkLCBpdFxuICAgKiAgICAgbWVhbnMgZWl0aGVyIGNyZWRlbnRpYWxzIGRvIG5vdCBuZWVkIHRvIGJlIHJlZnJlc2hlZCBvciByZWZyZXNoZWRcbiAgICogICAgIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZVxuICAgKiAgICAgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYGdldGAgY2FsbC5cbiAgICogICBAZXhhbXBsZSBDYWxsaW5nIHRoZSBgZ2V0UHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjcmVkUHJvdmlkZXIuZ2V0UHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICByZWZyZXNoUHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICogICBSZWZyZXNoZXMgdGhlIGNyZWRlbnRpYWxzLiBVc2VycyBzaG91bGQgY2FsbCB7Z2V0fSBiZWZvcmUgYXR0ZW1wdGluZ1xuICAgKiAgIHRvIGZvcmNpYmx5IHJlZnJlc2ggY3JlZGVudGlhbHMuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC4gV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCwgaXRcbiAgICogICAgIG1lYW5zIHJlZnJlc2hlZCBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0XG4gICAqICAgICAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGByZWZyZXNoYCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGByZWZyZXNoUHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjcmVkUHJvdmlkZXIucmVmcmVzaFByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIGNyZWRlbnRpYWxzLiBVc2VycyBzaG91bGQgY2FsbCB7Z2V0fSBiZWZvcmUgYXR0ZW1wdGluZ1xuICAgKiB0byBmb3JjaWJseSByZWZyZXNoIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgcmVmcmVzaGVkXG4gICAqICAgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlXG4gICAqICAgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQG5vdGUgU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBjbGFzcyB0byByZXNldCB0aGVcbiAgICogICB7YWNjZXNzS2V5SWR9LCB7c2VjcmV0QWNjZXNzS2V5fSBhbmQgb3B0aW9uYWwge3Nlc3Npb25Ub2tlbn1cbiAgICogICBvbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IGFuZCB0aGVuIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGhcbiAgICogICBhbnkgZXJyb3IgaW5mb3JtYXRpb24uXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY29hbGVzY2VSZWZyZXNoOiBmdW5jdGlvbiBjb2FsZXNjZVJlZnJlc2goY2FsbGJhY2ssIHN5bmMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYucmVmcmVzaENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKSA9PT0gMSkge1xuICAgICAgc2VsZi5sb2FkKGZ1bmN0aW9uIG9uTG9hZChlcnIpIHtcbiAgICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKHNlbGYucmVmcmVzaENhbGxiYWNrcywgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgY291bGQgdGhyb3csIHNvIGRlZmVyIHRvIGVuc3VyZSBhbGwgY2FsbGJhY2tzIGFyZSBub3RpZmllZFxuICAgICAgICAgICAgQVdTLnV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5yZWZyZXNoQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxzLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5nZXRQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdnZXQnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG4gIHRoaXMucHJvdG90eXBlLnJlZnJlc2hQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdyZWZyZXNoJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxzLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5nZXRQcm9taXNlO1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucmVmcmVzaFByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuQ3JlZGVudGlhbHMpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIHtBV1MuU1RTfS4gV2l0aG91dCBhbnlcbiAqIGV4dHJhIHBhcmFtZXRlcnMsIGNyZWRlbnRpYWxzIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIHRoZVxuICoge0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb24uIElmIGFuIElBTSByb2xlIGlzIHByb3ZpZGVkLCB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9wZXJhdGlvbiB3aWxsIGJlIHVzZWQgdG8gZmV0Y2ggY3JlZGVudGlhbHMgZm9yIHRoZVxuICogcm9sZSBpbnN0ZWFkLlxuICpcbiAqIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyBkaWZmZXJzIGZyb20gQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGluXG4gKiB0aGUgd2F5IG1hc3RlckNyZWRlbnRpYWxzIGFuZCByZWZyZXNoZXMgYXJlIGhhbmRsZWQuXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgcmVmcmVzaGVzIGV4cGlyZWQgY3JlZGVudGlhbHMgdXNpbmcgdGhlXG4gKiBtYXN0ZXJDcmVkZW50aWFscyBwYXNzZWQgYnkgdGhlIHVzZXIgdG8gc3VwcG9ydCBjaGFpbmluZyBvZiBTVFMgY3JlZGVudGlhbHMuXG4gKiBIb3dldmVyLCBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgcmVjdXJzaXZlbHkgY29sbGFwc2VzIHRoZSBtYXN0ZXJDcmVkZW50aWFsc1xuICogZHVyaW5nIGluc3RhbnRpYXRpb24sIHByZWNsdWRpbmcgdGhlIGFiaWxpdHkgdG8gcmVmcmVzaCBjcmVkZW50aWFscyB3aGljaFxuICogcmVxdWlyZSBpbnRlcm1lZGlhdGUsIHRlbXBvcmFyeSBjcmVkZW50aWFscy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGFwcGxpY2F0aW9uIHNob3VsZCB1c2UgUm9sZUEsIHdoaWNoIG11c3QgYmUgYXNzdW1lZCBmcm9tXG4gKiBSb2xlQiwgYW5kIHRoZSBlbnZpcm9ubWVudCBwcm92aWRlcyBjcmVkZW50aWFscyB3aGljaCBjYW4gYXNzdW1lIFJvbGVCLCB0aGVuXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgbXVzdCBiZSB1c2VkIHRvIHN1cHBvcnQgcmVmcmVzaGluZyB0aGVcbiAqIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmb3IgUm9sZUE6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHJvbGVBQ3JlZHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgcGFyYW1zOiB7Um9sZUFybjogJ1JvbGVBJ30sXG4gKiAgIG1hc3RlckNyZWRlbnRpYWxzOiBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgICBwYXJhbXM6IHtSb2xlQXJuOiAnUm9sZUInfSxcbiAqICAgICBtYXN0ZXJDcmVkZW50aWFsczogbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKVxuICogICB9KVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBJZiBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgaGFkIGJlZW4gdXNlZCBpbiB0aGUgcHJldmlvdXMgZXhhbXBsZSxcbiAqIGByb2xlQUNyZWRzYCB3b3VsZCBmYWlsIHRvIHJlZnJlc2ggYmVjYXVzZSBgcm9sZUFDcmVkc2Agd291bGRcbiAqIHVzZSB0aGUgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMgZm9yIHRoZSBBc3N1bWVSb2xlIHJlcXVlc3QuXG4gKlxuICogQW5vdGhlciBkaWZmZXJlbmNlIGlzIHRoYXQgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIGNyZWF0ZXMgdGhlIFNUU1xuICogc2VydmljZSBpbnN0YW5jZSBkdXJpbmcgaW5zdGFudGlhdGlvbiB3aGlsZSBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgY3JlYXRlc1xuICogdGhlIFNUUyBzZXJ2aWNlIGluc3RhbmNlIGR1cmluZyB0aGUgZmlyc3QgcmVmcmVzaC4gQ3JlYXRpbmcgdGhlIHNlcnZpY2VcbiAqIGluc3RhbmNlIGR1cmluZyBpbnN0YW50aWF0aW9uIGVmZmVjdGl2ZWx5IGNhcHR1cmVzIHRoZSBtYXN0ZXIgY3JlZGVudGlhbHNcbiAqIGZyb20gdGhlIGdsb2JhbCBjb25maWcsIHNvIHRoYXQgc3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBnbG9iYWwgY29uZmlnIGRvXG4gKiBub3QgYWZmZWN0IHRoZSBtYXN0ZXIgY3JlZGVudGlhbHMgdXNlZCB0byByZWZyZXNoIHRoZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMuXG4gKlxuICogVGhpcyBhbGxvd3MgYW4gaW5zdGFuY2Ugb2YgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIHRvIGJlIGFzc2lnbmVkXG4gKiB0byBBV1MuY29uZmlnLmNyZWRlbnRpYWxzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBlbnZDcmVkcyA9IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gZW52Q3JlZHM7XG4gKiAvLyBtYXN0ZXJDcmVkZW50aWFscyB3aWxsIGJlIGVudkNyZWRzXG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgIHBhcmFtczoge1JvbGVBcm46ICcuLi4nfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBTaW1pbGFybHksIHRvIHVzZSB0aGUgQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4ncyBkZWZhdWx0IHByb3ZpZGVycyBhcyB0aGVcbiAqIG1hc3RlciBjcmVkZW50aWFscywgc2ltcGx5IGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZlxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICogICBwYXJhbXM6IHtSb2xlQXJuOiAnLi4uJ31cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQCFhdHRyaWJ1dGUgc2VydmljZVxuICogICBAcmV0dXJuIFtBV1MuU1RTXSB0aGUgU1RTIHNlcnZpY2UgaW5zdGFuY2UgdXNlZCB0b1xuICogICAgIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogQG5vdGUgKHNlZSBjb25zdHJ1Y3RvcilcbiAqL1xuQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF0gYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgcGFyYW1zIFttYXBdICh7fSkgYSBtYXAgb2Ygb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlXG4gICAqICAge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3Ige0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb25zLlxuICAgKiAgIElmIGEgYFJvbGVBcm5gIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIGNyZWRlbnRpYWxzIHdpbGwgYmUgYmFzZWQgb24gdGhlXG4gICAqICAgSUFNIHJvbGUuIElmIGEgYFNlcmlhbE51bWJlcmAgcGFyYW1ldGVyIGlzIHBhc3NlZCBpbiwge3Rva2VuQ29kZUZufSBtdXN0XG4gICAqICAgYWxzbyBiZSBwYXNzZWQgaW4gb3IgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXN0ZXJDcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzXG4gICAqICAgdXNlZCB0byBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy4gQnkgZGVmYXVsdCxcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzIG9yIEFXUy5jb25maWcuY3JlZGVudGlhbFByb3ZpZGVyIHdpbGwgYmUgdXNlZC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHRva2VuQ29kZUZuIFtGdW5jdGlvbl0gKG51bGwpIEZ1bmN0aW9uIHRvIHByb3ZpZGVcbiAgICogICBgVG9rZW5Db2RlYCwgaWYgYFNlcmlhbE51bWJlcmAgaXMgcHJvdmlkZWQgZm9yIHByb2ZpbGUgaW4ge3BhcmFtc30uIEZ1bmN0aW9uXG4gICAqICAgaXMgY2FsbGVkIHdpdGggdmFsdWUgb2YgYFNlcmlhbE51bWJlcmAgYW5kIGBjYWxsYmFja2AsIGFuZCBzaG91bGQgcHJvdmlkZVxuICAgKiAgIHRoZSBgVG9rZW5Db2RlYCBvciBhbiBlcnJvciB0byB0aGUgY2FsbGJhY2sgaW4gdGhlIGZvcm1hdFxuICAgKiAgIGBjYWxsYmFjayhlcnIsIHRva2VuKWAuXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgZ2VuZXJpYyB0ZW1wb3JhcnkgY3JlZGVudGlhbHNcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGFuIElBTSByb2xlXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICAgKiAgICAgcGFyYW1zOiB7XG4gICAqICAgICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1RlbXBvcmFyeUNyZWRlbnRpYWxzJ1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBAc2VlIEFXUy5TVFMuYXNzdW1lUm9sZVxuICAgKiBAc2VlIEFXUy5TVFMuZ2V0U2Vzc2lvblRva2VuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZXJyb3JDb2RlID0gJ0NoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJztcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMudG9rZW5Db2RlRm4gPSBudWxsO1xuXG4gICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkob3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xuICAgIGlmIChwYXJhbXMuUm9sZUFybikge1xuICAgICAgcGFyYW1zLlJvbGVTZXNzaW9uTmFtZSA9IHBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgfHwgJ3RlbXBvcmFyeS1jcmVkZW50aWFscyc7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuU2VyaWFsTnVtYmVyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudG9rZW5Db2RlRm4gfHwgKHR5cGVvZiBvcHRpb25zLnRva2VuQ29kZUZuICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCd0b2tlbkNvZGVGbiBtdXN0IGJlIGEgZnVuY3Rpb24gd2hlbiBwYXJhbXMuU2VyaWFsTnVtYmVyIGlzIGdpdmVuJyksXG4gICAgICAgICAge2NvZGU6IHRoaXMuZXJyb3JDb2RlfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2tlbkNvZGVGbiA9IG9wdGlvbnMudG9rZW5Db2RlRm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb25maWcgPSBBV1MudXRpbC5tZXJnZShcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLm1hc3RlckNyZWRlbnRpYWxzIHx8IEFXUy5jb25maWcuY3JlZGVudGlhbHNcbiAgICAgIH0sXG4gICAgICBvcHRpb25zLnN0c0NvbmZpZyB8fCB7fVxuICAgICk7XG4gICAgdGhpcy5zZXJ2aWNlID0gbmV3IFNUUyhjb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3JcbiAgICoge0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYW4gSUFNIHJvbGUgQVJOIHdhcyBwYXNzZWRcbiAgICogdG8gdGhlIGNyZWRlbnRpYWxzIHtjb25zdHJ1Y3Rvcn0uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgQVdTLkNyZWRlbnRpYWxzLmdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3BlcmF0aW9uID0gc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuUm9sZUFybiA/ICdhc3N1bWVSb2xlJyA6ICdnZXRTZXNzaW9uVG9rZW4nO1xuICAgIHRoaXMuZ2V0VG9rZW5Db2RlKGZ1bmN0aW9uIChlcnIsIHRva2VuQ29kZSkge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5Db2RlKSB7XG4gICAgICAgIHBhcmFtcy5Ub2tlbkNvZGUgPSB0b2tlbkNvZGU7XG4gICAgICB9XG4gICAgICBzZWxmLnNlcnZpY2Vbb3BlcmF0aW9uXShwYXJhbXMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBzZWxmLnNlcnZpY2UuY3JlZGVudGlhbHNGcm9tKGRhdGEsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRUb2tlbkNvZGU6IGZ1bmN0aW9uIGdldFRva2VuQ29kZShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy50b2tlbkNvZGVGbikge1xuICAgICAgdGhpcy50b2tlbkNvZGVGbih0aGlzLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5TZXJpYWxOdW1iZXIsIGZ1bmN0aW9uIChlcnIsIHRva2VuKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycjtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBNRkEgdG9rZW46ICcgKyBtZXNzYWdlKSxcbiAgICAgICAgICAgICAgeyBjb2RlOiBzZWxmLmVycm9yQ29kZX1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgQ29nbml0b0lkZW50aXR5ID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9jb2duaXRvaWRlbnRpdHknKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20gU1RTIFdlYiBJZGVudGl0eSBGZWRlcmF0aW9uIHVzaW5nXG4gKiB0aGUgQW1hem9uIENvZ25pdG8gSWRlbnRpdHkgc2VydmljZS5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLCB3aGljaFxuICogcmVxdWlyZXMgZWl0aGVyIGFuIGBJZGVudGl0eUlkYCBvciBhbiBgSWRlbnRpdHlQb29sSWRgIChBbWF6b24gQ29nbml0b1xuICogSWRlbnRpdHkgUG9vbCBJRCksIHdoaWNoIGlzIHVzZWQgdG8gY2FsbCB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJZH0gdG9cbiAqIG9idGFpbiBhbiBgSWRlbnRpdHlJZGAuIElmIHRoZSBpZGVudGl0eSBvciBpZGVudGl0eSBwb29sIGlzIG5vdCBjb25maWd1cmVkIGluXG4gKiB0aGUgQW1hem9uIENvZ25pdG8gQ29uc29sZSB0byB1c2UgSUFNIHJvbGVzIHdpdGggdGhlIGFwcHJvcHJpYXRlIHBlcm1pc3Npb25zLFxuICogdGhlbiBhZGRpdGlvbmFsbHkgYSBgUm9sZUFybmAgaXMgcmVxdWlyZWQgY29udGFpbmluZyB0aGUgQVJOIG9mIHRoZSBJQU0gdHJ1c3RcbiAqIHBvbGljeSBmb3IgdGhlIEFtYXpvbiBDb2duaXRvIHJvbGUgdGhhdCB0aGUgdXNlciB3aWxsIGxvZyBpbnRvLiBJZiBhIGBSb2xlQXJuYFxuICogaXMgcHJvdmlkZWQsIHRoZW4gdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0gc2VydmljZSBvcGVyYXRpb24sIGFmdGVyIGZpcnN0IGdldHRpbmcgYW5cbiAqIE9wZW4gSUQgdG9rZW4gZnJvbSB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0uXG4gKlxuICogSW4gYWRkaXRpb24sIGlmIHRoaXMgY3JlZGVudGlhbCBwcm92aWRlciBpcyB1c2VkIHRvIHByb3ZpZGUgYXV0aGVudGljYXRlZFxuICogbG9naW4sIHRoZSBgTG9naW5zYCBtYXAgbWF5IGJlIHNldCB0byB0aGUgdG9rZW5zIHByb3ZpZGVkIGJ5IHRoZSByZXNwZWN0aXZlXG4gKiBpZGVudGl0eSBwcm92aWRlcnMuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogIyMgUmVmcmVzaGluZyBDcmVkZW50aWFscyBmcm9tIElkZW50aXR5IFNlcnZpY2VcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBBV1MgY3JlZGVudGlhbHMgZXhwaXJpbmcgYWZ0ZXIgYSBnaXZlbiBhbW91bnQgb2YgdGltZSwgdGhlXG4gKiBsb2dpbiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlciB3aWxsIGFsc28gZXhwaXJlLiBPbmNlIHRoaXMgdG9rZW5cbiAqIGV4cGlyZXMsIGl0IHdpbGwgbm90IGJlIHVzYWJsZSB0byByZWZyZXNoIEFXUyBjcmVkZW50aWFscywgYW5kIGFub3RoZXJcbiAqIHRva2VuIHdpbGwgYmUgbmVlZGVkLiBUaGUgU0RLIGRvZXMgbm90IG1hbmFnZSByZWZyZXNoaW5nIG9mIHRoZSB0b2tlbiB2YWx1ZSxcbiAqIGJ1dCB0aGlzIGNhbiBiZSBkb25lIHRocm91Z2ggYSBcInJlZnJlc2ggdG9rZW5cIiBzdXBwb3J0ZWQgYnkgbW9zdCBpZGVudGl0eVxuICogcHJvdmlkZXJzLiBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgZm9yIHJlZnJlc2hpbmdcbiAqIHRva2Vucy4gT25jZSB0aGUgcmVmcmVzaGVkIHRva2VuIGlzIGFjcXVpcmVkLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byB1cGRhdGVcbiAqIHRoaXMgbmV3IHRva2VuIGluIHRoZSBjcmVkZW50aWFscyBvYmplY3QncyB7cGFyYW1zfSBwcm9wZXJ0eS4gVGhlIGZvbGxvd2luZ1xuICogY29kZSB3aWxsIHVwZGF0ZSB0aGUgV2ViSWRlbnRpdHlUb2tlbiwgYXNzdW1pbmcgeW91IGhhdmUgcmV0cmlldmVkIGFuIHVwZGF0ZWRcbiAqIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMucGFyYW1zLkxvZ2luc1snZ3JhcGguZmFjZWJvb2suY29tJ10gPSB1cGRhdGVkVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBGdXR1cmUgY2FsbHMgdG8gYGNyZWRlbnRpYWxzLnJlZnJlc2goKWAgd2lsbCBub3cgdXNlIHRoZSBuZXcgdG9rZW4uXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1zXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIG1hcCBvZiBwYXJhbXMgcGFzc2VkIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWR9LFxuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VufSwgYW5kXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLldlYklkZW50aXR5VG9rZW5gIHByb3BlcnR5LlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmV0dXJuIFttYXBdIHRoZSByYXcgZGF0YSByZXNwb25zZSBmcm9tIHRoZSBjYWxsIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eX0sIG9yXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGdldFxuICogICAgIGFjY2VzcyB0byBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3BvbnNlLlxuICogQCFhdHRyaWJ1dGUgaWRlbnRpdHlJZFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBDb2duaXRvIElEIHJldHVybmVkIGJ5IHRoZSBsYXN0IGNhbGwgdG9cbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0uIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgYWN0dWFsXG4gKiAgICAgZmluYWwgcmVzb2x2ZWQgaWRlbnRpdHkgSUQgZnJvbSBBbWF6b24gQ29nbml0by5cbiAqL1xuQVdTLkNvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9jYWxTdG9yYWdlS2V5OiB7XG4gICAgaWQ6ICdhd3MuY29nbml0by5pZGVudGl0eS1pZC4nLFxuICAgIHByb3ZpZGVyczogJ2F3cy5jb2duaXRvLmlkZW50aXR5LXByb3ZpZGVycy4nXG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyh7XG4gICAqXG4gICAqICAgICAvLyBlaXRoZXIgSWRlbnRpdHlQb29sSWQgb3IgSWRlbnRpdHlJZCBpcyByZXF1aXJlZFxuICAgKiAgICAgLy8gU2VlIHRoZSBJZGVudGl0eVBvb2xJZCBwYXJhbSBmb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJRCAobGlua2VkIGJlbG93KVxuICAgKiAgICAgLy8gU2VlIHRoZSBJZGVudGl0eUlkIHBhcmFtIGZvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcbiAgICogICAgIC8vIG9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW4gKGxpbmtlZCBiZWxvdylcbiAgICogICAgIElkZW50aXR5UG9vbElkOiAndXMtZWFzdC0xOjE2OTllYmMwLTc5MDAtNDA5OS1iOTEwLTJkZjk0ZjUyYTAzMCcsXG4gICAqICAgICBJZGVudGl0eUlkOiAndXMtZWFzdC0xOjEyOGQwYTc0LWM4MmYtNDU1My05MTZkLTkwMDUzZTRhOGIwZidcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsLCBvbmx5IG5lY2Vzc2FyeSB3aGVuIHRoZSBpZGVudGl0eSBwb29sIGlzIG5vdCBjb25maWd1cmVkXG4gICAqICAgICAvLyB0byB1c2UgSUFNIHJvbGVzIGluIHRoZSBBbWF6b24gQ29nbml0byBDb25zb2xlXG4gICAqICAgICAvLyBTZWUgdGhlIFJvbGVBcm4gcGFyYW0gZm9yIEFXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eSAobGlua2VkIGJlbG93KVxuICAgKiAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvTVlBUFAtQ29nbml0b0lkZW50aXR5JyxcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsIHRva2VucywgdXNlZCBmb3IgYXV0aGVudGljYXRlZCBsb2dpblxuICAgKiAgICAgLy8gU2VlIHRoZSBMb2dpbnMgcGFyYW0gZm9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SUQgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIExvZ2luczoge1xuICAgKiAgICAgICAnZ3JhcGguZmFjZWJvb2suY29tJzogJ0ZCVE9LRU4nLFxuICAgKiAgICAgICAnd3d3LmFtYXpvbi5jb20nOiAnQU1BWk9OVE9LRU4nLFxuICAgKiAgICAgICAnYWNjb3VudHMuZ29vZ2xlLmNvbSc6ICdHT09HTEVUT0tFTicsXG4gICAqICAgICAgICdhcGkudHdpdHRlci5jb20nOiAnVFdJVFRFUlRPS0VOJyxcbiAgICogICAgICAgJ3d3dy5kaWdpdHMuY29tJzogJ0RJR0lUU1RPS0VOJ1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsIG5hbWUsIGRlZmF1bHRzIHRvIHdlYi1pZGVudGl0eVxuICAgKiAgICAgLy8gU2VlIHRoZSBSb2xlU2Vzc2lvbk5hbWUgcGFyYW0gZm9yIEFXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eSAobGlua2VkIGJlbG93KVxuICAgKiAgICAgUm9sZVNlc3Npb25OYW1lOiAnd2ViJyxcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsLCBvbmx5IG5lY2Vzc2FyeSB3aGVuIGFwcGxpY2F0aW9uIHJ1bnMgaW4gYSBicm93c2VyXG4gICAqICAgICAvLyBhbmQgbXVsdGlwbGUgdXNlcnMgYXJlIHNpZ25lZCBpbiBhdCBvbmNlLCB1c2VkIGZvciBjYWNoaW5nXG4gICAqICAgICBMb2dpbklkOiAnZXhhbXBsZUBnbWFpbC5jb20nXG4gICAqXG4gICAqICAgfSwge1xuICAgKiAgICAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2UgY2xpZW50c1xuICAgKiAgICAgIC8vIGlmIGNvbmZpZ3VyYXRpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBwdWxsZWQgZnJvbSBBV1MuY29uZmlnXG4gICAqXG4gICAqICAgICAgLy8gcmVnaW9uIHNob3VsZCBtYXRjaCB0aGUgcmVnaW9uIHlvdXIgaWRlbnRpdHkgcG9vbCBpcyBsb2NhdGVkIGluXG4gICAqICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICpcbiAgICogICAgICAvLyBzcGVjaWZ5IHRpbWVvdXQgb3B0aW9uc1xuICAgKiAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAqICAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgICB9XG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJZFxuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eVxuICAgKiBAc2VlIEFXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eVxuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW5cbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqIEBub3RlIElmIGEgcmVnaW9uIGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgZ2xvYmFsIEFXUy5jb25maWcsIG9yXG4gICAqICAgc3BlY2lmaWVkIGluIHRoZSBgY2xpZW50Q29uZmlnYCB0byB0aGUgQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHNcbiAgICogICBjb25zdHJ1Y3RvciwgeW91IG1heSBlbmNvdW50ZXIgYSAnTWlzc2luZyBjcmVkZW50aWFscyBpbiBjb25maWcnIGVycm9yXG4gICAqICAgd2hlbiBjYWxsaW5nIG1ha2luZyBhIHNlcnZpY2UgY2FsbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDb2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyhwYXJhbXMsIGNsaWVudENvbmZpZykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICB0aGlzLl9jbGllbnRDb25maWcgPSBBV1MudXRpbC5jb3B5KGNsaWVudENvbmZpZyB8fCB7fSk7XG4gICAgdGhpcy5sb2FkQ2FjaGVkSWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZGVudGl0eUlkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5sb2FkQ2FjaGVkSWQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2lkZW50aXR5SWQgfHwgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGlkZW50aXR5SWQpIHtcbiAgICAgICAgc2VsZi5faWRlbnRpdHlJZCA9IGlkZW50aXR5SWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBjcmVkZW50aWFscyB1c2luZyB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5fSxcbiAgICogb3Ige0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgQVdTLkNyZWRlbnRpYWxzLmdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLmRhdGEgPSBudWxsO1xuICAgIHNlbGYuX2lkZW50aXR5SWQgPSBudWxsO1xuICAgIHNlbGYuZ2V0SWQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBpZiAoIXNlbGYucGFyYW1zLlJvbGVBcm4pIHtcbiAgICAgICAgICBzZWxmLmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZ2V0Q3JlZGVudGlhbHNGcm9tU1RTKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jbGVhcklkT25Ob3RBdXRob3JpemVkKGVycik7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY2FjaGVkIENvZ25pdG8gSUQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZFxuICAgKiBpZGVudGl0eSBwb29sIElELiBVc2UgdGhpcyB0byBtYW51YWxseSBpbnZhbGlkYXRlIHlvdXIgY2FjaGUgaWZcbiAgICogdGhlIGlkZW50aXR5IHBvb2wgSUQgd2FzIGRlbGV0ZWQuXG4gICAqL1xuICBjbGVhckNhY2hlZElkOiBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX2lkZW50aXR5SWQgPSBudWxsO1xuICAgIGRlbGV0ZSB0aGlzLnBhcmFtcy5JZGVudGl0eUlkO1xuXG4gICAgdmFyIHBvb2xJZCA9IHRoaXMucGFyYW1zLklkZW50aXR5UG9vbElkO1xuICAgIHZhciBsb2dpbklkID0gdGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJztcbiAgICBkZWxldGUgdGhpcy5zdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5LmlkICsgcG9vbElkICsgbG9naW5JZF07XG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleS5wcm92aWRlcnMgKyBwb29sSWQgKyBsb2dpbklkXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbGVhcklkT25Ob3RBdXRob3JpemVkOiBmdW5jdGlvbiBjbGVhcklkT25Ob3RBdXRob3JpemVkKGVycikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZXJyLmNvZGUgPT0gJ05vdEF1dGhvcml6ZWRFeGNlcHRpb24nKSB7XG4gICAgICBzZWxmLmNsZWFyQ2FjaGVkSWQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIENvZ25pdG8gSUQsIGxvYWRpbmcgZnJvbSBjYWNoZSBpZiBpdCB3YXMgYWxyZWFkeSByZXRyaWV2ZWRcbiAgICogb24gdGhpcyBkZXZpY2UuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGlkZW50aXR5SWQpXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3IsIG51bGxdIGFuIGVycm9yIG9iamVjdCBpZiB0aGUgY2FsbCBmYWlsZWQgb3IgbnVsbCBpZlxuICAgKiAgICAgaXQgc3VjY2VlZGVkLlxuICAgKiAgIEBwYXJhbSBpZGVudGl0eUlkIFtTdHJpbmcsIG51bGxdIGlmIHN1Y2Nlc3NmdWwsIHRoZSBjYWxsYmFjayB3aWxsIHJldHVyblxuICAgKiAgICAgdGhlIENvZ25pdG8gSUQuXG4gICAqIEBub3RlIElmIG5vdCBsb2FkZWQgZXhwbGljaXRseSwgdGhlIENvZ25pdG8gSUQgaXMgbG9hZGVkIGFuZCBzdG9yZWQgaW5cbiAgICogICBsb2NhbFN0b3JhZ2UgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb2YgYSBkZXZpY2UuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzZWxmLnBhcmFtcy5JZGVudGl0eUlkKTtcbiAgICB9XG5cbiAgICBzZWxmLmNvZ25pdG8uZ2V0SWQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVyciAmJiBkYXRhLklkZW50aXR5SWQpIHtcbiAgICAgICAgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9IGRhdGEuSWRlbnRpdHlJZDtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YS5JZGVudGl0eUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkQ3JlZGVudGlhbHM6IGZ1bmN0aW9uIGxvYWRDcmVkZW50aWFscyhkYXRhLCBjcmVkZW50aWFscykge1xuICAgIGlmICghZGF0YSB8fCAhY3JlZGVudGlhbHMpIHJldHVybjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVkID0gZmFsc2U7XG4gICAgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgPSBkYXRhLkNyZWRlbnRpYWxzLkFjY2Vzc0tleUlkO1xuICAgIGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSA9IGRhdGEuQ3JlZGVudGlhbHMuU2VjcmV0S2V5O1xuICAgIGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbiA9IGRhdGEuQ3JlZGVudGlhbHMuU2Vzc2lvblRva2VuO1xuICAgIGNyZWRlbnRpYWxzLmV4cGlyZVRpbWUgPSBkYXRhLkNyZWRlbnRpYWxzLkV4cGlyYXRpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eTogZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNvZ25pdG8uZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eShmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuY2FjaGVJZChkYXRhKTtcbiAgICAgICAgc2VsZi5kYXRhID0gZGF0YTtcbiAgICAgICAgc2VsZi5sb2FkQ3JlZGVudGlhbHMoc2VsZi5kYXRhLCBzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRDcmVkZW50aWFsc0Zyb21TVFM6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzRnJvbVNUUyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNvZ25pdG8uZ2V0T3BlbklkVG9rZW4oZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBzZWxmLmNhY2hlSWQoZGF0YSk7XG4gICAgICAgIHNlbGYucGFyYW1zLldlYklkZW50aXR5VG9rZW4gPSBkYXRhLlRva2VuO1xuICAgICAgICBzZWxmLndlYklkZW50aXR5Q3JlZGVudGlhbHMucmVmcmVzaChmdW5jdGlvbih3ZWJFcnIpIHtcbiAgICAgICAgICBpZiAoIXdlYkVycikge1xuICAgICAgICAgICAgc2VsZi5kYXRhID0gc2VsZi53ZWJJZGVudGl0eUNyZWRlbnRpYWxzLmRhdGE7XG4gICAgICAgICAgICBzZWxmLnN0cy5jcmVkZW50aWFsc0Zyb20oc2VsZi5kYXRhLCBzZWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sod2ViRXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkQ2FjaGVkSWQ6IGZ1bmN0aW9uIGxvYWRDYWNoZWRJZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBpbiB0aGUgYnJvd3NlciB3ZSBzb3VyY2UgZGVmYXVsdCBJZGVudGl0eUlkIGZyb20gbG9jYWxTdG9yYWdlXG4gICAgaWYgKEFXUy51dGlsLmlzQnJvd3NlcigpICYmICFzZWxmLnBhcmFtcy5JZGVudGl0eUlkKSB7XG4gICAgICB2YXIgaWQgPSBzZWxmLmdldFN0b3JhZ2UoJ2lkJyk7XG4gICAgICBpZiAoaWQgJiYgc2VsZi5wYXJhbXMuTG9naW5zKSB7XG4gICAgICAgIHZhciBhY3R1YWxQcm92aWRlcnMgPSBPYmplY3Qua2V5cyhzZWxmLnBhcmFtcy5Mb2dpbnMpO1xuICAgICAgICB2YXIgY2FjaGVkUHJvdmlkZXJzID1cbiAgICAgICAgICAoc2VsZi5nZXRTdG9yYWdlKCdwcm92aWRlcnMnKSB8fCAnJykuc3BsaXQoJywnKTtcblxuICAgICAgICAvLyBvbmx5IGxvYWQgSUQgaWYgYXQgbGVhc3Qgb25lIHByb3ZpZGVyIHVzZWQgdGhpcyBJRCBiZWZvcmVcbiAgICAgICAgdmFyIGludGVyc2VjdCA9IGNhY2hlZFByb3ZpZGVycy5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBhY3R1YWxQcm92aWRlcnMuaW5kZXhPZihuKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZCkge1xuICAgICAgICBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID0gaWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbGllbnRDb25maWcgPSB0aGlzLl9jbGllbnRDb25maWc7XG4gICAgdGhpcy53ZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gdGhpcy53ZWJJZGVudGl0eUNyZWRlbnRpYWxzIHx8XG4gICAgICBuZXcgQVdTLldlYklkZW50aXR5Q3JlZGVudGlhbHModGhpcy5wYXJhbXMsIGNsaWVudENvbmZpZyk7XG4gICAgaWYgKCF0aGlzLmNvZ25pdG8pIHtcbiAgICAgIHZhciBjb2duaXRvQ29uZmlnID0gQVdTLnV0aWwubWVyZ2Uoe30sIGNsaWVudENvbmZpZyk7XG4gICAgICBjb2duaXRvQ29uZmlnLnBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgdGhpcy5jb2duaXRvID0gbmV3IENvZ25pdG9JZGVudGl0eShjb2duaXRvQ29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5zdHMgPSB0aGlzLnN0cyB8fCBuZXcgU1RTKGNsaWVudENvbmZpZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FjaGVJZDogZnVuY3Rpb24gY2FjaGVJZChkYXRhKSB7XG4gICAgdGhpcy5faWRlbnRpdHlJZCA9IGRhdGEuSWRlbnRpdHlJZDtcbiAgICB0aGlzLnBhcmFtcy5JZGVudGl0eUlkID0gdGhpcy5faWRlbnRpdHlJZDtcblxuICAgIC8vIGNhY2hlIHRoaXMgSWRlbnRpdHlJZCBpbiBicm93c2VyIGxvY2FsU3RvcmFnZSBpZiBwb3NzaWJsZVxuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgdGhpcy5zZXRTdG9yYWdlKCdpZCcsIGRhdGEuSWRlbnRpdHlJZCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5Mb2dpbnMpIHtcbiAgICAgICAgdGhpcy5zZXRTdG9yYWdlKCdwcm92aWRlcnMnLCBPYmplY3Qua2V5cyh0aGlzLnBhcmFtcy5Mb2dpbnMpLmpvaW4oJywnKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFN0b3JhZ2U6IGZ1bmN0aW9uIGdldFN0b3JhZ2Uoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleVtrZXldICsgdGhpcy5wYXJhbXMuSWRlbnRpdHlQb29sSWQgKyAodGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJyldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldFN0b3JhZ2U6IGZ1bmN0aW9uIHNldFN0b3JhZ2Uoa2V5LCB2YWwpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5W2tleV0gKyB0aGlzLnBhcmFtcy5JZGVudGl0eVBvb2xJZCArICh0aGlzLnBhcmFtcy5Mb2dpbklkIHx8ICcnKV0gPSB2YWw7XG4gICAgfSBjYXRjaCAoXykge31cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzdG9yYWdlOiAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdG9yYWdlID0gQVdTLnV0aWwuaXNCcm93c2VyKCkgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LmxvY2FsU3RvcmFnZSA9PT0gJ29iamVjdCcgP1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiB7fTtcblxuICAgICAgLy8gVGVzdCBzZXQvcmVtb3ZlIHdoaWNoIHdvdWxkIHRocm93IGFuIGVycm9yIGluIFNhZmFyaSdzIHByaXZhdGUgYnJvd3NpbmdcbiAgICAgIHN0b3JhZ2VbJ2F3cy50ZXN0LXN0b3JhZ2UnXSA9ICdmb29iYXInO1xuICAgICAgZGVsZXRlIHN0b3JhZ2VbJ2F3cy50ZXN0LXN0b3JhZ2UnXTtcblxuICAgICAgcmV0dXJuIHN0b3JhZ2U7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfSkoKVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIHByb3ZpZGVyIGNoYWluIHRoYXQgc2VhcmNoZXMgZm9yIEFXUyBjcmVkZW50aWFsc1xuICogaW4gYSBsaXN0IG9mIGNyZWRlbnRpYWwgcHJvdmlkZXJzIHNwZWNpZmllZCBieSB0aGUge3Byb3ZpZGVyc30gcHJvcGVydHkuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIGNoYWluIHdpbGwgdXNlIHRoZSB7ZGVmYXVsdFByb3ZpZGVyc30gdG8gcmVzb2x2ZSBjcmVkZW50aWFscy5cbiAqIFRoZXNlIHByb3ZpZGVycyB3aWxsIGxvb2sgaW4gdGhlIGVudmlyb25tZW50IHVzaW5nIHRoZVxuICoge0FXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzfSBjbGFzcyB3aXRoIHRoZSAnQVdTJyBhbmQgJ0FNQVpPTicgcHJlZml4ZXMuXG4gKlxuICogIyMgU2V0dGluZyBQcm92aWRlcnNcbiAqXG4gKiBFYWNoIHByb3ZpZGVyIGluIHRoZSB7cHJvdmlkZXJzfSBsaXN0IHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICogYSB7QVdTLkNyZWRlbnRpYWxzfSBvYmplY3QsIG9yIGEgaGFyZGNvZGVkIGNyZWRlbnRpYWxzIG9iamVjdC4gVGhlIGZ1bmN0aW9uXG4gKiBmb3JtIGFsbG93cyBmb3IgZGVsYXllZCBleGVjdXRpb24gb2YgdGhlIGNyZWRlbnRpYWwgY29uc3RydWN0aW9uLlxuICpcbiAqICMjIFJlc29sdmluZyBDcmVkZW50aWFscyBmcm9tIGEgQ2hhaW5cbiAqXG4gKiBDYWxsIHtyZXNvbHZlfSB0byByZXR1cm4gdGhlIGZpcnN0IHZhbGlkIGNyZWRlbnRpYWwgb2JqZWN0IHRoYXQgY2FuIGJlXG4gKiBsb2FkZWQgYnkgdGhlIHByb3ZpZGVyIGNoYWluLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byByZXNvbHZlIGEgY2hhaW4gd2l0aCBhIGN1c3RvbSBwcm92aWRlciB0aGF0IGNoZWNrcyBhIGZpbGVcbiAqIG9uIGRpc2sgYWZ0ZXIgdGhlIHNldCBvZiB7ZGVmYXVsdFByb3ZpZGVyc306XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGRpc2tQcm92aWRlciA9IG5ldyBBV1MuRmlsZVN5c3RlbUNyZWRlbnRpYWxzKCcuL2NyZWRzLmpzb24nKTtcbiAqIHZhciBjaGFpbiA9IG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oKTtcbiAqIGNoYWluLnByb3ZpZGVycy5wdXNoKGRpc2tQcm92aWRlcik7XG4gKiBjaGFpbi5yZXNvbHZlKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYWJvdmUgY29kZSB3aWxsIHJldHVybiB0aGUgYGRpc2tQcm92aWRlcmAgb2JqZWN0IGlmIHRoZVxuICogZmlsZSBjb250YWlucyBjcmVkZW50aWFscyBhbmQgdGhlIGBkZWZhdWx0UHJvdmlkZXJzYCBkbyBub3QgY29udGFpblxuICogYW55IGNyZWRlbnRpYWwgc2V0dGluZ3MuXG4gKlxuICogQCFhdHRyaWJ1dGUgcHJvdmlkZXJzXG4gKiAgIEByZXR1cm4gW0FycmF5PEFXUy5DcmVkZW50aWFscywgRnVuY3Rpb24+XVxuICogICAgIGEgbGlzdCBvZiBjcmVkZW50aWFscyBvYmplY3RzIG9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBjcmVkZW50aWFsc1xuICogICAgIG9iamVjdHMuIElmIHRoZSBwcm92aWRlciBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gd2lsbCBiZVxuICogICAgIGV4ZWN1dGVkIGxhemlseSB3aGVuIHRoZSBwcm92aWRlciBuZWVkcyB0byBiZSBjaGVja2VkIGZvciB2YWxpZFxuICogICAgIGNyZWRlbnRpYWxzLiBCeSBkZWZhdWx0LCB0aGlzIG9iamVjdCB3aWxsIGJlIHNldCB0byB0aGVcbiAqICAgICB7ZGVmYXVsdFByb3ZpZGVyc30uXG4gKiAgIEBzZWUgZGVmYXVsdFByb3ZpZGVyc1xuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4gPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENyZWRlbnRpYWxQcm92aWRlckNoYWluIHdpdGggYSBkZWZhdWx0IHNldCBvZiBwcm92aWRlcnNcbiAgICogc3BlY2lmaWVkIGJ5IHtkZWZhdWx0UHJvdmlkZXJzfS5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbihwcm92aWRlcnMpIHtcbiAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm92aWRlcnMgPSBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycy5zbGljZSgwKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHZlQ2FsbGJhY2tzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICByZXNvbHZlUHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICogICBSZXNvbHZlcyB0aGUgcHJvdmlkZXIgY2hhaW4gYnkgc2VhcmNoaW5nIGZvciB0aGUgZmlyc3Qgc2V0IG9mXG4gICAqICAgY3JlZGVudGlhbHMgaW4ge3Byb3ZpZGVyc30uXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oY3JlZGVudGlhbHMpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIGFuZCB0aGUgcHJvdmlkZXIgcmVzb2x2ZXMgdGhlIGNoYWluXG4gICAqICAgICB0byBhIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBjcmVkZW50aWFscyBvYmplY3QgcmVzb2x2ZWRcbiAgICogICAgICAgYnkgdGhlIHByb3ZpZGVyIGNoYWluLlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycm9yKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgaWYgbm8gY3JlZGVudGlhbHMgYXJlIGZvdW5kLlxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgcmVzb2x2ZWAgbWV0aG9kIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgQ2FsbGluZyB0aGUgYHJlc29sdmVQcm9taXNlYCBtZXRob2QuXG4gICAqICAgICB2YXIgcHJvbWlzZSA9IGNoYWluLnJlc29sdmVQcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY3JlZGVudGlhbHMpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgcHJvdmlkZXIgY2hhaW4gYnkgc2VhcmNoaW5nIGZvciB0aGUgZmlyc3Qgc2V0IG9mXG4gICAqIGNyZWRlbnRpYWxzIGluIHtwcm92aWRlcnN9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBjcmVkZW50aWFscylcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgcHJvdmlkZXIgcmVzb2x2ZXMgdGhlIGNoYWluIHRvIGEgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgb3IgbnVsbCBpZiBubyBjcmVkZW50aWFscyBjYW4gYmUgZm91bmQuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgaWYgbm8gY3JlZGVudGlhbHMgYXJlXG4gICAqICAgICBmb3VuZC5cbiAgICogICBAcGFyYW0gY3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCByZXNvbHZlZFxuICAgKiAgICAgYnkgdGhlIHByb3ZpZGVyIGNoYWluLlxuICAgKiBAcmV0dXJuIFtBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW5dIHRoZSBwcm92aWRlciwgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5wcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIHByb3ZpZGVycycpKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnJlc29sdmVDYWxsYmFja3MucHVzaChjYWxsYmFjaykgPT09IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcHJvdmlkZXJzID0gc2VsZi5wcm92aWRlcnMuc2xpY2UoMCk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVOZXh0KGVyciwgY3JlZHMpIHtcbiAgICAgICAgaWYgKCghZXJyICYmIGNyZWRzKSB8fCBpbmRleCA9PT0gcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzZWxmLnJlc29sdmVDYWxsYmFja3MsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBjcmVkcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5yZXNvbHZlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJzW2luZGV4KytdO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3JlZHMgPSBwcm92aWRlci5jYWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3JlZHMgPSBwcm92aWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVkcy5nZXQpIHtcbiAgICAgICAgICBjcmVkcy5nZXQoZnVuY3Rpb24gKGdldEVycikge1xuICAgICAgICAgICAgcmVzb2x2ZU5leHQoZ2V0RXJyLCBnZXRFcnIgPyBudWxsIDogY3JlZHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVOZXh0KG51bGwsIGNyZWRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlTmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzIHVzZWQgYnkgYSB2YW5pbGxhIENyZWRlbnRpYWxQcm92aWRlckNoYWluLlxuICpcbiAqIEluIHRoZSBicm93c2VyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW11cbiAqIGBgYFxuICpcbiAqIEluIE5vZGUuanM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQU1BWk9OJyk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuU3NvQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FQ1NDcmVkZW50aWFscygpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlByb2Nlc3NDcmVkZW50aWFscygpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlRva2VuRmlsZVdlYklkZW50aXR5Q3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzKCkgfVxuICogXVxuICogYGBgXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW107XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUucmVzb2x2ZVByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ3Jlc29sdmUnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnJlc29sdmVQcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5yZXF1aXJlKCcuLi9tZXRhZGF0YV9zZXJ2aWNlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZWNlaXZlZCBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2aWNlIG9uIGFuIEVDMiBpbnN0YW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNsYXNzIHdpbGwgY29ubmVjdCB0byB0aGUgbWV0YWRhdGEgc2VydmljZSB1c2luZ1xuICoge0FXUy5NZXRhZGF0YVNlcnZpY2V9IGFuZCBhdHRlbXB0IHRvIGxvYWQgYW55IGF2YWlsYWJsZSBjcmVkZW50aWFscy4gSWYgaXRcbiAqIGNhbiBjb25uZWN0LCBhbmQgY3JlZGVudGlhbHMgYXJlIGF2YWlsYWJsZSwgdGhlc2Ugd2lsbCBiZSB1c2VkIHdpdGggemVyb1xuICogY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUaGlzIGNyZWRlbnRpYWxzIGNsYXNzIHdpbGwgYnkgZGVmYXVsdCB0aW1lb3V0IGFmdGVyIDEgc2Vjb25kIG9mIGluYWN0aXZpdHlcbiAqIGFuZCByZXRyeSAzIHRpbWVzLlxuICogSWYgeW91ciByZXF1ZXN0cyB0byB0aGUgRUMyIG1ldGFkYXRhIHNlcnZpY2UgYXJlIHRpbWluZyBvdXQsIHlvdSBjYW4gaW5jcmVhc2VcbiAqIHRoZXNlIHZhbHVlcyBieSBjb25maWd1cmluZyB0aGVtIGRpcmVjdGx5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoe1xuICogICBodHRwT3B0aW9uczogeyB0aW1lb3V0OiA1MDAwIH0sIC8vIDUgc2Vjb25kIHRpbWVvdXRcbiAqICAgbWF4UmV0cmllczogMTAsIC8vIHJldHJ5IDEwIHRpbWVzXG4gKiAgIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDIwMCB9LCAvLyBzZWUgQVdTLkNvbmZpZyBmb3IgaW5mb3JtYXRpb25cbiAqICAgbG9nZ2VyOiBjb25zb2xlIC8vIHNlZSBBV1MuQ29uZmlnIGZvciBpbmZvcm1hdGlvblxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBJZiB5b3VyIHJlcXVlc3RzIGFyZSB0aW1pbmcgb3V0IGluIGNvbm5lY3RpbmcgdG8gdGhlIG1ldGFkYXRhIHNlcnZpY2UsIHN1Y2hcbiAqIGFzIHdoZW4gdGVzdGluZyBvbiBhIGRldmVsb3BtZW50IG1hY2hpbmUsIHlvdSBjYW4gdXNlIHRoZSBjb25uZWN0VGltZW91dFxuICogb3B0aW9uLCBzcGVjaWZpZWQgaW4gbWlsbGlzZWNvbmRzLCB3aGljaCBhbHNvIGRlZmF1bHRzIHRvIDEgc2Vjb25kLlxuICpcbiAqIElmIHRoZSByZXF1ZXN0cyBmYWlsZWQgb3IgcmV0dXJucyBleHBpcmVkIGNyZWRlbnRpYWxzLCBpdCB3aWxsXG4gKiBleHRlbmQgdGhlIGV4cGlyYXRpb24gb2YgY3VycmVudCBjcmVkZW50aWFsLCB3aXRoIGEgd2FybmluZyBtZXNzYWdlLiBGb3IgbW9yZVxuICogaW5mb3JtYXRpb24sIHBsZWFzZSBnbyB0bzpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9zZGtyZWYvbGF0ZXN0L2d1aWRlL2ZlYXR1cmUtc3RhdGljLWNyZWRlbnRpYWxzLmh0bWxcbiAqXG4gKiBAIWF0dHJpYnV0ZSBvcmlnaW5hbEV4cGlyYXRpb25cbiAqICAgQHJldHVybiBbRGF0ZV0gVGhlIG9wdGlvbmFsIG9yaWdpbmFsIGV4cGlyYXRpb24gb2YgdGhlIGN1cnJlbnQgY3JlZGVudGlhbC5cbiAqICAgSW4gY2FzZSBvZiBBV1Mgb3V0YWdlLCB0aGUgRUMyIG1ldGFkYXRhIHdpbGwgZXh0ZW5kIGV4cGlyYXRpb24gb2YgdGhlXG4gKiAgIGV4aXN0aW5nIGNyZWRlbnRpYWwuXG4gKlxuICogQHNlZSBBV1MuQ29uZmlnLnJldHJ5RGVsYXlPcHRpb25zXG4gKiBAc2VlIEFXUy5Db25maWcubG9nZ2VyXG4gKlxuICogQCFtYWNybyBub2Jyb3dzZXJcbiAqL1xuQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gRUMyTWV0YWRhdGFDcmVkZW50aWFscyhvcHRpb25zKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IEFXUy51dGlsLmNvcHkob3B0aW9ucykgOiB7fTtcbiAgICBvcHRpb25zID0gQVdTLnV0aWwubWVyZ2UoXG4gICAgICB7bWF4UmV0cmllczogdGhpcy5kZWZhdWx0TWF4UmV0cmllc30sIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5odHRwT3B0aW9ucykgb3B0aW9ucy5odHRwT3B0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSBBV1MudXRpbC5tZXJnZShcbiAgICAgIHt0aW1lb3V0OiB0aGlzLmRlZmF1bHRUaW1lb3V0LFxuICAgICAgICBjb25uZWN0VGltZW91dDogdGhpcy5kZWZhdWx0Q29ubmVjdFRpbWVvdXR9LFxuICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMpO1xuXG4gICAgdGhpcy5tZXRhZGF0YVNlcnZpY2UgPSBuZXcgQVdTLk1ldGFkYXRhU2VydmljZShvcHRpb25zKTtcbiAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyIHx8IEFXUy5jb25maWcgJiYgQVdTLmNvbmZpZy5sb2dnZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdFRpbWVvdXQ6IDEwMDAsXG5cbiAgIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRDb25uZWN0VGltZW91dDogMTAwMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZhdWx0TWF4UmV0cmllczogMyxcblxuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIGV4cGlyYXRpb24gb2YgdGhlIGN1cnJlbnQgY3JlZGVudGlhbC4gSW4gY2FzZSBvZiBBV1NcbiAgICogb3V0YWdlLCB0aGUgRUMyIG1ldGFkYXRhIHdpbGwgZXh0ZW5kIGV4cGlyYXRpb24gb2YgdGhlIGV4aXN0aW5nXG4gICAqIGNyZWRlbnRpYWwuXG4gICAqL1xuICBvcmlnaW5hbEV4cGlyYXRpb246IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIGluc3RhbmNlIG1ldGFkYXRhIHNlcnZpY2VcbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgaW5zdGFuY2UgbWV0YWRhdGEgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm1ldGFkYXRhU2VydmljZS5sb2FkQ3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyLCBjcmVkcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc2VsZi5oYXNMb2FkZWRDcmVkZW50aWFscygpKSB7XG4gICAgICAgICAgc2VsZi5leHRlbmRFeHBpcmF0aW9uSWZFeHBpcmVkKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldENyZWRlbnRpYWxzKGNyZWRzKTtcbiAgICAgICAgc2VsZi5leHRlbmRFeHBpcmF0aW9uSWZFeHBpcmVkKCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBjcmVkZW50aWFsIGhhcyBiZWVuIGxvYWRlZC5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoYXNMb2FkZWRDcmVkZW50aWFsczogZnVuY3Rpb24gaGFzTG9hZGVkQ3JlZGVudGlhbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuQWNjZXNzS2V5SWQgJiYgdGhpcy5zZWNyZXRBY2Nlc3NLZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGlmIGV4cGlyZWQsIGV4dGVuZCB0aGUgZXhwaXJhdGlvbiBieSAxNSBtaW51dGVzIGJhc2UgcGx1cyBhIGppdHRlciBvZiA1XG4gICAqIG1pbnV0ZXMgcmFuZ2UuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0ZW5kRXhwaXJhdGlvbklmRXhwaXJlZDogZnVuY3Rpb24gZXh0ZW5kRXhwaXJhdGlvbklmRXhwaXJlZCgpIHtcbiAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goKSkge1xuICAgICAgdGhpcy5vcmlnaW5hbEV4cGlyYXRpb24gPSB0aGlzLm9yaWdpbmFsRXhwaXJhdGlvbiB8fCB0aGlzLmV4cGlyZVRpbWU7XG4gICAgICB0aGlzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICAgIHZhciBuZXh0VGltZW91dCA9IDE1ICogNjAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1ICogNjApO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5leHBpcmVUaW1lID0gbmV3IERhdGUoY3VycmVudFRpbWUgKyBuZXh0VGltZW91dCAqIDEwMDApO1xuICAgICAgLy8gVE9ETzogYWRkIGRvYyBsaW5rO1xuICAgICAgdGhpcy5sb2dnZXIud2FybignQXR0ZW1wdGluZyBjcmVkZW50aWFsIGV4cGlyYXRpb24gZXh0ZW5zaW9uIGR1ZSB0byBhICdcbiAgICAgICAgICArICdjcmVkZW50aWFsIHNlcnZpY2UgYXZhaWxhYmlsaXR5IGlzc3VlLiBBIHJlZnJlc2ggb2YgdGhlc2UgJ1xuICAgICAgICAgICsgJ2NyZWRlbnRpYWxzIHdpbGwgYmUgYXR0ZW1wdGVkIGFnYWluIGF0ICcgKyB0aGlzLmV4cGlyZVRpbWVcbiAgICAgICAgICArICdcXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpc2l0OiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vc2RrcmVmL2xhdGVzdC9ndWlkZS9mZWF0dXJlLXN0YXRpYy1jcmVkZW50aWFscy5odG1sJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNyZWRlbnRpYWwgd2l0aCBuZXcgY3JlZGVudGlhbCByZXNwb25kZWQgZnJvbSBFQzIgbWV0YWRhdGFcbiAgICogc2VydmljZS5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRDcmVkZW50aWFsczogZnVuY3Rpb24gc2V0Q3JlZGVudGlhbHMoY3JlZHMpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGV4cGlyZVRpbWUgPSBuZXcgRGF0ZShjcmVkcy5FeHBpcmF0aW9uKTtcbiAgICB0aGlzLmV4cGlyZWQgPSBjdXJyZW50VGltZSA+PSBleHBpcmVUaW1lID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXMubWV0YWRhdGEgPSBjcmVkcztcbiAgICB0aGlzLmFjY2Vzc0tleUlkID0gY3JlZHMuQWNjZXNzS2V5SWQ7XG4gICAgdGhpcy5zZWNyZXRBY2Nlc3NLZXkgPSBjcmVkcy5TZWNyZXRBY2Nlc3NLZXk7XG4gICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBjcmVkcy5Ub2tlbjtcbiAgICB0aGlzLmV4cGlyZVRpbWUgPSBleHBpcmVUaW1lO1xuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZWNlaXZlZCBmcm9tIHJlbGF0aXZlIFVSSSBzcGVjaWZpZWQgaW4gdGhlIEVDUyBjb250YWluZXIuXG4gKlxuICogVGhpcyBjbGFzcyB3aWxsIHJlcXVlc3QgcmVmcmVzaGFibGUgY3JlZGVudGlhbHMgZnJvbSB0aGUgcmVsYXRpdmUgVVJJXG4gKiBzcGVjaWZpZWQgYnkgdGhlIEFXU19DT05UQUlORVJfQ1JFREVOVElBTFNfUkVMQVRJVkVfVVJJIG9yIHRoZVxuICogQVdTX0NPTlRBSU5FUl9DUkVERU5USUFMU19GVUxMX1VSSSBlbnZpcm9ubWVudCB2YXJpYWJsZS4gSWYgdmFsaWQgY3JlZGVudGlhbHNcbiAqIGFyZSByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UsIHRoZXNlIHdpbGwgYmUgdXNlZCB3aXRoIHplcm8gY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUaGlzIGNyZWRlbnRpYWxzIGNsYXNzIHdpbGwgYnkgZGVmYXVsdCB0aW1lb3V0IGFmdGVyIDEgc2Vjb25kIG9mIGluYWN0aXZpdHlcbiAqIGFuZCByZXRyeSAzIHRpbWVzLlxuICogSWYgeW91ciByZXF1ZXN0cyB0byB0aGUgcmVsYXRpdmUgVVJJIGFyZSB0aW1pbmcgb3V0LCB5b3UgY2FuIGluY3JlYXNlXG4gKiB0aGUgdmFsdWUgYnkgY29uZmlndXJpbmcgdGhlbSBkaXJlY3RseTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5FQ1NDcmVkZW50aWFscyh7XG4gKiAgIGh0dHBPcHRpb25zOiB7IHRpbWVvdXQ6IDUwMDAgfSwgLy8gNSBzZWNvbmQgdGltZW91dFxuICogICBtYXhSZXRyaWVzOiAxMCwgLy8gcmV0cnkgMTAgdGltZXNcbiAqICAgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMjAwIH0gLy8gc2VlIEFXUy5Db25maWcgZm9yIGluZm9ybWF0aW9uXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWUgQVdTLkNvbmZpZy5yZXRyeURlbGF5T3B0aW9uc1xuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5FQ1NDcmVkZW50aWFscyA9IEFXUy5SZW1vdGVDcmVkZW50aWFscztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNsYXNzIHdpbGwgbG9vayBmb3IgdGhlIG1hdGNoaW5nIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogcHJlZml4ZWQgYnkgYSBnaXZlbiB7ZW52UHJlZml4fS4gVGhlIHVuLXByZWZpeGVkIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVzXG4gKiBmb3IgZWFjaCBjcmVkZW50aWFsIHZhbHVlIGlzIGxpc3RlZCBiZWxvdzpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBhY2Nlc3NLZXlJZDogQUNDRVNTX0tFWV9JRFxuICogc2VjcmV0QWNjZXNzS2V5OiBTRUNSRVRfQUNDRVNTX0tFWVxuICogc2Vzc2lvblRva2VuOiBTRVNTSU9OX1RPS0VOXG4gKiBgYGBcbiAqXG4gKiBXaXRoIHRoZSBkZWZhdWx0IHByZWZpeCBvZiAnQVdTJywgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3b3VsZCBiZTpcbiAqXG4gKiAgICAgQVdTX0FDQ0VTU19LRVlfSUQsIEFXU19TRUNSRVRfQUNDRVNTX0tFWSwgQVdTX1NFU1NJT05fVE9LRU5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBlbnZQcmVmaXhcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHByZWZpeCBmb3IgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVzIGV4Y2x1ZGluZ1xuICogICAgIHRoZSBzZXBhcmF0aW5nIHVuZGVyc2NvcmUgKCdfJykuXG4gKi9cbkFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFbnZpcm9ubWVudENyZWRlbnRpYWxzIGNsYXNzIHdpdGggYSBnaXZlbiB2YXJpYWJsZVxuICAgKiBwcmVmaXgge2VudlByZWZpeH0uIEZvciBleGFtcGxlLCB0byBsb2FkIGNyZWRlbnRpYWxzIHVzaW5nIHRoZSAnQVdTJ1xuICAgKiBwcmVmaXg6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIGNyZWRzID0gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTtcbiAgICogY3JlZHMuYWNjZXNzS2V5SWQgPT0gJ0FLSUQnIC8vIGZyb20gQVdTX0FDQ0VTU19LRVlfSUQgZW52IHZhclxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGVudlByZWZpeCBbU3RyaW5nXSB0aGUgcHJlZml4IHRvIHVzZSAoZS5nLiwgJ0FXUycpIGZvciBlbnZpcm9ubWVudFxuICAgKiAgIHZhcmlhYmxlcy4gRG8gbm90IGluY2x1ZGUgdGhlIHNlcGFyYXRpbmcgdW5kZXJzY29yZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBFbnZpcm9ubWVudENyZWRlbnRpYWxzKGVudlByZWZpeCkge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW52UHJlZml4ID0gZW52UHJlZml4O1xuICAgIHRoaXMuZ2V0KGZ1bmN0aW9uKCkge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudCB1c2luZyB0aGUgcHJlZml4ZWRcbiAgICogZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCBhZnRlciB0aGUgKHByZWZpeGVkKSBBQ0NFU1NfS0VZX0lELCBTRUNSRVRfQUNDRVNTX0tFWSwgYW5kXG4gICAqICAgU0VTU0lPTl9UT0tFTiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHJlYWQuIFdoZW4gdGhpcyBjYWxsYmFjayBpc1xuICAgKiAgIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXNcbiAgICogICBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCxcbiAgICogICBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBBV1MudXRpbC5mbi5jYWxsYmFjaztcblxuICAgIGlmICghcHJvY2VzcyB8fCAhcHJvY2Vzcy5lbnYpIHtcbiAgICAgIGNhbGxiYWNrKEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ05vIHByb2Nlc3MgaW5mbyBvciBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXZhaWxhYmxlJyksXG4gICAgICAgIHsgY29kZTogJ0Vudmlyb25tZW50Q3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gWydBQ0NFU1NfS0VZX0lEJywgJ1NFQ1JFVF9BQ0NFU1NfS0VZJywgJ1NFU1NJT05fVE9LRU4nXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcmVmaXggPSAnJztcbiAgICAgIGlmICh0aGlzLmVudlByZWZpeCkgcHJlZml4ID0gdGhpcy5lbnZQcmVmaXggKyAnXyc7XG4gICAgICB2YWx1ZXNbaV0gPSBwcm9jZXNzLmVudltwcmVmaXggKyBrZXlzW2ldXTtcbiAgICAgIGlmICghdmFsdWVzW2ldICYmIGtleXNbaV0gIT09ICdTRVNTSU9OX1RPS0VOJykge1xuICAgICAgICBjYWxsYmFjayhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ1ZhcmlhYmxlICcgKyBwcmVmaXggKyBrZXlzW2ldICsgJyBub3Qgc2V0LicpLFxuICAgICAgICB7IGNvZGU6ICdFbnZpcm9ubWVudENyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJyB9XG4gICAgICAgICkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyBmcm9tIGEgSlNPTiBmaWxlIG9uIGRpc2suXG4gKiBJZiB0aGUgY3JlZGVudGlhbHMgZXhwaXJlLCB0aGUgU0RLIGNhbiB7cmVmcmVzaH0gdGhlIGNyZWRlbnRpYWxzXG4gKiBmcm9tIHRoZSBmaWxlLlxuICpcbiAqIFRoZSBmb3JtYXQgb2YgdGhlIGZpbGUgc2hvdWxkIGJlIHNpbWlsYXIgdG8gdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG4gKiB7QVdTLkNvbmZpZ306XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICoge2FjY2Vzc0tleUlkOiAnYWtpZCcsIHNlY3JldEFjY2Vzc0tleTogJ3NlY3JldCcsIHNlc3Npb25Ub2tlbjogJ29wdGlvbmFsJ31cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIExvYWRpbmcgY3JlZGVudGlhbHMgZnJvbSBkaXNrXG4gKiAgIHZhciBjcmVkcyA9IG5ldyBBV1MuRmlsZVN5c3RlbUNyZWRlbnRpYWxzKCcuL2NvbmZpZ3VyYXRpb24uanNvbicpO1xuICogICBjcmVkcy5hY2Nlc3NLZXlJZCA9PSAnQUtJRCdcbiAqXG4gKiBAIWF0dHJpYnV0ZSBmaWxlbmFtZVxuICogICBAcmVhZG9ubHlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcGF0aCB0byB0aGUgSlNPTiBmaWxlIG9uIGRpc2sgY29udGFpbmluZyB0aGVcbiAqICAgICBjcmVkZW50aWFscy5cbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5GaWxlU3lzdGVtQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscyhmaWxlbmFtZSlcbiAgICogICBDcmVhdGVzIGEgbmV3IEZpbGVTeXN0ZW1DcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIGZpbGVuYW1lXG4gICAqXG4gICAqICAgQHBhcmFtIGZpbGVuYW1lIFtTdHJpbmddIHRoZSBwYXRoIG9uIGRpc2sgdG8gdGhlIEpTT04gZmlsZSB0byBsb2FkLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEZpbGVTeXN0ZW1DcmVkZW50aWFscyhmaWxlbmFtZSkge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICB0aGlzLmdldChmdW5jdGlvbigpIHt9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIHtmaWxlbmFtZX0gb24gZGlzay5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgYWZ0ZXIgdGhlIEpTT04gZmlsZSBvbiBkaXNrIGlzIHJlYWQgYW5kIHBhcnNlZC4gV2hlbiB0aGlzIGNhbGxiYWNrXG4gICAqICAgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uXG4gICAqICAgaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLFxuICAgKiAgIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IEFXUy51dGlsLmZuLmNhbGxiYWNrO1xuICAgIHRyeSB7XG4gICAgICB2YXIgY3JlZHMgPSBKU09OLnBhcnNlKEFXUy51dGlsLnJlYWRGaWxlU3luYyh0aGlzLmZpbGVuYW1lKSk7XG4gICAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzLCBjcmVkcyk7XG4gICAgICBpZiAoIXRoaXMuYWNjZXNzS2V5SWQgfHwgIXRoaXMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignQ3JlZGVudGlhbHMgbm90IHNldCBpbiAnICsgdGhpcy5maWxlbmFtZSksXG4gICAgICAgIHsgY29kZTogJ0ZpbGVTeXN0ZW1DcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHByb2MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG52YXIgaW5pTG9hZGVyID0gQVdTLnV0aWwuaW5pTG9hZGVyO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgbG9hZGVkIGZyb20gc2hhcmVkIGNyZWRlbnRpYWxzIGZpbGVcbiAqIChkZWZhdWx0aW5nIHRvIH4vLmF3cy9jcmVkZW50aWFscyBvciBkZWZpbmVkIGJ5IHRoZVxuICogYEFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRWAgZW52aXJvbm1lbnQgdmFyaWFibGUpLlxuICpcbiAqICMjIFVzaW5nIHByb2Nlc3MgY3JlZGVudGlhbHNcbiAqXG4gKiBUaGUgY3JlZGVudGlhbHMgZmlsZSBjYW4gc3BlY2lmeSBhIGNyZWRlbnRpYWwgcHJvdmlkZXIgdGhhdCBleGVjdXRlc1xuICogYSBnaXZlbiBwcm9jZXNzIGFuZCBhdHRlbXB0cyB0byByZWFkIGl0cyBzdGRvdXQgdG8gcmVjaWV2ZSBhIEpTT04gcGF5bG9hZFxuICogY29udGFpbmluZyB0aGUgY3JlZGVudGlhbHM6XG4gKlxuICogICAgIFtkZWZhdWx0XVxuICogICAgIGNyZWRlbnRpYWxfcHJvY2VzcyA9IC91c3IvYmluL2NyZWRlbnRpYWxfcHJvY1xuICpcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyByZWZyZXNoaW5nIGNyZWRlbnRpYWxzIGlmIGFuIEV4cGlyYXRpb24gdGltZSBpc1xuICogcHJvdmlkZWQgaW4gdGhlIGNyZWRlbnRpYWxzIHBheWxvYWQuIENyZWRlbnRpYWxzIHN1cHBsaWVkIGluIHRoZSBzYW1lIHByb2ZpbGVcbiAqIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhlIGNyZWRlbnRpYWxfcHJvY2Vzcy5cbiAqXG4gKiBTb3VyY2luZyBjcmVkZW50aWFscyBmcm9tIGFuIGV4dGVybmFsIHByb2Nlc3MgY2FuIHBvdGVudGlhbGx5IGJlIGRhbmdlcm91cyxcbiAqIHNvIHByb2NlZWQgd2l0aCBjYXV0aW9uLiBPdGhlciBjcmVkZW50aWFsIHByb3ZpZGVycyBzaG91bGQgYmUgcHJlZmVycmVkIGlmXG4gKiBhdCBhbGwgcG9zc2libGUuIElmIHVzaW5nIHRoaXMgb3B0aW9uLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0aGF0IHRoZSBzaGFyZWRcbiAqIGNyZWRlbnRpYWxzIGZpbGUgaXMgYXMgbG9ja2VkIGRvd24gYXMgcG9zc2libGUgdXNpbmcgc2VjdXJpdHkgYmVzdCBwcmFjdGljZXNcbiAqIGZvciB5b3VyIG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogIyMgVXNpbmcgY3VzdG9tIHByb2ZpbGVzXG4gKlxuICogVGhlIFNESyBzdXBwb3J0cyBsb2FkaW5nIGNyZWRlbnRpYWxzIGZvciBzZXBhcmF0ZSBwcm9maWxlcy4gVGhpcyBjYW4gYmUgZG9uZVxuICogaW4gdHdvIHdheXM6XG4gKlxuICogMS4gU2V0IHRoZSBgQVdTX1BST0ZJTEVgIGVudmlyb25tZW50IHZhcmlhYmxlIGluIHlvdXIgcHJvY2VzcyBwcmlvciB0b1xuICogICAgbG9hZGluZyB0aGUgU0RLLlxuICogMi4gRGlyZWN0bHkgbG9hZCB0aGUgQVdTLlByb2Nlc3NDcmVkZW50aWFscyBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgY3JlZHMgPSBuZXcgQVdTLlByb2Nlc3NDcmVkZW50aWFscyh7cHJvZmlsZTogJ215cHJvZmlsZSd9KTtcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAqIGBgYFxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5Qcm9jZXNzQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQcm9jZXNzQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXSBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwcm9maWxlIFtTdHJpbmddIChBV1NfUFJPRklMRSBlbnYgdmFyIG9yICdkZWZhdWx0JylcbiAgICogICB0aGUgbmFtZSBvZiB0aGUgcHJvZmlsZSB0byBsb2FkLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZmlsZW5hbWUgW1N0cmluZ10gKCd+Ly5hd3MvY3JlZGVudGlhbHMnIG9yIGRlZmluZWQgYnlcbiAgICogICBBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgcHJvY2VzcyBlbnYgdmFyKVxuICAgKiAgIHRoZSBmaWxlbmFtZSB0byB1c2Ugd2hlbiBsb2FkaW5nIGNyZWRlbnRpYWxzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY2FsbGJhY2sgW0Z1bmN0aW9uXSAoZXJyKSBDcmVkZW50aWFscyBhcmUgZWFnZXJseSBsb2FkZWRcbiAgICogICBieSB0aGUgY29uc3RydWN0b3IuIFdoZW4gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCB0aGVcbiAgICogICBjcmVkZW50aWFscyBoYXZlIGJlZW4gbG9hZGVkIHN1Y2Nlc3NmdWxseS5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBQcm9jZXNzQ3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICB0aGlzLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGU7XG4gICAgdGhpcy5nZXQob3B0aW9ucy5jYWxsYmFjayB8fCBBV1MudXRpbC5mbi5ub29wKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoaW5pTG9hZGVyLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgIHZhciBwcm9maWxlID0gcHJvZmlsZXNbdGhpcy5wcm9maWxlXSB8fCB7fTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHByb2ZpbGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ1Byb2ZpbGUgJyArIHRoaXMucHJvZmlsZSArICcgbm90IGZvdW5kJyksXG4gICAgICAgICAgeyBjb2RlOiAnUHJvY2Vzc0NyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJyB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9maWxlWydjcmVkZW50aWFsX3Byb2Nlc3MnXSkge1xuICAgICAgICB0aGlzLmxvYWRWaWFDcmVkZW50aWFsUHJvY2Vzcyhwcm9maWxlLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmV4cGlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuYWNjZXNzS2V5SWQgPSBkYXRhLkFjY2Vzc0tleUlkO1xuICAgICAgICAgICAgc2VsZi5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLlNlY3JldEFjY2Vzc0tleTtcbiAgICAgICAgICAgIHNlbGYuc2Vzc2lvblRva2VuID0gZGF0YS5TZXNzaW9uVG9rZW47XG4gICAgICAgICAgICBpZiAoZGF0YS5FeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICAgIHNlbGYuZXhwaXJlVGltZSA9IG5ldyBEYXRlKGRhdGEuRXhwaXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdQcm9maWxlICcgKyB0aGlzLnByb2ZpbGUgKyAnIGRpZCBub3QgaW5jbHVkZSBjcmVkZW50aWFsIHByb2Nlc3MnKSxcbiAgICAgICAgICB7IGNvZGU6ICdQcm9jZXNzQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEV4ZWN1dGVzIHRoZSBjcmVkZW50aWFsX3Byb2Nlc3MgYW5kIHJldHJpZXZlc1xuICAqIGNyZWRlbnRpYWxzIGZyb20gdGhlIG91dHB1dFxuICAqIEBhcGkgcHJpdmF0ZVxuICAqIEBwYXJhbSBwcm9maWxlIFttYXBdIGNyZWRlbnRpYWxzIHByb2ZpbGVcbiAgKiBAdGhyb3dzIFByb2Nlc3NDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZVxuICAqL1xuICBsb2FkVmlhQ3JlZGVudGlhbFByb2Nlc3M6IGZ1bmN0aW9uIGxvYWRWaWFDcmVkZW50aWFsUHJvY2Vzcyhwcm9maWxlLCBjYWxsYmFjaykge1xuICAgIHByb2MuZXhlYyhwcm9maWxlWydjcmVkZW50aWFsX3Byb2Nlc3MnXSwgeyBlbnY6IHByb2Nlc3MuZW52IH0sIGZ1bmN0aW9uKGVyciwgc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdjcmVkZW50aWFsX3Byb2Nlc3MgcmV0dXJuZWQgZXJyb3InKSxcbiAgICAgICAgICB7IGNvZGU6ICdQcm9jZXNzQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnfVxuICAgICAgICApLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNyZWREYXRhID0gSlNPTi5wYXJzZShzdGRPdXQpO1xuICAgICAgICAgIGlmIChjcmVkRGF0YS5FeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBleHBpcmVUaW1lID0gbmV3IERhdGUoY3JlZERhdGEuRXhwaXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZXhwaXJlVGltZSA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdjcmVkZW50aWFsX3Byb2Nlc3MgcmV0dXJuZWQgZXhwaXJlZCBjcmVkZW50aWFscycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjcmVkRGF0YS5WZXJzaW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignY3JlZGVudGlhbF9wcm9jZXNzIGRvZXMgbm90IHJldHVybiBWZXJzaW9uID09IDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgY3JlZERhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgIG5ldyBFcnJvcihlcnIubWVzc2FnZSksXG4gICAgICAgICAgICB7IGNvZGU6ICdQcm9jZXNzQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnfVxuICAgICAgICAgICksIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSBjcmVkZW50aWFsIHByb2Nlc3NcbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgYWZ0ZXIgdGhlIGNyZWRlbnRpYWwgcHJvY2VzcyBoYXMgYmVlbiBleGVjdXRlZC4gV2hlbiB0aGlzXG4gICAqICAgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICBpbmlMb2FkZXIuY2xlYXJDYWNoZWRGaWxlcygpO1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpLFxuICBFTlZfUkVMQVRJVkVfVVJJID0gJ0FXU19DT05UQUlORVJfQ1JFREVOVElBTFNfUkVMQVRJVkVfVVJJJyxcbiAgRU5WX0ZVTExfVVJJID0gJ0FXU19DT05UQUlORVJfQ1JFREVOVElBTFNfRlVMTF9VUkknLFxuICBFTlZfQVVUSF9UT0tFTiA9ICdBV1NfQ09OVEFJTkVSX0FVVEhPUklaQVRJT05fVE9LRU4nLFxuICBGVUxMX1VSSV9VTlJFU1RSSUNURURfUFJPVE9DT0xTID0gWydodHRwczonXSxcbiAgRlVMTF9VUklfQUxMT1dFRF9QUk9UT0NPTFMgPSBbJ2h0dHA6JywgJ2h0dHBzOiddLFxuICBGVUxMX1VSSV9BTExPV0VEX0hPU1ROQU1FUyA9IFsnbG9jYWxob3N0JywgJzEyNy4wLjAuMSddLFxuICBSRUxBVElWRV9VUklfSE9TVCA9ICcxNjkuMjU0LjE3MC4yJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJlY2VpdmVkIGZyb20gc3BlY2lmaWVkIFVSSS5cbiAqXG4gKiBUaGlzIGNsYXNzIHdpbGwgcmVxdWVzdCByZWZyZXNoYWJsZSBjcmVkZW50aWFscyBmcm9tIHRoZSByZWxhdGl2ZSBVUklcbiAqIHNwZWNpZmllZCBieSB0aGUgQVdTX0NPTlRBSU5FUl9DUkVERU5USUFMU19SRUxBVElWRV9VUkkgb3IgdGhlXG4gKiBBV1NfQ09OVEFJTkVSX0NSRURFTlRJQUxTX0ZVTExfVVJJIGVudmlyb25tZW50IHZhcmlhYmxlLiBJZiB2YWxpZCBjcmVkZW50aWFsc1xuICogYXJlIHJldHVybmVkIGluIHRoZSByZXNwb25zZSwgdGhlc2Ugd2lsbCBiZSB1c2VkIHdpdGggemVybyBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoaXMgY3JlZGVudGlhbHMgY2xhc3Mgd2lsbCBieSBkZWZhdWx0IHRpbWVvdXQgYWZ0ZXIgMSBzZWNvbmQgb2YgaW5hY3Rpdml0eVxuICogYW5kIHJldHJ5IDMgdGltZXMuXG4gKiBJZiB5b3VyIHJlcXVlc3RzIHRvIHRoZSByZWxhdGl2ZSBVUkkgYXJlIHRpbWluZyBvdXQsIHlvdSBjYW4gaW5jcmVhc2VcbiAqIHRoZSB2YWx1ZSBieSBjb25maWd1cmluZyB0aGVtIGRpcmVjdGx5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlJlbW90ZUNyZWRlbnRpYWxzKHtcbiAqICAgaHR0cE9wdGlvbnM6IHsgdGltZW91dDogNTAwMCB9LCAvLyA1IHNlY29uZCB0aW1lb3V0XG4gKiAgIG1heFJldHJpZXM6IDEwLCAvLyByZXRyeSAxMCB0aW1lc1xuICogICByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiAyMDAgfSAvLyBzZWUgQVdTLkNvbmZpZyBmb3IgaW5mb3JtYXRpb25cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlZSBBV1MuQ29uZmlnLnJldHJ5RGVsYXlPcHRpb25zXG4gKlxuICogQCFtYWNybyBub2Jyb3dzZXJcbiAqL1xuQVdTLlJlbW90ZUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlbW90ZUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IEFXUy51dGlsLmNvcHkob3B0aW9ucykgOiB7fTtcbiAgICBpZiAoIW9wdGlvbnMuaHR0cE9wdGlvbnMpIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zLmh0dHBPcHRpb25zID0gQVdTLnV0aWwubWVyZ2UoXG4gICAgICB0aGlzLmh0dHBPcHRpb25zLCBvcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICBBV1MudXRpbC51cGRhdGUodGhpcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaHR0cE9wdGlvbnM6IHsgdGltZW91dDogMTAwMCB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1heFJldHJpZXM6IDMsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNDb25maWd1cmVkRm9yRWNzQ3JlZGVudGlhbHM6IGZ1bmN0aW9uIGlzQ29uZmlndXJlZEZvckVjc0NyZWRlbnRpYWxzKCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgICBwcm9jZXNzICYmXG4gICAgICAgIHByb2Nlc3MuZW52ICYmXG4gICAgICAgIChwcm9jZXNzLmVudltFTlZfUkVMQVRJVkVfVVJJXSB8fCBwcm9jZXNzLmVudltFTlZfRlVMTF9VUkldKVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RUNTRnVsbFVyaTogZnVuY3Rpb24gZ2V0RUNTRnVsbFVyaSgpIHtcbiAgICBpZiAocHJvY2VzcyAmJiBwcm9jZXNzLmVudikge1xuICAgICAgdmFyIHJlbGF0aXZlID0gcHJvY2Vzcy5lbnZbRU5WX1JFTEFUSVZFX1VSSV0sXG4gICAgICAgICAgZnVsbCA9IHByb2Nlc3MuZW52W0VOVl9GVUxMX1VSSV07XG4gICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuICdodHRwOi8vJyArIFJFTEFUSVZFX1VSSV9IT1NUICsgcmVsYXRpdmU7XG4gICAgICB9IGVsc2UgaWYgKGZ1bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IEFXUy51dGlsLnVybFBhcnNlKGZ1bGwpO1xuICAgICAgICBpZiAoRlVMTF9VUklfQUxMT1dFRF9QUk9UT0NPTFMuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpIDwgMCkge1xuICAgICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbDogIEFXUy5SZW1vdGVDcmVkZW50aWFscyBzdXBwb3J0cyAnXG4gICAgICAgICAgICAgICsgRlVMTF9VUklfQUxMT1dFRF9QUk9UT0NPTFMuam9pbignLCcpICsgJyBvbmx5OyAnXG4gICAgICAgICAgICAgICsgcGFyc2VkLnByb3RvY29sICsgJyByZXF1ZXN0ZWQuJyksXG4gICAgICAgICAgICB7IGNvZGU6ICdFQ1NDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRlVMTF9VUklfVU5SRVNUUklDVEVEX1BST1RPQ09MUy5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPCAwICYmXG4gICAgICAgICAgICBGVUxMX1VSSV9BTExPV0VEX0hPU1ROQU1FUy5pbmRleE9mKHBhcnNlZC5ob3N0bmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGhvc3RuYW1lOiBBV1MuUmVtb3RlQ3JlZGVudGlhbHMgb25seSBzdXBwb3J0cyAnXG4gICAgICAgICAgICAgICsgRlVMTF9VUklfQUxMT1dFRF9IT1NUTkFNRVMuam9pbignLCcpICsgJyBmb3IgJyArIHBhcnNlZC5wcm90b2NvbCArICc7ICdcbiAgICAgICAgICAgICAgKyBwYXJzZWQucHJvdG9jb2wgKyAnLy8nICsgcGFyc2VkLmhvc3RuYW1lICsgJyByZXF1ZXN0ZWQuJyksXG4gICAgICAgICAgICB7IGNvZGU6ICdFQ1NDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignVmFyaWFibGUgJyArIEVOVl9SRUxBVElWRV9VUkkgKyAnIG9yICcgKyBFTlZfRlVMTF9VUkkgK1xuICAgICAgICAgICAgJyBtdXN0IGJlIHNldCB0byB1c2UgQVdTLlJlbW90ZUNyZWRlbnRpYWxzLicpLFxuICAgICAgICAgIHsgY29kZTogJ0VDU0NyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJyB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ05vIHByb2Nlc3MgaW5mbyBhdmFpbGFibGUnKSxcbiAgICAgICAgeyBjb2RlOiAnRUNTQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldEVDU0F1dGhUb2tlbjogZnVuY3Rpb24gZ2V0RUNTQXV0aFRva2VuKCkge1xuICAgIGlmIChwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52W0VOVl9GVUxMX1VSSV0pIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudltFTlZfQVVUSF9UT0tFTl07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWRzRm9ybWF0SXNWYWxpZDogZnVuY3Rpb24gY3JlZHNGb3JtYXRJc1ZhbGlkKGNyZWREYXRhKSB7XG4gICAgcmV0dXJuICghIWNyZWREYXRhLmFjY2Vzc0tleUlkICYmICEhY3JlZERhdGEuc2VjcmV0QWNjZXNzS2V5ICYmXG4gICAgICAhIWNyZWREYXRhLnNlc3Npb25Ub2tlbiAmJiAhIWNyZWREYXRhLmV4cGlyZVRpbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZvcm1hdENyZWRzOiBmdW5jdGlvbiBmb3JtYXRDcmVkcyhjcmVkRGF0YSkge1xuICAgIGlmICghIWNyZWREYXRhLmNyZWRlbnRpYWxzKSB7XG4gICAgICBjcmVkRGF0YSA9IGNyZWREYXRhLmNyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHBpcmVkOiBmYWxzZSxcbiAgICAgIGFjY2Vzc0tleUlkOiBjcmVkRGF0YS5hY2Nlc3NLZXlJZCB8fCBjcmVkRGF0YS5BY2Nlc3NLZXlJZCxcbiAgICAgIHNlY3JldEFjY2Vzc0tleTogY3JlZERhdGEuc2VjcmV0QWNjZXNzS2V5IHx8IGNyZWREYXRhLlNlY3JldEFjY2Vzc0tleSxcbiAgICAgIHNlc3Npb25Ub2tlbjogY3JlZERhdGEuc2Vzc2lvblRva2VuIHx8IGNyZWREYXRhLlRva2VuLFxuICAgICAgZXhwaXJlVGltZTogbmV3IERhdGUoY3JlZERhdGEuZXhwaXJhdGlvbiB8fCBjcmVkRGF0YS5FeHBpcmF0aW9uKVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IEFXUy5IdHRwUmVxdWVzdCh1cmwpO1xuICAgIGh0dHBSZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnO1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnMuQWNjZXB0ID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIHZhciB0b2tlbiA9IHRoaXMuZ2V0RUNTQXV0aFRva2VuKCk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSB0b2tlbjtcbiAgICB9XG4gICAgQVdTLnV0aWwuaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzKGh0dHBSZXF1ZXN0LCB0aGlzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSByZWxhdGl2ZSBVUkkgc3BlY2lmaWVkIGJ5IGNvbnRhaW5lclxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHRvIHRoZSByZWxhdGl2ZSBVUkkgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGBzZXNzaW9uVG9rZW5gLCBhbmQgYGV4cGlyZVRpbWVgIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmdWxsVXJpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZ1bGxVcmkgPSB0aGlzLmdldEVDU0Z1bGxVcmkoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0KGZ1bGxVcmksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICB2YXIgY3JlZHMgPSBzZWxmLmZvcm1hdENyZWRzKGRhdGEpO1xuICAgICAgICAgIGlmICghc2VsZi5jcmVkc0Zvcm1hdElzVmFsaWQoY3JlZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdSZXNwb25zZSBkYXRhIGlzIG5vdCBpbiB2YWxpZCBmb3JtYXQnKSxcbiAgICAgICAgICAgICAgeyBjb2RlOiAnRUNTQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEFXUy51dGlsLnVwZGF0ZShzZWxmLCBjcmVkcyk7XG4gICAgICAgIH0gY2F0Y2ggKGRhdGFFcnJvcikge1xuICAgICAgICAgIGVyciA9IGRhdGFFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyLCBjcmVkcyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20gU1RTIFNBTUwgc3VwcG9ydC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH0gc2VydmljZSBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uXG4gKiByZXF1aXJlcyBhIGBSb2xlQXJuYCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdCBwb2xpY3kgZm9yIHRoZVxuICogYXBwbGljYXRpb24gZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHdpbGwgYmUgZ2l2ZW4sIGFzIHdlbGwgYXMgYSBgUHJpbmNpcGFsQXJuYFxuICogcmVwcmVzZW50aW5nIHRoZSBBUk4gZm9yIHRoZSBTQU1MIGlkZW50aXR5IHByb3ZpZGVyLiBJbiBhZGRpdGlvbiwgdGhlXG4gKiBgU0FNTEFzc2VydGlvbmAgbXVzdCBiZSBzZXQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBpZGVudGl0eVxuICogcHJvdmlkZXIuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBgUm9sZUFybmAsIGBQcmluY2lwYWxBcm5gLCBhbmQgYFNBTUxBc3NlcnRpb25gIHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBTQU1MQXNzZXJ0aW9uLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuU0FNTEFzc2VydGlvbiA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUx9LiBUbyB1cGRhdGUgdGhlIHRva2VuLCBzZXQgdGhlXG4gKiAgICAgYHBhcmFtcy5TQU1MQXNzZXJ0aW9uYCBwcm9wZXJ0eS5cbiAqL1xuQVdTLlNBTUxDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQHBhcmFtIChzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUwpXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlNBTUxDcmVkZW50aWFscyh7XG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9TQU1MUm9sZScsXG4gICAqICAgICBQcmluY2lwYWxBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1NBTUxQcmluY2lwYWwnLFxuICAgKiAgICAgU0FNTEFzc2VydGlvbjogJ2Jhc2U2NC10b2tlbicsIC8vIGJhc2U2NC1lbmNvZGVkIHRva2VuIGZyb20gSWRQXG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUxcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTQU1MQ3JlZGVudGlhbHMocGFyYW1zKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH1cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZVdpdGhTQU1MKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG52YXIgaW5pTG9hZGVyID0gQVdTLnV0aWwuaW5pTG9hZGVyO1xuXG52YXIgQVNTVU1FX1JPTEVfREVGQVVMVF9SRUdJT04gPSAndXMtZWFzdC0xJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIGxvYWRlZCBmcm9tIHNoYXJlZCBjcmVkZW50aWFscyBmaWxlXG4gKiAoZGVmYXVsdGluZyB0byB+Ly5hd3MvY3JlZGVudGlhbHMgb3IgZGVmaW5lZCBieSB0aGVcbiAqIGBBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEVgIGVudmlyb25tZW50IHZhcmlhYmxlKS5cbiAqXG4gKiAjIyBVc2luZyB0aGUgc2hhcmVkIGNyZWRlbnRpYWxzIGZpbGVcbiAqXG4gKiBUaGlzIHByb3ZpZGVyIGlzIGNoZWNrZWQgYnkgZGVmYXVsdCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudC4gVG8gdXNlIHRoZVxuICogY3JlZGVudGlhbHMgZmlsZSBwcm92aWRlciwgc2ltcGx5IGFkZCB5b3VyIGFjY2VzcyBhbmQgc2VjcmV0IGtleXMgdG8gdGhlXG4gKiB+Ly5hd3MvY3JlZGVudGlhbHMgZmlsZSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAqXG4gKiAgICAgW2RlZmF1bHRdXG4gKiAgICAgYXdzX2FjY2Vzc19rZXlfaWQgPSBBS0lELi4uXG4gKiAgICAgYXdzX3NlY3JldF9hY2Nlc3Nfa2V5ID0gWU9VUl9TRUNSRVRfS0VZXG4gKlxuICogIyMgVXNpbmcgY3VzdG9tIHByb2ZpbGVzXG4gKlxuICogVGhlIFNESyBzdXBwb3J0cyBsb2FkaW5nIGNyZWRlbnRpYWxzIGZvciBzZXBhcmF0ZSBwcm9maWxlcy4gVGhpcyBjYW4gYmUgZG9uZVxuICogaW4gdHdvIHdheXM6XG4gKlxuICogMS4gU2V0IHRoZSBgQVdTX1BST0ZJTEVgIGVudmlyb25tZW50IHZhcmlhYmxlIGluIHlvdXIgcHJvY2VzcyBwcmlvciB0b1xuICogICAgbG9hZGluZyB0aGUgU0RLLlxuICogMi4gRGlyZWN0bHkgbG9hZCB0aGUgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgY3JlZHMgPSBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyh7cHJvZmlsZTogJ215cHJvZmlsZSd9KTtcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAqIGBgYFxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXSBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwcm9maWxlIFtTdHJpbmddIChBV1NfUFJPRklMRSBlbnYgdmFyIG9yICdkZWZhdWx0JylcbiAgICogICB0aGUgbmFtZSBvZiB0aGUgcHJvZmlsZSB0byBsb2FkLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZmlsZW5hbWUgW1N0cmluZ10gKCd+Ly5hd3MvY3JlZGVudGlhbHMnIG9yIGRlZmluZWQgYnlcbiAgICogICBBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgcHJvY2VzcyBlbnYgdmFyKVxuICAgKiAgIHRoZSBmaWxlbmFtZSB0byB1c2Ugd2hlbiBsb2FkaW5nIGNyZWRlbnRpYWxzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZGlzYWJsZUFzc3VtZVJvbGUgW0Jvb2xlYW5dIChmYWxzZSkgVHJ1ZSB0byBkaXNhYmxlXG4gICAqICAgc3VwcG9ydCBmb3IgcHJvZmlsZXMgdGhhdCBhc3N1bWUgYW4gSUFNIHJvbGUuIElmIHRydWUsIGFuZCBhbiBhc3N1bWVcbiAgICogICByb2xlIHByb2ZpbGUgaXMgc2VsZWN0ZWQsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHByZWZlclN0YXRpY0NyZWRlbnRpYWxzIFtCb29sZWFuXSAoZmFsc2UpIFRydWUgdG9cbiAgICogICBwcmVmZXIgc3RhdGljIGNyZWRlbnRpYWxzIHRvIHJvbGVfYXJuIGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB0b2tlbkNvZGVGbiBbRnVuY3Rpb25dIChudWxsKSBGdW5jdGlvbiB0byBwcm92aWRlXG4gICAqICAgU1RTIEFzc3VtZSBSb2xlIFRva2VuQ29kZSwgaWYgbWZhX3NlcmlhbCBpcyBwcm92aWRlZCBmb3IgcHJvZmlsZSBpbiBpbmlcbiAgICogICBmaWxlLiBGdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB2YWx1ZSBvZiBtZmFfc2VyaWFsIGFuZCBjYWxsYmFjaywgYW5kXG4gICAqICAgc2hvdWxkIHByb3ZpZGUgdGhlIFRva2VuQ29kZSBvciBhbiBlcnJvciB0byB0aGUgY2FsbGJhY2sgaW4gdGhlIGZvcm1hdFxuICAgKiAgIGNhbGxiYWNrKGVyciwgdG9rZW4pXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjYWxsYmFjayBbRnVuY3Rpb25dIChlcnIpIENyZWRlbnRpYWxzIGFyZSBlYWdlcmx5IGxvYWRlZFxuICAgKiAgIGJ5IHRoZSBjb25zdHJ1Y3Rvci4gV2hlbiB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIHRoZVxuICAgKiAgIGNyZWRlbnRpYWxzIGhhdmUgYmVlbiBsb2FkZWQgc3VjY2Vzc2Z1bGx5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaHR0cE9wdGlvbnMgW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBsb3ctbGV2ZWxcbiAgICogICBIVFRQIHJlcXVlc3QuIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAqICAgKiAqKnByb3h5KiogW1N0cmluZ10gJm1kYXNoOyB0aGUgVVJMIHRvIHByb3h5IHJlcXVlc3RzIHRocm91Z2hcbiAgICogICAqICoqYWdlbnQqKiBbaHR0cC5BZ2VudCwgaHR0cHMuQWdlbnRdICZtZGFzaDsgdGhlIEFnZW50IG9iamVjdCB0byBwZXJmb3JtXG4gICAqICAgICBIVFRQIHJlcXVlc3RzIHdpdGguIFVzZWQgZm9yIGNvbm5lY3Rpb24gcG9vbGluZy4gRGVmYXVsdHMgdG8gdGhlIGdsb2JhbFxuICAgKiAgICAgYWdlbnQgKGBodHRwLmdsb2JhbEFnZW50YCkgZm9yIG5vbi1TU0wgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBmb3JcbiAgICogICAgIFNTTCBjb25uZWN0aW9ucywgYSBzcGVjaWFsIEFnZW50IG9iamVjdCBpcyB1c2VkIGluIG9yZGVyIHRvIGVuYWJsZVxuICAgKiAgICAgcGVlciBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24uIFRoaXMgZmVhdHVyZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGVcbiAgICogICAgIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAqICAgKiAqKmNvbm5lY3RUaW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXJcbiAgICogICAgIGZhaWxpbmcgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgYWZ0ZXJcbiAgICogICAgIGBjb25uZWN0VGltZW91dGAgbWlsbGlzZWNvbmRzLiBUaGlzIHRpbWVvdXQgaGFzIG5vIGVmZmVjdCBvbmNlIGEgc29ja2V0XG4gICAqICAgICBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgKiAgICogKip0aW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhblxuICAgKiAgICAgdGFrZSBiZWZvcmUgYXV0b21hdGljYWxseSBiZWluZyB0ZXJtaW5hdGVkLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gdHdvIG1pbnV0ZXMgKDEyMDAwMCkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5maWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgdGhpcy5wcm9maWxlID0gb3B0aW9ucy5wcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlO1xuICAgIHRoaXMuZGlzYWJsZUFzc3VtZVJvbGUgPSBCb29sZWFuKG9wdGlvbnMuZGlzYWJsZUFzc3VtZVJvbGUpO1xuICAgIHRoaXMucHJlZmVyU3RhdGljQ3JlZGVudGlhbHMgPSBCb29sZWFuKG9wdGlvbnMucHJlZmVyU3RhdGljQ3JlZGVudGlhbHMpO1xuICAgIHRoaXMudG9rZW5Db2RlRm4gPSBvcHRpb25zLnRva2VuQ29kZUZuIHx8IG51bGw7XG4gICAgdGhpcy5odHRwT3B0aW9ucyA9IG9wdGlvbnMuaHR0cE9wdGlvbnMgfHwgbnVsbDtcbiAgICB0aGlzLmdldChvcHRpb25zLmNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLm5vb3ApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm9maWxlcyA9IEFXUy51dGlsLmdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhpbmlMb2FkZXIsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgdmFyIHByb2ZpbGUgPSBwcm9maWxlc1t0aGlzLnByb2ZpbGVdIHx8IHt9O1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMocHJvZmlsZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignUHJvZmlsZSAnICsgdGhpcy5wcm9maWxlICsgJyBub3QgZm91bmQnKSxcbiAgICAgICAgICB7IGNvZGU6ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEluIHRoZSBDTEksIHRoZSBwcmVzZW5jZSBvZiBib3RoIGEgcm9sZV9hcm4gYW5kIHN0YXRpYyBjcmVkZW50aWFscyBoYXZlXG4gICAgICBkaWZmZXJlbnQgbWVhbmluZ3MgZGVwZW5kaW5nIG9uIGhvdyBtYW55IHByb2ZpbGVzIGhhdmUgYmVlbiB2aXNpdGVkLiBGb3JcbiAgICAgIHRoZSBmaXJzdCBwcm9maWxlIHByb2Nlc3NlZCwgcm9sZV9hcm4gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSBzdGF0aWNcbiAgICAgIGNyZWRlbnRpYWxzLCBidXQgZm9yIGFsbCBzdWJzZXF1ZW50IHByb2ZpbGVzLCBzdGF0aWMgY3JlZGVudGlhbHMgYXJlXG4gICAgICB1c2VkIGlmIHByZXNlbnQsIGFuZCBvbmx5IGluIHRoZWlyIGFic2VuY2Ugd2lsbCB0aGUgcHJvZmlsZSdzXG4gICAgICBzb3VyY2VfcHJvZmlsZSBhbmQgcm9sZV9hcm4ga2V5cyBiZSB1c2VkIHRvIGxvYWQgYW5vdGhlciBzZXQgb2ZcbiAgICAgIGNyZWRlbnRpYWxzLiBUaGlzIHZhciBpcyBpbnRlbmRlZCB0byB5aWVsZCBjb21wYXRpYmxlIGJlaGF2aW91ciBpbiB0aGlzXG4gICAgICBzZGsuXG4gICAgICAqL1xuICAgICAgdmFyIHByZWZlclN0YXRpY0NyZWRlbnRpYWxzVG9Sb2xlQXJuID0gQm9vbGVhbihcbiAgICAgICAgdGhpcy5wcmVmZXJTdGF0aWNDcmVkZW50aWFsc1xuICAgICAgICAmJiBwcm9maWxlWydhd3NfYWNjZXNzX2tleV9pZCddXG4gICAgICAgICYmIHByb2ZpbGVbJ2F3c19zZWNyZXRfYWNjZXNzX2tleSddXG4gICAgICApO1xuXG4gICAgICBpZiAocHJvZmlsZVsncm9sZV9hcm4nXSAmJiAhcHJlZmVyU3RhdGljQ3JlZGVudGlhbHNUb1JvbGVBcm4pIHtcbiAgICAgICAgdGhpcy5sb2FkUm9sZVByb2ZpbGUocHJvZmlsZXMsIHByb2ZpbGUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXhwaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5hY2Nlc3NLZXlJZCA9IGRhdGEuQ3JlZGVudGlhbHMuQWNjZXNzS2V5SWQ7XG4gICAgICAgICAgICBzZWxmLnNlY3JldEFjY2Vzc0tleSA9IGRhdGEuQ3JlZGVudGlhbHMuU2VjcmV0QWNjZXNzS2V5O1xuICAgICAgICAgICAgc2VsZi5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICAgICAgICAgIHNlbGYuZXhwaXJlVGltZSA9IGRhdGEuQ3JlZGVudGlhbHMuRXhwaXJhdGlvbjtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY2Nlc3NLZXlJZCA9IHByb2ZpbGVbJ2F3c19hY2Nlc3Nfa2V5X2lkJ107XG4gICAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IHByb2ZpbGVbJ2F3c19zZWNyZXRfYWNjZXNzX2tleSddO1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBwcm9maWxlWydhd3Nfc2Vzc2lvbl90b2tlbiddO1xuXG4gICAgICBpZiAoIXRoaXMuYWNjZXNzS2V5SWQgfHwgIXRoaXMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignQ3JlZGVudGlhbHMgbm90IHNldCBmb3IgcHJvZmlsZSAnICsgdGhpcy5wcm9maWxlKSxcbiAgICAgICAgICB7IGNvZGU6ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwaXJlZCA9IGZhbHNlO1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIHNoYXJlZCBjcmVkZW50aWFscyBmaWxlXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIGFmdGVyIHRoZSBzaGFyZWQgSU5JIGZpbGUgb24gZGlzayBpcyByZWFkIGFuZCBwYXJzZWQuIFdoZW4gdGhpc1xuICAgKiAgIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgaW5pTG9hZGVyLmNsZWFyQ2FjaGVkRmlsZXMoKTtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChcbiAgICAgIGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrLFxuICAgICAgdGhpcy5kaXNhYmxlQXNzdW1lUm9sZVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFJvbGVQcm9maWxlOiBmdW5jdGlvbiBsb2FkUm9sZVByb2ZpbGUoY3JlZHMsIHJvbGVQcm9maWxlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmRpc2FibGVBc3N1bWVSb2xlKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgbmV3IEVycm9yKCdSb2xlIGFzc3VtcHRpb24gcHJvZmlsZXMgYXJlIGRpc2FibGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gbG9hZCBwcm9maWxlICcgKyB0aGlzLnByb2ZpbGUgK1xuICAgICAgICAgICAgICAgICAgJyBmcm9tICcgKyBjcmVkcy5maWxlbmFtZSksXG4gICAgICAgIHsgY29kZTogJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJvbGVBcm4gPSByb2xlUHJvZmlsZVsncm9sZV9hcm4nXTtcbiAgICB2YXIgcm9sZVNlc3Npb25OYW1lID0gcm9sZVByb2ZpbGVbJ3JvbGVfc2Vzc2lvbl9uYW1lJ107XG4gICAgdmFyIGV4dGVybmFsSWQgPSByb2xlUHJvZmlsZVsnZXh0ZXJuYWxfaWQnXTtcbiAgICB2YXIgbWZhU2VyaWFsID0gcm9sZVByb2ZpbGVbJ21mYV9zZXJpYWwnXTtcbiAgICB2YXIgc291cmNlUHJvZmlsZU5hbWUgPSByb2xlUHJvZmlsZVsnc291cmNlX3Byb2ZpbGUnXTtcblxuICAgIC8vIEZyb20gZXhwZXJpbWVudGF0aW9uLCB0aGUgZm9sbG93aW5nIGJlaGF2aW9yIG1pbWljcyB0aGUgQVdTIENMSTpcbiAgICAvL1xuICAgIC8vIDEuIFVzZSByZWdpb24gZnJvbSB0aGUgcHJvZmlsZSBpZiBwcmVzZW50LlxuICAgIC8vIDIuIE90aGVyd2lzZSBmYWxsIGJhY2sgdG8gTi4gVmlyZ2luaWEgKGdsb2JhbCBlbmRwb2ludCkuXG4gICAgLy9cbiAgICAvLyBJdCBpcyBuZWNlc3NhcnkgdG8gZG8gdGhlIGZhbGxiYWNrIGV4cGxpY2l0bHksIGJlY2F1c2UgaWZcbiAgICAvLyAnQVdTX1NUU19SRUdJT05BTF9FTkRQT0lOVFM9cmVnaW9uYWwnLCB0aGUgdW5kZXJseWluZyBTVFMgY2xpZW50IHdpbGxcbiAgICAvLyBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IgaWYgcmVnaW9uIGlzIGxlZnQgJ3VuZGVmaW5lZCcuXG4gICAgLy9cbiAgICAvLyBFeHBlcmltZW50YXRpb24gc2hvd3MgdGhhdCB0aGUgQVdTIENMSSAodGVzdGVkIGF0IHZlcnNpb24gMS4xOC4xMzYpXG4gICAgLy8gaWdub3JlcyB0aGUgZm9sbG93aW5nIHBvdGVudGlhbCBzb3VyY2VzIG9mIGEgcmVnaW9uIGZvciB0aGUgcHVycG9zZXMgb2ZcbiAgICAvLyB0aGlzIEFzc3VtZVJvbGUgY2FsbDpcbiAgICAvL1xuICAgIC8vIC0gVGhlIFtkZWZhdWx0XSBwcm9maWxlXG4gICAgLy8gLSBUaGUgQVdTX1JFR0lPTiBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIC8vXG4gICAgLy8gSWdub3JpbmcgdGhlIFtkZWZhdWx0XSBwcm9maWxlIGZvciB0aGUgcHVycG9zZXMgb2YgQXNzdW1lUm9sZSBpcyBhcmd1YWJseVxuICAgIC8vIGEgYnVnIGluIHRoZSBDTEkgc2luY2UgaXQgZG9lcyB1c2UgdGhlIFtkZWZhdWx0XSByZWdpb24gZm9yIHNlcnZpY2VcbiAgICAvLyBjYWxscy4uLiBidXQgcmlnaHQgbm93IHdlJ3JlIG1hdGNoaW5nIGJlaGF2aW9yIG9mIHRoZSBvdGhlciB0b29sLlxuICAgIHZhciBwcm9maWxlUmVnaW9uID0gcm9sZVByb2ZpbGVbJ3JlZ2lvbiddIHx8IEFTU1VNRV9ST0xFX0RFRkFVTFRfUkVHSU9OO1xuXG4gICAgaWYgKCFzb3VyY2VQcm9maWxlTmFtZSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgIG5ldyBFcnJvcignc291cmNlX3Byb2ZpbGUgaXMgbm90IHNldCB1c2luZyBwcm9maWxlICcgKyB0aGlzLnByb2ZpbGUpLFxuICAgICAgICB7IGNvZGU6ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVByb2ZpbGVFeGlzdGFuY2VUZXN0ID0gY3JlZHNbc291cmNlUHJvZmlsZU5hbWVdO1xuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9maWxlRXhpc3RhbmNlVGVzdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ3NvdXJjZV9wcm9maWxlICcgKyBzb3VyY2VQcm9maWxlTmFtZSArICcgdXNpbmcgcHJvZmlsZSAnXG4gICAgICAgICAgKyB0aGlzLnByb2ZpbGUgKyAnIGRvZXMgbm90IGV4aXN0JyksXG4gICAgICAgIHsgY29kZTogJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlQ3JlZGVudGlhbHMgPSBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyhcbiAgICAgIEFXUy51dGlsLm1lcmdlKHRoaXMub3B0aW9ucyB8fCB7fSwge1xuICAgICAgICBwcm9maWxlOiBzb3VyY2VQcm9maWxlTmFtZSxcbiAgICAgICAgcHJlZmVyU3RhdGljQ3JlZGVudGlhbHM6IHRydWVcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMucm9sZUFybiA9IHJvbGVBcm47XG4gICAgdmFyIHN0cyA9IG5ldyBTVFMoe1xuICAgICAgY3JlZGVudGlhbHM6IHNvdXJjZUNyZWRlbnRpYWxzLFxuICAgICAgcmVnaW9uOiBwcm9maWxlUmVnaW9uLFxuICAgICAgaHR0cE9wdGlvbnM6IHRoaXMuaHR0cE9wdGlvbnNcbiAgICB9KTtcblxuICAgIHZhciByb2xlUGFyYW1zID0ge1xuICAgICAgUm9sZUFybjogcm9sZUFybixcbiAgICAgIFJvbGVTZXNzaW9uTmFtZTogcm9sZVNlc3Npb25OYW1lIHx8ICdhd3Mtc2RrLWpzLScgKyBEYXRlLm5vdygpXG4gICAgfTtcblxuICAgIGlmIChleHRlcm5hbElkKSB7XG4gICAgICByb2xlUGFyYW1zLkV4dGVybmFsSWQgPSBleHRlcm5hbElkO1xuICAgIH1cblxuICAgIGlmIChtZmFTZXJpYWwgJiYgc2VsZi50b2tlbkNvZGVGbikge1xuICAgICAgcm9sZVBhcmFtcy5TZXJpYWxOdW1iZXIgPSBtZmFTZXJpYWw7XG4gICAgICBzZWxmLnRva2VuQ29kZUZuKG1mYVNlcmlhbCwgZnVuY3Rpb24oZXJyLCB0b2tlbikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgTUZBIHRva2VuOiAnICsgbWVzc2FnZSksXG4gICAgICAgICAgICAgIHsgY29kZTogJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9sZVBhcmFtcy5Ub2tlbkNvZGUgPSB0b2tlbjtcbiAgICAgICAgc3RzLmFzc3VtZVJvbGUocm9sZVBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0cy5hc3N1bWVSb2xlKHJvbGVQYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgaW5pTG9hZGVyID0gQVdTLnV0aWwuaW5pTG9hZGVyO1xuXG4vKipcbiAqICBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIGZyb20gc3NvLmdldFJvbGVDcmVkZW50aWFscyBBUEkgZm9yXG4gKiBgc3NvXypgIHZhbHVlcyBkZWZpbmVkIGluIHNoYXJlZCBjcmVkZW50aWFscyBmaWxlLlxuICpcbiAqICMjIFVzaW5nIFNTTyBjcmVkZW50aWFsc1xuICpcbiAqIFRoZSBjcmVkZW50aWFscyBmaWxlIG11c3Qgc3BlY2lmeSB0aGUgaW5mb3JtYXRpb24gYmVsb3cgdG8gdXNlIHNzbzpcbiAqXG4gKiAgICAgW2RlZmF1bHRdXG4gKiAgICAgc3NvX2FjY291bnRfaWQgPSAwMTIzNDU2Nzg5MDFcbiAqICAgICBzc29fcmVnaW9uID0gdXMtZWFzdC0xXG4gKiAgICAgc3NvX3JvbGVfbmFtZSA9IFNhbXBsZVJvbGVcbiAqICAgICBzc29fc3RhcnRfdXJsID0gaHR0cHM6Ly9kLWFiYzEyMy5hd3NhcHBzLmNvbS9zdGFydFxuICpcbiAqIFRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHlvdXIgc2hhcmVkIGNyZWRlbnRpYWxzIGZpbGUgYnkgcnVubmluZ1xuICogYGF3cyBjb25maWd1cmUgc3NvYC5cbiAqXG4gKiAjIyBVc2luZyBjdXN0b20gcHJvZmlsZXNcbiAqXG4gKiBUaGUgU0RLIHN1cHBvcnRzIGxvYWRpbmcgY3JlZGVudGlhbHMgZm9yIHNlcGFyYXRlIHByb2ZpbGVzLiBUaGlzIGNhbiBiZSBkb25lXG4gKiBpbiB0d28gd2F5czpcbiAqXG4gKiAxLiBTZXQgdGhlIGBBV1NfUFJPRklMRWAgZW52aXJvbm1lbnQgdmFyaWFibGUgaW4geW91ciBwcm9jZXNzIHByaW9yIHRvXG4gKiAgICBsb2FkaW5nIHRoZSBTREsuXG4gKiAyLiBEaXJlY3RseSBsb2FkIHRoZSBBV1MuU3NvQ3JlZGVudGlhbHMgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGNyZWRzID0gbmV3IEFXUy5Tc29DcmVkZW50aWFscyh7cHJvZmlsZTogJ215cHJvZmlsZSd9KTtcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAqIGBgYFxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5Tc29DcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNzb0NyZWRlbnRpYWxzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF0gYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgcHJvZmlsZSBbU3RyaW5nXSAoQVdTX1BST0ZJTEUgZW52IHZhciBvciAnZGVmYXVsdCcpXG4gICAqICAgdGhlIG5hbWUgb2YgdGhlIHByb2ZpbGUgdG8gbG9hZC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGZpbGVuYW1lIFtTdHJpbmddICgnfi8uYXdzL2NyZWRlbnRpYWxzJyBvciBkZWZpbmVkIGJ5XG4gICAqICAgQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFIHByb2Nlc3MgZW52IHZhcilcbiAgICogICB0aGUgZmlsZW5hbWUgdG8gdXNlIHdoZW4gbG9hZGluZyBjcmVkZW50aWFscy5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNhbGxiYWNrIFtGdW5jdGlvbl0gKGVycikgQ3JlZGVudGlhbHMgYXJlIGVhZ2VybHkgbG9hZGVkXG4gICAqICAgYnkgdGhlIGNvbnN0cnVjdG9yLiBXaGVuIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgdGhlXG4gICAqICAgY3JlZGVudGlhbHMgaGF2ZSBiZWVuIGxvYWRlZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU3NvQ3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5lcnJvckNvZGUgPSAnU3NvQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG5cbiAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICB0aGlzLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGU7XG4gICAgdGhpcy5zZXJ2aWNlID0gb3B0aW9ucy5zc29DbGllbnQ7XG4gICAgdGhpcy5nZXQob3B0aW9ucy5jYWxsYmFjayB8fCBBV1MudXRpbC5mbi5ub29wKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRpbWUgd2luZG93ICgxNSBtaW5zKSB0aGF0IFNESyB3aWxsIHRyZWF0IHRoZSBTU08gdG9rZW4gZXhwaXJlcyBpbiBiZWZvcmUgdGhlIGRlZmluZWQgZXhwaXJhdGlvbiBkYXRlIGluIHRva2VuLlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugc2VydmVyIHNpZGUgbWF5IGhhdmUgaW52YWxpZGF0ZWQgdGhlIHRva2VuIGJlZm9yZSB0aGUgZGVmaW5lZCBleHBpcmF0aW9uIGRhdGUuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB2YXIgRVhQSVJFX1dJTkRPV19NUyA9IDE1ICogNjAgKiAxMDAwO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgdmFyIHByb2ZpbGVzID0gQVdTLnV0aWwuZ2V0UHJvZmlsZXNGcm9tU2hhcmVkQ29uZmlnKGluaUxvYWRlciwgdGhpcy5maWxlbmFtZSk7XG4gICAgICB2YXIgcHJvZmlsZSA9IHByb2ZpbGVzW3RoaXMucHJvZmlsZV0gfHwge307XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9maWxlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdQcm9maWxlICcgKyB0aGlzLnByb2ZpbGUgKyAnIG5vdCBmb3VuZCcpLFxuICAgICAgICAgIHsgY29kZTogc2VsZi5lcnJvckNvZGUgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXByb2ZpbGUuc3NvX3N0YXJ0X3VybCB8fCAhcHJvZmlsZS5zc29fYWNjb3VudF9pZCB8fCAhcHJvZmlsZS5zc29fcmVnaW9uIHx8ICFwcm9maWxlLnNzb19yb2xlX25hbWUpIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdQcm9maWxlICcgKyB0aGlzLnByb2ZpbGUgKyAnIGRvZXMgbm90IGhhdmUgdmFsaWQgU1NPIGNyZWRlbnRpYWxzLiBSZXF1aXJlZCBwYXJhbWV0ZXJzIFwic3NvX2FjY291bnRfaWRcIiwgXCJzc29fcmVnaW9uXCIsICcgK1xuICAgICAgICAgICdcInNzb19yb2xlX25hbWVcIiwgXCJzc29fc3RhcnRfdXJsXCIuIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2NsaS9sYXRlc3QvdXNlcmd1aWRlL2NsaS1jb25maWd1cmUtc3NvLmh0bWwnKSxcbiAgICAgICAgICB7IGNvZGU6IHNlbGYuZXJyb3JDb2RlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2hlciA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBoYXNoZXIudXBkYXRlKHByb2ZpbGUuc3NvX3N0YXJ0X3VybCkuZGlnZXN0KCdoZXgnKSArICcuanNvbic7XG5cbiAgICAgIHZhciBjYWNoZVBhdGggPSBwYXRoLmpvaW4oXG4gICAgICAgIGluaUxvYWRlci5nZXRIb21lRGlyKCksXG4gICAgICAgICcuYXdzJyxcbiAgICAgICAgJ3NzbycsXG4gICAgICAgICdjYWNoZScsXG4gICAgICAgIGZpbGVOYW1lXG4gICAgICApO1xuICAgICAgdmFyIGNhY2hlRmlsZSA9IEFXUy51dGlsLnJlYWRGaWxlU3luYyhjYWNoZVBhdGgpO1xuICAgICAgdmFyIGNhY2hlQ29udGVudCA9IG51bGw7XG4gICAgICBpZiAoY2FjaGVGaWxlKSB7XG4gICAgICAgIGNhY2hlQ29udGVudCA9IEpTT04ucGFyc2UoY2FjaGVGaWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYWNoZUNvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdDYWNoZWQgY3JlZGVudGlhbHMgbm90IGZvdW5kIHVuZGVyICcgKyB0aGlzLnByb2ZpbGUgKyAnIHByb2ZpbGUuIFBsZWFzZSBtYWtlIHN1cmUgeW91IGxvZyBpbiB3aXRoIGF3cyBzc28gbG9naW4gZmlyc3QnKSxcbiAgICAgICAgICB7IGNvZGU6IHNlbGYuZXJyb3JDb2RlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYWNoZUNvbnRlbnQuc3RhcnRVcmwgfHwgIWNhY2hlQ29udGVudC5yZWdpb24gfHwgIWNhY2hlQ29udGVudC5hY2Nlc3NUb2tlbiB8fCAhY2FjaGVDb250ZW50LmV4cGlyZXNBdCkge1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ0NhY2hlZCBjcmVkZW50aWFscyBhcmUgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUcnkgcnVubmluZyBhd3Mgc3NvIGxvZ2luLicpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXcgRGF0ZShjYWNoZUNvbnRlbnQuZXhwaXJlc0F0KS5nZXRUaW1lKCkgLSBEYXRlLm5vdygpIDw9IEVYUElSRV9XSU5ET1dfTVMpIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgU1NPIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHJvZmlsZSBoYXMgZXhwaXJlZC4gVG8gcmVmcmVzaCB0aGlzIFNTTyBzZXNzaW9uIHJ1biBhd3Mgc3NvIGxvZ2luIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvZmlsZS4nXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuc2VydmljZSB8fCBzZWxmLnNlcnZpY2UuY29uZmlnLnJlZ2lvbiAhPT0gcHJvZmlsZS5zc29fcmVnaW9uKSB7XG4gICAgICAgIHNlbGYuc2VydmljZSA9IG5ldyBBV1MuU1NPKHsgcmVnaW9uOiBwcm9maWxlLnNzb19yZWdpb24gfSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgYWNjZXNzVG9rZW46IGNhY2hlQ29udGVudC5hY2Nlc3NUb2tlbixcbiAgICAgICAgYWNjb3VudElkOiBwcm9maWxlLnNzb19hY2NvdW50X2lkLFxuICAgICAgICByb2xlTmFtZTogcHJvZmlsZS5zc29fcm9sZV9uYW1lLFxuICAgICAgfTtcbiAgICAgIHNlbGYuc2VydmljZS5nZXRSb2xlQ3JlZGVudGlhbHMocmVxdWVzdCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIgfHwgIWRhdGEgfHwgIWRhdGEucm9sZUNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgY2FsbGJhY2soQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICBlcnIgfHwgbmV3IEVycm9yKCdQbGVhc2UgbG9nIGluIHVzaW5nIFwiYXdzIHNzbyBsb2dpblwiJyksXG4gICAgICAgICAgICB7IGNvZGU6IHNlbGYuZXJyb3JDb2RlIH1cbiAgICAgICAgICApLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGF0YS5yb2xlQ3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgfHwgIWRhdGEucm9sZUNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSB8fCAhZGF0YS5yb2xlQ3JlZGVudGlhbHMuc2Vzc2lvblRva2VuIHx8ICFkYXRhLnJvbGVDcmVkZW50aWFscy5leHBpcmF0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKFxuICAgICAgICAgICAgJ1NTTyByZXR1cm5zIGFuIGludmFsaWQgdGVtcG9yYXJ5IGNyZWRlbnRpYWwuJ1xuICAgICAgICAgICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZXhwaXJlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuYWNjZXNzS2V5SWQgPSBkYXRhLnJvbGVDcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcbiAgICAgICAgICBzZWxmLnNlY3JldEFjY2Vzc0tleSA9IGRhdGEucm9sZUNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleTtcbiAgICAgICAgICBzZWxmLnNlc3Npb25Ub2tlbiA9IGRhdGEucm9sZUNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICAgICAgICBzZWxmLmV4cGlyZVRpbWUgPSBuZXcgRGF0ZShkYXRhLnJvbGVDcmVkZW50aWFscy5leHBpcmF0aW9uKTtcbiAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIEFXUyBTU08gcHJvY2Vzc1xuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCBhZnRlciB0aGUgQVdTIFNTTyBwcm9jZXNzIGhhcyBiZWVuIGV4ZWN1dGVkLiBXaGVuIHRoaXNcbiAgICogICBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIGluaUxvYWRlci5jbGVhckNhY2hlZEZpbGVzKCk7XG4gICAgdGhpcy5jb2FsZXNjZVJlZnJlc2goY2FsbGJhY2sgfHwgQVdTLnV0aWwuZm4uY2FsbGJhY2spO1xuICB9LFxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20ge0FXUy5TVFN9LiBXaXRob3V0IGFueVxuICogZXh0cmEgcGFyYW1ldGVycywgY3JlZGVudGlhbHMgd2lsbCBiZSBmZXRjaGVkIGZyb20gdGhlXG4gKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbi4gSWYgYW4gSUFNIHJvbGUgaXMgcHJvdmlkZWQsIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3BlcmF0aW9uIHdpbGwgYmUgdXNlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiByb2xlIGluc3RlYWQuXG4gKlxuICogQG5vdGUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGlzIGRlcHJlY2F0ZWQsIGJ1dCByZW1haW5zIGF2YWlsYWJsZSBmb3JcbiAqICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIHtBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHN9IGlzIHRoZVxuICogICBwcmVmZXJyZWQgY2xhc3MgZm9yIHRlbXBvcmFyeSBjcmVkZW50aWFscy5cbiAqXG4gKiBUbyBzZXR1cCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMsIGNvbmZpZ3VyZSBhIHNldCBvZiBtYXN0ZXIgY3JlZGVudGlhbHNcbiAqIHVzaW5nIHRoZSBzdGFuZGFyZCBjcmVkZW50aWFscyBwcm92aWRlcnMgKGVudmlyb25tZW50LCBFQzIgaW5zdGFuY2UgbWV0YWRhdGEsXG4gKiBvciBmcm9tIHRoZSBmaWxlc3lzdGVtKSwgdGhlbiBzZXQgdGhlIGdsb2JhbCBjcmVkZW50aWFscyB0byBhIG5ld1xuICogdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBOb3RlIHRoYXQgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMgYXJlIGxvYWRlZCBieSBkZWZhdWx0LFxuICogLy8gdGhlIGZvbGxvd2luZyBsaW5lIGlzIHNob3duIGZvciBjbGFyaXR5OlxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7XG4gKlxuICogLy8gTm93IHNldCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgc2VlZGVkIGZyb20gdGhlIG1hc3RlciBjcmVkZW50aWFsc1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAqXG4gKiAvLyBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgbm93IHVzZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogbmV3IEFXUy5TMygpLmxpc3RCdWNrZXQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IC4uLiB9KTtcbiAqIGBgYFxuICpcbiAqIEAhYXR0cmlidXRlIG1hc3RlckNyZWRlbnRpYWxzXG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gdGhlIG1hc3RlciAobm9uLXRlbXBvcmFyeSkgY3JlZGVudGlhbHMgdXNlZCB0b1xuICogICAgIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogQG5vdGUgKHNlZSBjb25zdHJ1Y3RvcilcbiAqL1xuQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgSW4gb3JkZXIgdG8gY3JlYXRlIHRlbXBvcmFyeSBjcmVkZW50aWFscywgeW91IGZpcnN0IG5lZWQgdG8gaGF2ZVxuICAgKiAgIFwibWFzdGVyXCIgY3JlZGVudGlhbHMgY29uZmlndXJlZCBpbiB7QVdTLkNvbmZpZy5jcmVkZW50aWFsc30uIFRoZXNlXG4gICAqICAgbWFzdGVyIGNyZWRlbnRpYWxzIGFyZSBuZWNlc3NhcnkgdG8gcmV0cmlldmUgdGhlIHRlbXBvcmFyeSBjcmVkZW50aWFscyxcbiAgICogICBhcyB3ZWxsIGFzIHJlZnJlc2ggdGhlIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBleHBpcmUuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlXG4gICAqICAge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3Ige0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb25zLlxuICAgKiAgIElmIGEgYFJvbGVBcm5gIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIGNyZWRlbnRpYWxzIHdpbGwgYmUgYmFzZWQgb24gdGhlXG4gICAqICAgSUFNIHJvbGUuXG4gICAqIEBwYXJhbSBtYXN0ZXJDcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIChub24tdGVtcG9yYXJ5KSBjcmVkZW50aWFsc1xuICAgKiAgdXNlZCB0byBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBnZW5lcmljIHRlbXBvcmFyeSBjcmVkZW50aWFsc1xuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgYW4gSUFNIHJvbGVcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9UZW1wb3JhcnlDcmVkZW50aWFscycsXG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlXG4gICAqIEBzZWUgQVdTLlNUUy5nZXRTZXNzaW9uVG9rZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBUZW1wb3JhcnlDcmVkZW50aWFscyhwYXJhbXMsIG1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sb2FkTWFzdGVyQ3JlZGVudGlhbHMobWFzdGVyQ3JlZGVudGlhbHMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBpZiAodGhpcy5wYXJhbXMuUm9sZUFybikge1xuICAgICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lID1cbiAgICAgICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd0ZW1wb3JhcnktY3JlZGVudGlhbHMnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yXG4gICAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0sIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIElBTSByb2xlIEFSTiB3YXMgcGFzc2VkXG4gICAqIHRvIHRoZSBjcmVkZW50aWFscyB7Y29uc3RydWN0b3J9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZCAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5tYXN0ZXJDcmVkZW50aWFscy5nZXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscyA9IHNlbGYubWFzdGVyQ3JlZGVudGlhbHM7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gc2VsZi5wYXJhbXMuUm9sZUFybiA/XG4gICAgICAgIHNlbGYuc2VydmljZS5hc3N1bWVSb2xlIDogc2VsZi5zZXJ2aWNlLmdldFNlc3Npb25Ub2tlbjtcbiAgICAgIG9wZXJhdGlvbi5jYWxsKHNlbGYuc2VydmljZSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRNYXN0ZXJDcmVkZW50aWFsczogZnVuY3Rpb24gbG9hZE1hc3RlckNyZWRlbnRpYWxzIChtYXN0ZXJDcmVkZW50aWFscykge1xuICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSBtYXN0ZXJDcmVkZW50aWFscyB8fCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzO1xuICAgIHdoaWxlICh0aGlzLm1hc3RlckNyZWRlbnRpYWxzLm1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gdGhpcy5tYXN0ZXJDcmVkZW50aWFscy5tYXN0ZXJDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMuZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gbmV3IEFXUy5DcmVkZW50aWFscyh0aGlzLm1hc3RlckNyZWRlbnRpYWxzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xudmFyIGluaUxvYWRlciA9IEFXUy51dGlsLmluaUxvYWRlcjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIE9JREMgY3JlZGVudGlhbHMgZnJvbSBhIGZpbGUgb24gZGlza1xuICogSWYgdGhlIGNyZWRlbnRpYWxzIGV4cGlyZSwgdGhlIFNESyBjYW4ge3JlZnJlc2h9IHRoZSBjcmVkZW50aWFsc1xuICogZnJvbSB0aGUgZmlsZS5cbiAqXG4gKiAjIyBVc2luZyB0aGUgd2ViIGlkZW50aXR5IHRva2VuIGZpbGVcbiAqXG4gKiBUaGlzIHByb3ZpZGVyIGlzIGNoZWNrZWQgYnkgZGVmYXVsdCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudC4gVG8gdXNlXG4gKiB0aGUgcHJvdmlkZXIgc2ltcGx5IGFkZCB5b3VyIE9JREMgdG9rZW4gdG8gYSBmaWxlIChBU0NJSSBlbmNvZGluZykgYW5kXG4gKiBzaGFyZSB0aGUgZmlsZW5hbWUgaW4gZWl0aGVyIEFXU19XRUJfSURFTlRJVFlfVE9LRU5fRklMRSBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgb3Igd2ViX2lkZW50aXR5X3Rva2VuX2ZpbGUgc2hhcmVkIGNvbmZpZyB2YXJpYWJsZVxuICpcbiAqIFRoZSBmaWxlIGNvbnRhaW5zIGVuY29kZWQgT0lEQyB0b2tlbiBhbmQgdGhlIGNoYXJhY3RlcnMgYXJlXG4gKiBBU0NJSSBlbmNvZGVkLiBPSURDIHRva2VucyBhcmUgSlNPTiBXZWIgVG9rZW5zIChKV1QpLlxuICogSldUJ3MgYXJlIDMgYmFzZTY0IGVuY29kZWQgc3RyaW5ncyBqb2luZWQgYnkgdGhlICcuJyBjaGFyYWN0ZXIuXG4gKlxuICogVGhpcyBjbGFzcyB3aWxsIHJlYWQgZmlsZW5hbWUgZnJvbSBBV1NfV0VCX0lERU5USVRZX1RPS0VOX0ZJTEVcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHdlYl9pZGVudGl0eV90b2tlbl9maWxlIHNoYXJlZCBjb25maWcgdmFyaWFibGUsXG4gKiBhbmQgZ2V0IHRoZSBPSURDIHRva2VuIGZyb20gZmlsZW5hbWUuXG4gKiBJdCB3aWxsIGFsc28gcmVhZCBJQU0gcm9sZSB0byBiZSBhc3N1bWVkIGZyb20gQVdTX1JPTEVfQVJOXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciByb2xlX2FybiBzaGFyZWQgY29uZmlnIHZhcmlhYmxlLlxuICogVGhpcyBwcm92aWRlciBnZXRzIGNyZWRldGlhbHMgdXNpbmcgdGhlIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gKiBzZXJ2aWNlIG9wZXJhdGlvblxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzKFxuICAgKiAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIEFXUy5TVFMgc2VydmljZSBjbGllbnRcbiAgICogICAvLyBpZiBjb25maWd1cmF0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBjb25maWd1cmF0aW9uIHdpbGwgYmUgcHVsbGVkIGZyb20gQVdTLmNvbmZpZ1xuICAgKiAgIHtcbiAgICogICAgIC8vIHNwZWNpZnkgdGltZW91dCBvcHRpb25zXG4gICAqICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFscyhjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcmFtcyBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFBhcmFtc0Zyb21FbnY6IGZ1bmN0aW9uIGdldFBhcmFtc0Zyb21FbnYoKSB7XG4gICAgdmFyIEVOVl9UT0tFTl9GSUxFID0gJ0FXU19XRUJfSURFTlRJVFlfVE9LRU5fRklMRScsXG4gICAgICAgIEVOVl9ST0xFX0FSTiA9ICdBV1NfUk9MRV9BUk4nO1xuICAgIGlmIChwcm9jZXNzLmVudltFTlZfVE9LRU5fRklMRV0gJiYgcHJvY2Vzcy5lbnZbRU5WX1JPTEVfQVJOXSkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGVudlRva2VuRmlsZTogcHJvY2Vzcy5lbnZbRU5WX1RPS0VOX0ZJTEVdLFxuICAgICAgICByb2xlQXJuOiBwcm9jZXNzLmVudltFTlZfUk9MRV9BUk5dLFxuICAgICAgICByb2xlU2Vzc2lvbk5hbWU6IHByb2Nlc3MuZW52WydBV1NfUk9MRV9TRVNTSU9OX05BTUUnXVxuICAgICAgfV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcmFtcyBmcm9tIHNoYXJlZCBjb25maWcgdmFyaWFibGVzXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFyYW1zRnJvbVNoYXJlZENvbmZpZzogZnVuY3Rpb24gZ2V0UGFyYW1zRnJvbVNoYXJlZENvbmZpZygpIHtcbiAgICB2YXIgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoaW5pTG9hZGVyKTtcbiAgICB2YXIgcHJvZmlsZU5hbWUgPSBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZTtcbiAgICB2YXIgcHJvZmlsZSA9IHByb2ZpbGVzW3Byb2ZpbGVOYW1lXSB8fCB7fTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhwcm9maWxlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ1Byb2ZpbGUgJyArIHByb2ZpbGVOYW1lICsgJyBub3QgZm91bmQnKSxcbiAgICAgICAgeyBjb2RlOiAnVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zQXJyYXkgPSBbXTtcblxuICAgIHdoaWxlICghcHJvZmlsZVsnd2ViX2lkZW50aXR5X3Rva2VuX2ZpbGUnXSAmJiBwcm9maWxlWydzb3VyY2VfcHJvZmlsZSddKSB7XG4gICAgICBwYXJhbXNBcnJheS51bnNoaWZ0KHtcbiAgICAgICAgcm9sZUFybjogcHJvZmlsZVsncm9sZV9hcm4nXSxcbiAgICAgICAgcm9sZVNlc3Npb25OYW1lOiBwcm9maWxlWydyb2xlX3Nlc3Npb25fbmFtZSddXG4gICAgICB9KTtcbiAgICAgIHZhciBzb3VyY2VQcm9maWxlID0gcHJvZmlsZVsnc291cmNlX3Byb2ZpbGUnXTtcbiAgICAgIHByb2ZpbGUgPSBwcm9maWxlc1tzb3VyY2VQcm9maWxlXTtcbiAgICB9XG5cbiAgICBwYXJhbXNBcnJheS51bnNoaWZ0KHtcbiAgICAgIGVudlRva2VuRmlsZTogcHJvZmlsZVsnd2ViX2lkZW50aXR5X3Rva2VuX2ZpbGUnXSxcbiAgICAgIHJvbGVBcm46IHByb2ZpbGVbJ3JvbGVfYXJuJ10sXG4gICAgICByb2xlU2Vzc2lvbk5hbWU6IHByb2ZpbGVbJ3JvbGVfc2Vzc2lvbl9uYW1lJ11cbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbXNBcnJheTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgQVdTLkNyZWRlbnRpYWxzLmdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICovXG4gIGFzc3VtZVJvbGVDaGFpbmluZzogZnVuY3Rpb24gYXNzdW1lUm9sZUNoYWluaW5nKHBhcmFtc0FycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAocGFyYW1zQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLnNlcnZpY2UuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyYW1zID0gcGFyYW1zQXJyYXkuc2hpZnQoKTtcbiAgICAgIHNlbGYuc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMgPSBzZWxmLnNlcnZpY2UuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZShcbiAgICAgICAge1xuICAgICAgICAgIFJvbGVBcm46IHBhcmFtcy5yb2xlQXJuLFxuICAgICAgICAgIFJvbGVTZXNzaW9uTmFtZTogcGFyYW1zLnJvbGVTZXNzaW9uTmFtZSB8fCAndG9rZW4tZmlsZS13ZWItaWRlbnRpdHknXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICBzZWxmLmRhdGEgPSBudWxsO1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBzZWxmLmFzc3VtZVJvbGVDaGFpbmluZyhwYXJhbXNBcnJheSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgdmFyIHBhcmFtc0FycmF5ID0gc2VsZi5nZXRQYXJhbXNGcm9tRW52KCk7XG4gICAgICBpZiAoIXBhcmFtc0FycmF5KSB7XG4gICAgICAgIHBhcmFtc0FycmF5ID0gc2VsZi5nZXRQYXJhbXNGcm9tU2hhcmVkQ29uZmlnKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zQXJyYXkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHBhcmFtc0FycmF5LnNoaWZ0KCk7XG4gICAgICAgIHZhciBvaWRjVG9rZW4gPSBmcy5yZWFkRmlsZVN5bmMocGFyYW1zLmVudlRva2VuRmlsZSwge2VuY29kaW5nOiAnYXNjaWknfSk7XG4gICAgICAgIGlmICghc2VsZi5zZXJ2aWNlKSB7XG4gICAgICAgICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkoXG4gICAgICAgICAge1xuICAgICAgICAgICAgV2ViSWRlbnRpdHlUb2tlbjogb2lkY1Rva2VuLFxuICAgICAgICAgICAgUm9sZUFybjogcGFyYW1zLnJvbGVBcm4sXG4gICAgICAgICAgICBSb2xlU2Vzc2lvbk5hbWU6IHBhcmFtcy5yb2xlU2Vzc2lvbk5hbWUgfHwgJ3Rva2VuLWZpbGUtd2ViLWlkZW50aXR5J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgIHNlbGYuYXNzdW1lUm9sZUNoYWluaW5nKHBhcmFtc0FycmF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgIHZhciBzdHNDb25maWcgPSBBV1MudXRpbC5tZXJnZSh7fSwgdGhpcy5jbGllbnRDb25maWcpO1xuICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IFNUUyhzdHNDb25maWcpO1xuXG4gICAgICAvLyBSZXRyeSBpbiBjYXNlIG9mIElEUENvbW11bmljYXRpb25FcnJvckV4Y2VwdGlvbiBvciBJbnZhbGlkSWRlbnRpdHlUb2tlblxuICAgICAgdGhpcy5zZXJ2aWNlLnJldHJ5YWJsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdJRFBDb21tdW5pY2F0aW9uRXJyb3JFeGNlcHRpb24nIHx8IGVycm9yLmNvZGUgPT09ICdJbnZhbGlkSWRlbnRpdHlUb2tlbicpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gQVdTLlNlcnZpY2UucHJvdG90eXBlLnJldHJ5YWJsZUVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgV2ViIElkZW50aXR5IEZlZGVyYXRpb24gc3VwcG9ydC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvblxuICogcmVxdWlyZXMgYSBgUm9sZUFybmAgY29udGFpbmluZyB0aGUgQVJOIG9mIHRoZSBJQU0gdHJ1c3QgcG9saWN5IGZvciB0aGVcbiAqIGFwcGxpY2F0aW9uIGZvciB3aGljaCBjcmVkZW50aWFscyB3aWxsIGJlIGdpdmVuLiBJbiBhZGRpdGlvbiwgdGhlXG4gKiBgV2ViSWRlbnRpdHlUb2tlbmAgbXVzdCBiZSBzZXQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBpZGVudGl0eVxuICogcHJvdmlkZXIuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBgUm9sZUFybmAgYW5kIGBXZWJJZGVudGl0eVRva2VuYCB2YWx1ZXMuXG4gKlxuICogIyMgUmVmcmVzaGluZyBDcmVkZW50aWFscyBmcm9tIElkZW50aXR5IFNlcnZpY2VcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBBV1MgY3JlZGVudGlhbHMgZXhwaXJpbmcgYWZ0ZXIgYSBnaXZlbiBhbW91bnQgb2YgdGltZSwgdGhlXG4gKiBsb2dpbiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlciB3aWxsIGFsc28gZXhwaXJlLiBPbmNlIHRoaXMgdG9rZW5cbiAqIGV4cGlyZXMsIGl0IHdpbGwgbm90IGJlIHVzYWJsZSB0byByZWZyZXNoIEFXUyBjcmVkZW50aWFscywgYW5kIGFub3RoZXJcbiAqIHRva2VuIHdpbGwgYmUgbmVlZGVkLiBUaGUgU0RLIGRvZXMgbm90IG1hbmFnZSByZWZyZXNoaW5nIG9mIHRoZSB0b2tlbiB2YWx1ZSxcbiAqIGJ1dCB0aGlzIGNhbiBiZSBkb25lIHRocm91Z2ggYSBcInJlZnJlc2ggdG9rZW5cIiBzdXBwb3J0ZWQgYnkgbW9zdCBpZGVudGl0eVxuICogcHJvdmlkZXJzLiBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgZm9yIHJlZnJlc2hpbmdcbiAqIHRva2Vucy4gT25jZSB0aGUgcmVmcmVzaGVkIHRva2VuIGlzIGFjcXVpcmVkLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byB1cGRhdGVcbiAqIHRoaXMgbmV3IHRva2VuIGluIHRoZSBjcmVkZW50aWFscyBvYmplY3QncyB7cGFyYW1zfSBwcm9wZXJ0eS4gVGhlIGZvbGxvd2luZ1xuICogY29kZSB3aWxsIHVwZGF0ZSB0aGUgV2ViSWRlbnRpdHlUb2tlbiwgYXNzdW1pbmcgeW91IGhhdmUgcmV0cmlldmVkIGFuIHVwZGF0ZWRcbiAqIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMucGFyYW1zLldlYklkZW50aXR5VG9rZW4gPSB1cGRhdGVkVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBGdXR1cmUgY2FsbHMgdG8gYGNyZWRlbnRpYWxzLnJlZnJlc2goKWAgd2lsbCBub3cgdXNlIHRoZSBuZXcgdG9rZW4uXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1zXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIG1hcCBvZiBwYXJhbXMgcGFzc2VkIHRvXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLldlYklkZW50aXR5VG9rZW5gIHByb3BlcnR5LlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmV0dXJuIFttYXBdIHRoZSByYXcgZGF0YSByZXNwb25zZSBmcm9tIHRoZSBjYWxsIHRvXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGdldFxuICogICAgIGFjY2VzcyB0byBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3BvbnNlLlxuICovXG5BV1MuV2ViSWRlbnRpdHlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQHBhcmFtIChzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5KVxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1dlYklkZW50aXR5JyxcbiAgICogICAgIFdlYklkZW50aXR5VG9rZW46ICdBQkNERUZHSElKS0xNTk9QJywgLy8gdG9rZW4gZnJvbSBpZGVudGl0eSBzZXJ2aWNlXG4gICAqICAgICBSb2xlU2Vzc2lvbk5hbWU6ICd3ZWInIC8vIG9wdGlvbmFsIG5hbWUsIGRlZmF1bHRzIHRvIHdlYi1pZGVudGl0eVxuICAgKiAgIH0sIHtcbiAgICogICAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIEFXUy5TVFMgc2VydmljZSBjbGllbnRcbiAgICogICAgIC8vIGlmIGNvbmZpZ3VyYXRpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBwdWxsZWQgZnJvbSBBV1MuY29uZmlnXG4gICAqXG4gICAqICAgICAvLyBzcGVjaWZ5IHRpbWVvdXQgb3B0aW9uc1xuICAgKiAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICogICAgICAgdGltZW91dDogMTAwXG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5XG4gICAqIEBzZWUgQVdTLkNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFdlYklkZW50aXR5Q3JlZGVudGlhbHMocGFyYW1zLCBjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSA9IHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSB8fCAnd2ViLWlkZW50aXR5JztcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuX2NsaWVudENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY2xpZW50Q29uZmlnIHx8IHt9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jb2FsZXNjZVJlZnJlc2goY2FsbGJhY2sgfHwgQVdTLnV0aWwuZm4uY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlKSB7XG4gICAgICB2YXIgc3RzQ29uZmlnID0gQVdTLnV0aWwubWVyZ2Uoe30sIHRoaXMuX2NsaWVudENvbmZpZyk7XG4gICAgICBzdHNDb25maWcucGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBuZXcgU1RTKHN0c0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzID0gWydBV1NfRU5BQkxFX0VORFBPSU5UX0RJU0NPVkVSWScsICdBV1NfRU5EUE9JTlRfRElTQ09WRVJZX0VOQUJMRUQnXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBrZXkgKGV4Y2VwdCByZXNvdXJjZXMgYW5kIG9wZXJhdGlvbiBwYXJ0KSB0byBpbmRleCB0aGUgZW5kcG9pbnRzIGluIHRoZSBjYWNoZVxuICogSWYgaW5wdXQgc2hhcGUgaGFzIGVuZHBvaW50ZGlzY292ZXJ5aWQgdHJhaXQgdGhlbiB1c2VcbiAqICAgYWNjZXNzS2V5ICsgb3BlcmF0aW9uICsgcmVzb3VyY2VzICsgcmVnaW9uICsgc2VydmljZSBhcyBjYWNoZSBrZXlcbiAqIElmIGlucHV0IHNoYXBlIGRvZXNuJ3QgaGF2ZSBlbmRwb2ludGRpc2NvdmVyeWlkIHRyYWl0IHRoZW4gdXNlXG4gKiAgIGFjY2Vzc0tleSArIHJlZ2lvbiArIHNlcnZpY2UgYXMgY2FjaGUga2V5XG4gKiBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dIG9iamVjdCB3aXRoIGtleXMgdG8gaW5kZXggZW5kcG9pbnRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENhY2hlS2V5KHJlcXVlc3QpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gIHZhciBhcGkgPSBzZXJ2aWNlLmFwaSB8fCB7fTtcbiAgdmFyIG9wZXJhdGlvbnMgPSBhcGkub3BlcmF0aW9ucztcbiAgdmFyIGlkZW50aWZpZXJzID0ge307XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5yZWdpb24pIHtcbiAgICBpZGVudGlmaWVycy5yZWdpb24gPSBzZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gIH1cbiAgaWYgKGFwaS5zZXJ2aWNlSWQpIHtcbiAgICBpZGVudGlmaWVycy5zZXJ2aWNlSWQgPSBhcGkuc2VydmljZUlkO1xuICB9XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCkge1xuICAgIGlkZW50aWZpZXJzLmFjY2Vzc0tleUlkID0gc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMoKS5cbiAqIExvb2tzIGZvciByZXF1aXJlZCBzdHJpbmcgaW5wdXQgbWVtYmVycyB0aGF0IGhhdmUgJ2VuZHBvaW50ZGlzY292ZXJ5aWQnIHRyYWl0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnNIZWxwZXIocmVzdWx0LCBwYXJhbXMsIHNoYXBlKSB7XG4gIGlmICghc2hhcGUgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSByZXR1cm47XG4gIGlmIChzaGFwZS50eXBlID09PSAnc3RydWN0dXJlJyAmJiBzaGFwZS5yZXF1aXJlZCAmJiBzaGFwZS5yZXF1aXJlZC5sZW5ndGggPiAwKSB7XG4gICAgdXRpbC5hcnJheUVhY2goc2hhcGUucmVxdWlyZWQsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgICBpZiAobWVtYmVyU2hhcGUuZW5kcG9pbnREaXNjb3ZlcnlJZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYXRpb25OYW1lID0gbWVtYmVyU2hhcGUuaXNMb2NhdGlvbk5hbWUgPyBtZW1iZXJTaGFwZS5uYW1lIDogbmFtZTtcbiAgICAgICAgcmVzdWx0W2xvY2F0aW9uTmFtZV0gPSBTdHJpbmcocGFyYW1zW25hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnNIZWxwZXIocmVzdWx0LCBwYXJhbXNbbmFtZV0sIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBjdXN0b20gaWRlbnRpZmllcnMgZm9yIGNhY2hlIGtleS5cbiAqIElkZW50aWZpZXMgY3VzdG9tIGlkZW50aWZpZXJzIGJ5IGNoZWNraW5nIGVhY2ggc2hhcGUncyBgZW5kcG9pbnREaXNjb3ZlcnlJZGAgdHJhaXQuXG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSBbb2JqZWN0XSBpbnB1dCBzaGFwZSBvZiB0aGUgZ2l2ZW4gb3BlcmF0aW9uJ3MgYXBpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBzaGFwZSkge1xuICB2YXIgaWRlbnRpZmllcnMgPSB7fTtcbiAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihpZGVudGlmaWVycywgcmVxdWVzdC5wYXJhbXMsIHNoYXBlKTtcbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG4vKipcbiAqIENhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbiB3aGVuIGl0J3Mgb3B0aW9uYWwuXG4gKiBXaGVuIGVuZHBvaW50IGlzIGF2YWlsYWJsZSBpbiBjYWNoZSB0aGVuIHVzZSB0aGUgY2FjaGVkIGVuZHBvaW50cy4gSWYgZW5kcG9pbnRzXG4gKiBhcmUgdW5hdmFpbGFibGUgdGhlbiB1c2UgcmVnaW9uYWwgZW5kcG9pbnRzIGFuZCBjYWxsIGVuZHBvaW50IGRpc2NvdmVyeSBvcGVyYXRpb25cbiAqIGFzeW5jaHJvbm91c2x5LiBUaGlzIGlzIHR1cm5lZCBvZmYgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0KSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICB2YXIgYXBpID0gc2VydmljZS5hcGk7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IGFwaS5vcGVyYXRpb25zID8gYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgaW5wdXRTaGFwZSA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuaW5wdXQgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlkZW50aWZpZXJzID0gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBpbnB1dFNoYXBlKTtcbiAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgIGNhY2hlS2V5ID0gdXRpbC51cGRhdGUoY2FjaGVLZXksIGlkZW50aWZpZXJzKTtcbiAgICBpZiAob3BlcmF0aW9uTW9kZWwpIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLm5hbWU7XG4gIH1cbiAgdmFyIGVuZHBvaW50cyA9IEFXUy5lbmRwb2ludENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBlbmRwb2ludHNbMF0uQWRkcmVzcyA9PT0gJycpIHtcbiAgICAvL2VuZHBvaW50IG9wZXJhdGlvbiBpcyBiZWluZyBtYWRlIGJ1dCByZXNwb25zZSBub3QgeWV0IHJlY2VpdmVkXG4gICAgLy9vciBlbmRwb2ludCBvcGVyYXRpb24ganVzdCBmYWlsZWQgaW4gMSBtaW51dGVcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgLy9mb3VuZCBlbmRwb2ludCByZWNvcmQgZnJvbSBjYWNoZVxuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICB9IGVsc2Uge1xuICAgIC8vZW5kcG9pbnQgcmVjb3JkIG5vdCBpbiBjYWNoZSBvciBvdXRkYXRlZC4gbWFrZSBkaXNjb3Zlcnkgb3BlcmF0aW9uXG4gICAgdmFyIGVuZHBvaW50UmVxdWVzdCA9IHNlcnZpY2UubWFrZVJlcXVlc3QoYXBpLmVuZHBvaW50T3BlcmF0aW9uLCB7XG4gICAgICBPcGVyYXRpb246IG9wZXJhdGlvbk1vZGVsLm5hbWUsXG4gICAgICBJZGVudGlmaWVyczogaWRlbnRpZmllcnMsXG4gICAgfSk7XG4gICAgYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICBlbmRwb2ludFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3JldHJ5JywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuUkVUUllfQ0hFQ0spO1xuICAgIC8vcHV0IGluIGEgcGxhY2Vob2xkZXIgZm9yIGVuZHBvaW50cyBhbHJlYWR5IHJlcXVlc3RlZCwgcHJldmVudFxuICAgIC8vdG9vIG11Y2ggaW4tZmxpZ2h0IGNhbGxzXG4gICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBbe1xuICAgICAgQWRkcmVzczogJycsXG4gICAgICBDYWNoZVBlcmlvZEluTWludXRlczogMVxuICAgIH1dKTtcbiAgICBlbmRwb2ludFJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuRW5kcG9pbnRzKSB7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleSwgZGF0YS5FbmRwb2ludHMpO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBbe1xuICAgICAgICAgIEFkZHJlc3M6ICcnLFxuICAgICAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiAxIC8vbm90IHRvIG1ha2UgbW9yZSBlbmRwb2ludCBvcGVyYXRpb24gaW4gbmV4dCAxIG1pbnV0ZVxuICAgICAgICB9XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIHJlcXVlc3RRdWV1ZSA9IHt9O1xuXG4vKipcbiAqIENhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbiB3aGVuIGl0J3MgcmVxdWlyZWQuXG4gKiBXaGVuIGVuZHBvaW50IGlzIGF2YWlsYWJsZSBpbiBjYWNoZSB0aGVuIHVzZSBjYWNoZWQgb25lcy4gSWYgZW5kcG9pbnRzIGFyZVxuICogdW5hdmFpbGFibGUgdGhlbiBTREsgc2hvdWxkIGNhbGwgZW5kcG9pbnQgb3BlcmF0aW9uIHRoZW4gdXNlIHJldHVybmVkIG5ld1xuICogZW5kcG9pbnQgZm9yIHRoZSBhcGkgY2FsbC4gU0RLIHdpbGwgYXV0b21hdGljYWxseSBhdHRlbXB0IHRvIGRvIGVuZHBvaW50XG4gKiBkaXNjb3ZlcnkuIFRoaXMgaXMgdHVybmVkIG9mZiBieSBkZWZhdWx0XG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZTtcbiAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpO1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBhcGkub3BlcmF0aW9ucyA/IGFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGlucHV0U2hhcGUgPSBvcGVyYXRpb25Nb2RlbCA/IG9wZXJhdGlvbk1vZGVsLmlucHV0IDogdW5kZWZpbmVkO1xuXG4gIHZhciBpZGVudGlmaWVycyA9IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMocmVxdWVzdCwgaW5wdXRTaGFwZSk7XG4gIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KHJlcXVlc3QpO1xuICBpZiAoT2JqZWN0LmtleXMoaWRlbnRpZmllcnMpLmxlbmd0aCA+IDApIHtcbiAgICBjYWNoZUtleSA9IHV0aWwudXBkYXRlKGNhY2hlS2V5LCBpZGVudGlmaWVycyk7XG4gICAgaWYgKG9wZXJhdGlvbk1vZGVsKSBjYWNoZUtleS5vcGVyYXRpb24gPSBvcGVyYXRpb25Nb2RlbC5uYW1lO1xuICB9XG4gIHZhciBjYWNoZUtleVN0ciA9IEFXUy5FbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhjYWNoZUtleSk7XG4gIHZhciBlbmRwb2ludHMgPSBBV1MuZW5kcG9pbnRDYWNoZS5nZXQoY2FjaGVLZXlTdHIpOyAvL2VuZHBvaW50IGNhY2hlIGFsc28gYWNjZXB0cyBzdHJpbmcga2V5c1xuICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPT09IDEgJiYgZW5kcG9pbnRzWzBdLkFkZHJlc3MgPT09ICcnKSB7XG4gICAgLy9lbmRwb2ludCBvcGVyYXRpb24gaXMgYmVpbmcgbWFkZSBidXQgcmVzcG9uc2Ugbm90IHlldCByZWNlaXZlZFxuICAgIC8vcHVzaCByZXF1ZXN0IG9iamVjdCB0byBhIHBlbmRpbmcgcXVldWVcbiAgICBpZiAoIXJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0pIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0gPSBbXTtcbiAgICByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdLnB1c2goe3JlcXVlc3Q6IHJlcXVlc3QsIGNhbGxiYWNrOiBkb25lfSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGVuZHBvaW50cyAmJiBlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICAgIGRvbmUoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5kcG9pbnRSZXF1ZXN0ID0gc2VydmljZS5tYWtlUmVxdWVzdChhcGkuZW5kcG9pbnRPcGVyYXRpb24sIHtcbiAgICAgIE9wZXJhdGlvbjogb3BlcmF0aW9uTW9kZWwubmFtZSxcbiAgICAgIElkZW50aWZpZXJzOiBpZGVudGlmaWVycyxcbiAgICB9KTtcbiAgICBlbmRwb2ludFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUyk7XG4gICAgYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpO1xuXG4gICAgLy9wdXQgaW4gYSBwbGFjZWhvbGRlciBmb3IgZW5kcG9pbnRzIGFscmVhZHkgcmVxdWVzdGVkLCBwcmV2ZW50XG4gICAgLy90b28gbXVjaCBpbi1mbGlnaHQgY2FsbHNcbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXlTdHIsIFt7XG4gICAgICBBZGRyZXNzOiAnJyxcbiAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiA2MCAvL2xvbmctbGl2ZSBjYWNoZVxuICAgIH1dKTtcbiAgICBlbmRwb2ludFJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZS5lcnJvciA9IHV0aWwuZXJyb3IoZXJyLCB7IHJldHJ5YWJsZTogZmFsc2UgfSk7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG5cbiAgICAgICAgLy9mYWlsIGFsbCB0aGUgcGVuZGluZyByZXF1ZXN0cyBpbiBiYXRjaFxuICAgICAgICBpZiAocmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdO1xuICAgICAgICAgIHV0aWwuYXJyYXlFYWNoKHBlbmRpbmdSZXF1ZXN0cywgZnVuY3Rpb24ocmVxdWVzdENvbnRleHQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LnJlcXVlc3QucmVzcG9uc2UuZXJyb3IgPSB1dGlsLmVycm9yKGVyciwgeyByZXRyeWFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleVN0ciwgZGF0YS5FbmRwb2ludHMpO1xuICAgICAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KGRhdGEuRW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuXG4gICAgICAgIC8vdXBkYXRlIHRoZSBlbmRwb2ludCBmb3IgYWxsIHRoZSBwZW5kaW5nIHJlcXVlc3RzIGluIGJhdGNoXG4gICAgICAgIGlmIChyZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgICAgdXRpbC5hcnJheUVhY2gocGVuZGluZ1JlcXVlc3RzLCBmdW5jdGlvbihyZXF1ZXN0Q29udGV4dCkge1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQucmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChkYXRhLkVuZHBvaW50c1swXS5BZGRyZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LmNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIGFkZCBhcGkgdmVyc2lvbiBoZWFkZXIgdG8gZW5kcG9pbnQgb3BlcmF0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpIHtcbiAgdmFyIGFwaSA9IGVuZHBvaW50UmVxdWVzdC5zZXJ2aWNlLmFwaTtcbiAgdmFyIGFwaVZlcnNpb24gPSBhcGkuYXBpVmVyc2lvbjtcbiAgaWYgKGFwaVZlcnNpb24gJiYgIWVuZHBvaW50UmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWyd4LWFtei1hcGktdmVyc2lvbiddKSB7XG4gICAgZW5kcG9pbnRSZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LWFwaS12ZXJzaW9uJ10gPSBhcGlWZXJzaW9uO1xuICB9XG59XG5cbi8qKlxuICogSWYgYXBpIGNhbGwgZ2V0cyBpbnZhbGlkIGVuZHBvaW50IGV4Y2VwdGlvbiwgU0RLIHNob3VsZCBhdHRlbXB0IHRvIHJlbW92ZSB0aGUgaW52YWxpZFxuICogZW5kcG9pbnQgZnJvbSBjYWNoZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnRzKHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICB2YXIgaHR0cFJlc3BvbnNlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlO1xuICBpZiAoZXJyb3IgJiZcbiAgICAoZXJyb3IuY29kZSA9PT0gJ0ludmFsaWRFbmRwb2ludEV4Y2VwdGlvbicgfHwgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyMSlcbiAgKSB7XG4gICAgdmFyIHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb25zID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICAgIHZhciBpbnB1dFNoYXBlID0gb3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0gPyBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXS5pbnB1dCA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaWRlbnRpZmllcnMgPSBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIGlucHV0U2hhcGUpO1xuICAgIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KHJlcXVlc3QpO1xuICAgIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgICAgY2FjaGVLZXkgPSB1dGlsLnVwZGF0ZShjYWNoZUtleSwgaWRlbnRpZmllcnMpO1xuICAgICAgaWYgKG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dKSBjYWNoZUtleS5vcGVyYXRpb24gPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXS5uYW1lO1xuICAgIH1cbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5yZW1vdmUoY2FjaGVLZXkpO1xuICB9XG59XG5cbi8qKlxuICogSWYgZW5kcG9pbnQgaXMgZXhwbGljaXRseSBjb25maWd1cmVkLCBTREsgc2hvdWxkIG5vdCBkbyBlbmRwb2ludCBkaXNjb3ZlcnkgaW4gYW55dGltZS5cbiAqIEBwYXJhbSBbb2JqZWN0XSBjbGllbnQgU2VydmljZSBjbGllbnQgb2JqZWN0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0N1c3RvbUVuZHBvaW50KGNsaWVudCkge1xuICAvL2lmIHNldCBlbmRwb2ludCBpcyBzZXQgZm9yIHNwZWNpZmljIGNsaWVudCwgZW5hYmxlIGVuZHBvaW50IGRpc2NvdmVyeSB3aWxsIHJhaXNlIGFuIGVycm9yLlxuICBpZiAoY2xpZW50Ll9vcmlnaW5hbENvbmZpZyAmJiBjbGllbnQuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50ICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgbWVzc2FnZTogJ0N1c3RvbSBlbmRwb2ludCBpcyBzdXBwbGllZDsgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkIG11c3Qgbm90IGJlIHRydWUuJ1xuICAgIH0pO1xuICB9O1xuICB2YXIgc3ZjQ29uZmlnID0gQVdTLmNvbmZpZ1tjbGllbnQuc2VydmljZUlkZW50aWZpZXJdIHx8IHt9O1xuICByZXR1cm4gQm9vbGVhbihBV1MuY29uZmlnLmVuZHBvaW50IHx8IHN2Y0NvbmZpZy5lbmRwb2ludCB8fCAoY2xpZW50Ll9vcmlnaW5hbENvbmZpZyAmJiBjbGllbnQuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50KSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kodmFsdWUpIHtcbiAgcmV0dXJuIFsnZmFsc2UnLCAnMCddLmluZGV4T2YodmFsdWUpID49IDA7XG59XG5cbi8qKlxuICogSWYgZW5kcG9pbnQgZGlzY292ZXJ5IHNob3VsZCBwZXJmb3JtIGZvciB0aGlzIHJlcXVlc3Qgd2hlbiBubyBvcGVyYXRpb24gcmVxdWlyZXMgZW5kcG9pbnRcbiAqIGRpc2NvdmVyeSBmb3IgdGhlIGdpdmVuIHNlcnZpY2UuXG4gKiBTREsgcGVyZm9ybXMgY29uZmlnIHJlc29sdXRpb24gaW4gb3JkZXIgbGlrZSBiZWxvdzpcbiAqIDEuIElmIHNldCBpbiBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAqIDIuIElmIHNldCBpbiBlbnYgQVdTX0VOQUJMRV9FTkRQT0lOVF9ESVNDT1ZFUlkuXG4gKiAzLiBJZiBzZXQgaW4gc2hhcmVkIGluaSBjb25maWcgZmlsZSB3aXRoIGtleSAnZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQnLlxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3QgcmVxdWVzdCBvYmplY3QuXG4gKiBAcmV0dXJucyBbYm9vbGVhbnx1bmRlZmluZWRdIGlmIGVuZHBvaW50IGRpc2NvdmVyeSBjb25maWcgaXMgbm90IHNldCBpbiBhbnkgc291cmNlLCB0aGlzXG4gKiAgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlRW5kcG9pbnREaXNjb3ZlcnlDb25maWcocmVxdWVzdCkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZSB8fCB7fTtcbiAgaWYgKHNlcnZpY2UuY29uZmlnLmVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHNlcnZpY2UuY29uZmlnLmVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZDtcbiAgfVxuXG4gIC8vc2hhcmVkIGluaSBmaWxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5vZGVcbiAgLy9ub3QgdG8gY2hlY2sgZW52IGluIGJyb3dzZXJcbiAgaWYgKHV0aWwuaXNCcm93c2VyKCkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgYW55IG9mIHJlY29nbml6ZWQgZW5kcG9pbnQgZGlzY292ZXJ5IGNvbmZpZyBlbnYgaXMgc2V0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkRW52cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnYgPSBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzW2ldO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzcy5lbnYsIGVudikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudltlbnZdID09PSAnJyB8fCBwcm9jZXNzLmVudltlbnZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgIGNvZGU6ICdDb25maWd1cmF0aW9uRXhjZXB0aW9uJyxcbiAgICAgICAgICBtZXNzYWdlOiAnZW52aXJvbm1lbnRhbCB2YXJpYWJsZSAnICsgZW52ICsgJyBjYW5ub3QgYmUgc2V0IHRvIG5vdGhpbmcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFpc0ZhbHN5KHByb2Nlc3MuZW52W2Vudl0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb25maWdGaWxlID0ge307XG4gIHRyeSB7XG4gICAgY29uZmlnRmlsZSA9IEFXUy51dGlsLmluaUxvYWRlciA/IEFXUy51dGlsLmluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICBpc0NvbmZpZzogdHJ1ZSxcbiAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudltBV1MudXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgIH0pIDoge307XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHZhciBzaGFyZWRGaWxlQ29uZmlnID0gY29uZmlnRmlsZVtcbiAgICBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZVxuICBdIHx8IHt9O1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNoYXJlZEZpbGVDb25maWcsICdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCcpKSB7XG4gICAgaWYgKHNoYXJlZEZpbGVDb25maWcuZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdjb25maWcgZmlsZSBlbnRyeSBcXCdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZFxcJyBjYW5ub3QgYmUgc2V0IHRvIG5vdGhpbmcnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICFpc0ZhbHN5KHNoYXJlZEZpbGVDb25maWcuZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogYXR0YWNoIGVuZHBvaW50IGRpc2NvdmVyeSBsb2dpYyB0byByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QsIGRvbmUpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2UgfHwge307XG4gIGlmIChoYXNDdXN0b21FbmRwb2ludChzZXJ2aWNlKSB8fCByZXF1ZXN0LmlzUHJlc2lnbmVkKCkpIHJldHVybiBkb25lKCk7XG5cbiAgdmFyIG9wZXJhdGlvbnMgPSBzZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgdmFyIGlzRW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuZW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCA6ICdOVUxMJztcbiAgdmFyIGlzRW5hYmxlZCA9IHJlc29sdmVFbmRwb2ludERpc2NvdmVyeUNvbmZpZyhyZXF1ZXN0KTtcbiAgdmFyIGhhc1JlcXVpcmVkRW5kcG9pbnREaXNjb3ZlcnkgPSBzZXJ2aWNlLmFwaS5oYXNSZXF1aXJlZEVuZHBvaW50RGlzY292ZXJ5O1xuICBpZiAoaXNFbmFibGVkIHx8IGhhc1JlcXVpcmVkRW5kcG9pbnREaXNjb3ZlcnkpIHtcbiAgICAvLyBPbmNlIGEgY3VzdG9tZXIgZW5hYmxlcyBlbmRwb2ludCBkaXNjb3ZlcnksIHRoZSBTREsgc2hvdWxkIHN0YXJ0IGFwcGVuZGluZ1xuICAgIC8vIHRoZSBzdHJpbmcgZW5kcG9pbnQtZGlzY292ZXJ5IHRvIHRoZSB1c2VyLWFnZW50IG9uIGFsbCByZXF1ZXN0cy5cbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdlbmRwb2ludC1kaXNjb3ZlcnknKTtcbiAgfVxuICBzd2l0Y2ggKGlzRW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCkge1xuICAgIGNhc2UgJ09QVElPTkFMJzpcbiAgICAgIGlmIChpc0VuYWJsZWQgfHwgaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSkge1xuICAgICAgICAvLyBGb3IgYSBnaXZlbiBzZXJ2aWNlOyBpZiBhdCBsZWFzdCBvbmUgb3BlcmF0aW9uIHJlcXVpcmVzIGVuZHBvaW50IGRpc2NvdmVyeSB0aGVuIHRoZSBTREsgbXVzdCBlbmFibGUgZW5kcG9pbnQgZGlzY292ZXJ5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgZm9yIGFsbCBvcGVyYXRpb25zIG9mIHRoYXQgc2VydmljZSwgaW5jbHVkaW5nIG9wZXJhdGlvbnMgd2hlcmUgZW5kcG9pbnQgZGlzY292ZXJ5IGlzIG9wdGlvbmFsLlxuICAgICAgICBvcHRpb25hbERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCk7XG4gICAgICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignSU5WQUxJREFURV9DQUNIRURfRU5EUE9JTlRTJywgJ2V4dHJhY3RFcnJvcicsIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMpO1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkVRVUlSRUQnOlxuICAgICAgaWYgKGlzRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gRm9yIGEgZ2l2ZW4gb3BlcmF0aW9uOyBpZiBlbmRwb2ludCBkaXNjb3ZlcnkgaXMgcmVxdWlyZWQgYW5kIGl0IGhhcyBiZWVuIGRpc2FibGVkIG9uIHRoZSBTREsgY2xpZW50LFxuICAgICAgICAvLyB0aGVuIHRoZSBTREsgbXVzdCByZXR1cm4gYSBjbGVhciBhbmQgYWN0aW9uYWJsZSBleGNlcHRpb24uXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2UuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFbmRwb2ludCBEaXNjb3ZlcnkgaXMgZGlzYWJsZWQgYnV0ICcgKyBzZXJ2aWNlLmFwaS5jbGFzc05hbWUgKyAnLicgKyByZXF1ZXN0Lm9wZXJhdGlvbiArXG4gICAgICAgICAgICAgICAgICAgICcoKSByZXF1aXJlcyBpdC4gUGxlYXNlIGNoZWNrIHlvdXIgY29uZmlndXJhdGlvbnMuJ1xuICAgICAgICB9KTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignSU5WQUxJREFURV9DQUNIRURfRU5EUE9JTlRTJywgJ2V4dHJhY3RFcnJvcicsIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMpO1xuICAgICAgcmVxdWlyZWREaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QsIGRvbmUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTlVMTCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGRvbmUoKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkaXNjb3ZlckVuZHBvaW50OiBkaXNjb3ZlckVuZHBvaW50LFxuICByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQ6IHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludCxcbiAgb3B0aW9uYWxEaXNjb3ZlckVuZHBvaW50OiBvcHRpb25hbERpc2NvdmVyRW5kcG9pbnQsXG4gIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnM6IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMsXG4gIGdldENhY2hlS2V5OiBnZXRDYWNoZUtleSxcbiAgaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50OiBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnRzLFxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IEFXUy51dGlsO1xudmFyIHR5cGVPZiA9IHJlcXVpcmUoJy4vdHlwZXMnKS50eXBlT2Y7XG52YXIgRHluYW1vREJTZXQgPSByZXF1aXJlKCcuL3NldCcpO1xudmFyIE51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9udW1iZXJWYWx1ZScpO1xuXG5BV1MuRHluYW1vREIuQ29udmVydGVyID0ge1xuICAvKipcbiAgICogQ29udmVydCBhIEphdmFTY3JpcHQgdmFsdWUgdG8gaXRzIGVxdWl2YWxlbnQgRHluYW1vREIgQXR0cmlidXRlVmFsdWUgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBbYW55XSBUaGUgZGF0YSB0byBjb252ZXJ0IHRvIGEgRHluYW1vREIgQXR0cmlidXRlVmFsdWVcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF1cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbnZlcnRFbXB0eVZhbHVlcyBbQm9vbGVhbl0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnQgZW1wdHkgc3RyaW5ncywgYmxvYnMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzZXRzIHRvIGBudWxsYFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgd3JhcE51bWJlcnMgW0Jvb2xlYW5dICBXaGV0aGVyIHRvIHJldHVybiBudW1iZXJzIGFzIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyVmFsdWUgb2JqZWN0IGluc3RlYWQgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGluZyB0aGVtIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuIFRoaXMgYWxsb3dzIGZvciB0aGUgc2FmZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZC10cmlwIHRyYW5zcG9ydCBvZiBudW1iZXJzIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyeSBzaXplLlxuICAgKiBAcmV0dXJuIFttYXBdIEFuIG9iamVjdCBpbiB0aGUgQW1hem9uIER5bmFtb0RCIEF0dHJpYnV0ZVZhbHVlIGZvcm1hdFxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi5Db252ZXJ0ZXIubWFyc2hhbGwgQVdTLkR5bmFtb0RCLkNvbnZlcnRlci5tYXJzaGFsbCB0b1xuICAgKiAgICBjb252ZXJ0IGVudGlyZSByZWNvcmRzIChyYXRoZXIgdGhhbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMpXG4gICAqL1xuICBpbnB1dDogZnVuY3Rpb24gY29udmVydElucHV0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdHlwZSA9IHR5cGVPZihkYXRhKTtcbiAgICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHJldHVybiBmb3JtYXRNYXAoZGF0YSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgICByZXR1cm4gZm9ybWF0TGlzdChkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdTZXQnKSB7XG4gICAgICByZXR1cm4gZm9ybWF0U2V0KGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiBvcHRpb25zLmNvbnZlcnRFbXB0eVZhbHVlcykge1xuICAgICAgICByZXR1cm4gY29udmVydElucHV0KG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgUzogZGF0YSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicgfHwgdHlwZSA9PT0gJ051bWJlclZhbHVlJykge1xuICAgICAgcmV0dXJuIHsgTjogZGF0YS50b1N0cmluZygpIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIG9wdGlvbnMuY29udmVydEVtcHR5VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0SW5wdXQobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBCOiBkYXRhIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB7IEJPT0w6IGRhdGEgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudWxsJykge1xuICAgICAgcmV0dXJuIHsgTlVMTDogdHJ1ZSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZSAhPT0gJ0Z1bmN0aW9uJykge1xuICAgICAgLy8gdGhpcyB2YWx1ZSBoYXMgYSBjdXN0b20gY29uc3RydWN0b3JcbiAgICAgIHJldHVybiBmb3JtYXRNYXAoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgSmF2YVNjcmlwdCBvYmplY3QgaW50byBhIER5bmFtb0RCIHJlY29yZC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgW2FueV0gVGhlIGRhdGEgdG8gY29udmVydCB0byBhIER5bmFtb0RCIHJlY29yZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXVxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29udmVydEVtcHR5VmFsdWVzIFtCb29sZWFuXSBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydCBlbXB0eSBzdHJpbmdzLCBibG9icyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHNldHMgdG8gYG51bGxgXG4gICAqIEBvcHRpb24gb3B0aW9ucyB3cmFwTnVtYmVycyBbQm9vbGVhbl0gIFdoZXRoZXIgdG8gcmV0dXJuIG51bWJlcnMgYXMgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXJWYWx1ZSBvYmplY3QgaW5zdGVhZCBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0aW5nIHRoZW0gdG8gbmF0aXZlIEphdmFTY3JpcHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycy4gVGhpcyBhbGxvd3MgZm9yIHRoZSBzYWZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kLXRyaXAgdHJhbnNwb3J0IG9mIG51bWJlcnMgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJiaXRyYXJ5IHNpemUuXG4gICAqXG4gICAqIEByZXR1cm4gW21hcF0gQW4gb2JqZWN0IGluIHRoZSBEeW5hbW9EQiByZWNvcmQgZm9ybWF0LlxuICAgKlxuICAgKiBAZXhhbXBsZSBDb252ZXJ0IGEgSmF2YVNjcmlwdCBvYmplY3QgaW50byBhIER5bmFtb0RCIHJlY29yZFxuICAgKiAgdmFyIG1hcnNoYWxsZWQgPSBBV1MuRHluYW1vREIuQ29udmVydGVyLm1hcnNoYWxsKHtcbiAgICogICAgc3RyaW5nOiAnZm9vJyxcbiAgICogICAgbGlzdDogWydmaXp6JywgJ2J1enonLCAncG9wJ10sXG4gICAqICAgIG1hcDoge1xuICAgKiAgICAgIG5lc3RlZE1hcDoge1xuICAgKiAgICAgICAga2V5OiAndmFsdWUnLFxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgbnVtYmVyOiAxMjMsXG4gICAqICAgIG51bGxWYWx1ZTogbnVsbCxcbiAgICogICAgYm9vbFZhbHVlOiB0cnVlLFxuICAgKiAgICBzdHJpbmdTZXQ6IG5ldyBEeW5hbW9EQlNldChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gICAqICB9KTtcbiAgICovXG4gIG1hcnNoYWxsOiBmdW5jdGlvbiBtYXJzaGFsbEl0ZW0oZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBBV1MuRHluYW1vREIuQ29udmVydGVyLmlucHV0KGRhdGEsIG9wdGlvbnMpLk07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBEeW5hbW9EQiBBdHRyaWJ1dGVWYWx1ZSBvYmplY3QgdG8gaXRzIGVxdWl2YWxlbnQgSmF2YVNjcmlwdCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBbbWFwXSBBbiBvYmplY3QgaW4gdGhlIEFtYXpvbiBEeW5hbW9EQiBBdHRyaWJ1dGVWYWx1ZSBmb3JtYXRcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF1cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbnZlcnRFbXB0eVZhbHVlcyBbQm9vbGVhbl0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnQgZW1wdHkgc3RyaW5ncywgYmxvYnMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzZXRzIHRvIGBudWxsYFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgd3JhcE51bWJlcnMgW0Jvb2xlYW5dICBXaGV0aGVyIHRvIHJldHVybiBudW1iZXJzIGFzIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyVmFsdWUgb2JqZWN0IGluc3RlYWQgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGluZyB0aGVtIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuIFRoaXMgYWxsb3dzIGZvciB0aGUgc2FmZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZC10cmlwIHRyYW5zcG9ydCBvZiBudW1iZXJzIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyeSBzaXplLlxuICAgKlxuICAgKiBAcmV0dXJuIFtPYmplY3R8QXJyYXl8U3RyaW5nfE51bWJlcnxCb29sZWFufG51bGxdXG4gICAqXG4gICAqIEBzZWUgQVdTLkR5bmFtb0RCLkNvbnZlcnRlci51bm1hcnNoYWxsIEFXUy5EeW5hbW9EQi5Db252ZXJ0ZXIudW5tYXJzaGFsbCB0b1xuICAgKiAgICBjb252ZXJ0IGVudGlyZSByZWNvcmRzIChyYXRoZXIgdGhhbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMpXG4gICAqL1xuICBvdXRwdXQ6IGZ1bmN0aW9uIGNvbnZlcnRPdXRwdXQoZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBsaXN0LCBtYXAsIGk7XG4gICAgZm9yICh2YXIgdHlwZSBpbiBkYXRhKSB7XG4gICAgICB2YXIgdmFsdWVzID0gZGF0YVt0eXBlXTtcbiAgICAgIGlmICh0eXBlID09PSAnTScpIHtcbiAgICAgICAgbWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICBtYXBba2V5XSA9IGNvbnZlcnRPdXRwdXQodmFsdWVzW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMJykge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2goY29udmVydE91dHB1dCh2YWx1ZXNbaV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1NTJykge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2godmFsdWVzW2ldICsgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1vREJTZXQobGlzdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOUycpIHtcbiAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGNvbnZlcnROdW1iZXIodmFsdWVzW2ldLCBvcHRpb25zLndyYXBOdW1iZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEeW5hbW9EQlNldChsaXN0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0JTJykge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2goQVdTLnV0aWwuYnVmZmVyLnRvQnVmZmVyKHZhbHVlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1vREJTZXQobGlzdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdTJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzICsgJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOJykge1xuICAgICAgICByZXR1cm4gY29udmVydE51bWJlcih2YWx1ZXMsIG9wdGlvbnMud3JhcE51bWJlcnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnQicpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuYnVmZmVyLnRvQnVmZmVyKHZhbHVlcyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdCT09MJykge1xuICAgICAgICByZXR1cm4gKHZhbHVlcyA9PT0gJ3RydWUnIHx8IHZhbHVlcyA9PT0gJ1RSVUUnIHx8IHZhbHVlcyA9PT0gdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOVUxMJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBEeW5hbW9EQiByZWNvcmQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBbYW55XSBUaGUgRHluYW1vREIgcmVjb3JkXG4gICAqIEBwYXJhbSBvcHRpb25zIFttYXBdXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb252ZXJ0RW1wdHlWYWx1ZXMgW0Jvb2xlYW5dIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0IGVtcHR5IHN0cmluZ3MsIGJsb2JzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2V0cyB0byBgbnVsbGBcbiAgICogQG9wdGlvbiBvcHRpb25zIHdyYXBOdW1iZXJzIFtCb29sZWFuXSAgV2hldGhlciB0byByZXR1cm4gbnVtYmVycyBhcyBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlclZhbHVlIG9iamVjdCBpbnN0ZWFkIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRpbmcgdGhlbSB0byBuYXRpdmUgSmF2YVNjcmlwdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLiBUaGlzIGFsbG93cyBmb3IgdGhlIHNhZmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQtdHJpcCB0cmFuc3BvcnQgb2YgbnVtYmVycyBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmJpdHJhcnkgc2l6ZS5cbiAgICpcbiAgICogQHJldHVybiBbbWFwXSBBbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBoYXZlIGJlZW4gY29udmVydGVkIGZyb21cbiAgICogICAgRHluYW1vREIncyBBdHRyaWJ1dGVWYWx1ZSBmb3JtYXQgaW50byB0aGVpciBjb3JyZXNwb25kaW5nIG5hdGl2ZVxuICAgKiAgICBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBDb252ZXJ0IGEgcmVjb3JkIHJlY2VpdmVkIGZyb20gYSBEeW5hbW9EQiBzdHJlYW1cbiAgICogIHZhciB1bm1hcnNoYWxsZWQgPSBBV1MuRHluYW1vREIuQ29udmVydGVyLnVubWFyc2hhbGwoe1xuICAgKiAgICBzdHJpbmc6IHtTOiAnZm9vJ30sXG4gICAqICAgIGxpc3Q6IHtMOiBbe1M6ICdmaXp6J30sIHtTOiAnYnV6eid9LCB7UzogJ3BvcCd9XX0sXG4gICAqICAgIG1hcDoge1xuICAgKiAgICAgIE06IHtcbiAgICogICAgICAgIG5lc3RlZE1hcDoge1xuICAgKiAgICAgICAgICBNOiB7XG4gICAqICAgICAgICAgICAga2V5OiB7UzogJ3ZhbHVlJ31cbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgbnVtYmVyOiB7TjogJzEyMyd9LFxuICAgKiAgICBudWxsVmFsdWU6IHtOVUxMOiB0cnVlfSxcbiAgICogICAgYm9vbFZhbHVlOiB7Qk9PTDogdHJ1ZX1cbiAgICogIH0pO1xuICAgKi9cbiAgdW5tYXJzaGFsbDogZnVuY3Rpb24gdW5tYXJzaGFsbChkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFXUy5EeW5hbW9EQi5Db252ZXJ0ZXIub3V0cHV0KHtNOiBkYXRhfSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcGFyYW0gZGF0YSBbQXJyYXldXG4gKiBAcGFyYW0gb3B0aW9ucyBbbWFwXVxuICovXG5mdW5jdGlvbiBmb3JtYXRMaXN0KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpc3QgPSB7TDogW119O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0WydMJ10ucHVzaChBV1MuRHluYW1vREIuQ29udmVydGVyLmlucHV0KGRhdGFbaV0sIG9wdGlvbnMpKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXVxuICogQHBhcmFtIHdyYXBOdW1iZXJzIFtCb29sZWFuXVxuICovXG5mdW5jdGlvbiBjb252ZXJ0TnVtYmVyKHZhbHVlLCB3cmFwTnVtYmVycykge1xuICByZXR1cm4gd3JhcE51bWJlcnMgPyBuZXcgTnVtYmVyVmFsdWUodmFsdWUpIDogTnVtYmVyKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwYXJhbSBkYXRhIFttYXBdXG4gKiBAcGFyYW0gb3B0aW9ucyBbbWFwXVxuICovXG5mdW5jdGlvbiBmb3JtYXRNYXAoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgbWFwID0ge006IHt9fTtcbiAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICB2YXIgZm9ybWF0dGVkID0gQVdTLkR5bmFtb0RCLkNvbnZlcnRlci5pbnB1dChkYXRhW2tleV0sIG9wdGlvbnMpO1xuICAgIGlmIChmb3JtYXR0ZWQgIT09IHZvaWQgMCkge1xuICAgICAgbWFwWydNJ11ba2V5XSA9IGZvcm1hdHRlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2V0KGRhdGEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB2YWx1ZXMgPSBkYXRhLnZhbHVlcztcbiAgaWYgKG9wdGlvbnMuY29udmVydEVtcHR5VmFsdWVzKSB7XG4gICAgdmFsdWVzID0gZmlsdGVyRW1wdHlTZXRWYWx1ZXMoZGF0YSk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBBV1MuRHluYW1vREIuQ29udmVydGVyLmlucHV0KG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXAgPSB7fTtcbiAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOiBtYXBbJ1NTJ10gPSB2YWx1ZXM7IGJyZWFrO1xuICAgIGNhc2UgJ0JpbmFyeSc6IG1hcFsnQlMnXSA9IHZhbHVlczsgYnJlYWs7XG4gICAgY2FzZSAnTnVtYmVyJzogbWFwWydOUyddID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckVtcHR5U2V0VmFsdWVzKHNldCkge1xuICAgIHZhciBub25FbXB0eVZhbHVlcyA9IFtdO1xuICAgIHZhciBwb3RlbnRpYWxseUVtcHR5VHlwZXMgPSB7XG4gICAgICAgIFN0cmluZzogdHJ1ZSxcbiAgICAgICAgQmluYXJ5OiB0cnVlLFxuICAgICAgICBOdW1iZXI6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAocG90ZW50aWFsbHlFbXB0eVR5cGVzW3NldC50eXBlXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZXQudmFsdWVzW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9uRW1wdHlWYWx1ZXMucHVzaChzZXQudmFsdWVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub25FbXB0eVZhbHVlcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnZhbHVlcztcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuRHluYW1vREIuQ29udmVydGVyO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBUcmFuc2xhdG9yID0gcmVxdWlyZSgnLi90cmFuc2xhdG9yJyk7XG52YXIgRHluYW1vREJTZXQgPSByZXF1aXJlKCcuL3NldCcpO1xuXG4vKipcbiAqIFRoZSBkb2N1bWVudCBjbGllbnQgc2ltcGxpZmllcyB3b3JraW5nIHdpdGggaXRlbXMgaW4gQW1hem9uIER5bmFtb0RCXG4gKiBieSBhYnN0cmFjdGluZyBhd2F5IHRoZSBub3Rpb24gb2YgYXR0cmlidXRlIHZhbHVlcy4gVGhpcyBhYnN0cmFjdGlvblxuICogYW5ub3RhdGVzIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzIHN1cHBsaWVkIGFzIGlucHV0IHBhcmFtZXRlcnMsIGFzIHdlbGxcbiAqIGFzIGNvbnZlcnRzIGFubm90YXRlZCByZXNwb25zZSBkYXRhIHRvIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICpcbiAqICMjIE1hcnNoYWxsaW5nIElucHV0IGFuZCBVbm1hcnNoYWxsaW5nIFJlc3BvbnNlIERhdGFcbiAqXG4gKiBUaGUgZG9jdW1lbnQgY2xpZW50IGFmZm9yZHMgZGV2ZWxvcGVycyB0aGUgdXNlIG9mIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzXG4gKiBpbnN0ZWFkIG9mIGBBdHRyaWJ1dGVWYWx1ZWBzIHRvIHNpbXBsaWZ5IHRoZSBKYXZhU2NyaXB0IGRldmVsb3BtZW50XG4gKiBleHBlcmllbmNlIHdpdGggQW1hem9uIER5bmFtb0RCLiBKYXZhU2NyaXB0IG9iamVjdHMgcGFzc2VkIGluIGFzIHBhcmFtZXRlcnNcbiAqIGFyZSBtYXJzaGFsbGVkIGludG8gYEF0dHJpYnV0ZVZhbHVlYCBzaGFwZXMgcmVxdWlyZWQgYnkgQW1hem9uIER5bmFtb0RCLlxuICogUmVzcG9uc2VzIGZyb20gRHluYW1vREIgYXJlIHVubWFyc2hhbGxlZCBpbnRvIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0c1xuICogYnkgdGhlIGBEb2N1bWVudENsaWVudGAuIFRoZSBgRG9jdW1lbnRDbGllbnRgLCBkb2VzIG5vdCBhY2NlcHRcbiAqIGBBdHRyaWJ1dGVWYWx1ZWBzIGluIGZhdm9yIG9mIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICpcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEphdmFTY3JpcHQgVHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IER5bmFtb0RCIEF0dHJpYnV0ZVZhbHVlIHxcbiAqIHw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFMgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQm9vbGVhbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJPT0wgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgbnVsbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5VTEwgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgT2JqZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE0gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQnVmZmVyLCBGaWxlLCBCbG9iLCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIGFuZCBKYXZhU2NyaXB0IHR5cGVkIGFycmF5cyB8IEIgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiAjIyBTdXBwb3J0IGZvciBTZXRzXG4gKlxuICogVGhlIGBEb2N1bWVudENsaWVudGAgb2ZmZXJzIGEgY29udmVuaWVudCB3YXkgdG8gY3JlYXRlIHNldHMgZnJvbVxuICogSmF2YVNjcmlwdCBBcnJheXMuIFRoZSB0eXBlIG9mIHNldCBpcyBpbmZlcnJlZCBmcm9tIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBpbiB0aGUgYXJyYXkuIER5bmFtb0RCIHN1cHBvcnRzIHN0cmluZywgbnVtYmVyLCBhbmQgYmluYXJ5IHNldHMuIFRvXG4gKiBsZWFybiBtb3JlIGFib3V0IHN1cHBvcnRlZCB0eXBlcyBzZWUgdGhlXG4gKiBbQW1hem9uIER5bmFtb0RCIERhdGEgTW9kZWwgRG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vYW1hem9uZHluYW1vZGIvbGF0ZXN0L2RldmVsb3Blcmd1aWRlL0RhdGFNb2RlbC5odG1sKVxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIHtBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQuY3JlYXRlU2V0fVxuICpcbiAqL1xuQVdTLkR5bmFtb0RCLkRvY3VtZW50Q2xpZW50ID0gQVdTLnV0aWwuaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEeW5hbW9EQiBkb2N1bWVudCBjbGllbnQgd2l0aCBhIHNldCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbXMgW21hcF0gQW4gb3B0aW9uYWwgbWFwIG9mIHBhcmFtZXRlcnMgdG8gYmluZCB0byBldmVyeVxuICAgKiAgIHJlcXVlc3Qgc2VudCBieSB0aGlzIHNlcnZpY2Ugb2JqZWN0LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2VydmljZSBbQVdTLkR5bmFtb0RCXSBBbiBvcHRpb25hbCBwcmUtY29uZmlndXJlZCBpbnN0YW5jZVxuICAgKiAgb2YgdGhlIEFXUy5EeW5hbW9EQiBzZXJ2aWNlIG9iamVjdCB0byB1c2UgZm9yIHJlcXVlc3RzLiBUaGUgb2JqZWN0IG1heVxuICAgKiAgYm91bmQgcGFyYW1ldGVycyB1c2VkIGJ5IHRoZSBkb2N1bWVudCBjbGllbnQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb252ZXJ0RW1wdHlWYWx1ZXMgW0Jvb2xlYW5dIHNldCB0byB0cnVlIGlmIHlvdSB3b3VsZCBsaWtlXG4gICAqICB0aGUgZG9jdW1lbnQgY2xpZW50IHRvIGNvbnZlcnQgZW1wdHkgdmFsdWVzICgwLWxlbmd0aCBzdHJpbmdzLCBiaW5hcnlcbiAgICogIGJ1ZmZlcnMsIGFuZCBzZXRzKSB0byBiZSBjb252ZXJ0ZWQgdG8gTlVMTCB0eXBlcyB3aGVuIHBlcnNpc3RpbmcgdG9cbiAgICogIER5bmFtb0RCLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgd3JhcE51bWJlcnMgW0Jvb2xlYW5dIFNldCB0byB0cnVlIHRvIHJldHVybiBudW1iZXJzIGFzIGFcbiAgICogIE51bWJlclZhbHVlIG9iamVjdCBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgdGhlbSB0byBuYXRpdmUgSmF2YVNjcmlwdCBudW1iZXJzLlxuICAgKiAgVGhpcyBhbGxvd3MgZm9yIHRoZSBzYWZlIHJvdW5kLXRyaXAgdHJhbnNwb3J0IG9mIG51bWJlcnMgb2YgYXJiaXRyYXJ5IHNpemUuXG4gICAqIEBzZWUgQVdTLkR5bmFtb0RCLmNvbnN0cnVjdG9yXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gRG9jdW1lbnRDbGllbnQob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHNlbGYuY29uZmlndXJlKHNlbGYub3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlndXJlOiBmdW5jdGlvbiBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnNlcnZpY2UgPSBvcHRpb25zLnNlcnZpY2U7XG4gICAgc2VsZi5iaW5kU2VydmljZU9iamVjdChvcHRpb25zKTtcbiAgICBzZWxmLmF0dHJWYWx1ZSA9IG9wdGlvbnMuYXR0clZhbHVlID1cbiAgICAgIHNlbGYuc2VydmljZS5hcGkub3BlcmF0aW9ucy5wdXRJdGVtLmlucHV0Lm1lbWJlcnMuSXRlbS52YWx1ZS5zaGFwZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBiaW5kU2VydmljZU9iamVjdDogZnVuY3Rpb24gYmluZFNlcnZpY2VPYmplY3Qob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghc2VsZi5zZXJ2aWNlKSB7XG4gICAgICBzZWxmLnNlcnZpY2UgPSBuZXcgQVdTLkR5bmFtb0RCKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwuY29weShzZWxmLnNlcnZpY2UuY29uZmlnKTtcbiAgICAgIHNlbGYuc2VydmljZSA9IG5ldyBzZWxmLnNlcnZpY2UuY29uc3RydWN0b3IuX19zdXBlcl9fKGNvbmZpZyk7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcyA9XG4gICAgICAgIEFXUy51dGlsLm1lcmdlKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zIHx8IHt9LCBvcHRpb25zLnBhcmFtcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1ha2VTZXJ2aWNlUmVxdWVzdDogZnVuY3Rpb24ob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXF1ZXN0ID0gc2VsZi5zZXJ2aWNlW29wZXJhdGlvbl0ocGFyYW1zKTtcbiAgICBzZWxmLnNldHVwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBzZWxmLnNldHVwUmVzcG9uc2UocmVxdWVzdCk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2VydmljZUNsaWVudE9wZXJhdGlvbnNNYXA6IHtcbiAgICBiYXRjaEdldDogJ2JhdGNoR2V0SXRlbScsXG4gICAgYmF0Y2hXcml0ZTogJ2JhdGNoV3JpdGVJdGVtJyxcbiAgICBkZWxldGU6ICdkZWxldGVJdGVtJyxcbiAgICBnZXQ6ICdnZXRJdGVtJyxcbiAgICBwdXQ6ICdwdXRJdGVtJyxcbiAgICBxdWVyeTogJ3F1ZXJ5JyxcbiAgICBzY2FuOiAnc2NhbicsXG4gICAgdXBkYXRlOiAndXBkYXRlSXRlbScsXG4gICAgdHJhbnNhY3RHZXQ6ICd0cmFuc2FjdEdldEl0ZW1zJyxcbiAgICB0cmFuc2FjdFdyaXRlOiAndHJhbnNhY3RXcml0ZUl0ZW1zJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIG9mIG9uZSBvciBtb3JlIGl0ZW1zIGZyb20gb25lIG9yIG1vcmUgdGFibGVzXG4gICAqIGJ5IGRlbGVnYXRpbmcgdG8gYEFXUy5EeW5hbW9EQi5iYXRjaEdldEl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIuYmF0Y2hHZXRJdGVtfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi5iYXRjaEdldEl0ZW1cbiAgICogQGV4YW1wbGUgR2V0IGl0ZW1zIGZyb20gbXVsdGlwbGUgdGFibGVzXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBSZXF1ZXN0SXRlbXM6IHtcbiAgICogICAgICAnVGFibGUtMSc6IHtcbiAgICogICAgICAgIEtleXM6IFtcbiAgICogICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBIYXNoS2V5OiAnaGFza2V5JyxcbiAgICogICAgICAgICAgICAgTnVtYmVyUmFuZ2VLZXk6IDFcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICAgXVxuICAgKiAgICAgIH0sXG4gICAqICAgICAgJ1RhYmxlLTInOiB7XG4gICAqICAgICAgICBLZXlzOiBbXG4gICAqICAgICAgICAgIHsgZm9vOiAnYmFyJyB9LFxuICAgKiAgICAgICAgXVxuICAgKiAgICAgIH1cbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LmJhdGNoR2V0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIGJhdGNoR2V0OiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMuc2VydmljZUNsaWVudE9wZXJhdGlvbnNNYXBbJ2JhdGNoR2V0J107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1dHMgb3IgZGVsZXRlcyBtdWx0aXBsZSBpdGVtcyBpbiBvbmUgb3IgbW9yZSB0YWJsZXMgYnkgZGVsZWdhdGluZ1xuICAgKiB0byBgQVdTLkR5bmFtb0RCLmJhdGNoV3JpdGVJdGVtKClgLlxuICAgKlxuICAgKiBTdXBwbHkgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB7QVdTLkR5bmFtb0RCLmJhdGNoV3JpdGVJdGVtfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi5iYXRjaFdyaXRlSXRlbVxuICAgKiBAZXhhbXBsZSBXcml0ZSB0byBhbmQgZGVsZXRlIGZyb20gYSB0YWJsZVxuICAgKiAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgUmVxdWVzdEl0ZW1zOiB7XG4gICAqICAgICAgJ1RhYmxlLTEnOiBbXG4gICAqICAgICAgICB7XG4gICAqICAgICAgICAgIERlbGV0ZVJlcXVlc3Q6IHtcbiAgICogICAgICAgICAgICBLZXk6IHsgSGFzaEtleTogJ3NvbWVLZXknIH1cbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICAgfSxcbiAgICogICAgICAgIHtcbiAgICogICAgICAgICAgUHV0UmVxdWVzdDoge1xuICAgKiAgICAgICAgICAgIEl0ZW06IHtcbiAgICogICAgICAgICAgICAgIEhhc2hLZXk6ICdhbm90aGVyS2V5JyxcbiAgICogICAgICAgICAgICAgIE51bUF0dHJpYnV0ZTogMSxcbiAgICogICAgICAgICAgICAgIEJvb2xBdHRyaWJ1dGU6IHRydWUsXG4gICAqICAgICAgICAgICAgICBMaXN0QXR0cmlidXRlOiBbMSwgJ3R3bycsIGZhbHNlXSxcbiAgICogICAgICAgICAgICAgIE1hcEF0dHJpYnV0ZTogeyBmb286ICdiYXInIH1cbiAgICogICAgICAgICAgICB9XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICAgIH1cbiAgICogICAgICBdXG4gICAqICAgIH1cbiAgICogIH07XG4gICAqXG4gICAqICB2YXIgZG9jdW1lbnRDbGllbnQgPSBuZXcgQVdTLkR5bmFtb0RCLkRvY3VtZW50Q2xpZW50KCk7XG4gICAqXG4gICAqICBkb2N1bWVudENsaWVudC5iYXRjaFdyaXRlKHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIGJhdGNoV3JpdGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsnYmF0Y2hXcml0ZSddO1xuICAgIHJldHVybiB0aGlzLm1ha2VTZXJ2aWNlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc2luZ2xlIGl0ZW0gaW4gYSB0YWJsZSBieSBwcmltYXJ5IGtleSBieSBkZWxlZ2F0aW5nIHRvXG4gICAqIGBBV1MuRHluYW1vREIuZGVsZXRlSXRlbSgpYFxuICAgKlxuICAgKiBTdXBwbHkgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB7QVdTLkR5bmFtb0RCLmRlbGV0ZUl0ZW19IHdpdGhcbiAgICogYEF0dHJpYnV0ZVZhbHVlYHMgc3Vic3RpdHV0ZWQgYnkgbmF0aXZlIEphdmFTY3JpcHQgdHlwZXMuXG4gICAqXG4gICAqIEBzZWUgQVdTLkR5bmFtb0RCLmRlbGV0ZUl0ZW1cbiAgICogQGV4YW1wbGUgRGVsZXRlIGFuIGl0ZW0gZnJvbSBhIHRhYmxlXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUYWJsZU5hbWUgOiAnVGFibGUnLFxuICAgKiAgICBLZXk6IHtcbiAgICogICAgICBIYXNoS2V5OiAnaGFzaGtleScsXG4gICAqICAgICAgTnVtYmVyUmFuZ2VLZXk6IDFcbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LmRlbGV0ZShwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpO1xuICAgKiAgICBlbHNlIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgfSk7XG4gICAqXG4gICAqL1xuICBkZWxldGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsnZGVsZXRlJ107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXQgb2YgYXR0cmlidXRlcyBmb3IgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4gcHJpbWFyeSBrZXlcbiAgICogYnkgZGVsZWdhdGluZyB0byBgQVdTLkR5bmFtb0RCLmdldEl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIuZ2V0SXRlbX0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIuZ2V0SXRlbVxuICAgKiBAZXhhbXBsZSBHZXQgYW4gaXRlbSBmcm9tIGEgdGFibGVcbiAgICogIHZhciBwYXJhbXMgPSB7XG4gICAqICAgIFRhYmxlTmFtZSA6ICdUYWJsZScsXG4gICAqICAgIEtleToge1xuICAgKiAgICAgIEhhc2hLZXk6ICdoYXNoa2V5J1xuICAgKiAgICB9XG4gICAqICB9O1xuICAgKlxuICAgKiAgdmFyIGRvY3VtZW50Q2xpZW50ID0gbmV3IEFXUy5EeW5hbW9EQi5Eb2N1bWVudENsaWVudCgpO1xuICAgKlxuICAgKiAgZG9jdW1lbnRDbGllbnQuZ2V0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIGdldDogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnNlcnZpY2VDbGllbnRPcGVyYXRpb25zTWFwWydnZXQnXTtcbiAgICByZXR1cm4gdGhpcy5tYWtlU2VydmljZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVtLCBvciByZXBsYWNlcyBhbiBvbGQgaXRlbSB3aXRoIGEgbmV3IGl0ZW0gYnlcbiAgICogZGVsZWdhdGluZyB0byBgQVdTLkR5bmFtb0RCLnB1dEl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIucHV0SXRlbX0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIucHV0SXRlbVxuICAgKiBAZXhhbXBsZSBDcmVhdGUgYSBuZXcgaXRlbSBpbiBhIHRhYmxlXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUYWJsZU5hbWUgOiAnVGFibGUnLFxuICAgKiAgICBJdGVtOiB7XG4gICAqICAgICAgIEhhc2hLZXk6ICdoYXNrZXknLFxuICAgKiAgICAgICBOdW1BdHRyaWJ1dGU6IDEsXG4gICAqICAgICAgIEJvb2xBdHRyaWJ1dGU6IHRydWUsXG4gICAqICAgICAgIExpc3RBdHRyaWJ1dGU6IFsxLCAndHdvJywgZmFsc2VdLFxuICAgKiAgICAgICBNYXBBdHRyaWJ1dGU6IHsgZm9vOiAnYmFyJ30sXG4gICAqICAgICAgIE51bGxBdHRyaWJ1dGU6IG51bGxcbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LnB1dChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpO1xuICAgKiAgICBlbHNlIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgfSk7XG4gICAqXG4gICAqL1xuICBwdXQ6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsncHV0J107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVkaXRzIGFuIGV4aXN0aW5nIGl0ZW0ncyBhdHRyaWJ1dGVzLCBvciBhZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIHRhYmxlIGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QgYnkgZGVsZWdhdGluZyB0byBgQVdTLkR5bmFtb0RCLnVwZGF0ZUl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIudXBkYXRlSXRlbX0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIudXBkYXRlSXRlbVxuICAgKiBAZXhhbXBsZSBVcGRhdGUgYW4gaXRlbSB3aXRoIGV4cHJlc3Npb25zXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUYWJsZU5hbWU6ICdUYWJsZScsXG4gICAqICAgIEtleTogeyBIYXNoS2V5IDogJ2hhc2hrZXknIH0sXG4gICAqICAgIFVwZGF0ZUV4cHJlc3Npb246ICdzZXQgI2EgPSA6eCArIDp5JyxcbiAgICogICAgQ29uZGl0aW9uRXhwcmVzc2lvbjogJyNhIDwgOk1BWCcsXG4gICAqICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczogeycjYScgOiAnU3VtJ30sXG4gICAqICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICogICAgICAnOngnIDogMjAsXG4gICAqICAgICAgJzp5JyA6IDQ1LFxuICAgKiAgICAgICc6TUFYJyA6IDEwMCxcbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LnVwZGF0ZShwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnNlcnZpY2VDbGllbnRPcGVyYXRpb25zTWFwWyd1cGRhdGUnXTtcbiAgICByZXR1cm4gdGhpcy5tYWtlU2VydmljZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvbmUgb3IgbW9yZSBpdGVtcyBhbmQgaXRlbSBhdHRyaWJ1dGVzIGJ5IGFjY2Vzc2luZyBldmVyeSBpdGVtXG4gICAqIGluIGEgdGFibGUgb3IgYSBzZWNvbmRhcnkgaW5kZXguXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIuc2Nhbn0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIuc2NhblxuICAgKiBAZXhhbXBsZSBTY2FuIHRoZSB0YWJsZSB3aXRoIGEgZmlsdGVyIGV4cHJlc3Npb25cbiAgICogIHZhciBwYXJhbXMgPSB7XG4gICAqICAgIFRhYmxlTmFtZSA6ICdUYWJsZScsXG4gICAqICAgIEZpbHRlckV4cHJlc3Npb24gOiAnWWVhciA9IDp0aGlzX3llYXInLFxuICAgKiAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzIDogeyc6dGhpc195ZWFyJyA6IDIwMTV9XG4gICAqICB9O1xuICAgKlxuICAgKiAgdmFyIGRvY3VtZW50Q2xpZW50ID0gbmV3IEFXUy5EeW5hbW9EQi5Eb2N1bWVudENsaWVudCgpO1xuICAgKlxuICAgKiAgZG9jdW1lbnRDbGllbnQuc2NhbihwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIHNjYW46IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsnc2NhbiddO1xuICAgIHJldHVybiB0aGlzLm1ha2VTZXJ2aWNlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gICAvKipcbiAgICAqIERpcmVjdGx5IGFjY2VzcyBpdGVtcyBmcm9tIGEgdGFibGUgYnkgcHJpbWFyeSBrZXkgb3IgYSBzZWNvbmRhcnkgaW5kZXguXG4gICAgKlxuICAgICogU3VwcGx5IHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMge0FXUy5EeW5hbW9EQi5xdWVyeX0gd2l0aFxuICAgICogYEF0dHJpYnV0ZVZhbHVlYHMgc3Vic3RpdHV0ZWQgYnkgbmF0aXZlIEphdmFTY3JpcHQgdHlwZXMuXG4gICAgKlxuICAgICogQHNlZSBBV1MuRHluYW1vREIucXVlcnlcbiAgICAqIEBleGFtcGxlIFF1ZXJ5IGFuIGluZGV4XG4gICAgKiAgdmFyIHBhcmFtcyA9IHtcbiAgICAqICAgIFRhYmxlTmFtZTogJ1RhYmxlJyxcbiAgICAqICAgIEluZGV4TmFtZTogJ0luZGV4JyxcbiAgICAqICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246ICdIYXNoS2V5ID0gOmhrZXkgYW5kIFJhbmdlS2V5ID4gOnJrZXknLFxuICAgICogICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICogICAgICAnOmhrZXknOiAna2V5JyxcbiAgICAqICAgICAgJzpya2V5JzogMjAxNVxuICAgICogICAgfVxuICAgICogIH07XG4gICAgKlxuICAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICAqXG4gICAgKiAgZG9jdW1lbnRDbGllbnQucXVlcnkocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpO1xuICAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAgKiAgfSk7XG4gICAgKlxuICAgICovXG4gIHF1ZXJ5OiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMuc2VydmljZUNsaWVudE9wZXJhdGlvbnNNYXBbJ3F1ZXJ5J107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIHdyaXRlIG9wZXJhdGlvbiB0aGF0IGdyb3VwcyB1cCB0byAyNSBhY3Rpb24gcmVxdWVzdHMuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIudHJhbnNhY3RXcml0ZUl0ZW1zfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi50cmFuc2FjdFdyaXRlSXRlbXNcbiAgICogQGV4YW1wbGUgR2V0IGl0ZW1zIGZyb20gbXVsdGlwbGUgdGFibGVzXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUcmFuc2FjdEl0ZW1zOiBbe1xuICAgKiAgICAgIFB1dDoge1xuICAgKiAgICAgICAgVGFibGVOYW1lIDogJ1RhYmxlMCcsXG4gICAqICAgICAgICBJdGVtOiB7XG4gICAqICAgICAgICAgIEhhc2hLZXk6ICdoYXNrZXknLFxuICAgKiAgICAgICAgICBOdW1BdHRyaWJ1dGU6IDEsXG4gICAqICAgICAgICAgIEJvb2xBdHRyaWJ1dGU6IHRydWUsXG4gICAqICAgICAgICAgIExpc3RBdHRyaWJ1dGU6IFsxLCAndHdvJywgZmFsc2VdLFxuICAgKiAgICAgICAgICBNYXBBdHRyaWJ1dGU6IHsgZm9vOiAnYmFyJ30sXG4gICAqICAgICAgICAgIE51bGxBdHRyaWJ1dGU6IG51bGxcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sIHtcbiAgICogICAgICBVcGRhdGU6IHtcbiAgICogICAgICAgIFRhYmxlTmFtZTogJ1RhYmxlMScsXG4gICAqICAgICAgICBLZXk6IHsgSGFzaEtleSA6ICdoYXNoa2V5JyB9LFxuICAgKiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ3NldCAjYSA9IDp4ICsgOnknLFxuICAgKiAgICAgICAgQ29uZGl0aW9uRXhwcmVzc2lvbjogJyNhIDwgOk1BWCcsXG4gICAqICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHsnI2EnIDogJ1N1bSd9LFxuICAgKiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgKiAgICAgICAgICAnOngnIDogMjAsXG4gICAqICAgICAgICAgICc6eScgOiA0NSxcbiAgICogICAgICAgICAgJzpNQVgnIDogMTAwLFxuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfV1cbiAgICogIH07XG4gICAqXG4gICAqICBkb2N1bWVudENsaWVudC50cmFuc2FjdFdyaXRlKHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICovXG4gIHRyYW5zYWN0V3JpdGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsndHJhbnNhY3RXcml0ZSddO1xuICAgIHJldHVybiB0aGlzLm1ha2VTZXJ2aWNlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdG9taWNhbGx5IHJldHJpZXZlcyBtdWx0aXBsZSBpdGVtcyBmcm9tIG9uZSBvciBtb3JlIHRhYmxlcyAoYnV0IG5vdCBmcm9tIGluZGV4ZXMpXG4gICAqIGluIGEgc2luZ2xlIGFjY291bnQgYW5kIHJlZ2lvbi5cbiAgICpcbiAgICogU3VwcGx5IHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMge0FXUy5EeW5hbW9EQi50cmFuc2FjdEdldEl0ZW1zfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi50cmFuc2FjdEdldEl0ZW1zXG4gICAqIEBleGFtcGxlIEdldCBpdGVtcyBmcm9tIG11bHRpcGxlIHRhYmxlc1xuICAgKiAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgVHJhbnNhY3RJdGVtczogW3tcbiAgICogICAgICBHZXQ6IHtcbiAgICogICAgICAgIFRhYmxlTmFtZSA6ICdUYWJsZTAnLFxuICAgKiAgICAgICAgS2V5OiB7XG4gICAqICAgICAgICAgIEhhc2hLZXk6ICdoYXNoa2V5MCdcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sIHtcbiAgICogICAgICBHZXQ6IHtcbiAgICogICAgICAgIFRhYmxlTmFtZSA6ICdUYWJsZTEnLFxuICAgKiAgICAgICAgS2V5OiB7XG4gICAqICAgICAgICAgIEhhc2hLZXk6ICdoYXNoa2V5MSdcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH1dXG4gICAqICB9O1xuICAgKlxuICAgKiAgZG9jdW1lbnRDbGllbnQudHJhbnNhY3RHZXQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogIH0pO1xuICAgKi9cbiAgdHJhbnNhY3RHZXQ6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsndHJhbnNhY3RHZXQnXTtcbiAgICByZXR1cm4gdGhpcy5tYWtlU2VydmljZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNldCBvZiBlbGVtZW50cyBpbmZlcnJpbmcgdGhlIHR5cGUgb2Ygc2V0IGZyb21cbiAgICogdGhlIHR5cGUgb2YgdGhlIGZpcnN0IGVsZW1lbnQuIEFtYXpvbiBEeW5hbW9EQiBjdXJyZW50bHkgc3VwcG9ydHNcbiAgICogdGhlIG51bWJlciBzZXRzLCBzdHJpbmcgc2V0cywgYW5kIGJpbmFyeSBzZXRzLiBGb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKiBhYm91dCBEeW5hbW9EQiBkYXRhIHR5cGVzIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvbiB0aGVcbiAgICogW0FtYXpvbiBEeW5hbW9EQiBEYXRhIE1vZGVsXShodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9hbWF6b25keW5hbW9kYi9sYXRlc3QvZGV2ZWxvcGVyZ3VpZGUvRGF0YU1vZGVsLmh0bWwjRGF0YU1vZGVsLkRhdGFUeXBlcykuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IFtBcnJheV0gQ29sbGVjdGlvbiB0byByZXByZXNlbnQgeW91ciBEeW5hbW9EQiBTZXRcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF1cbiAgICogICogKip2YWxpZGF0ZSoqIFtCb29sZWFuXSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB2YWxpZGF0ZSB0aGUgdHlwZVxuICAgKiAgICBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBudW1iZXIgc2V0XG4gICAqICB2YXIgZG9jdW1lbnRDbGllbnQgPSBuZXcgQVdTLkR5bmFtb0RCLkRvY3VtZW50Q2xpZW50KCk7XG4gICAqXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBJdGVtOiB7XG4gICAqICAgICAgaGFzaGtleTogJ2hhc2hrZXknXG4gICAqICAgICAgbnVtYmVyczogZG9jdW1lbnRDbGllbnQuY3JlYXRlU2V0KFsxLCAyLCAzXSk7XG4gICAqICAgIH1cbiAgICogIH07XG4gICAqXG4gICAqICBkb2N1bWVudENsaWVudC5wdXQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogIH0pO1xuICAgKlxuICAgKi9cbiAgY3JlYXRlU2V0OiBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG5ldyBEeW5hbW9EQlNldChsaXN0LCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRUcmFuc2xhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXR1cFJlcXVlc3Q6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0cmFuc2xhdG9yID0gc2VsZi5nZXRUcmFuc2xhdG9yKCk7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlcXVlc3Qub3BlcmF0aW9uO1xuICAgIHZhciBpbnB1dFNoYXBlID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0uaW5wdXQ7XG4gICAgcmVxdWVzdC5fZXZlbnRzLnZhbGlkYXRlLnVuc2hpZnQoZnVuY3Rpb24ocmVxKSB7XG4gICAgICByZXEucmF3UGFyYW1zID0gQVdTLnV0aWwuY29weShyZXEucGFyYW1zKTtcbiAgICAgIHJlcS5wYXJhbXMgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZUlucHV0KHJlcS5yYXdQYXJhbXMsIGlucHV0U2hhcGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVzcG9uc2U6IGZ1bmN0aW9uIHNldHVwUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHJhbnNsYXRvciA9IHNlbGYuZ2V0VHJhbnNsYXRvcigpO1xuICAgIHZhciBvdXRwdXRTaGFwZSA9IHNlbGYuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0ub3V0cHV0O1xuICAgIHJlcXVlc3Qub24oJ2V4dHJhY3REYXRhJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZU91dHB1dChyZXNwb25zZS5kYXRhLCBvdXRwdXRTaGFwZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIHJlc3BvbnNlLm5leHRQYWdlID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciByZXNwID0gdGhpcztcbiAgICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgICB2YXIgY29uZmlnO1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSByZXEub3BlcmF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnID0gc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7IHJlc3AuZXJyb3IgPSBlOyB9XG5cbiAgICAgIGlmICghcmVzcC5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgIGlmIChjYikgY2IocmVzcC5lcnJvciwgbnVsbCk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3AuZXJyb3IpIHRocm93IHJlc3AuZXJyb3I7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weShyZXEucmF3UGFyYW1zKTtcbiAgICAgIGlmICghcmVzcC5uZXh0UGFnZVRva2Vucykge1xuICAgICAgICByZXR1cm4gY2IgPyBjYihudWxsLCBudWxsKSA6IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5wdXRUb2tlbnMgPSBjb25maWcuaW5wdXRUb2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFRva2VucyA9PT0gJ3N0cmluZycpIGlucHV0VG9rZW5zID0gW2lucHV0VG9rZW5zXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcmFtc1tpbnB1dFRva2Vuc1tpXV0gPSByZXNwLm5leHRQYWdlVG9rZW5zW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmW29wZXJhdGlvbl0ocGFyYW1zLCBjYik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xuXG4vKipcbiAqIEFuIG9iamVjdCByZWNvZ25pemFibGUgYXMgYSBudW1lcmljIHZhbHVlIHRoYXQgc3RvcmVzIHRoZSB1bmRlcmx5aW5nIG51bWJlclxuICogYXMgYSBzdHJpbmcuXG4gKlxuICogSW50ZW5kZWQgdG8gYmUgYSBkZXNlcmlhbGl6YXRpb24gdGFyZ2V0IGZvciB0aGUgRHluYW1vREIgRG9jdW1lbnQgQ2xpZW50IHdoZW5cbiAqIHRoZSBgd3JhcE51bWJlcnNgIGZsYWcgaXMgc2V0LiBUaGlzIGFsbG93cyBmb3IgbnVtZXJpYyB2YWx1ZXMgdGhhdCBsb3NlXG4gKiBwcmVjaXNpb24gd2hlbiBjb252ZXJ0ZWQgdG8gSmF2YVNjcmlwdCdzIGBudW1iZXJgIHR5cGUuXG4gKi9cbnZhciBEeW5hbW9EQk51bWJlclZhbHVlID0gdXRpbC5pbmhlcml0KHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIE51bWJlclZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy53cmFwcGVyTmFtZSA9ICdOdW1iZXJWYWx1ZSc7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgdW5kZXJseWluZyB2YWx1ZSBhcyBhIG51bWJlciB3aGVuIGNvbnZlcnRpbmcgdG8gSlNPTi5cbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHVuZGVybHlpbmcgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICovXG4gIHRvTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLnZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdW5hbHRlcmVkIHZhbHVlIHByb3ZpZGVkIHRvIHRoZVxuICAgKiBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtb0RCTnVtYmVyVmFsdWU7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIHR5cGVPZiA9IHJlcXVpcmUoJy4vdHlwZXMnKS50eXBlT2Y7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBtZW1iZXJUeXBlVG9TZXRUeXBlID0ge1xuICAnU3RyaW5nJzogJ1N0cmluZycsXG4gICdOdW1iZXInOiAnTnVtYmVyJyxcbiAgJ051bWJlclZhbHVlJzogJ051bWJlcicsXG4gICdCaW5hcnknOiAnQmluYXJ5J1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIER5bmFtb0RCU2V0ID0gdXRpbC5pbmhlcml0KHtcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2V0KGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLndyYXBwZXJOYW1lID0gJ1NldCc7XG4gICAgdGhpcy5pbml0aWFsaXplKGxpc3QsIG9wdGlvbnMudmFsaWRhdGUpO1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxpc3QsIHZhbGlkYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudmFsdWVzID0gW10uY29uY2F0KGxpc3QpO1xuICAgIHNlbGYuZGV0ZWN0VHlwZSgpO1xuICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgc2VsZi52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICBkZXRlY3RUeXBlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnR5cGUgPSBtZW1iZXJUeXBlVG9TZXRUeXBlW3R5cGVPZih0aGlzLnZhbHVlc1swXSldO1xuICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkU2V0VHlwZScsXG4gICAgICAgIG1lc3NhZ2U6ICdTZXRzIGNhbiBjb250YWluIHN0cmluZywgbnVtYmVyLCBvciBiaW5hcnkgdmFsdWVzJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlbmd0aCA9IHNlbGYudmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gc2VsZi52YWx1ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1lbWJlclR5cGVUb1NldFR5cGVbdHlwZU9mKHZhbHVlc1tpXSldICE9PSBzZWxmLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgIGNvZGU6ICdJbnZhbGlkVHlwZScsXG4gICAgICAgICAgbWVzc2FnZTogc2VsZi50eXBlICsgJyBTZXQgY29udGFpbnMgJyArIHR5cGVPZih2YWx1ZXNbaV0pICsgJyB2YWx1ZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHVuZGVybHlpbmcgdmFsdWVzIG9ubHkgd2hlbiBjb252ZXJ0aW5nIHRvIEpTT04uXG4gICAqL1xuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gc2VsZi52YWx1ZXM7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRHluYW1vREJTZXQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIGNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnRlcicpO1xuXG52YXIgVHJhbnNsYXRvciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuYXR0clZhbHVlID0gb3B0aW9ucy5hdHRyVmFsdWU7XG4gIHRoaXMuY29udmVydEVtcHR5VmFsdWVzID0gQm9vbGVhbihvcHRpb25zLmNvbnZlcnRFbXB0eVZhbHVlcyk7XG4gIHRoaXMud3JhcE51bWJlcnMgPSBCb29sZWFuKG9wdGlvbnMud3JhcE51bWJlcnMpO1xufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlSW5wdXQgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgdGhpcy5tb2RlID0gJ2lucHV0JztcbiAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKHZhbHVlLCBzaGFwZSk7XG59O1xuXG5UcmFuc2xhdG9yLnByb3RvdHlwZS50cmFuc2xhdGVPdXRwdXQgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgdGhpcy5tb2RlID0gJ291dHB1dCc7XG4gIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpO1xufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKCFzaGFwZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGlmIChzaGFwZS5zaGFwZSA9PT0gc2VsZi5hdHRyVmFsdWUpIHtcbiAgICByZXR1cm4gY29udmVydFtzZWxmLm1vZGVdKHZhbHVlLCB7XG4gICAgICBjb252ZXJ0RW1wdHlWYWx1ZXM6IHNlbGYuY29udmVydEVtcHR5VmFsdWVzLFxuICAgICAgd3JhcE51bWJlcnM6IHNlbGYud3JhcE51bWJlcnMsXG4gICAgfSk7XG4gIH1cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHNlbGYudHJhbnNsYXRlU3RydWN0dXJlKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHNlbGYudHJhbnNsYXRlTWFwKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiBzZWxmLnRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gc2VsZi50cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKTtcbiAgfVxufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlU3RydWN0dXJlID0gZnVuY3Rpb24oc3RydWN0dXJlLCBzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzdHJ1Y3R1cmUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgc3RydWN0ID0ge307XG4gIHV0aWwuZWFjaChzdHJ1Y3R1cmUsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1tuYW1lXTtcbiAgICBpZiAobWVtYmVyU2hhcGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBzZWxmLnRyYW5zbGF0ZSh2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBzdHJ1Y3RbbmFtZV0gPSByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cnVjdDtcbn07XG5cblRyYW5zbGF0b3IucHJvdG90eXBlLnRyYW5zbGF0ZUxpc3QgPSBmdW5jdGlvbihsaXN0LCBzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBzZWxmLnRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dC5wdXNoKG51bGwpO1xuICAgIGVsc2Ugb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5UcmFuc2xhdG9yLnByb3RvdHlwZS50cmFuc2xhdGVNYXAgPSBmdW5jdGlvbihtYXAsIHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKG1hcCA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHZhciBvdXQgPSB7fTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBzZWxmLnRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSBudWxsO1xuICAgIGVsc2Ugb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlU2NhbGFyID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1R5cGUodmFsdWUpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2xhdG9yO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcblxuZnVuY3Rpb24gdHlwZU9mKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSBlbHNlIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgaXNCaW5hcnkoZGF0YSkpIHtcbiAgICByZXR1cm4gJ0JpbmFyeSc7XG4gIH0gZWxzZSBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZGF0YS53cmFwcGVyTmFtZSB8fCB1dGlsLnR5cGVOYW1lKGRhdGEuY29uc3RydWN0b3IpO1xuICB9IGVsc2UgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyB0aGlzIG9iamVjdCBpcyB0aGUgcmVzdWx0IG9mIE9iamVjdC5jcmVhdGUobnVsbCksIGhlbmNlIHRoZSBhYnNlbmNlIG9mIGFcbiAgICAvLyBkZWZpbmVkIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShkYXRhKSB7XG4gIHZhciB0eXBlcyA9IFtcbiAgICAnQnVmZmVyJywgJ0ZpbGUnLCAnQmxvYicsICdBcnJheUJ1ZmZlcicsICdEYXRhVmlldycsXG4gICAgJ0ludDhBcnJheScsICdVaW50OEFycmF5JywgJ1VpbnQ4Q2xhbXBlZEFycmF5JyxcbiAgICAnSW50MTZBcnJheScsICdVaW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ1VpbnQzMkFycmF5JyxcbiAgICAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheSdcbiAgXTtcbiAgaWYgKHV0aWwuaXNOb2RlKCkpIHtcbiAgICB2YXIgU3RyZWFtID0gdXRpbC5zdHJlYW0uU3RyZWFtO1xuICAgIGlmICh1dGlsLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhIGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAodXRpbC5pc1R5cGUoZGF0YSwgdHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh1dGlsLnR5cGVOYW1lKGRhdGEuY29uc3RydWN0b3IpID09PSB0eXBlc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHlwZU9mOiB0eXBlT2YsXG4gIGlzQmluYXJ5OiBpc0JpbmFyeVxufTtcbiIsInZhciBldmVudE1lc3NhZ2VDaHVua2VyID0gcmVxdWlyZSgnLi4vZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlcicpLmV2ZW50TWVzc2FnZUNodW5rZXI7XG52YXIgcGFyc2VFdmVudCA9IHJlcXVpcmUoJy4vcGFyc2UtZXZlbnQnKS5wYXJzZUV2ZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbShib2R5LCBwYXJzZXIsIG1vZGVsKSB7XG4gICAgdmFyIGV2ZW50TWVzc2FnZXMgPSBldmVudE1lc3NhZ2VDaHVua2VyKGJvZHkpO1xuXG4gICAgdmFyIGV2ZW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKHBhcnNlRXZlbnQocGFyc2VyLCBldmVudE1lc3NhZ2VzW2ldLCBtb2RlbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudHM7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUV2ZW50U3RyZWFtOiBjcmVhdGVFdmVudFN0cmVhbVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZScpLnV0aWw7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xudmFyIGFsbG9jQnVmZmVyID0gdXRpbC5idWZmZXIuYWxsb2M7XG5cbi8qKiBAdHlwZSB7VHJhbnNmb3JtfSAqL1xuZnVuY3Rpb24gRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbShvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoID0gMDtcbiAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7QnVmZmVyfSAqL1xuICAgIHRoaXMubWVzc2FnZUxlbmd0aEJ1ZmZlciA9IG51bGw7XG59XG5cbkV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAqL1xuRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB2YXIgY2h1bmtMZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSAwO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRPZmZzZXQgPCBjaHVua0xlbmd0aCkge1xuICAgICAgICAvLyBjcmVhdGUgbmV3IG1lc3NhZ2UgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50TWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gd29ya2luZyBvbiBhIG5ldyBtZXNzYWdlLCBkZXRlcm1pbmUgdG90YWwgbGVuZ3RoXG4gICAgICAgICAgICB2YXIgYnl0ZXNSZW1haW5pbmcgPSBjaHVua0xlbmd0aCAtIGN1cnJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGVkZ2UgY2FzZSB3aGVyZSB0b3RhbCBsZW5ndGggc3BhbnMgMiBjaHVua3NcbiAgICAgICAgICAgIGlmICghdGhpcy5tZXNzYWdlTGVuZ3RoQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlTGVuZ3RoQnVmZmVyID0gYWxsb2NCdWZmZXIoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtQnl0ZXNGb3JUb3RhbCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIDQgLSB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCwgLy8gcmVtYWluaW5nIGJ5dGVzIHRvIGZpbGwgdGhlIG1lc3NhZ2VMZW5ndGhCdWZmZXJcbiAgICAgICAgICAgICAgICBieXRlc1JlbWFpbmluZyAvLyBieXRlcyBsZWZ0IGluIGNodW5rXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjaHVuay5jb3B5KFxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUxlbmd0aEJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXJyZW50T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgKyBudW1CeXRlc0ZvclRvdGFsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCArPSBudW1CeXRlc0ZvclRvdGFsO1xuICAgICAgICAgICAgY3VycmVudE9mZnNldCArPSBudW1CeXRlc0ZvclRvdGFsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhlIGN1cnJlbnQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZU1lc3NhZ2UodGhpcy5tZXNzYWdlTGVuZ3RoQnVmZmVyLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VMZW5ndGhCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JpdGUgZGF0YSBpbnRvIGN1cnJlbnQgbWVzc2FnZVxuICAgICAgICB2YXIgbnVtQnl0ZXNUb1dyaXRlID0gTWF0aC5taW4oXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggLSB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCwgLy8gbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gY29tcGxldGUgbWVzc2FnZVxuICAgICAgICAgICAgY2h1bmtMZW5ndGggLSBjdXJyZW50T2Zmc2V0IC8vIG51bWJlciBvZiBieXRlcyBsZWZ0IGluIHRoZSBvcmlnaW5hbCBjaHVua1xuICAgICAgICApO1xuICAgICAgICBjaHVuay5jb3B5KFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSwgLy8gdGFyZ2V0IGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGgsIC8vIHRhcmdldCBvZmZzZXRcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQsIC8vIGNodW5rIG9mZnNldFxuICAgICAgICAgICAgY3VycmVudE9mZnNldCArIG51bUJ5dGVzVG9Xcml0ZSAvLyBjaHVuayBlbmQgdG8gd3JpdGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggKz0gbnVtQnl0ZXNUb1dyaXRlO1xuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IG51bUJ5dGVzVG9Xcml0ZTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhIG1lc3NhZ2UgaXMgcmVhZHkgdG8gYmUgcHVzaGVkXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggJiYgdGhpcy5jdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID09PSB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCkge1xuICAgICAgICAgICAgLy8gcHVzaCBvdXQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnRNZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG59O1xuXG5FdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lc3NhZ2VUb3RhbExlbmd0aCA9PT0gdGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuY3VycmVudE1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUcnVuY2F0ZWQgZXZlbnQgbWVzc2FnZSByZWNlaXZlZC4nKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgU2l6ZSBvZiB0aGUgbWVzc2FnZSB0byBiZSBhbGxvY2F0ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbS5wcm90b3R5cGUuYWxsb2NhdGVNZXNzYWdlID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gYWxsb2NhdGUgYW4gZXZlbnQgbWVzc2FnZSB3aGVyZSBzaXplIHdhcyBub3QgYSBudW1iZXI6ICcgKyBzaXplKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID0gc2l6ZTtcbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCA9IDQ7XG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IGFsbG9jQnVmZmVyKHNpemUpO1xuICAgIHRoaXMuY3VycmVudE1lc3NhZ2Uud3JpdGVVSW50MzJCRShzaXplLCAwKTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW06IEV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW1cbn07XG4iLCIvKipcbiAqIFRha2VzIGluIGEgYnVmZmVyIG9mIGV2ZW50IG1lc3NhZ2VzIGFuZCBzcGxpdHMgdGhlbSBpbnRvIGluZGl2aWR1YWwgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRNZXNzYWdlQ2h1bmtlcihidWZmZXIpIHtcbiAgICAvKiogQHR5cGUgQnVmZmVyW10gKi9cbiAgICB2YXIgbWVzc2FnZXMgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IGJ1ZmZlci5yZWFkSW50MzJCRShvZmZzZXQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgYnVmZmVyIGZvciBpbmRpdmlkdWFsIG1lc3NhZ2UgKHNoYXJlcyBtZW1vcnkgd2l0aCBvcmlnaW5hbClcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCB0b3RhbExlbmd0aCArIG9mZnNldCk7XG4gICAgICAgIC8vIGluY3JlbWVudCBvZmZzZXQgdG8gaXQgc3RhcnRzIGF0IHRoZSBuZXh0IG1lc3NhZ2VcbiAgICAgICAgb2Zmc2V0ICs9IHRvdGFsTGVuZ3RoO1xuXG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBldmVudE1lc3NhZ2VDaHVua2VyOiBldmVudE1lc3NhZ2VDaHVua2VyXG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbnZhciBwYXJzZUV2ZW50ID0gcmVxdWlyZSgnLi9wYXJzZS1ldmVudCcpLnBhcnNlRXZlbnQ7XG5cbi8qKiBAdHlwZSB7VHJhbnNmb3JtfSAqL1xuZnVuY3Rpb24gRXZlbnRVbm1hcnNoYWxsZXJTdHJlYW0ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIHNldCBvdXRwdXQgdG8gb2JqZWN0IG1vZGVcbiAgICBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSA9IHRydWU7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG4gICAgdGhpcy5ldmVudFN0cmVhbU1vZGVsID0gb3B0aW9ucy5ldmVudFN0cmVhbU1vZGVsO1xufVxuXG5FdmVudFVubWFyc2hhbGxlclN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICovXG5FdmVudFVubWFyc2hhbGxlclN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZXZlbnQgPSBwYXJzZUV2ZW50KHRoaXMucGFyc2VyLCBjaHVuaywgdGhpcy5ldmVudFN0cmVhbU1vZGVsKTtcbiAgICAgICAgdGhpcy5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXZlbnRVbm1hcnNoYWxsZXJTdHJlYW06IEV2ZW50VW5tYXJzaGFsbGVyU3RyZWFtXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcbnZhciB0b0J1ZmZlciA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgcmVwcmVzZW50YXRpb24gb2YgYSBzaWduZWQsIDY0LWJpdCBpbnRlZ2VyLiBJbnN0YW5jZXMgb2YgdGhpc1xuICogY2xhc3MgbWF5IGJlIHVzZWQgaW4gYXJpdGhtZXRpYyBleHByZXNzaW9ucyBhcyBpZiB0aGV5IHdlcmUgbnVtZXJpY1xuICogcHJpbWl0aXZlcywgYnV0IHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gd2lsbCBiZSBwcmVzZXJ2ZWQgdW5jaGFuZ2VkIGFzIHRoZVxuICogYGJ5dGVzYCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LiBUaGUgYnl0ZXMgc2hvdWxkIGJlIGVuY29kZWQgYXMgYmlnLWVuZGlhbixcbiAqIHR3bydzIGNvbXBsZW1lbnQgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnl0ZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gSW50NjQoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50NjQgYnVmZmVycyBtdXN0IGJlIGV4YWN0bHkgOCBieXRlcycpO1xuICAgIH1cbiAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKSkgYnl0ZXMgPSB0b0J1ZmZlcihieXRlcyk7XG5cbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICogQHJldHVybnMge0ludDY0fVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5JbnQ2NC5mcm9tTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA+IDkyMjMzNzIwMzY4NTQ3NzU4MDcgfHwgbnVtYmVyIDwgLTkyMjMzNzIwMzY4NTQ3NzU4MDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgbnVtYmVyICsgJyBpcyB0b28gbGFyZ2UgKG9yLCBpZiBuZWdhdGl2ZSwgdG9vIHNtYWxsKSB0byByZXByZXNlbnQgYXMgYW4gSW50NjQnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgZm9yIChcbiAgICAgICAgdmFyIGkgPSA3LCByZW1haW5pbmcgPSBNYXRoLmFicyhNYXRoLnJvdW5kKG51bWJlcikpO1xuICAgICAgICBpID4gLTEgJiYgcmVtYWluaW5nID4gMDtcbiAgICAgICAgaS0tLCByZW1haW5pbmcgLz0gMjU2XG4gICAgKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIG5lZ2F0ZShieXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnQ2NChieXRlcyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkludDY0LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcy5zbGljZSgwKTtcbiAgICB2YXIgbmVnYXRpdmUgPSBieXRlc1swXSAmIDEyODtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbmVnYXRlKGJ5dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VJbnQoYnl0ZXMudG9TdHJpbmcoJ2hleCcpLCAxNikgKiAobmVnYXRpdmUgPyAtMSA6IDEpO1xufTtcblxuSW50NjQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBieXRlc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZWdhdGUoYnl0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSBePSAweEZGO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gNzsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgYnl0ZXNbaV0rKztcbiAgICAgICAgaWYgKGJ5dGVzW2ldICE9PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSW50NjQ6IEludDY0XG59O1xuIiwidmFyIHBhcnNlTWVzc2FnZSA9IHJlcXVpcmUoJy4vcGFyc2UtbWVzc2FnZScpLnBhcnNlTWVzc2FnZTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBwYXJzZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0geyp9IHNoYXBlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudChwYXJzZXIsIG1lc3NhZ2UsIHNoYXBlKSB7XG4gICAgdmFyIHBhcnNlZE1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAvLyBjaGVjayBpZiBtZXNzYWdlIGlzIGFuIGV2ZW50IG9yIGVycm9yXG4gICAgdmFyIG1lc3NhZ2VUeXBlID0gcGFyc2VkTWVzc2FnZS5oZWFkZXJzWyc6bWVzc2FnZS10eXBlJ107XG4gICAgaWYgKG1lc3NhZ2VUeXBlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZS52YWx1ZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnJvcihwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZS52YWx1ZSAhPT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgaG93IHRvIHBhcnNlIG5vbi1ldmVudHMvbm9uLWVycm9ycywgaWdub3JlIGZvciBub3dcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBldmVudCB0eXBlXG4gICAgdmFyIGV2ZW50VHlwZSA9IHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1snOmV2ZW50LXR5cGUnXTtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBldmVudCB0eXBlIGlzIG1vZGVsZWRcbiAgICB2YXIgZXZlbnRNb2RlbCA9IHNoYXBlLm1lbWJlcnNbZXZlbnRUeXBlLnZhbHVlXTtcbiAgICBpZiAoIWV2ZW50TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAvLyBjaGVjayBpZiBhbiBldmVudCBwYXlsb2FkIGV4aXN0c1xuICAgIHZhciBldmVudFBheWxvYWRNZW1iZXJOYW1lID0gZXZlbnRNb2RlbC5ldmVudFBheWxvYWRNZW1iZXJOYW1lO1xuICAgIGlmIChldmVudFBheWxvYWRNZW1iZXJOYW1lKSB7XG4gICAgICAgIHZhciBwYXlsb2FkU2hhcGUgPSBldmVudE1vZGVsLm1lbWJlcnNbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV07XG4gICAgICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBiaW5hcnksIHJldHVybiB0aGUgYnl0ZSBhcnJheVxuICAgICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgICByZXN1bHRbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV0gPSBwYXJzZWRNZXNzYWdlLmJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV0gPSBwYXJzZXIucGFyc2UocGFyc2VkTWVzc2FnZS5ib2R5LnRvU3RyaW5nKCksIHBheWxvYWRTaGFwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFkIGV2ZW50IGhlYWRlcnNcbiAgICB2YXIgZXZlbnRIZWFkZXJOYW1lcyA9IGV2ZW50TW9kZWwuZXZlbnRIZWFkZXJNZW1iZXJOYW1lcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SGVhZGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBldmVudEhlYWRlck5hbWVzW2ldO1xuICAgICAgICBpZiAocGFyc2VkTWVzc2FnZS5oZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgaGVhZGVyIVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gZXZlbnRNb2RlbC5tZW1iZXJzW25hbWVdLnRvVHlwZShwYXJzZWRNZXNzYWdlLmhlYWRlcnNbbmFtZV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIG91dHB1dFtldmVudFR5cGUudmFsdWVdID0gcmVzdWx0O1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBlcnJvckNvZGUgPSBtZXNzYWdlLmhlYWRlcnNbJzplcnJvci1jb2RlJ107XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UuaGVhZGVyc1snOmVycm9yLW1lc3NhZ2UnXTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlLnZhbHVlIHx8IGVycm9yTWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLm5hbWUgPSBlcnJvckNvZGUudmFsdWUgfHwgZXJyb3JDb2RlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VFdmVudDogcGFyc2VFdmVudFxufTtcbiIsInZhciBJbnQ2NCA9IHJlcXVpcmUoJy4vaW50NjQnKS5JbnQ2NDtcblxudmFyIHNwbGl0TWVzc2FnZSA9IHJlcXVpcmUoJy4vc3BsaXQtbWVzc2FnZScpLnNwbGl0TWVzc2FnZTtcblxudmFyIEJPT0xFQU5fVEFHID0gJ2Jvb2xlYW4nO1xudmFyIEJZVEVfVEFHID0gJ2J5dGUnO1xudmFyIFNIT1JUX1RBRyA9ICdzaG9ydCc7XG52YXIgSU5UX1RBRyA9ICdpbnRlZ2VyJztcbnZhciBMT05HX1RBRyA9ICdsb25nJztcbnZhciBCSU5BUllfVEFHID0gJ2JpbmFyeSc7XG52YXIgU1RSSU5HX1RBRyA9ICdzdHJpbmcnO1xudmFyIFRJTUVTVEFNUF9UQUcgPSAndGltZXN0YW1wJztcbnZhciBVVUlEX1RBRyA9ICd1dWlkJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHdoaWxlIChwb3NpdGlvbiA8IGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuYW1lTGVuZ3RoID0gaGVhZGVycy5yZWFkVUludDgocG9zaXRpb24rKyk7XG4gICAgICAgIHZhciBuYW1lID0gaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBuYW1lTGVuZ3RoKS50b1N0cmluZygpO1xuICAgICAgICBwb3NpdGlvbiArPSBuYW1lTGVuZ3RoO1xuICAgICAgICBzd2l0Y2ggKGhlYWRlcnMucmVhZFVJbnQ4KHBvc2l0aW9uKyspKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogYm9vbFRydWUgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCT09MRUFOX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIGJvb2xGYWxzZSAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEJPT0xFQU5fVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIGJ5dGUgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCWVRFX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMucmVhZEludDgocG9zaXRpb24rKylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIHNob3J0ICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU0hPUlRfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5yZWFkSW50MTZCRShwb3NpdGlvbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogaW50ZWdlciAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IElOVF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnJlYWRJbnQzMkJFKHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBsb25nICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTE9OR19UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgSW50NjQoaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyA4KSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYgLyogYnl0ZUFycmF5ICovOlxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlMZW5ndGggPSBoZWFkZXJzLnJlYWRVSW50MTZCRShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEJJTkFSWV9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGJpbmFyeUxlbmd0aClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGJpbmFyeUxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBzdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IGhlYWRlcnMucmVhZFVJbnQxNkJFKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU1RSSU5HX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICsgc3RyaW5nTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyaW5nTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4IC8qIHRpbWVzdGFtcCAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRJTUVTVEFNUF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBJbnQ2NChoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiB1dWlkICovOlxuICAgICAgICAgICAgICAgIHZhciB1dWlkQ2hhcnMgPSBoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDE2KVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDE2O1xuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVVVJRF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkQ2hhcnMuc3Vic3RyKDAsIDgpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoOCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigxMiwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigxNiwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigyMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBoZWFkZXIgdHlwZSB0YWcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwYXJzZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHZhciBwYXJzZWQgPSBzcGxpdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgaGVhZGVyczogcGFyc2VIZWFkZXJzKHBhcnNlZC5oZWFkZXJzKSwgYm9keTogcGFyc2VkLmJvZHkgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VNZXNzYWdlOiBwYXJzZU1lc3NhZ2Vcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIHRvQnVmZmVyID0gdXRpbC5idWZmZXIudG9CdWZmZXI7XG5cbi8vIEFsbCBwcmVsdWRlIGNvbXBvbmVudHMgYXJlIHVuc2lnbmVkLCAzMi1iaXQgaW50ZWdlcnNcbnZhciBQUkVMVURFX01FTUJFUl9MRU5HVEggPSA0O1xuLy8gVGhlIHByZWx1ZGUgY29uc2lzdHMgb2YgdHdvIGNvbXBvbmVudHNcbnZhciBQUkVMVURFX0xFTkdUSCA9IFBSRUxVREVfTUVNQkVSX0xFTkdUSCAqIDI7XG4vLyBDaGVja3N1bXMgYXJlIGFsd2F5cyBDUkMzMiBoYXNoZXMuXG52YXIgQ0hFQ0tTVU1fTEVOR1RIID0gNDtcbi8vIE1lc3NhZ2VzIG11c3QgaW5jbHVkZSBhIGZ1bGwgcHJlbHVkZSwgYSBwcmVsdWRlIGNoZWNrc3VtLCBhbmQgYSBtZXNzYWdlIGNoZWNrc3VtXG52YXIgTUlOSU1VTV9NRVNTQUdFX0xFTkdUSCA9IFBSRUxVREVfTEVOR1RIICsgQ0hFQ0tTVU1fTEVOR1RIICogMjtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBzcGxpdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICghdXRpbC5CdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIG1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlKTtcblxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCA8IE1JTklNVU1fTUVTU0FHRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBtZXNzYWdlIHRvbyBzaG9ydCB0byBhY2NvbW1vZGF0ZSBldmVudCBzdHJlYW0gbWVzc2FnZSBvdmVyaGVhZCcpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCAhPT0gbWVzc2FnZS5yZWFkVUludDMyQkUoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXBvcnRlZCBtZXNzYWdlIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCByZWNlaXZlZCBtZXNzYWdlIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RlZFByZWx1ZGVDaGVja3N1bSA9IG1lc3NhZ2UucmVhZFVJbnQzMkJFKFBSRUxVREVfTEVOR1RIKTtcblxuICAgIGlmIChcbiAgICAgICAgZXhwZWN0ZWRQcmVsdWRlQ2hlY2tzdW0gIT09IHV0aWwuY3J5cHRvLmNyYzMyKFxuICAgICAgICAgICAgbWVzc2FnZS5zbGljZSgwLCBQUkVMVURFX0xFTkdUSClcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHByZWx1ZGUgY2hlY2tzdW0gc3BlY2lmaWVkIGluIHRoZSBtZXNzYWdlICgnICtcbiAgICAgICAgICAgIGV4cGVjdGVkUHJlbHVkZUNoZWNrc3VtICtcbiAgICAgICAgICAgICcpIGRvZXMgbm90IG1hdGNoIHRoZSBjYWxjdWxhdGVkIENSQzMyIGNoZWNrc3VtLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwZWN0ZWRNZXNzYWdlQ2hlY2tzdW0gPSBtZXNzYWdlLnJlYWRVSW50MzJCRShtZXNzYWdlLmxlbmd0aCAtIENIRUNLU1VNX0xFTkdUSCk7XG5cbiAgICBpZiAoXG4gICAgICAgIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtICE9PSB1dGlsLmNyeXB0by5jcmMzMihcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2xpY2UoMCwgbWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBtZXNzYWdlIGNoZWNrc3VtIGRpZCBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlIG9mICcgK1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlcnNTdGFydCA9IFBSRUxVREVfTEVOR1RIICsgQ0hFQ0tTVU1fTEVOR1RIO1xuICAgIHZhciBoZWFkZXJzRW5kID0gaGVhZGVyc1N0YXJ0ICsgbWVzc2FnZS5yZWFkVUludDMyQkUoUFJFTFVERV9NRU1CRVJfTEVOR1RIKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcnM6IG1lc3NhZ2Uuc2xpY2UoaGVhZGVyc1N0YXJ0LCBoZWFkZXJzRW5kKSxcbiAgICAgICAgYm9keTogbWVzc2FnZS5zbGljZShoZWFkZXJzRW5kLCBtZXNzYWdlLmxlbmd0aCAtIENIRUNLU1VNX0xFTkdUSCksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3BsaXRNZXNzYWdlOiBzcGxpdE1lc3NhZ2Vcbn07XG4iLCIvKipcbiAqIFdoYXQgaXMgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBhbiBldmVudCBzdHJlYW0gaW4gbm9kZT9cbiAqICAtIGh0dHAgcmVzcG9uc2Ugc3RyZWFtXG4gKiAgLSBwYXJzZXJcbiAqICAtIGV2ZW50IHN0cmVhbSBtb2RlbFxuICovXG5cbnZhciBFdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtID0gcmVxdWlyZSgnLi4vZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlci1zdHJlYW0nKS5FdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtO1xudmFyIEV2ZW50VW5tYXJzaGFsbGVyU3RyZWFtID0gcmVxdWlyZSgnLi4vZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtdW5tYXJzaGFsbGVyLXN0cmVhbScpLkV2ZW50VW5tYXJzaGFsbGVyU3RyZWFtO1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbShzdHJlYW0sIHBhcnNlciwgbW9kZWwpIHtcbiAgICB2YXIgZXZlbnRTdHJlYW0gPSBuZXcgRXZlbnRVbm1hcnNoYWxsZXJTdHJlYW0oe1xuICAgICAgICBwYXJzZXI6IHBhcnNlcixcbiAgICAgICAgZXZlbnRTdHJlYW1Nb2RlbDogbW9kZWxcbiAgICB9KTtcblxuICAgIHZhciBldmVudE1lc3NhZ2VDaHVua2VyID0gbmV3IEV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW0oKTtcblxuICAgIHN0cmVhbS5waXBlKFxuICAgICAgICBldmVudE1lc3NhZ2VDaHVua2VyXG4gICAgKS5waXBlKGV2ZW50U3RyZWFtKTtcblxuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgZXZlbnRNZXNzYWdlQ2h1bmtlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICBldmVudE1lc3NhZ2VDaHVua2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBldmVudFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXZlbnRTdHJlYW07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUV2ZW50U3RyZWFtOiBjcmVhdGVFdmVudFN0cmVhbVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBTZXF1ZW50aWFsRXhlY3V0b3IgPSByZXF1aXJlKCcuL3NlcXVlbnRpYWxfZXhlY3V0b3InKTtcbnZhciBESVNDT1ZFUl9FTkRQT0lOVCA9IHJlcXVpcmUoJy4vZGlzY292ZXJfZW5kcG9pbnQnKS5kaXNjb3ZlckVuZHBvaW50O1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIHVzZWQgdG8gcmVnaXN0ZXIgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyBmb3IgcmVxdWVzdCBidWlsZGluZ1xuICogYW5kIHNlbmRpbmcuXG4gKi9cbkFXUy5FdmVudExpc3RlbmVycyA9IHtcbiAgLyoqXG4gICAqIEAhYXR0cmlidXRlIFZBTElEQVRFX0NSRURFTlRJQUxTXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgdmFsaWRhdGVzIHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYmVpbmdcbiAgICogICBzZW50IHdpdGggY3JlZGVudGlhbHMuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnZhbGlkYXRlICd2YWxpZGF0ZScgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRob3V0IHZhbGlkYXRpbmcgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX0NSRURFTlRJQUxTO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBsaXN0ZW5lcik7XG4gICAqICAgQHJlYWRvbmx5XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqIEAhYXR0cmlidXRlIFZBTElEQVRFX1JFR0lPTlxuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHZhbGlkYXRlcyB3aGV0aGVyIHRoZSByZWdpb24gaXMgc2V0XG4gICAqICAgZm9yIGEgcmVxdWVzdC5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+dmFsaWRhdGUgJ3ZhbGlkYXRlJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgdmFsaWRhdGluZyByZWdpb24gY29uZmlndXJhdGlvblxuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBsaXN0ZW5lcik7XG4gICAqICAgQHJlYWRvbmx5XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqIEAhYXR0cmlidXRlIFZBTElEQVRFX1BBUkFNRVRFUlNcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCB2YWxpZGF0ZXMgaW5wdXQgcGFyYW1ldGVycyBpbiBhIHJlcXVlc3QuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnZhbGlkYXRlICd2YWxpZGF0ZScgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRob3V0IHZhbGlkYXRpbmcgcGFyYW1ldGVyc1xuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUztcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgbGlzdGVuZXIpO1xuICAgKiAgIEBleGFtcGxlIERpc2FibGUgcGFyYW1ldGVyIHZhbGlkYXRpb24gZ2xvYmFsbHlcbiAgICogICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsXG4gICAqICAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1JFR0lPTik7XG4gICAqICAgQHJlYWRvbmx5XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqIEAhYXR0cmlidXRlIFNFTkRcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCBpbml0aWF0ZXMgdGhlIEhUVFAgY29ubmVjdGlvbiBmb3IgYVxuICAgKiAgIHJlcXVlc3QgYmVpbmcgc2VudC4gSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnNlbmQgJ3NlbmQnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgUmVwbGFjaW5nIHRoZSBIVFRQIGhhbmRsZXJcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkQ7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdzZW5kJywgbGlzdGVuZXIpO1xuICAgKiAgICAgcmVxdWVzdC5vbignc2VuZCcsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAqICAgICAgIGN1c3RvbUhhbmRsZXIuc2VuZChyZXNwb25zZSk7XG4gICAqICAgICB9KTtcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogICBAcmVhZG9ubHlcbiAgICogQCFhdHRyaWJ1dGUgSFRUUF9EQVRBXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgcmVhZHMgZGF0YSBmcm9tIHRoZSBIVFRQIGNvbm5lY3Rpb24gaW4gb3JkZXJcbiAgICogICB0byBidWlsZCB0aGUgcmVzcG9uc2UgZGF0YS5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+aHR0cERhdGEgJ2h0dHBEYXRhJyBSZXF1ZXN0IGV2ZW50fS5cbiAgICogICBSZW1vdmUgdGhpcyBoYW5kbGVyIGlmIHlvdSBhcmUgb3ZlcnJpZGluZyB0aGUgJ2h0dHBEYXRhJyBldmVudCBhbmRcbiAgICogICBkbyBub3Qgd2FudCBleHRyYSBkYXRhIHByb2Nlc3NpbmcgYW5kIGJ1ZmZlcmluZyBvdmVyaGVhZC5cbiAgICogICBAZXhhbXBsZSBEaXNhYmxpbmcgZGVmYXVsdCBkYXRhIHByb2Nlc3NpbmdcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQTtcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2h0dHBEYXRhJywgbGlzdGVuZXIpO1xuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiAgIEByZWFkb25seVxuICAgKi9cbiAgQ29yZToge30gLyogZG9jIGhhY2sgKi9cbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkF1dGh0eXBlKHJlcSkge1xuICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgcmV0dXJuIG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xufVxuXG5BV1MuRXZlbnRMaXN0ZW5lcnMgPSB7XG4gIENvcmU6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQsIGFkZEFzeW5jKSB7XG4gICAgYWRkQXN5bmMoJ1ZBTElEQVRFX0NSRURFTlRJQUxTJywgJ3ZhbGlkYXRlJyxcbiAgICAgICAgZnVuY3Rpb24gVkFMSURBVEVfQ1JFREVOVElBTFMocmVxLCBkb25lKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uICYmICFyZXEuc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuICAgICAgcmVxLnNlcnZpY2UuY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyLFxuICAgICAgICAgICAge2NvZGU6ICdDcmVkZW50aWFsc0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnLCBpZiB1c2luZyBBV1NfQ09ORklHX0ZJTEUsIHNldCBBV1NfU0RLX0xPQURfQ09ORklHPTEnfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1JFR0lPTicsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIFZBTElEQVRFX1JFR0lPTihyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCkge1xuICAgICAgICB2YXIgZG5zSG9zdFJlZ2V4ID0gbmV3IFJlZ0V4cCgvXihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKSQvKTtcbiAgICAgICAgaWYgKCFyZXEuc2VydmljZS5jb25maWcucmVnaW9uKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAgICB7Y29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgcmVnaW9uIGluIGNvbmZpZyd9KTtcbiAgICAgICAgfSBlbHNlIGlmICghZG5zSG9zdFJlZ2V4LnRlc3QocmVxLnNlcnZpY2UuY29uZmlnLnJlZ2lvbikpIHtcbiAgICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgIHtjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiAnSW52YWxpZCByZWdpb24gaW4gY29uZmlnJ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0JVSUxEX0lERU1QT1RFTkNZX1RPS0VOUycsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIEJVSUxEX0lERU1QT1RFTkNZX1RPS0VOUyhyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICAgICAgaWYgKCFvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlkZW1wb3RlbnRNZW1iZXJzID0gb3BlcmF0aW9uLmlkZW1wb3RlbnRNZW1iZXJzO1xuICAgICAgaWYgKCFpZGVtcG90ZW50TWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlcyBhIGNvcHkgb2YgcGFyYW1zIHNvIHVzZXIncyBwYXJhbSBvYmplY3QgaXNuJ3QgbXV0YXRlZFxuICAgICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocmVxLnBhcmFtcyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGlkZW1wb3RlbnRNZW1iZXJzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICBpZiAoIXBhcmFtc1tpZGVtcG90ZW50TWVtYmVyc1tpXV0pIHtcbiAgICAgICAgICAvLyBhZGQgdGhlIG1lbWJlclxuICAgICAgICAgIHBhcmFtc1tpZGVtcG90ZW50TWVtYmVyc1tpXV0gPSBBV1MudXRpbC51dWlkLnY0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1BBUkFNRVRFUlMnLCAndmFsaWRhdGUnLCBmdW5jdGlvbiBWQUxJREFURV9QQVJBTUVURVJTKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gcmVxLnNlcnZpY2UuY29uZmlnLnBhcmFtVmFsaWRhdGlvbjtcbiAgICAgIG5ldyBBV1MuUGFyYW1WYWxpZGF0b3IodmFsaWRhdGlvbikudmFsaWRhdGUocnVsZXMsIHJlcS5wYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgYWRkKCdDT01QVVRFX0NIRUNLU1VNJywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBDT01QVVRFX0NIRUNLU1VNKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYm9keSA9IHJlcS5odHRwUmVxdWVzdC5ib2R5O1xuICAgICAgdmFyIGlzTm9uU3RyZWFtaW5nUGF5bG9hZCA9IGJvZHkgJiYgKEFXUy51dGlsLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSB8fCB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpO1xuICAgICAgdmFyIGhlYWRlcnMgPSByZXEuaHR0cFJlcXVlc3QuaGVhZGVycztcbiAgICAgIGlmIChcbiAgICAgICAgb3BlcmF0aW9uLmh0dHBDaGVja3N1bVJlcXVpcmVkICYmXG4gICAgICAgIHJlcS5zZXJ2aWNlLmNvbmZpZy5jb21wdXRlQ2hlY2tzdW1zICYmXG4gICAgICAgIGlzTm9uU3RyZWFtaW5nUGF5bG9hZCAmJlxuICAgICAgICAhaGVhZGVyc1snQ29udGVudC1NRDUnXVxuICAgICAgKSB7XG4gICAgICAgIHZhciBtZDUgPSBBV1MudXRpbC5jcnlwdG8ubWQ1KGJvZHksICdiYXNlNjQnKTtcbiAgICAgICAgaGVhZGVyc1snQ29udGVudC1NRDUnXSA9IG1kNTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZEFzeW5jKCdDT01QVVRFX1NIQTI1NicsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gQ09NUFVURV9TSEEyNTYocmVxLCBkb25lKSB7XG4gICAgICByZXEuaGFsdEhhbmRsZXJzT25FcnJvcigpO1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICB2YXIgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb24gJiYgIWF1dGh0eXBlICYmICFyZXEuc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuICAgICAgaWYgKHJlcS5zZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSkgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgICAgIHZhciBib2R5ID0gcmVxLmh0dHBSZXF1ZXN0LmJvZHkgfHwgJyc7XG4gICAgICAgIGlmIChhdXRodHlwZS5pbmRleE9mKCd1bnNpZ25lZC1ib2R5JykgPj0gMCkge1xuICAgICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddID0gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgQVdTLnV0aWwuY29tcHV0ZVNoYTI1Nihib2R5LCBmdW5jdGlvbihlcnIsIHNoYSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9IHNoYTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdTRVRfQ09OVEVOVF9MRU5HVEgnLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIFNFVF9DT05URU5UX0xFTkdUSChyZXEpIHtcbiAgICAgIHZhciBhdXRodHlwZSA9IGdldE9wZXJhdGlvbkF1dGh0eXBlKHJlcSk7XG4gICAgICB2YXIgcGF5bG9hZE1lbWJlciA9IEFXUy51dGlsLmdldFJlcXVlc3RQYXlsb2FkU2hhcGUocmVxKTtcbiAgICAgIGlmIChyZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IEFXUy51dGlsLnN0cmluZy5ieXRlTGVuZ3RoKHJlcS5odHRwUmVxdWVzdC5ib2R5KTtcbiAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGxlbmd0aDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRNZW1iZXIgJiYgcGF5bG9hZE1lbWJlci5pc1N0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKHBheWxvYWRNZW1iZXIucmVxdWlyZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy9zdHJlYW1pbmcgcGF5bG9hZCByZXF1aXJlcyBsZW5ndGgoczMsIGdsYWNpZXIpXG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0aHR5cGUuaW5kZXhPZigndW5zaWduZWQtYm9keScpID49IDApIHtcbiAgICAgICAgICAgICAgLy91bmJvdW5kZWQgc3RyZWFtaW5nIHBheWxvYWQobGV4LCBtZWRpYXN0b3JlKVxuICAgICAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snVHJhbnNmZXItRW5jb2RpbmcnXSA9ICdjaHVua2VkJztcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnU0VUX0hUVFBfSE9TVCcsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gU0VUX0hUVFBfSE9TVChyZXEpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydIb3N0J10gPSByZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICB9KTtcblxuICAgIGFkZCgnUkVTVEFSVCcsICdyZXN0YXJ0JywgZnVuY3Rpb24gUkVTVEFSVCgpIHtcbiAgICAgIHZhciBlcnIgPSB0aGlzLnJlc3BvbnNlLmVycm9yO1xuICAgICAgaWYgKCFlcnIgfHwgIWVyci5yZXRyeWFibGUpIHJldHVybjtcblxuICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QoXG4gICAgICAgIHRoaXMuc2VydmljZS5lbmRwb2ludCxcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnJlZ2lvblxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMucmVzcG9uc2UucmV0cnlDb3VudCA8IHRoaXMuc2VydmljZS5jb25maWcubWF4UmV0cmllcykge1xuICAgICAgICB0aGlzLnJlc3BvbnNlLnJldHJ5Q291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGFkZFRvSGVhZCA9IHRydWU7XG4gICAgYWRkQXN5bmMoJ0RJU0NPVkVSX0VORFBPSU5UJywgJ3NpZ24nLCBESVNDT1ZFUl9FTkRQT0lOVCwgYWRkVG9IZWFkKTtcblxuICAgIGFkZEFzeW5jKCdTSUdOJywgJ3NpZ24nLCBmdW5jdGlvbiBTSUdOKHJlcSwgZG9uZSkge1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciBvcGVyYXRpb25zID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIHZhciBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgICAgaWYgKCFzZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uICYmICFhdXRodHlwZSAmJiAhc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuXG4gICAgICBzZXJ2aWNlLmNvbmZpZy5nZXRDcmVkZW50aWFscyhmdW5jdGlvbiAoZXJyLCBjcmVkZW50aWFscykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkYXRlID0gc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpO1xuICAgICAgICAgIHZhciBTaWduZXJDbGFzcyA9IHNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKTtcbiAgICAgICAgICB2YXIgc2lnbmVyID0gbmV3IFNpZ25lckNsYXNzKHJlcS5odHRwUmVxdWVzdCxcbiAgICAgICAgICAgIHNlcnZpY2UuZ2V0U2lnbmluZ05hbWUocmVxKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlQ2FjaGU6IHNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZUNhY2hlLFxuICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgc2lnbmF0dXJlVmVyc2lvbjogc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgc2lnbmVyLnNldFNlcnZpY2VDbGllbnRJZChzZXJ2aWNlLl9jbGllbnRJZCk7XG5cbiAgICAgICAgICAvLyBjbGVhciBvbGQgYXV0aG9yaXphdGlvbiBoZWFkZXJzXG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ107XG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydEYXRlJ107XG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ107XG5cbiAgICAgICAgICAvLyBhZGQgbmV3IGF1dGhvcml6YXRpb25cbiAgICAgICAgICBzaWduZXIuYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSk7XG4gICAgICAgICAgcmVxLnNpZ25lZEF0ID0gZGF0ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1JFU1BPTlNFJywgJ3ZhbGlkYXRlUmVzcG9uc2UnLCBmdW5jdGlvbiBWQUxJREFURV9SRVNQT05TRShyZXNwKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlLnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwLCB0aGlzKSkge1xuICAgICAgICByZXNwLmRhdGEgPSB7fTtcbiAgICAgICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwLmRhdGEgPSBudWxsO1xuICAgICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAge2NvZGU6ICdVbmtub3duRXJyb3InLCBtZXNzYWdlOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC4nfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRBc3luYygnU0VORCcsICdzZW5kJywgZnVuY3Rpb24gU0VORChyZXNwLCBkb25lKSB7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5fYWJvcnRDYWxsYmFjayA9IGRvbmU7XG4gICAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGh0dHBSZXNwKSB7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbSA9IGh0dHBSZXNwO1xuICAgICAgICB2YXIgc3RyZWFtID0gcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnN0cmVhbTtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSByZXNwLnJlcXVlc3Quc2VydmljZTtcbiAgICAgICAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpO1xuICAgICAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IHJlc3AucmVxdWVzdC5vcGVyYXRpb247XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBhcGkub3BlcmF0aW9uc1tvcGVyYXRpb25OYW1lXSB8fCB7fTtcblxuICAgICAgICBodHRwUmVzcC5vbignaGVhZGVycycsIGZ1bmN0aW9uIG9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoXG4gICAgICAgICAgICAnaHR0cEhlYWRlcnMnLFxuICAgICAgICAgICAgW3N0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3AsIHN0YXR1c01lc3NhZ2VdXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHsgLy8gc3RyZWFtczIgQVBJIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGlmIHdlIGRldGVjdCBldmVudCBzdHJlYW1zLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvXG4gICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQgJiYgc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHJlYWRpbmcgdGhlIEluY29taW5nU3RyZWFtXG4gICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb25lJyk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGh0dHBSZXNwLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uIG9uUmVhZGFibGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBodHRwUmVzcC5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRGF0YScsIFtkYXRhLCByZXNwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGxlZ2FjeSBzdHJlYW1zIEFQSVxuICAgICAgICAgICAgICBodHRwUmVzcC5vbignZGF0YScsIGZ1bmN0aW9uIG9uRGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEYXRhJywgW2RhdGEsIHJlc3BdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBodHRwUmVzcC5vbignZW5kJywgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0gfHwgIXN0cmVhbS5kaWRDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyICYmIChvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQgJiYgc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkpKSB7XG4gICAgICAgICAgICAgIC8vIGRvbid0IGNvbmNhdGVuYXRlIHJlc3BvbnNlIGNodW5rcyB3aGVuIHN0cmVhbWluZyBldmVudCBzdHJlYW0gZGF0YSB3aGVuIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb25lJyk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoaHR0cFJlc3ApIHtcbiAgICAgICAgaHR0cFJlc3Aub24oJ3NlbmRQcm9ncmVzcycsIGZ1bmN0aW9uIG9uU2VuZFByb2dyZXNzKHZhbHVlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBVcGxvYWRQcm9ncmVzcycsIFt2YWx1ZSwgcmVzcF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBodHRwUmVzcC5vbigncmVjZWl2ZVByb2dyZXNzJywgZnVuY3Rpb24gb25SZWNlaXZlUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvd25sb2FkUHJvZ3Jlc3MnLCBbdmFsdWUsIHJlc3BdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdSZXF1ZXN0QWJvcnRlZEVycm9yJykge1xuICAgICAgICAgIHZhciBlcnJDb2RlID0gZXJyLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InID8gZXJyLmNvZGUgOiAnTmV0d29ya2luZ0Vycm9yJztcbiAgICAgICAgICBlcnIgPSBBV1MudXRpbC5lcnJvcihlcnIsIHtcbiAgICAgICAgICAgIGNvZGU6IGVyckNvZGUsXG4gICAgICAgICAgICByZWdpb246IHJlc3AucmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24sXG4gICAgICAgICAgICBob3N0bmFtZTogcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcC5lcnJvciA9IGVycjtcbiAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBFcnJvcicsIFtyZXNwLmVycm9yLCByZXNwXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZVNlbmQoKSB7XG4gICAgICAgIHZhciBodHRwID0gQVdTLkh0dHBDbGllbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIGh0dHBPcHRpb25zID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmh0dHBPcHRpb25zIHx8IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBodHRwLmhhbmRsZVJlcXVlc3QocmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LCBodHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBlcnJvcik7XG4gICAgICAgICAgcHJvZ3Jlc3Moc3RyZWFtKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRpbWVEaWZmID0gKHJlc3AucmVxdWVzdC5zZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkgLSB0aGlzLnNpZ25lZEF0KSAvIDEwMDA7XG4gICAgICBpZiAodGltZURpZmYgPj0gNjAgKiAxMCkgeyAvLyBpZiB3ZSBzaWduZWQgMTBtaW4gYWdvLCByZS1zaWduXG4gICAgICAgIHRoaXMuZW1pdCgnc2lnbicsIFt0aGlzXSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgIGVsc2UgZXhlY3V0ZVNlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRlU2VuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdIVFRQX0hFQURFUlMnLCAnaHR0cEhlYWRlcnMnLFxuICAgICAgICBmdW5jdGlvbiBIVFRQX0hFQURFUlMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCwgc3RhdHVzTWVzc2FnZSkge1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYm9keSA9IEFXUy51dGlsLmJ1ZmZlci50b0J1ZmZlcignJyk7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzID0gW107XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcyA9IDA7XG4gICAgICB2YXIgZGF0ZUhlYWRlciA9IGhlYWRlcnMuZGF0ZSB8fCBoZWFkZXJzLkRhdGU7XG4gICAgICB2YXIgc2VydmljZSA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlO1xuICAgICAgaWYgKGRhdGVIZWFkZXIpIHtcbiAgICAgICAgdmFyIHNlcnZlclRpbWUgPSBEYXRlLnBhcnNlKGRhdGVIZWFkZXIpO1xuICAgICAgICBpZiAoc2VydmljZS5jb25maWcuY29ycmVjdENsb2NrU2tld1xuICAgICAgICAgICAgJiYgc2VydmljZS5pc0Nsb2NrU2tld2VkKHNlcnZlclRpbWUpKSB7XG4gICAgICAgICAgc2VydmljZS5hcHBseUNsb2NrT2Zmc2V0KHNlcnZlclRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0hUVFBfREFUQScsICdodHRwRGF0YScsIGZ1bmN0aW9uIEhUVFBfREFUQShjaHVuaywgcmVzcCkge1xuICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc05vZGUoKSkge1xuICAgICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgIHZhciB0b3RhbCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0geyBsb2FkZWQ6IHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzLCB0b3RhbDogdG90YWwgfTtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvd25sb2FkUHJvZ3Jlc3MnLCBbcHJvZ3Jlc3MsIHJlc3BdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMucHVzaChBV1MudXRpbC5idWZmZXIudG9CdWZmZXIoY2h1bmspKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9ET05FJywgJ2h0dHBEb25lJywgZnVuY3Rpb24gSFRUUF9ET05FKHJlc3ApIHtcbiAgICAgIC8vIGNvbnZlcnQgYnVmZmVycyBhcnJheSBpbnRvIHNpbmdsZSBidWZmZXJcbiAgICAgIGlmIChyZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzICYmIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYm9keSA9IEFXUy51dGlsLmJ1ZmZlci5jb25jYXQocmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycyk7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzO1xuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ0ZJTkFMSVpFX0VSUk9SJywgJ3JldHJ5JywgZnVuY3Rpb24gRklOQUxJWkVfRVJST1IocmVzcCkge1xuICAgICAgaWYgKHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgcmVzcC5lcnJvci5zdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IucmV0cnlhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRoaXMuc2VydmljZS5yZXRyeWFibGVFcnJvcihyZXNwLmVycm9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdJTlZBTElEQVRFX0NSRURFTlRJQUxTJywgJ3JldHJ5JywgZnVuY3Rpb24gSU5WQUxJREFURV9DUkVERU5USUFMUyhyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIHN3aXRjaCAocmVzcC5lcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ1JlcXVlc3RFeHBpcmVkJzogLy8gRUMyIG9ubHlcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJzpcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuJzpcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmV4cGlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdFWFBJUkVEX1NJR05BVFVSRScsICdyZXRyeScsIGZ1bmN0aW9uIEVYUElSRURfU0lHTkFUVVJFKHJlc3ApIHtcbiAgICAgIHZhciBlcnIgPSByZXNwLmVycm9yO1xuICAgICAgaWYgKCFlcnIpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmNvZGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlLm1hdGNoKC9TaWduYXR1cmUvKSAmJiBlcnIubWVzc2FnZS5tYXRjaCgvZXhwaXJlZC8pKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NMT0NLX1NLRVdFRCcsICdyZXRyeScsIGZ1bmN0aW9uIENMT0NLX1NLRVdFRChyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuY2xvY2tTa2V3RXJyb3IocmVzcC5lcnJvcilcbiAgICAgICAgICAmJiB0aGlzLnNlcnZpY2UuY29uZmlnLmNvcnJlY3RDbG9ja1NrZXcpIHtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdSRURJUkVDVCcsICdyZXRyeScsIGZ1bmN0aW9uIFJFRElSRUNUKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLmVycm9yICYmIHJlc3AuZXJyb3Iuc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgICAgICByZXNwLmVycm9yLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSkge1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmVuZHBvaW50ID1cbiAgICAgICAgICBuZXcgQVdTLkVuZHBvaW50KHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2xvY2F0aW9uJ10pO1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0hvc3QnXSA9IHRoaXMuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICAgICAgcmVzcC5lcnJvci5yZWRpcmVjdCA9IHRydWU7XG4gICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbiBSRVRSWV9DSEVDSyhyZXNwKSB7XG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZWRpcmVjdCAmJiByZXNwLnJlZGlyZWN0Q291bnQgPCByZXNwLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlEZWxheSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gdGhpcy5zZXJ2aWNlLnJldHJ5RGVsYXlzKHJlc3AucmV0cnlDb3VudCwgcmVzcC5lcnJvcikgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkQXN5bmMoJ1JFU0VUX1JFVFJZX1NUQVRFJywgJ2FmdGVyUmV0cnknLCBmdW5jdGlvbiBSRVNFVF9SRVRSWV9TVEFURShyZXNwLCBkb25lKSB7XG4gICAgICB2YXIgZGVsYXksIHdpbGxSZXRyeSA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBkZWxheSA9IHJlc3AuZXJyb3IucmV0cnlEZWxheSB8fCAwO1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZXRyeWFibGUgJiYgcmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5yZXRyeUNvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLmVycm9yLnJlZGlyZWN0ICYmIHJlc3AucmVkaXJlY3RDb3VudCA8IHJlc3AubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgcmVzcC5yZWRpcmVjdENvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWxheSA8IDAgaXMgYSBzaWduYWwgZnJvbSBjdXN0b21CYWNrb2ZmIHRvIHNraXAgcmV0cmllc1xuICAgICAgaWYgKHdpbGxSZXRyeSAmJiBkZWxheSA+PSAwKSB7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgQ29yZVBvc3Q6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0VYVFJBQ1RfUkVRVUVTVF9JRCcsICdleHRyYWN0RGF0YScsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuICAgIGFkZCgnRVhUUkFDVF9SRVFVRVNUX0lEJywgJ2V4dHJhY3RFcnJvcicsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuXG4gICAgYWRkKCdFTk9URk9VTkRfRVJST1InLCAnaHR0cEVycm9yJywgZnVuY3Rpb24gRU5PVEZPVU5EX0VSUk9SKGVycikge1xuICAgICAgZnVuY3Rpb24gaXNETlNFcnJvcihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVyci5lcnJubyA9PT0gJ0VOT1RGT1VORCcgfHxcbiAgICAgICAgICB0eXBlb2YgZXJyLmVycm5vID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgIHR5cGVvZiBBV1MudXRpbC5nZXRTeXN0ZW1FcnJvck5hbWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBbJ0VBSV9OT05BTUUnLCAnRUFJX05PREFUQSddLmluZGV4T2YoQVdTLnV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lKGVyci5lcnJubykgPj0gMCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdOZXR3b3JraW5nRXJyb3InICYmIGlzRE5TRXJyb3IoZXJyKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdJbmFjY2Vzc2libGUgaG9zdDogYCcgKyBlcnIuaG9zdG5hbWUgKyAnXFwnIGF0IHBvcnQgYCcgKyBlcnIucG9ydCArXG4gICAgICAgICAgJ1xcJy4gVGhpcyBzZXJ2aWNlIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBgJyArIGVyci5yZWdpb24gK1xuICAgICAgICAgICdcXCcgcmVnaW9uLic7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtcbiAgICAgICAgICBjb2RlOiAnVW5rbm93bkVuZHBvaW50JyxcbiAgICAgICAgICByZWdpb246IGVyci5yZWdpb24sXG4gICAgICAgICAgaG9zdG5hbWU6IGVyci5ob3N0bmFtZSxcbiAgICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBMb2dnZXI6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0xPR19SRVFVRVNUJywgJ2NvbXBsZXRlJywgZnVuY3Rpb24gTE9HX1JFUVVFU1QocmVzcCkge1xuICAgICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICAgIHZhciBsb2dnZXIgPSByZXEuc2VydmljZS5jb25maWcubG9nZ2VyO1xuICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgIGZ1bmN0aW9uIGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLCBzaGFwZSkge1xuICAgICAgICBpZiAoIXNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmlzU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuICcqKipTZW5zaXRpdmVJbmZvcm1hdGlvbioqKic7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpbnB1dFNoYXBlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdHJ1Y3R1cmUnOlxuICAgICAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICAgICAgQVdTLnV0aWwuZWFjaChzaGFwZSwgZnVuY3Rpb24oc3ViU2hhcGVOYW1lLCBzdWJTaGFwZSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0U2hhcGUubWVtYmVycywgc3ViU2hhcGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHN0cnVjdFtzdWJTaGFwZU5hbWVdID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUubWVtYmVyc1tzdWJTaGFwZU5hbWVdLCBzdWJTaGFwZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RydWN0W3N1YlNoYXBlTmFtZV0gPSBzdWJTaGFwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzaGFwZSwgZnVuY3Rpb24oc3ViU2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGxpc3QucHVzaChmaWx0ZXJTZW5zaXRpdmVMb2coaW5wdXRTaGFwZS5tZW1iZXIsIHN1YlNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgICBBV1MudXRpbC5lYWNoKHNoYXBlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSByZXNwLnJlcXVlc3Quc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gKHRpbWUgLSByZXEuc3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgICB2YXIgYW5zaSA9IGxvZ2dlci5pc1RUWSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBjZW5zb3JlZFBhcmFtcyA9IHJlcS5wYXJhbXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucyAmJlxuICAgICAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXSAmJlxuICAgICAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICAgICAgICAgIGNlbnNvcmVkUGFyYW1zID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUsIHJlcS5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdChjZW5zb3JlZFBhcmFtcywgdHJ1ZSwgbnVsbCk7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChhbnNpKSBtZXNzYWdlICs9ICdcXHgxQlszM20nO1xuICAgICAgICBtZXNzYWdlICs9ICdbQVdTICcgKyByZXEuc2VydmljZS5zZXJ2aWNlSWRlbnRpZmllciArICcgJyArIHN0YXR1cztcbiAgICAgICAgbWVzc2FnZSArPSAnICcgKyBkZWx0YS50b1N0cmluZygpICsgJ3MgJyArIHJlc3AucmV0cnlDb3VudCArICcgcmV0cmllc10nO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMDsxbSc7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgQVdTLnV0aWwuc3RyaW5nLmxvd2VyRmlyc3QocmVxLm9wZXJhdGlvbik7XG4gICAgICAgIG1lc3NhZ2UgKz0gJygnICsgcGFyYW1zICsgJyknO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMG0nO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSBidWlsZE1lc3NhZ2UoKTtcbiAgICAgIGlmICh0eXBlb2YgbG9nZ2VyLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKGxpbmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbG9nZ2VyLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci53cml0ZShsaW5lICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBKc29uOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvanNvbicpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0OiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdCcpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0SnNvbjogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfanNvbicpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0WG1sOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF94bWwnKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUXVlcnk6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9xdWVyeScpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBUaGUgZW5kcG9pbnQgdGhhdCBhIHNlcnZpY2Ugd2lsbCB0YWxrIHRvLCBmb3IgZXhhbXBsZSxcbiAqIGAnaHR0cHM6Ly9lYzIuYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbSdgLiBJZlxuICogeW91IG5lZWQgdG8gb3ZlcnJpZGUgYW4gZW5kcG9pbnQgZm9yIGEgc2VydmljZSwgeW91IGNhblxuICogc2V0IHRoZSBlbmRwb2ludCBvbiBhIHNlcnZpY2UgYnkgcGFzc2luZyB0aGUgZW5kcG9pbnRcbiAqIG9iamVjdCB3aXRoIHRoZSBgZW5kcG9pbnRgIG9wdGlvbiBrZXk6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGVwID0gbmV3IEFXUy5FbmRwb2ludCgnYXdzcHJveHkuZXhhbXBsZS5jb20nKTtcbiAqIHZhciBzMyA9IG5ldyBBV1MuUzMoe2VuZHBvaW50OiBlcH0pO1xuICogczMuc2VydmljZS5lbmRwb2ludC5ob3N0bmFtZSA9PSAnYXdzcHJveHkuZXhhbXBsZS5jb20nXG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IGRvIG5vdCBzcGVjaWZ5IGEgcHJvdG9jb2wsIHRoZSBwcm90b2NvbCB3aWxsXG4gKiBiZSBzZWxlY3RlZCBiYXNlZCBvbiB5b3VyIGN1cnJlbnQge0FXUy5jb25maWd9IGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQCFhdHRyaWJ1dGUgcHJvdG9jb2xcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcHJvdG9jb2wgKGh0dHAgb3IgaHR0cHMpIG9mIHRoZSBlbmRwb2ludFxuICogICAgIFVSTFxuICogQCFhdHRyaWJ1dGUgaG9zdG5hbWVcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoZSBlbmRwb2ludCwgZS5nLixcbiAqICAgICBleGFtcGxlLmNvbVxuICogQCFhdHRyaWJ1dGUgaG9zdFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBob3N0IHBvcnRpb24gb2YgdGhlIGVuZHBvaW50IGluY2x1ZGluZ1xuICogICAgIHRoZSBwb3J0LCBlLmcuLCBleGFtcGxlLmNvbTo4MFxuICogQCFhdHRyaWJ1dGUgcG9ydFxuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgcG9ydCBvZiB0aGUgZW5kcG9pbnRcbiAqIEAhYXR0cmlidXRlIGhyZWZcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgZnVsbCBVUkwgb2YgdGhlIGVuZHBvaW50XG4gKi9cbkFXUy5FbmRwb2ludCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgRW5kcG9pbnQoZW5kcG9pbnQpXG4gICAqICAgQ29uc3RydWN0cyBhIG5ldyBlbmRwb2ludCBnaXZlbiBhbiBlbmRwb2ludCBVUkwuIElmIHRoZVxuICAgKiAgIFVSTCBvbWl0cyBhIHByb3RvY29sIChodHRwIG9yIGh0dHBzKSwgdGhlIGRlZmF1bHQgcHJvdG9jb2xcbiAgICogICBzZXQgaW4gdGhlIGdsb2JhbCB7QVdTLmNvbmZpZ30gd2lsbCBiZSB1c2VkLlxuICAgKiAgIEBwYXJhbSBlbmRwb2ludCBbU3RyaW5nXSB0aGUgVVJMIHRvIGNvbnN0cnVjdCBhbiBlbmRwb2ludCBmcm9tXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gRW5kcG9pbnQoZW5kcG9pbnQsIGNvbmZpZykge1xuICAgIEFXUy51dGlsLmhpZGVQcm9wZXJ0aWVzKHRoaXMsIFsnc2xhc2hlcycsICdhdXRoJywgJ2hhc2gnLCAnc2VhcmNoJywgJ3F1ZXJ5J10pO1xuXG4gICAgaWYgKHR5cGVvZiBlbmRwb2ludCA9PT0gJ3VuZGVmaW5lZCcgfHwgZW5kcG9pbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmRwb2ludDogJyArIGVuZHBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmRwb2ludCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBBV1MudXRpbC5jb3B5KGVuZHBvaW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWVuZHBvaW50Lm1hdGNoKC9eaHR0cC8pKSB7XG4gICAgICB2YXIgdXNlU1NMID0gY29uZmlnICYmIGNvbmZpZy5zc2xFbmFibGVkICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBjb25maWcuc3NsRW5hYmxlZCA6IEFXUy5jb25maWcuc3NsRW5hYmxlZDtcbiAgICAgIGVuZHBvaW50ID0gKHVzZVNTTCA/ICdodHRwcycgOiAnaHR0cCcpICsgJzovLycgKyBlbmRwb2ludDtcbiAgICB9XG5cbiAgICBBV1MudXRpbC51cGRhdGUodGhpcywgQVdTLnV0aWwudXJsUGFyc2UoZW5kcG9pbnQpKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgcG9ydCBwcm9wZXJ0eSBpcyBzZXQgYXMgYW4gaW50ZWdlclxuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBhcnNlSW50KHRoaXMucG9ydCwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcnQgPSB0aGlzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG59KTtcblxuLyoqXG4gKiBUaGUgbG93IGxldmVsIEhUVFAgcmVxdWVzdCBvYmplY3QsIGVuY2Fwc3VsYXRpbmcgYWxsIEhUVFAgaGVhZGVyXG4gKiBhbmQgYm9keSBkYXRhIHNlbnQgYnkgYSBzZXJ2aWNlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgbWV0aG9kXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEhUVFAgbWV0aG9kIG9mIHRoZSByZXF1ZXN0XG4gKiBAIWF0dHJpYnV0ZSBwYXRoXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgVVJJLCBlLmcuLFxuICogICAgIFwiL2xpc3QvP3N0YXJ0PTUmbnVtPTEwXCJcbiAqIEAhYXR0cmlidXRlIGhlYWRlcnNcbiAqICAgQHJldHVybiBbbWFwPFN0cmluZyxTdHJpbmc+XVxuICogICAgIGEgbWFwIG9mIGhlYWRlciBrZXlzIGFuZCB0aGVpciByZXNwZWN0aXZlIHZhbHVlc1xuICogQCFhdHRyaWJ1dGUgYm9keVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXF1ZXN0IGJvZHkgcGF5bG9hZFxuICogQCFhdHRyaWJ1dGUgZW5kcG9pbnRcbiAqICAgQHJldHVybiBbQVdTLkVuZHBvaW50XSB0aGUgZW5kcG9pbnQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAIWF0dHJpYnV0ZSByZWdpb25cbiAqICAgQGFwaSBwcml2YXRlXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHJlZ2lvbiwgZm9yIHNpZ25pbmcgcHVycG9zZXMgb25seS5cbiAqL1xuQVdTLkh0dHBSZXF1ZXN0ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KGVuZHBvaW50LCByZWdpb24pIHtcbiAgICBlbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgIHRoaXMubWV0aG9kID0gJ1BPU1QnO1xuICAgIHRoaXMucGF0aCA9IGVuZHBvaW50LnBhdGggfHwgJy8nO1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgIHRoaXMuYm9keSA9ICcnO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSAnJztcbiAgICB0aGlzLnNldFVzZXJBZ2VudCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldFVzZXJBZ2VudDogZnVuY3Rpb24gc2V0VXNlckFnZW50KCkge1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHRoaXMuaGVhZGVyc1t0aGlzLmdldFVzZXJBZ2VudEhlYWRlck5hbWUoKV0gPSBBV1MudXRpbC51c2VyQWdlbnQoKTtcbiAgfSxcblxuICBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lOiBmdW5jdGlvbiBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCkge1xuICAgIHZhciBwcmVmaXggPSBBV1MudXRpbC5pc0Jyb3dzZXIoKSA/ICdYLUFtei0nIDogJyc7XG4gICAgcmV0dXJuIHByZWZpeCArICdVc2VyLUFnZW50JztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcHBlbmRUb1VzZXJBZ2VudDogZnVuY3Rpb24gYXBwZW5kVG9Vc2VyQWdlbnQoYWdlbnRQYXJ0aWFsKSB7XG4gICAgaWYgKHR5cGVvZiBhZ2VudFBhcnRpYWwgPT09ICdzdHJpbmcnICYmIGFnZW50UGFydGlhbCkge1xuICAgICAgdGhpcy5fdXNlckFnZW50ICs9ICcgJyArIGFnZW50UGFydGlhbDtcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzW3RoaXMuZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpXSA9IHRoaXMuX3VzZXJBZ2VudDtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRVc2VyQWdlbnQ6IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckFnZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBwYXJ0IG9mIHRoZSB7cGF0aH0gZXhjbHVkaW5nIHRoZVxuICAgKiAgIHF1ZXJ5IHN0cmluZ1xuICAgKi9cbiAgcGF0aG5hbWU6IGZ1bmN0aW9uIHBhdGhuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGguc3BsaXQoJz8nLCAxKVswXTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIHtwYXRofVxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5wYXRoLnNwbGl0KCc/JywgMilbMV07XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IEFXUy51dGlsLnF1ZXJ5U3RyaW5nUGFyc2UocXVlcnkpO1xuICAgICAgcmV0dXJuIEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiB1cGRhdGUgaHR0cFJlcXVlc3QgZW5kcG9pbnQgd2l0aCBlbmRwb2ludCBzdHJpbmdcbiAgICovXG4gIHVwZGF0ZUVuZHBvaW50OiBmdW5jdGlvbiB1cGRhdGVFbmRwb2ludChlbmRwb2ludFN0cikge1xuICAgIHZhciBuZXdFbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnRTdHIpO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBuZXdFbmRwb2ludDtcbiAgICB0aGlzLnBhdGggPSBuZXdFbmRwb2ludC5wYXRoIHx8ICcvJztcbiAgICBpZiAodGhpcy5oZWFkZXJzWydIb3N0J10pIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snSG9zdCddID0gbmV3RW5kcG9pbnQuaG9zdDtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBsb3cgbGV2ZWwgSFRUUCByZXNwb25zZSBvYmplY3QsIGVuY2Fwc3VsYXRpbmcgYWxsIEhUVFAgaGVhZGVyXG4gKiBhbmQgYm9keSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3RhdHVzQ29kZVxuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgSFRUUCBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIDIwMCwgNDA0KVxuICogQCFhdHRyaWJ1dGUgaGVhZGVyc1xuICogICBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dXG4gKiAgICAgIGEgbWFwIG9mIHJlc3BvbnNlIGhlYWRlciBrZXlzIGFuZCB0aGVpciByZXNwZWN0aXZlIHZhbHVlc1xuICogQCFhdHRyaWJ1dGUgYm9keVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBib2R5IHBheWxvYWRcbiAqIEAhYXR0cmlidXRlIFtyXSBzdHJlYW1pbmdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGlzIHJlc3BvbnNlIGlzIGJlaW5nIHN0cmVhbWVkIGF0IGEgbG93LWxldmVsLlxuICogICAgIERlZmF1bHRzIHRvIGBmYWxzZWAgKGJ1ZmZlcmVkIHJlYWRzKS4gRG8gbm90IG1vZGlmeSB0aGlzIG1hbnVhbGx5LCB1c2VcbiAqICAgICB7Y3JlYXRlVW5idWZmZXJlZFN0cmVhbX0gdG8gY29udmVydCB0aGUgc3RyZWFtIHRvIHVuYnVmZmVyZWQgbW9kZVxuICogICAgIGluc3RlYWQuXG4gKi9cbkFXUy5IdHRwUmVzcG9uc2UgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gSHR0cFJlc3BvbnNlKCkge1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGJ1ZmZlcmluZyBvbiB0aGUgSFRUUCByZXNwb25zZSBhbmQgcmV0dXJucyB0aGUgc3RyZWFtIGZvciByZWFkaW5nLlxuICAgKiBAcmV0dXJuIFtTdHJlYW0sIFhNTEh0dHBSZXF1ZXN0LCBudWxsXSB0aGUgdW5kZXJseWluZyBzdHJlYW0gb2JqZWN0LlxuICAgKiAgIFVzZSB0aGlzIG9iamVjdCB0byBkaXJlY3RseSByZWFkIGRhdGEgb2ZmIG9mIHRoZSBzdHJlYW0uXG4gICAqIEBub3RlIFRoaXMgb2JqZWN0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7QVdTLlJlcXVlc3R+aHR0cEhlYWRlcnN9XG4gICAqICAgZXZlbnQgaGFzIGZpcmVkLiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBwcmlvciB0b1xuICAgKiAgIHtBV1MuUmVxdWVzdH5odHRwRGF0YX0uXG4gICAqIEBleGFtcGxlIFRha2luZyBjb250cm9sIG9mIGEgc3RyZWFtXG4gICAqICAgcmVxdWVzdC5vbignaHR0cEhlYWRlcnMnLCBmdW5jdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKSB7XG4gICAqICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgKiAgICAgICBpZiAoaGVhZGVycy5ldGFnID09PSAneHl6Jykge1xuICAgKiAgICAgICAgIC8vIHBpcGUgdGhlIHN0cmVhbSwgZGlzYWJsaW5nIGJ1ZmZlcmluZ1xuICAgKiAgICAgICAgIHZhciBzdHJlYW0gPSB0aGlzLnJlc3BvbnNlLmh0dHBSZXNwb25zZS5jcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCk7XG4gICAqICAgICAgICAgc3RyZWFtLnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgKiAgICAgICB9IGVsc2UgeyAvLyBhYm9ydCB0aGlzIHJlcXVlc3QgYW5kIHNldCBhIGJldHRlciBlcnJvciBtZXNzYWdlXG4gICAqICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgKiAgICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgRVRhZycpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgfSkuc2VuZChjb25zb2xlLmxvZyk7XG4gICAqL1xuICBjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCkge1xuICAgIHRoaXMuc3RyZWFtaW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW07XG4gIH1cbn0pO1xuXG5cbkFXUy5IdHRwQ2xpZW50ID0gaW5oZXJpdCh7fSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5IdHRwQ2xpZW50LmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gIGlmICh0aGlzLnNpbmdsZXRvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zaW5nbGV0b24gPSBuZXcgdGhpcygpO1xuICB9XG4gIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5TdHJlYW07XG52YXIgVHJhbnNmb3JtU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlRyYW5zZm9ybTtcbnZhciBSZWFkYWJsZVN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5SZWFkYWJsZTtcbnJlcXVpcmUoJy4uL2h0dHAnKTtcbnZhciBDT05ORUNUSU9OX1JFVVNFX0VOVl9OQU1FID0gJ0FXU19OT0RFSlNfQ09OTkVDVElPTl9SRVVTRV9FTkFCTEVEJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLk5vZGVIdHRwQ2xpZW50ID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIGhhbmRsZVJlcXVlc3Q6IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QoaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLCBjYWxsYmFjaywgZXJyQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVuZHBvaW50ID0gaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gICAgdmFyIHBhdGhQcmVmaXggPSAnJztcbiAgICBpZiAoIWh0dHBPcHRpb25zKSBodHRwT3B0aW9ucyA9IHt9O1xuICAgIGlmIChodHRwT3B0aW9ucy5wcm94eSkge1xuICAgICAgcGF0aFByZWZpeCA9IGVuZHBvaW50LnByb3RvY29sICsgJy8vJyArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgICAgaWYgKGVuZHBvaW50LnBvcnQgIT09IDgwICYmIGVuZHBvaW50LnBvcnQgIT09IDQ0Mykge1xuICAgICAgICBwYXRoUHJlZml4ICs9ICc6JyArIGVuZHBvaW50LnBvcnQ7XG4gICAgICB9XG4gICAgICBlbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoaHR0cE9wdGlvbnMucHJveHkpO1xuICAgIH1cblxuICAgIHZhciB1c2VTU0wgPSBlbmRwb2ludC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgdmFyIGh0dHAgPSB1c2VTU0wgPyByZXF1aXJlKCdodHRwcycpIDogcmVxdWlyZSgnaHR0cCcpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogZW5kcG9pbnQuaG9zdG5hbWUsXG4gICAgICBwb3J0OiBlbmRwb2ludC5wb3J0LFxuICAgICAgbWV0aG9kOiBodHRwUmVxdWVzdC5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBodHRwUmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcGF0aDogcGF0aFByZWZpeCArIGh0dHBSZXF1ZXN0LnBhdGhcbiAgICB9O1xuXG4gICAgaWYgKCFodHRwT3B0aW9ucy5hZ2VudCkge1xuICAgICAgb3B0aW9ucy5hZ2VudCA9IHRoaXMuZ2V0QWdlbnQodXNlU1NMLCB7XG4gICAgICAgIGtlZXBBbGl2ZTogcHJvY2Vzcy5lbnZbQ09OTkVDVElPTl9SRVVTRV9FTlZfTkFNRV0gPT09ICcxJyA/IHRydWUgOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgQVdTLnV0aWwudXBkYXRlKG9wdGlvbnMsIGh0dHBPcHRpb25zKTtcbiAgICBkZWxldGUgb3B0aW9ucy5wcm94eTsgLy8gcHJveHkgaXNuJ3QgYW4gSFRUUCBvcHRpb25cbiAgICBkZWxldGUgb3B0aW9ucy50aW1lb3V0OyAvLyB0aW1lb3V0IGlzbid0IGFuIEhUVFAgb3B0aW9uXG5cbiAgICB2YXIgc3RyZWFtID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIChodHRwUmVzcCkge1xuICAgICAgaWYgKHN0cmVhbS5kaWRDYWxsYmFjaykgcmV0dXJuO1xuXG4gICAgICBjYWxsYmFjayhodHRwUmVzcCk7XG4gICAgICBodHRwUmVzcC5lbWl0KFxuICAgICAgICAnaGVhZGVycycsXG4gICAgICAgIGh0dHBSZXNwLnN0YXR1c0NvZGUsXG4gICAgICAgIGh0dHBSZXNwLmhlYWRlcnMsXG4gICAgICAgIGh0dHBSZXNwLnN0YXR1c01lc3NhZ2VcbiAgICAgICk7XG4gICAgfSk7XG4gICAgaHR0cFJlcXVlc3Quc3RyZWFtID0gc3RyZWFtOyAvLyBhdHRhY2ggc3RyZWFtIHRvIGh0dHBSZXF1ZXN0XG4gICAgc3RyZWFtLmRpZENhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAvLyBjb25uZWN0aW9uIHRpbWVvdXQgc3VwcG9ydFxuICAgIGlmIChodHRwT3B0aW9ucy5jb25uZWN0VGltZW91dCkge1xuICAgICAgdmFyIGNvbm5lY3RUaW1lb3V0SWQ7XG4gICAgICBzdHJlYW0ub24oJ3NvY2tldCcsIGZ1bmN0aW9uKHNvY2tldCkge1xuICAgICAgICBpZiAoc29ja2V0LmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICBjb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBjb25uZWN0VGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZGlkQ2FsbGJhY2spIHJldHVybjsgc3RyZWFtLmRpZENhbGxiYWNrID0gdHJ1ZTtcblxuICAgICAgICAgICAgc3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdTb2NrZXQgdGltZWQgb3V0IHdpdGhvdXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbicpLFxuICAgICAgICAgICAgICB7Y29kZTogJ1RpbWVvdXRFcnJvcid9XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9LCBodHRwT3B0aW9ucy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjb25uZWN0VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdGltZW91dCBzdXBwb3J0XG4gICAgc3RyZWFtLnNldFRpbWVvdXQoaHR0cE9wdGlvbnMudGltZW91dCB8fCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzdHJlYW0uZGlkQ2FsbGJhY2spIHJldHVybjsgc3RyZWFtLmRpZENhbGxiYWNrID0gdHJ1ZTtcblxuICAgICAgdmFyIG1zZyA9ICdDb25uZWN0aW9uIHRpbWVkIG91dCBhZnRlciAnICsgaHR0cE9wdGlvbnMudGltZW91dCArICdtcyc7XG4gICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobXNnKSwge2NvZGU6ICdUaW1lb3V0RXJyb3InfSkpO1xuICAgICAgc3RyZWFtLmFib3J0KCk7XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoY29ubmVjdFRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgIGNvbm5lY3RUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5kaWRDYWxsYmFjaykgcmV0dXJuOyBzdHJlYW0uZGlkQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgaWYgKCdFQ09OTlJFU0VUJyA9PT0gZXJyLmNvZGUgfHwgJ0VQSVBFJyA9PT0gZXJyLmNvZGUgfHwgJ0VUSU1FRE9VVCcgPT09IGVyci5jb2RlKSB7XG4gICAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKGVyciwge2NvZGU6ICdUaW1lb3V0RXJyb3InfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBleHBlY3QgPSBodHRwUmVxdWVzdC5oZWFkZXJzLkV4cGVjdCB8fCBodHRwUmVxdWVzdC5oZWFkZXJzLmV4cGVjdDtcbiAgICBpZiAoZXhwZWN0ID09PSAnMTAwLWNvbnRpbnVlJykge1xuICAgICAgc3RyZWFtLm9uY2UoJ2NvbnRpbnVlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYud3JpdGVCb2R5KHN0cmVhbSwgaHR0cFJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVCb2R5KHN0cmVhbSwgaHR0cFJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG5cbiAgd3JpdGVCb2R5OiBmdW5jdGlvbiB3cml0ZUJvZHkoc3RyZWFtLCBodHRwUmVxdWVzdCkge1xuICAgIHZhciBib2R5ID0gaHR0cFJlcXVlc3QuYm9keTtcbiAgICB2YXIgdG90YWxCeXRlcyA9IHBhcnNlSW50KGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10sIDEwKTtcblxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAvLyBGb3IgcHJvZ3Jlc3Mgc3VwcG9ydCBvZiBzdHJlYW1pbmcgY29udGVudCAtXG4gICAgICAvLyBwaXBlIHRoZSBkYXRhIHRocm91Z2ggYSB0cmFuc2Zvcm0gc3RyZWFtIHRvIGVtaXQgJ3NlbmRQcm9ncmVzcycgZXZlbnRzXG4gICAgICB2YXIgcHJvZ3Jlc3NTdHJlYW0gPSB0aGlzLnByb2dyZXNzU3RyZWFtKHN0cmVhbSwgdG90YWxCeXRlcyk7XG4gICAgICBpZiAocHJvZ3Jlc3NTdHJlYW0pIHtcbiAgICAgICAgYm9keS5waXBlKHByb2dyZXNzU3RyZWFtKS5waXBlKHN0cmVhbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LnBpcGUoc3RyZWFtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcbiAgICAgIC8vIFRoZSBwcm92aWRlZCBib2R5IGlzIGEgYnVmZmVyL3N0cmluZyBhbmQgaXMgYWxyZWFkeSBmdWxseSBhdmFpbGFibGUgaW4gbWVtb3J5IC1cbiAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSBpdCdzIGJlc3QgdG8gc2VuZCBpdCBhcyBhIHdob2xlIGJ5IGNhbGxpbmcgc3RyZWFtLmVuZChib2R5KSxcbiAgICAgIC8vIENhbGxlcnMgZXhwZWN0IGEgJ3NlbmRQcm9ncmVzcycgZXZlbnQgd2hpY2ggaXMgYmVzdCBlbWl0dGVkIG9uY2VcbiAgICAgIC8vIHRoZSBodHRwIHJlcXVlc3Qgc3RyZWFtIGhhcyBiZWVuIGZ1bGx5IHdyaXR0ZW4gYW5kIGFsbCBkYXRhIGZsdXNoZWQuXG4gICAgICAvLyBUaGUgdXNlIG9mIHRvdGFsQnl0ZXMgaXMgaW1wb3J0YW50IG92ZXIgYm9keS5sZW5ndGggZm9yIHN0cmluZ3Mgd2hlcmVcbiAgICAgIC8vIGxlbmd0aCBpcyBjaGFyIGxlbmd0aCBhbmQgbm90IGJ5dGUgbGVuZ3RoLlxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnc2VuZFByb2dyZXNzJywge1xuICAgICAgICAgIGxvYWRlZDogdG90YWxCeXRlcyxcbiAgICAgICAgICB0b3RhbDogdG90YWxCeXRlc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgc3RyZWFtLmVuZChib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gcmVxdWVzdCBib2R5XG4gICAgICBzdHJlYW0uZW5kKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGh0dHBzLkFnZW50IG9yIGh0dHAuQWdlbnQgYWNjb3JkaW5nIHRvIHRoZSByZXF1ZXN0IHNjaGVtYS5cbiAgICovXG4gIGdldEFnZW50OiBmdW5jdGlvbiBnZXRBZ2VudCh1c2VTU0wsIGFnZW50T3B0aW9ucykge1xuICAgIHZhciBodHRwID0gdXNlU1NMID8gcmVxdWlyZSgnaHR0cHMnKSA6IHJlcXVpcmUoJ2h0dHAnKTtcbiAgICBpZiAodXNlU1NMKSB7XG4gICAgICBpZiAoIUFXUy5Ob2RlSHR0cENsaWVudC5zc2xBZ2VudCkge1xuICAgICAgICBBV1MuTm9kZUh0dHBDbGllbnQuc3NsQWdlbnQgPSBuZXcgaHR0cC5BZ2VudChBV1MudXRpbC5tZXJnZSh7XG4gICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiBwcm9jZXNzLmVudi5OT0RFX1RMU19SRUpFQ1RfVU5BVVRIT1JJWkVEID09PSAnMCcgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgfSwgYWdlbnRPcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIEFXUy5Ob2RlSHR0cENsaWVudC5zc2xBZ2VudC5zZXRNYXhMaXN0ZW5lcnMoMCk7XG5cbiAgICAgICAgLy8gZGVsZWdhdGUgbWF4U29ja2V0cyB0byBnbG9iYWxBZ2VudCwgc2V0IGEgZGVmYXVsdCBsaW1pdCBvZiA1MCBpZiBjdXJyZW50IHZhbHVlIGlzIEluZmluaXR5LlxuICAgICAgICAvLyBVc2VycyBjYW4gYnlwYXNzIHRoaXMgZGVmYXVsdCBieSBzdXBwbHlpbmcgdGhlaXIgb3duIEFnZW50IGFzIHBhcnQgb2YgU0RLIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBV1MuTm9kZUh0dHBDbGllbnQuc3NsQWdlbnQsICdtYXhTb2NrZXRzJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TWF4U29ja2V0cyA9IDUwO1xuICAgICAgICAgICAgdmFyIGdsb2JhbEFnZW50ID0gaHR0cC5nbG9iYWxBZ2VudDtcbiAgICAgICAgICAgIGlmIChnbG9iYWxBZ2VudCAmJiBnbG9iYWxBZ2VudC5tYXhTb2NrZXRzICE9PSBJbmZpbml0eSAmJiB0eXBlb2YgZ2xvYmFsQWdlbnQubWF4U29ja2V0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbEFnZW50Lm1heFNvY2tldHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1heFNvY2tldHM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBV1MuTm9kZUh0dHBDbGllbnQuc3NsQWdlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghQVdTLk5vZGVIdHRwQ2xpZW50LmFnZW50KSB7XG4gICAgICAgIEFXUy5Ob2RlSHR0cENsaWVudC5hZ2VudCA9IG5ldyBodHRwLkFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQVdTLk5vZGVIdHRwQ2xpZW50LmFnZW50O1xuICAgIH1cbiAgfSxcblxuICBwcm9ncmVzc1N0cmVhbTogZnVuY3Rpb24gcHJvZ3Jlc3NTdHJlYW0oc3RyZWFtLCB0b3RhbEJ5dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1TdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBmb3Igbm9kZSAwLjggdGhlcmUgaXMgbm8gc3RyZWFtaW5nIHByb2dyZXNzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsb2FkZWRCeXRlcyA9IDA7XG4gICAgdmFyIHJlcG9ydGVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgIHJlcG9ydGVyLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgbG9hZGVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBzdHJlYW0uZW1pdCgnc2VuZFByb2dyZXNzJywge1xuICAgICAgICAgIGxvYWRlZDogbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgdG90YWw6IHRvdGFsQnl0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVwb3J0ZXI7XG4gIH0sXG5cbiAgZW1pdHRlcjogbnVsbFxufSk7XG5cbi8qKlxuICogQCFpZ25vcmVcbiAqL1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5wcm90b3R5cGUgPSBBV1MuTm9kZUh0dHBDbGllbnQucHJvdG90eXBlO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9IFJlYWRhYmxlU3RyZWFtID8gMiA6IDE7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gSnNvbkJ1aWxkZXIoKSB7IH1cblxuSnNvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmFuc2xhdGUodmFsdWUsIHNoYXBlKSk7XG59O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUsIHNoYXBlKSB7XG4gIGlmICghc2hhcGUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICBjYXNlICdzdHJ1Y3R1cmUnOiByZXR1cm4gdHJhbnNsYXRlU3RydWN0dXJlKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHRyYW5zbGF0ZU1hcCh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gdHJhbnNsYXRlTGlzdCh2YWx1ZSwgc2hhcGUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTdHJ1Y3R1cmUoc3RydWN0dXJlLCBzaGFwZSkge1xuICBpZiAoc2hhcGUuaXNEb2N1bWVudCkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gIH1cbiAgdmFyIHN0cnVjdCA9IHt9O1xuICB1dGlsLmVhY2goc3RydWN0dXJlLCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlKSB7XG4gICAgICBpZiAobWVtYmVyU2hhcGUubG9jYXRpb24gIT09ICdib2R5JykgcmV0dXJuO1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IG1lbWJlclNoYXBlLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyU2hhcGUubmFtZSA6IG5hbWU7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHN0cnVjdFtsb2NhdGlvbk5hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBvdXQucHVzaChyZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTWFwKG1hcCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1dpcmVGb3JtYXQodmFsdWUpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25CdWlsZGVyO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25QYXJzZXIoKSB7IH1cblxuSnNvblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShKU09OLnBhcnNlKHZhbHVlKSwgc2hhcGUpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHRyYW5zbGF0ZVN0cnVjdHVyZSh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiB0cmFuc2xhdGVNYXAodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU3RydWN0dXJlKHN0cnVjdHVyZSwgc2hhcGUpIHtcbiAgaWYgKHN0cnVjdHVyZSA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoc2hhcGUuaXNEb2N1bWVudCkgcmV0dXJuIHN0cnVjdHVyZTtcblxuICB2YXIgc3RydWN0ID0ge307XG4gIHZhciBzaGFwZU1lbWJlcnMgPSBzaGFwZS5tZW1iZXJzO1xuICB1dGlsLmVhY2goc2hhcGVNZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXJTaGFwZSkge1xuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RydWN0dXJlLCBsb2NhdGlvbk5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJ1Y3R1cmVbbG9jYXRpb25OYW1lXTtcbiAgICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgc3RydWN0W25hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0gW107XG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dC5wdXNoKG51bGwpO1xuICAgIGVsc2Ugb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1hcChtYXAsIHNoYXBlKSB7XG4gIGlmIChtYXAgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0ge307XG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBvdXRba2V5XSA9IG51bGw7XG4gICAgZWxzZSBvdXRba2V5XSA9IHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlLnRvVHlwZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSnNvblBhcnNlcjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnJlcXVpcmUoJy4vaHR0cCcpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGdldE1ldGFkYXRhU2VydmljZUVuZHBvaW50ID0gcmVxdWlyZSgnLi9tZXRhZGF0YV9zZXJ2aWNlL2dldF9tZXRhZGF0YV9zZXJ2aWNlX2VuZHBvaW50Jyk7XG52YXIgVVJMID0gcmVxdWlyZSgndXJsJykuVVJMO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXRhZGF0YSBzZXJ2aWNlIGF2YWlsYWJsZSBvbiBFQzIgaW5zdGFuY2VzLiBVc2luZyB0aGVcbiAqIHtyZXF1ZXN0fSBtZXRob2QsIHlvdSBjYW4gcmVjZWlldmUgbWV0YWRhdGEgYWJvdXQgYW55IGF2YWlsYWJsZSByZXNvdXJjZVxuICogb24gdGhlIG1ldGFkYXRhIHNlcnZpY2UuXG4gKlxuICogWW91IGNhbiBkaXNhYmxlIHRoZSB1c2Ugb2YgdGhlIElNRFMgYnkgc2V0dGluZyB0aGUgQVdTX0VDMl9NRVRBREFUQV9ESVNBQkxFRFxuICogZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKlxuICogQCFhdHRyaWJ1dGUgW3JdIGh0dHBPcHRpb25zXG4gKiAgIEByZXR1cm4gW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIEhUVFAgcmVxdWVzdDpcbiAqXG4gKiAgICAgKiAqKnRpbWVvdXQqKiAoTnVtYmVyKSAmbWRhc2g7IGEgdGltZW91dCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogICAgICAgYmVmb3JlIGFib3J0aW5nIHRoZSBjb25uZWN0aW9uLiBTZXQgdG8gMCBmb3Igbm8gdGltZW91dC5cbiAqXG4gKiBAIW1hY3JvIG5vYnJvd3NlclxuICovXG5BV1MuTWV0YWRhdGFTZXJ2aWNlID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBlbmRwb2ludCBvZiB0aGUgaW5zdGFuY2UgbWV0YWRhdGEgc2VydmljZVxuICAgKi9cbiAgZW5kcG9pbnQ6IGdldE1ldGFkYXRhU2VydmljZUVuZHBvaW50KCksXG5cbiAgLyoqXG4gICAqIEAhaWdub3JlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IEhUVFAgb3B0aW9ucy4gQnkgZGVmYXVsdCwgdGhlIG1ldGFkYXRhIHNlcnZpY2UgaXMgc2V0IHRvIG5vdFxuICAgKiB0aW1lb3V0IG9uIGxvbmcgcmVxdWVzdHMuIFRoaXMgbWVhbnMgdGhhdCBvbiBub24tRUMyIG1hY2hpbmVzLCB0aGlzXG4gICAqIHJlcXVlc3Qgd2lsbCBuZXZlciByZXR1cm4uIElmIHlvdSBhcmUgY2FsbGluZyB0aGlzIG9wZXJhdGlvbiBmcm9tIGFuXG4gICAqIGVudmlyb25tZW50IHRoYXQgbWF5IG5vdCBhbHdheXMgcnVuIG9uIEVDMiwgc2V0IGEgYHRpbWVvdXRgIHZhbHVlIHNvXG4gICAqIHRoZSBTREsgd2lsbCBhYm9ydCB0aGUgcmVxdWVzdCBhZnRlciBhIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBodHRwT3B0aW9uczogeyB0aW1lb3V0OiAwIH0sXG5cbiAgLyoqXG4gICAqIHdoZW4gZW5hYmxlZCwgbWV0YWRhdGEgc2VydmljZSB3aWxsIG5vdCBmZXRjaCB0b2tlblxuICAgKi9cbiAgZGlzYWJsZUZldGNoVG9rZW46IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1ldGFkYXRhU2VydmljZSBvYmplY3Qgd2l0aCBhIGdpdmVuIHNldCBvZiBvcHRpb25zLlxuICAgKlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaG9zdCBbU3RyaW5nXSB0aGUgaG9zdG5hbWUgb2YgdGhlIGluc3RhbmNlIG1ldGFkYXRhXG4gICAqICAgc2VydmljZVxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaHR0cE9wdGlvbnMgW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZVxuICAgKiAgIHVuZGVybHlpbmcgSFRUUCByZXF1ZXN0OlxuICAgKlxuICAgKiAgICogKip0aW1lb3V0KiogKE51bWJlcikgJm1kYXNoOyBhIHRpbWVvdXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAgICogICAgIGJlZm9yZSBhYm9ydGluZyB0aGUgY29ubmVjdGlvbi4gU2V0IHRvIDAgZm9yIG5vIHRpbWVvdXQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXhSZXRyaWVzIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyB0b1xuICAgKiAgIHBlcmZvcm0gZm9yIHRpbWVvdXQgZXJyb3JzXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZXRyeURlbGF5T3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGVcbiAgICogICByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLiBTZWUgQVdTLkNvbmZpZyBmb3IgZGV0YWlscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBNZXRhZGF0YVNlcnZpY2Uob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaG9zdCkge1xuICAgICAgb3B0aW9ucy5lbmRwb2ludCA9ICdodHRwOi8vJyArIG9wdGlvbnMuaG9zdDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIEFXUy51dGlsLnVwZGF0ZSh0aGlzLCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBpbnN0YW5jZSBtZXRhZGF0YSBzZXJ2aWNlIGZvciBhIGdpdmVuIHJlc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgcGF0aCBvZiB0aGUgcmVzb3VyY2UgdG8gZ2V0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFttYXBdIGFuIG9wdGlvbmFsIG1hcCB1c2VkIHRvIG1ha2UgcmVxdWVzdFxuICAgKlxuICAgKiAgICogKiptZXRob2QqKiAoU3RyaW5nKSAmbWRhc2g7IEhUVFAgcmVxdWVzdCBtZXRob2RcbiAgICpcbiAgICogICAqICoqaGVhZGVycyoqIChtYXA8U3RyaW5nLFN0cmluZz4pICZtZGFzaDsgYSBtYXAgb2YgcmVzcG9uc2UgaGVhZGVyIGtleXMgYW5kIHRoZWlyIHJlc3BlY3RpdmUgdmFsdWVzXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQ2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyBhdmFpbGFibGUgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvciwgbnVsbF0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBzZXRcbiAgICogICBAcGFyYW0gZGF0YSBbU3RyaW5nLCBudWxsXSBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCwgdGhlIGJvZHkgb2ZcbiAgICogICAgIHRoZSByZXNwb25zZVxuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52W0FXUy51dGlsLmltZHNEaXNhYmxlZEVudl0pIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRUMyIEluc3RhbmNlIE1ldGFkYXRhIFNlcnZpY2UgYWNjZXNzIGRpc2FibGVkJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoIHx8ICcvJztcblxuICAgIC8vIFZlcmlmeSB0aGF0IGhvc3QgaXMgYSB2YWxpZCBVUkxcbiAgICBpZiAoVVJMKSB7IG5ldyBVUkwodGhpcy5lbmRwb2ludCk7IH1cblxuICAgIHZhciBodHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QodGhpcy5lbmRwb2ludCArIHBhdGgpO1xuICAgIGh0dHBSZXF1ZXN0Lm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgfVxuICAgIEFXUy51dGlsLmhhbmRsZVJlcXVlc3RXaXRoUmV0cmllcyhodHRwUmVxdWVzdCwgdGhpcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuICBsb2FkQ3JlZGVudGlhbHNDYWxsYmFja3M6IFtdLFxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIG1ldGFkYXRhIHRva2VuIHVzZWQgZm9yIGdldHRpbmcgY3JlZGVudGlhbHNcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIHRva2VuKVxuICAgKiAgIENhbGxlZCB3aGVuIHRva2VuIGlzIGxvYWRlZCBmcm9tIHRoZSByZXNvdXJjZVxuICAgKi9cbiAgZmV0Y2hNZXRhZGF0YVRva2VuOiBmdW5jdGlvbiBmZXRjaE1ldGFkYXRhVG9rZW4oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRva2VuRmV0Y2hQYXRoID0gJy9sYXRlc3QvYXBpL3Rva2VuJztcbiAgICBzZWxmLnJlcXVlc3QoXG4gICAgICB0b2tlbkZldGNoUGF0aCxcbiAgICAgIHtcbiAgICAgICAgJ21ldGhvZCc6ICdQVVQnLFxuICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuLXR0bC1zZWNvbmRzJzogJzIxNjAwJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAY2FsbGJhY2sgY2IgZnVuY3Rpb24oZXJyLCBjcmVkcylcbiAgICogICBDYWxsZWQgd2hlbiBjcmVkZW50aWFscyBhcmUgbG9hZGVkIGZyb20gdGhlIHJlc291cmNlXG4gICAqL1xuICBmZXRjaENyZWRlbnRpYWxzOiBmdW5jdGlvbiBmZXRjaENyZWRlbnRpYWxzKG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBiYXNlUGF0aCA9ICcvbGF0ZXN0L21ldGEtZGF0YS9pYW0vc2VjdXJpdHktY3JlZGVudGlhbHMvJztcblxuICAgIHNlbGYucmVxdWVzdChiYXNlUGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcm9sZU5hbWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5kaXNhYmxlRmV0Y2hUb2tlbiA9ICEoZXJyLnN0YXR1c0NvZGUgPT09IDQwMSk7XG4gICAgICAgIGNiKEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnRUMyIE1ldGFkYXRhIHJvbGVOYW1lIHJlcXVlc3QgcmV0dXJuZWQgZXJyb3InXG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcm9sZU5hbWUgPSByb2xlTmFtZS5zcGxpdCgnXFxuJylbMF07IC8vIGdyYWIgZmlyc3QgKGFuZCBvbmx5KSByb2xlXG4gICAgICBzZWxmLnJlcXVlc3QoYmFzZVBhdGggKyByb2xlTmFtZSwgb3B0aW9ucywgZnVuY3Rpb24gKGNyZWRFcnIsIGNyZWREYXRhKSB7XG4gICAgICAgIGlmIChjcmVkRXJyKSB7XG4gICAgICAgICAgc2VsZi5kaXNhYmxlRmV0Y2hUb2tlbiA9ICEoY3JlZEVyci5zdGF0dXNDb2RlID09PSA0MDEpO1xuICAgICAgICAgIGNiKEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgICAgY3JlZEVycixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0VDMiBNZXRhZGF0YSBjcmVkcyByZXF1ZXN0IHJldHVybmVkIGVycm9yJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjcmVkZW50aWFscyA9IEpTT04ucGFyc2UoY3JlZERhdGEpO1xuICAgICAgICAgIGNiKG51bGwsIGNyZWRlbnRpYWxzKTtcbiAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgIGNiKHBhcnNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgYSBzZXQgb2YgY3JlZGVudGlhbHMgc3RvcmVkIGluIHRoZSBpbnN0YW5jZSBtZXRhZGF0YSBzZXJ2aWNlXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBjcmVkZW50aWFscylcbiAgICogICBDYWxsZWQgd2hlbiBjcmVkZW50aWFscyBhcmUgbG9hZGVkIGZyb20gdGhlIHJlc291cmNlXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgc2V0XG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtPYmplY3RdIHRoZSByYXcgSlNPTiBvYmplY3QgY29udGFpbmluZyBhbGxcbiAgICogICAgIG1ldGFkYXRhIGZyb20gdGhlIGNyZWRlbnRpYWxzIHJlc291cmNlXG4gICAqL1xuICBsb2FkQ3JlZGVudGlhbHM6IGZ1bmN0aW9uIGxvYWRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmxvYWRDcmVkZW50aWFsc0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICBpZiAoc2VsZi5sb2FkQ3JlZGVudGlhbHNDYWxsYmFja3MubGVuZ3RoID4gMSkgeyByZXR1cm47IH1cblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrcyhlcnIsIGNyZWRzKSB7XG4gICAgICB2YXIgY2I7XG4gICAgICB3aGlsZSAoKGNiID0gc2VsZi5sb2FkQ3JlZGVudGlhbHNDYWxsYmFja3Muc2hpZnQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYihlcnIsIGNyZWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5kaXNhYmxlRmV0Y2hUb2tlbikge1xuICAgICAgc2VsZi5mZXRjaENyZWRlbnRpYWxzKHt9LCBjYWxsYmFja3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmZldGNoTWV0YWRhdGFUb2tlbihmdW5jdGlvbih0b2tlbkVycm9yLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW5FcnJvcikge1xuICAgICAgICAgIGlmICh0b2tlbkVycm9yLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICAgICAgICBzZWxmLmRpc2FibGVGZXRjaFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuRXJyb3IucmV0cnlhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MoQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIHRva2VuRXJyb3IsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRUMyIE1ldGFkYXRhIHRva2VuIHJlcXVlc3QgcmV0dXJuZWQgZXJyb3InXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5FcnJvci5zdGF0dXNDb2RlID09PSA0MDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgdG9rZW5FcnJvcixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFQzIgTWV0YWRhdGEgdG9rZW4gcmVxdWVzdCByZXR1cm5lZCA0MDAnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuJzogdG9rZW5cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmV0Y2hDcmVkZW50aWFscyhvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgfSk7XG5cbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5NZXRhZGF0YVNlcnZpY2U7XG4iLCJ2YXIgZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBJUHY0OiAnaHR0cDovLzE2OS4yNTQuMTY5LjI1NCcsXG4gICAgSVB2NjogJ2h0dHA6Ly9bZmQwMDplYzI6OjI1NF0nLFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFbmRwb2ludDtcbiIsInZhciBFTlZfRU5EUE9JTlRfTkFNRSA9ICdBV1NfRUMyX01FVEFEQVRBX1NFUlZJQ0VfRU5EUE9JTlQnO1xudmFyIENPTkZJR19FTkRQT0lOVF9OQU1FID0gJ2VjMl9tZXRhZGF0YV9zZXJ2aWNlX2VuZHBvaW50JztcblxudmFyIGdldEVuZHBvaW50Q29uZmlnT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGVudmlyb25tZW50VmFyaWFibGVTZWxlY3RvcjogZnVuY3Rpb24oZW52KSB7IHJldHVybiBlbnZbRU5WX0VORFBPSU5UX05BTUVdOyB9LFxuICAgIGNvbmZpZ0ZpbGVTZWxlY3RvcjogZnVuY3Rpb24ocHJvZmlsZSkgeyByZXR1cm4gcHJvZmlsZVtDT05GSUdfRU5EUE9JTlRfTkFNRV07IH0sXG4gICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFbmRwb2ludENvbmZpZ09wdGlvbnM7XG4iLCJ2YXIgZ2V0RW5kcG9pbnRNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgSVB2NDogJ0lQdjQnLFxuICAgIElQdjY6ICdJUHY2JyxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RW5kcG9pbnRNb2RlO1xuIiwidmFyIEVuZHBvaW50TW9kZSA9IHJlcXVpcmUoJy4vZ2V0X2VuZHBvaW50X21vZGUnKSgpO1xuXG52YXIgRU5WX0VORFBPSU5UX01PREVfTkFNRSA9ICdBV1NfRUMyX01FVEFEQVRBX1NFUlZJQ0VfRU5EUE9JTlRfTU9ERSc7XG52YXIgQ09ORklHX0VORFBPSU5UX01PREVfTkFNRSA9ICdlYzJfbWV0YWRhdGFfc2VydmljZV9lbmRwb2ludF9tb2RlJztcblxudmFyIGdldEVuZHBvaW50TW9kZUNvbmZpZ09wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnZpcm9ubWVudFZhcmlhYmxlU2VsZWN0b3I6IGZ1bmN0aW9uKGVudikgeyByZXR1cm4gZW52W0VOVl9FTkRQT0lOVF9NT0RFX05BTUVdOyB9LFxuICAgIGNvbmZpZ0ZpbGVTZWxlY3RvcjogZnVuY3Rpb24ocHJvZmlsZSkgeyByZXR1cm4gcHJvZmlsZVtDT05GSUdfRU5EUE9JTlRfTU9ERV9OQU1FXTsgfSxcbiAgICBkZWZhdWx0OiBFbmRwb2ludE1vZGUuSVB2NCxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RW5kcG9pbnRNb2RlQ29uZmlnT3B0aW9ucztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbnZhciBFbmRwb2ludCA9IHJlcXVpcmUoJy4vZ2V0X2VuZHBvaW50JykoKTtcbnZhciBFbmRwb2ludE1vZGUgPSByZXF1aXJlKCcuL2dldF9lbmRwb2ludF9tb2RlJykoKTtcblxudmFyIEVORFBPSU5UX0NPTkZJR19PUFRJT05TID0gcmVxdWlyZSgnLi9nZXRfZW5kcG9pbnRfY29uZmlnX29wdGlvbnMnKSgpO1xudmFyIEVORFBPSU5UX01PREVfQ09ORklHX09QVElPTlMgPSByZXF1aXJlKCcuL2dldF9lbmRwb2ludF9tb2RlX2NvbmZpZ19vcHRpb25zJykoKTtcblxudmFyIGdldE1ldGFkYXRhU2VydmljZUVuZHBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmRwb2ludCA9IEFXUy51dGlsLmxvYWRDb25maWcoRU5EUE9JTlRfQ09ORklHX09QVElPTlMpO1xuICBpZiAoZW5kcG9pbnQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVuZHBvaW50O1xuXG4gIHZhciBlbmRwb2ludE1vZGUgPSBBV1MudXRpbC5sb2FkQ29uZmlnKEVORFBPSU5UX01PREVfQ09ORklHX09QVElPTlMpO1xuICBzd2l0Y2ggKGVuZHBvaW50TW9kZSkge1xuICAgIGNhc2UgRW5kcG9pbnRNb2RlLklQdjQ6XG4gICAgICByZXR1cm4gRW5kcG9pbnQuSVB2NDtcbiAgICBjYXNlIEVuZHBvaW50TW9kZS5JUHY2OlxuICAgICAgcmV0dXJuIEVuZHBvaW50LklQdjY7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZW5kcG9pbnQgbW9kZTogJyArIGVuZHBvaW50TW9kZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWV0YWRhdGFTZXJ2aWNlRW5kcG9pbnQ7XG4iLCJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xudmFyIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL3NoYXBlJyk7XG52YXIgUGFnaW5hdG9yID0gcmVxdWlyZSgnLi9wYWdpbmF0b3InKTtcbnZhciBSZXNvdXJjZVdhaXRlciA9IHJlcXVpcmUoJy4vcmVzb3VyY2Vfd2FpdGVyJyk7XG52YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuLi8uLi9hcGlzL21ldGFkYXRhLmpzb24nKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIEFwaShhcGksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBhcGkgPSBhcGkgfHwge307XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFwaSA9IHRoaXM7XG5cbiAgYXBpLm1ldGFkYXRhID0gYXBpLm1ldGFkYXRhIHx8IHt9O1xuXG4gIHZhciBzZXJ2aWNlSWRlbnRpZmllciA9IG9wdGlvbnMuc2VydmljZUlkZW50aWZpZXI7XG4gIGRlbGV0ZSBvcHRpb25zLnNlcnZpY2VJZGVudGlmaWVyO1xuXG4gIHByb3BlcnR5KHRoaXMsICdpc0FwaScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaVZlcnNpb24nLCBhcGkubWV0YWRhdGEuYXBpVmVyc2lvbik7XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludFByZWZpeCcsIGFwaS5tZXRhZGF0YS5lbmRwb2ludFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduaW5nTmFtZScsIGFwaS5tZXRhZGF0YS5zaWduaW5nTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdnbG9iYWxFbmRwb2ludCcsIGFwaS5tZXRhZGF0YS5nbG9iYWxFbmRwb2ludCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduYXR1cmVWZXJzaW9uJywgYXBpLm1ldGFkYXRhLnNpZ25hdHVyZVZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnanNvblZlcnNpb24nLCBhcGkubWV0YWRhdGEuanNvblZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAndGFyZ2V0UHJlZml4JywgYXBpLm1ldGFkYXRhLnRhcmdldFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdwcm90b2NvbCcsIGFwaS5tZXRhZGF0YS5wcm90b2NvbCk7XG4gIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBhcGkubWV0YWRhdGEudGltZXN0YW1wRm9ybWF0KTtcbiAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIGFwaS5tZXRhZGF0YS54bWxOYW1lc3BhY2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYWJicmV2aWF0aW9uJywgYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnZnVsbE5hbWUnLCBhcGkubWV0YWRhdGEuc2VydmljZUZ1bGxOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ3NlcnZpY2VJZCcsIGFwaS5tZXRhZGF0YS5zZXJ2aWNlSWQpO1xuICBpZiAoc2VydmljZUlkZW50aWZpZXIgJiYgbWV0YWRhdGFbc2VydmljZUlkZW50aWZpZXJdKSB7XG4gICAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTm9EZWZhdWx0TGlzdHMnLCBtZXRhZGF0YVtzZXJ2aWNlSWRlbnRpZmllcl0ueG1sTm9EZWZhdWx0TGlzdHMsIGZhbHNlKTtcbiAgfVxuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2NsYXNzTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24gfHwgYXBpLm1ldGFkYXRhLnNlcnZpY2VGdWxsTmFtZTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXkFtYXpvbnxBV1NcXHMqfFxcKC4qfFxccyt8XFxXKy9nLCAnJyk7XG4gICAgaWYgKG5hbWUgPT09ICdFbGFzdGljTG9hZEJhbGFuY2luZycpIG5hbWUgPSAnRUxCJztcbiAgICByZXR1cm4gbmFtZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWRkRW5kcG9pbnRPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5lbmRwb2ludG9wZXJhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcHJvcGVydHkoc2VsZiwgJ2VuZHBvaW50T3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdChuYW1lKSk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkgJiYgIXNlbGYuaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSkge1xuICAgICAgcHJvcGVydHkoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdoYXNSZXF1aXJlZEVuZHBvaW50RGlzY292ZXJ5JyxcbiAgICAgICAgb3BlcmF0aW9uLmVuZHBvaW50ZGlzY292ZXJ5LnJlcXVpcmVkID09PSB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3BlcnR5KHRoaXMsICdvcGVyYXRpb25zJywgbmV3IENvbGxlY3Rpb24oYXBpLm9wZXJhdGlvbnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIG9wZXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gIH0sIHV0aWwuc3RyaW5nLmxvd2VyRmlyc3QsIGFkZEVuZHBvaW50T3BlcmF0aW9uKSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3NoYXBlcycsIG5ldyBDb2xsZWN0aW9uKGFwaS5zaGFwZXMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZSwgb3B0aW9ucyk7XG4gIH0pKTtcblxuICBwcm9wZXJ0eSh0aGlzLCAncGFnaW5hdG9ycycsIG5ldyBDb2xsZWN0aW9uKGFwaS5wYWdpbmF0b3JzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IsIG9wdGlvbnMpO1xuICB9KSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3dhaXRlcnMnLCBuZXcgQ29sbGVjdGlvbihhcGkud2FpdGVycywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgd2FpdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVdhaXRlcihuYW1lLCB3YWl0ZXIsIG9wdGlvbnMpO1xuICB9LCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgYXBpLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgYXBpLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXBpO1xuIiwidmFyIG1lbW9pemVkUHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykubWVtb2l6ZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gbWVtb2l6ZShuYW1lLCB2YWx1ZSwgZmFjdG9yeSwgbmFtZVRyKSB7XG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgbmFtZVRyKG5hbWUpLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFjdG9yeShuYW1lLCB2YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKGl0ZXJhYmxlLCBvcHRpb25zLCBmYWN0b3J5LCBuYW1lVHIsIGNhbGxiYWNrKSB7XG4gIG5hbWVUciA9IG5hbWVUciB8fCBTdHJpbmc7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBpZCBpbiBpdGVyYWJsZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGlkKSkge1xuICAgICAgbWVtb2l6ZS5jYWxsKHNlbGYsIGlkLCBpdGVyYWJsZVtpZF0sIGZhY3RvcnksIG5hbWVUcik7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGlkLCBpdGVyYWJsZVtpZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL3NoYXBlJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHByb3BlcnR5ID0gdXRpbC5wcm9wZXJ0eTtcbnZhciBtZW1vaXplZFByb3BlcnR5ID0gdXRpbC5tZW1vaXplZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBvcGVyYXRpb24ubmFtZSB8fCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgb3BlcmF0aW9uLmh0dHAgPSBvcGVyYXRpb24uaHR0cCB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ2VuZHBvaW50Jywgb3BlcmF0aW9uLmVuZHBvaW50KTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBNZXRob2QnLCBvcGVyYXRpb24uaHR0cC5tZXRob2QgfHwgJ1BPU1QnKTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBQYXRoJywgb3BlcmF0aW9uLmh0dHAucmVxdWVzdFVyaSB8fCAnLycpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXV0aHR5cGUnLCBvcGVyYXRpb24uYXV0aHR5cGUgfHwgJycpO1xuICBwcm9wZXJ0eShcbiAgICB0aGlzLFxuICAgICdlbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkJyxcbiAgICBvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkgP1xuICAgICAgKG9wZXJhdGlvbi5lbmRwb2ludGRpc2NvdmVyeS5yZXF1aXJlZCA/ICdSRVFVSVJFRCcgOiAnT1BUSU9OQUwnKSA6XG4gICAgJ05VTEwnXG4gICk7XG5cbiAgLy8gaHR0cENoZWNrc3VtIHJlcGxhY2VzIHVzYWdlIG9mIGh0dHBDaGVja3N1bVJlcXVpcmVkLCBidXQgc29tZSBBUElzXG4gIC8vIChzM2NvbnRyb2wpIHN0aWxsIHVzZXMgb2xkIHRyYWl0LlxuICB2YXIgaHR0cENoZWNrc3VtUmVxdWlyZWQgPSBvcGVyYXRpb24uaHR0cENoZWNrc3VtUmVxdWlyZWRcbiAgICB8fCAob3BlcmF0aW9uLmh0dHBDaGVja3N1bSAmJiBvcGVyYXRpb24uaHR0cENoZWNrc3VtLnJlcXVlc3RDaGVja3N1bVJlcXVpcmVkKTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBDaGVja3N1bVJlcXVpcmVkJywgaHR0cENoZWNrc3VtUmVxdWlyZWQsIGZhbHNlKTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdpbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICghb3BlcmF0aW9uLmlucHV0KSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cnVjdHVyZSd9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShvcGVyYXRpb24uaW5wdXQsIG9wdGlvbnMpO1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdvdXRwdXQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW9wZXJhdGlvbi5vdXRwdXQpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGUuY3JlYXRlKG9wZXJhdGlvbi5vdXRwdXQsIG9wdGlvbnMpO1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdlcnJvcnMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIGlmICghb3BlcmF0aW9uLmVycm9ycykgcmV0dXJuIG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdGlvbi5lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QucHVzaChTaGFwZS5jcmVhdGUob3BlcmF0aW9uLmVycm9yc1tpXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdwYWdpbmF0b3InLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5hcGkucGFnaW5hdG9yc1tuYW1lXTtcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgb3BlcmF0aW9uLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgb3BlcmF0aW9uLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG5cbiAgLy8gaWRlbXBvdGVudE1lbWJlcnMgb25seSB0cmFja3MgdG9wLWxldmVsIGlucHV0IHNoYXBlc1xuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdpZGVtcG90ZW50TWVtYmVycycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZGVtcG90ZW50TWVtYmVycyA9IFtdO1xuICAgIHZhciBpbnB1dCA9IHNlbGYuaW5wdXQ7XG4gICAgdmFyIG1lbWJlcnMgPSBpbnB1dC5tZW1iZXJzO1xuICAgIGlmICghaW5wdXQubWVtYmVycykge1xuICAgICAgcmV0dXJuIGlkZW1wb3RlbnRNZW1iZXJzO1xuICAgIH1cbiAgICBmb3IgKHZhciBuYW1lIGluIG1lbWJlcnMpIHtcbiAgICAgIGlmICghbWVtYmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXJzW25hbWVdLmlzSWRlbXBvdGVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZGVtcG90ZW50TWVtYmVycy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRlbXBvdGVudE1lbWJlcnM7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2hhc0V2ZW50T3V0cHV0JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dHB1dCA9IHNlbGYub3V0cHV0O1xuICAgIHJldHVybiBoYXNFdmVudFN0cmVhbShvdXRwdXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFzRXZlbnRTdHJlYW0odG9wTGV2ZWxTaGFwZSkge1xuICB2YXIgbWVtYmVycyA9IHRvcExldmVsU2hhcGUubWVtYmVycztcbiAgdmFyIHBheWxvYWQgPSB0b3BMZXZlbFNoYXBlLnBheWxvYWQ7XG5cbiAgaWYgKCF0b3BMZXZlbFNoYXBlLm1lbWJlcnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gbWVtYmVyc1twYXlsb2FkXTtcbiAgICByZXR1cm4gcGF5bG9hZE1lbWJlci5pc0V2ZW50U3RyZWFtO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgYW55IG1lbWJlciBpcyBhbiBldmVudCBzdHJlYW1cbiAgZm9yICh2YXIgbmFtZSBpbiBtZW1iZXJzKSB7XG4gICAgaWYgKCFtZW1iZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBpZiAobWVtYmVyc1tuYW1lXS5pc0V2ZW50U3RyZWFtID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uO1xuIiwidmFyIHByb3BlcnR5ID0gcmVxdWlyZSgnLi4vdXRpbCcpLnByb3BlcnR5O1xuXG5mdW5jdGlvbiBQYWdpbmF0b3IobmFtZSwgcGFnaW5hdG9yKSB7XG4gIHByb3BlcnR5KHRoaXMsICdpbnB1dFRva2VuJywgcGFnaW5hdG9yLmlucHV0X3Rva2VuKTtcbiAgcHJvcGVydHkodGhpcywgJ2xpbWl0S2V5JywgcGFnaW5hdG9yLmxpbWl0X2tleSk7XG4gIHByb3BlcnR5KHRoaXMsICdtb3JlUmVzdWx0cycsIHBhZ2luYXRvci5tb3JlX3Jlc3VsdHMpO1xuICBwcm9wZXJ0eSh0aGlzLCAnb3V0cHV0VG9rZW4nLCBwYWdpbmF0b3Iub3V0cHV0X3Rva2VuKTtcbiAgcHJvcGVydHkodGhpcywgJ3Jlc3VsdEtleScsIHBhZ2luYXRvci5yZXN1bHRfa2V5KTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBQYWdpbmF0b3I7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwcm9wZXJ0eSA9IHV0aWwucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFJlc291cmNlV2FpdGVyKG5hbWUsIHdhaXRlciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgaWYgKHdhaXRlci5vcGVyYXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnb3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdCh3YWl0ZXIub3BlcmF0aW9uKSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrZXlzID0gW1xuICAgICd0eXBlJyxcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICdkZWxheScsXG4gICAgJ21heEF0dGVtcHRzJyxcbiAgICAnYWNjZXB0b3JzJ1xuICBdO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB3YWl0ZXJba2V5XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHByb3BlcnR5KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VXYWl0ZXI7XG4iLCJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gcHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHV0aWwucHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZW1vaXplZFByb3BlcnR5KG9iaiwgbmFtZSkge1xuICBpZiAoIW9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICB1dGlsLm1lbW9pemVkUHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTaGFwZShzaGFwZSwgb3B0aW9ucywgbWVtYmVyTmFtZSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnc2hhcGUnLCBzaGFwZS5zaGFwZSk7XG4gIHByb3BlcnR5KHRoaXMsICdhcGknLCBvcHRpb25zLmFwaSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAndHlwZScsIHNoYXBlLnR5cGUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW51bScsIHNoYXBlLmVudW0pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbWluJywgc2hhcGUubWluKTtcbiAgcHJvcGVydHkodGhpcywgJ21heCcsIHNoYXBlLm1heCk7XG4gIHByb3BlcnR5KHRoaXMsICdwYXR0ZXJuJywgc2hhcGUucGF0dGVybik7XG4gIHByb3BlcnR5KHRoaXMsICdsb2NhdGlvbicsIHNoYXBlLmxvY2F0aW9uIHx8IHRoaXMubG9jYXRpb24gfHwgJ2JvZHknKTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCB0aGlzLm5hbWUgfHwgc2hhcGUueG1sTmFtZSB8fCBzaGFwZS5xdWVyeU5hbWUgfHxcbiAgICBzaGFwZS5sb2NhdGlvbk5hbWUgfHwgbWVtYmVyTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1N0cmVhbWluZycsIHNoYXBlLnN0cmVhbWluZyB8fCB0aGlzLmlzU3RyZWFtaW5nIHx8IGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ3JlcXVpcmVzTGVuZ3RoJywgc2hhcGUucmVxdWlyZXNMZW5ndGgsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzQ29tcG9zaXRlJywgc2hhcGUuaXNDb21wb3NpdGUgfHwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNTaGFwZScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzUXVlcnlOYW1lJywgQm9vbGVhbihzaGFwZS5xdWVyeU5hbWUpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0xvY2F0aW9uTmFtZScsIEJvb2xlYW4oc2hhcGUubG9jYXRpb25OYW1lKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNJZGVtcG90ZW50Jywgc2hhcGUuaWRlbXBvdGVuY3lUb2tlbiA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0pzb25WYWx1ZScsIHNoYXBlLmpzb252YWx1ZSA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1NlbnNpdGl2ZScsIHNoYXBlLnNlbnNpdGl2ZSA9PT0gdHJ1ZSB8fCBzaGFwZS5wcm90b3R5cGUgJiYgc2hhcGUucHJvdG90eXBlLnNlbnNpdGl2ZSA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0V2ZW50U3RyZWFtJywgQm9vbGVhbihzaGFwZS5ldmVudHN0cmVhbSksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnQnLCBCb29sZWFuKHNoYXBlLmV2ZW50KSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudFBheWxvYWQnLCBCb29sZWFuKHNoYXBlLmV2ZW50cGF5bG9hZCksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnRIZWFkZXInLCBCb29sZWFuKHNoYXBlLmV2ZW50aGVhZGVyKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNUaW1lc3RhbXBGb3JtYXRTZXQnLCBCb29sZWFuKHNoYXBlLnRpbWVzdGFtcEZvcm1hdCkgfHwgc2hhcGUucHJvdG90eXBlICYmIHNoYXBlLnByb3RvdHlwZS5pc1RpbWVzdGFtcEZvcm1hdFNldCA9PT0gdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW5kcG9pbnREaXNjb3ZlcnlJZCcsIEJvb2xlYW4oc2hhcGUuZW5kcG9pbnRkaXNjb3ZlcnlpZCksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2hvc3RMYWJlbCcsIEJvb2xlYW4oc2hhcGUuaG9zdExhYmVsKSwgZmFsc2UpO1xuXG4gIGlmIChvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvbicsIHNoYXBlLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgc2hhcGUuZG9jdW1lbnRhdGlvblVybCk7XG4gIH1cblxuICBpZiAoc2hhcGUueG1sQXR0cmlidXRlKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzWG1sQXR0cmlidXRlJywgc2hhcGUueG1sQXR0cmlidXRlIHx8IGZhbHNlKTtcbiAgfVxuXG4gIC8vIHR5cGUgY29udmVyc2lvbiBhbmQgcGFyc2luZ1xuICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgbnVsbCk7XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLm5vcm1hbGl6ZWRUeXBlcyA9IHtcbiAgY2hhcmFjdGVyOiAnc3RyaW5nJyxcbiAgZG91YmxlOiAnZmxvYXQnLFxuICBsb25nOiAnaW50ZWdlcicsXG4gIHNob3J0OiAnaW50ZWdlcicsXG4gIGJpZ2ludGVnZXI6ICdpbnRlZ2VyJyxcbiAgYmlnZGVjaW1hbDogJ2Zsb2F0JyxcbiAgYmxvYjogJ2JpbmFyeSdcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLnR5cGVzID0ge1xuICAnc3RydWN0dXJlJzogU3RydWN0dXJlU2hhcGUsXG4gICdsaXN0JzogTGlzdFNoYXBlLFxuICAnbWFwJzogTWFwU2hhcGUsXG4gICdib29sZWFuJzogQm9vbGVhblNoYXBlLFxuICAndGltZXN0YW1wJzogVGltZXN0YW1wU2hhcGUsXG4gICdmbG9hdCc6IEZsb2F0U2hhcGUsXG4gICdpbnRlZ2VyJzogSW50ZWdlclNoYXBlLFxuICAnc3RyaW5nJzogU3RyaW5nU2hhcGUsXG4gICdiYXNlNjQnOiBCYXNlNjRTaGFwZSxcbiAgJ2JpbmFyeSc6IEJpbmFyeVNoYXBlXG59O1xuXG5TaGFwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShzaGFwZSwgb3B0aW9ucykge1xuICBpZiAoc2hhcGUuc2hhcGUpIHtcbiAgICB2YXIgcmVmU2hhcGUgPSBvcHRpb25zLmFwaS5zaGFwZXNbc2hhcGUuc2hhcGVdO1xuICAgIGlmICghcmVmU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc2hhcGUgcmVmZXJlbmNlOiAnICsgc2hhcGUuc2hhcGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZTaGFwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuU2hhcGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKSB7XG4gIGlmIChzaGFwZS5pc1NoYXBlKSByZXR1cm4gc2hhcGU7XG5cbiAgdmFyIHJlZlNoYXBlID0gU2hhcGUucmVzb2x2ZShzaGFwZSwgb3B0aW9ucyk7XG4gIGlmIChyZWZTaGFwZSkge1xuICAgIHZhciBmaWx0ZXJlZEtleXMgPSBPYmplY3Qua2V5cyhzaGFwZSk7XG4gICAgaWYgKCFvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICAgIGZpbHRlcmVkS2V5cyA9IGZpbHRlcmVkS2V5cy5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gIW5hbWUubWF0Y2goL2RvY3VtZW50YXRpb24vKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbiBpbmxpbmUgc2hhcGUgd2l0aCBleHRyYSBtZW1iZXJzXG4gICAgdmFyIElubGluZVNoYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWZTaGFwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKTtcbiAgICB9O1xuICAgIElubGluZVNoYXBlLnByb3RvdHlwZSA9IHJlZlNoYXBlO1xuICAgIHJldHVybiBuZXcgSW5saW5lU2hhcGUoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzZXQgdHlwZSBpZiBub3Qgc2V0XG4gICAgaWYgKCFzaGFwZS50eXBlKSB7XG4gICAgICBpZiAoc2hhcGUubWVtYmVycykgc2hhcGUudHlwZSA9ICdzdHJ1Y3R1cmUnO1xuICAgICAgZWxzZSBpZiAoc2hhcGUubWVtYmVyKSBzaGFwZS50eXBlID0gJ2xpc3QnO1xuICAgICAgZWxzZSBpZiAoc2hhcGUua2V5KSBzaGFwZS50eXBlID0gJ21hcCc7XG4gICAgICBlbHNlIHNoYXBlLnR5cGUgPSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgdHlwZXNcbiAgICB2YXIgb3JpZ1R5cGUgPSBzaGFwZS50eXBlO1xuICAgIGlmIChTaGFwZS5ub3JtYWxpemVkVHlwZXNbc2hhcGUudHlwZV0pIHtcbiAgICAgIHNoYXBlLnR5cGUgPSBTaGFwZS5ub3JtYWxpemVkVHlwZXNbc2hhcGUudHlwZV07XG4gICAgfVxuXG4gICAgaWYgKFNoYXBlLnR5cGVzW3NoYXBlLnR5cGVdKSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLnR5cGVzW3NoYXBlLnR5cGVdKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgc2hhcGUgdHlwZTogJyArIG9yaWdUeXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIENvbXBvc2l0ZVNoYXBlKHNoYXBlKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0NvbXBvc2l0ZScsIHRydWUpO1xuXG4gIGlmIChzaGFwZS5mbGF0dGVuZWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZmxhdHRlbmVkJywgc2hhcGUuZmxhdHRlbmVkIHx8IGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTdHJ1Y3R1cmVTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZXF1aXJlZE1hcCA9IG51bGwsIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG5cbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuICAgIHByb3BlcnR5KHRoaXMsICdtZW1iZXJzJywge30pO1xuICAgIHByb3BlcnR5KHRoaXMsICdtZW1iZXJOYW1lcycsIFtdKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZWQnLCBbXSk7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzUmVxdWlyZWQnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNEb2N1bWVudCcsIEJvb2xlYW4oc2hhcGUuZG9jdW1lbnQpKTtcbiAgfVxuXG4gIGlmIChzaGFwZS5tZW1iZXJzKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlcnMnLCBuZXcgQ29sbGVjdGlvbihzaGFwZS5tZW1iZXJzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUobWVtYmVyLCBvcHRpb25zLCBuYW1lKTtcbiAgICB9KSk7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnbWVtYmVyTmFtZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaGFwZS54bWxPcmRlciB8fCBPYmplY3Qua2V5cyhzaGFwZS5tZW1iZXJzKTtcbiAgICB9KTtcblxuICAgIGlmIChzaGFwZS5ldmVudCkge1xuICAgICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXZlbnRQYXlsb2FkTWVtYmVyTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gc2VsZi5tZW1iZXJOYW1lcztcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIG1lbWJlcnMgdG8gZmluZCBvbmVzIHRoYXQgYXJlIGV2ZW50IHBheWxvYWRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gbWVtYmVyTmFtZXMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1lbWJlcnNbbWVtYmVyTmFtZXNbaV1dLmlzRXZlbnRQYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyTmFtZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXZlbnRIZWFkZXJNZW1iZXJOYW1lcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gc2VsZi5tZW1iZXJOYW1lcztcbiAgICAgICAgdmFyIGV2ZW50SGVhZGVyTWVtYmVyTmFtZXMgPSBbXTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIG1lbWJlcnMgdG8gZmluZCBvbmVzIHRoYXQgYXJlIGV2ZW50IGhlYWRlcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBtZW1iZXJOYW1lcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWVtYmVyc1ttZW1iZXJOYW1lc1tpXV0uaXNFdmVudEhlYWRlcikge1xuICAgICAgICAgICAgZXZlbnRIZWFkZXJNZW1iZXJOYW1lcy5wdXNoKG1lbWJlck5hbWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50SGVhZGVyTWVtYmVyTmFtZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hhcGUucmVxdWlyZWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZWQnLCBzaGFwZS5yZXF1aXJlZCk7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzUmVxdWlyZWQnLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIXJlcXVpcmVkTWFwKSB7XG4gICAgICAgIHJlcXVpcmVkTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUucmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXF1aXJlZE1hcFtzaGFwZS5yZXF1aXJlZFtpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1aXJlZE1hcFtuYW1lXTtcbiAgICB9LCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICBwcm9wZXJ0eSh0aGlzLCAncmVzdWx0V3JhcHBlcicsIHNoYXBlLnJlc3VsdFdyYXBwZXIgfHwgbnVsbCk7XG5cbiAgaWYgKHNoYXBlLnBheWxvYWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncGF5bG9hZCcsIHNoYXBlLnBheWxvYWQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaGFwZS54bWxOYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIHNoYXBlLnhtbE5hbWVzcGFjZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNoYXBlLnhtbE5hbWVzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlUHJlZml4Jywgc2hhcGUueG1sTmFtZXNwYWNlLnByZWZpeCk7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIHNoYXBlLnhtbE5hbWVzcGFjZS51cmkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIExpc3RTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXMsIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG4gIENvbXBvc2l0ZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGZpcnN0SW5pdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgfVxuXG4gIGlmIChzaGFwZS5tZW1iZXIpIHtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdtZW1iZXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUubWVtYmVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmZsYXR0ZW5lZCkge1xuICAgIHZhciBvbGROYW1lID0gdGhpcy5uYW1lO1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ25hbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxmLm1lbWJlci5uYW1lIHx8IG9sZE5hbWU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTWFwU2hhcGUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgdmFyIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG4gIENvbXBvc2l0ZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGZpcnN0SW5pdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAna2V5JywgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RyaW5nJ30sIG9wdGlvbnMpKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJpbmcnfSwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKHNoYXBlLmtleSkge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2tleScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZS5rZXksIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIGlmIChzaGFwZS52YWx1ZSkge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ3ZhbHVlJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLnZhbHVlLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUaW1lc3RhbXBTaGFwZShzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKHNoYXBlLnRpbWVzdGFtcEZvcm1hdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBzaGFwZS50aW1lc3RhbXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHNlbGYuaXNUaW1lc3RhbXBGb3JtYXRTZXQgJiYgdGhpcy50aW1lc3RhbXBGb3JtYXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgdGhpcy50aW1lc3RhbXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdyZmM4MjInKTtcbiAgfSBlbHNlIGlmICh0aGlzLmxvY2F0aW9uID09PSAncXVlcnlzdHJpbmcnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdpc284NjAxJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5hcGkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgIGNhc2UgJ3Jlc3QtanNvbic6XG4gICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAndW5peFRpbWVzdGFtcCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3QteG1sJzpcbiAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGNhc2UgJ2VjMic6XG4gICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAnaXNvODYwMScpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2YgdmFsdWUudG9VVENTdHJpbmcgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgdXRpbC5kYXRlLnBhcnNlVGltZXN0YW1wKHZhbHVlKSA6IG51bGw7XG4gIH07XG5cbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLmRhdGUuZm9ybWF0KHZhbHVlLCBzZWxmLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFN0cmluZ1NoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHZhciBudWxsTGVzc1Byb3RvY29scyA9IFsncmVzdC14bWwnLCAncXVlcnknLCAnZWMyJ107XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXBpICYmIG51bGxMZXNzUHJvdG9jb2xzLmluZGV4T2YodGhpcy5hcGkucHJvdG9jb2wpID4gLTEgP1xuICAgICAgdmFsdWUgfHwgJycgOiB2YWx1ZTtcbiAgICBpZiAodGhpcy5pc0pzb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgP1xuICAgICAgdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuICB9O1xuXG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0pzb25WYWx1ZSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBGbG9hdFNoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHRoaXMudG9UeXBlO1xufVxuXG5mdW5jdGlvbiBJbnRlZ2VyU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSB0aGlzLnRvVHlwZTtcbn1cblxuZnVuY3Rpb24gQmluYXJ5U2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgYnVmID0gdXRpbC5iYXNlNjQuZGVjb2RlKHZhbHVlKTtcbiAgICBpZiAodGhpcy5pc1NlbnNpdGl2ZSAmJiB1dGlsLmlzTm9kZSgpICYmIHR5cGVvZiB1dGlsLkJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAvKiBOb2RlLmpzIGNhbiBjcmVhdGUgYSBCdWZmZXIgdGhhdCBpcyBub3QgaXNvbGF0ZWQuXG4gICAqIGkuZS4gYnVmLmJ5dGVMZW5ndGggIT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aFxuICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNlbnNpdGl2ZSBkYXRhIGlzIGFjY2Vzc2libGUgdG8gYW55b25lIHdpdGggYWNjZXNzIHRvIGJ1Zi5idWZmZXIuXG4gICAqIElmIHRoaXMgaXMgdGhlIG5vZGUgc2hhcmVkIEJ1ZmZlciwgdGhlbiBvdGhlciBjb2RlIHdpdGhpbiB0aGlzIHByb2Nlc3MgX2NvdWxkXyBmaW5kIHRoaXMgc2VjcmV0LlxuICAgKiBDb3B5IHNlbnNpdGl2ZSBkYXRhIHRvIGFuIGlzb2xhdGVkIEJ1ZmZlciBhbmQgemVybyB0aGUgc2Vuc2l0aXZlIGRhdGEuXG4gICAqIFdoaWxlIHRoaXMgaXMgc2FmZSB0byBkbyBoZXJlLCBjb3B5aW5nIHRoaXMgY29kZSBzb21ld2hlcmUgZWxzZSBtYXkgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAqL1xuICAgICAgdmFyIHNlY3VyZUJ1ZiA9IHV0aWwuQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgsIGJ1Zik7XG4gICAgICBidWYuZmlsbCgwKTtcbiAgICAgIGJ1ZiA9IHNlY3VyZUJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSB1dGlsLmJhc2U2NC5lbmNvZGU7XG59XG5cbmZ1bmN0aW9uIEJhc2U2NFNoYXBlKCkge1xuICBCaW5hcnlTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBCb29sZWFuU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUuc2hhcGVzID0ge1xuICBTdHJ1Y3R1cmVTaGFwZTogU3RydWN0dXJlU2hhcGUsXG4gIExpc3RTaGFwZTogTGlzdFNoYXBlLFxuICBNYXBTaGFwZTogTWFwU2hhcGUsXG4gIFN0cmluZ1NoYXBlOiBTdHJpbmdTaGFwZSxcbiAgQm9vbGVhblNoYXBlOiBCb29sZWFuU2hhcGUsXG4gIEJhc2U2NFNoYXBlOiBCYXNlNjRTaGFwZVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciByZWdpb25fdXRpbHMgPSByZXF1aXJlKCcuL3JlZ2lvbi91dGlscycpO1xudmFyIGlzRmlwc1JlZ2lvbiA9IHJlZ2lvbl91dGlscy5pc0ZpcHNSZWdpb247XG52YXIgZ2V0UmVhbFJlZ2lvbiA9IHJlZ2lvbl91dGlscy5nZXRSZWFsUmVnaW9uO1xuXG51dGlsLmlzQnJvd3NlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG51dGlsLmlzTm9kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblxuLy8gbm9kZS5qcyBzcGVjaWZpYyBtb2R1bGVzXG51dGlsLmNyeXB0by5saWIgPSByZXF1aXJlKCdjcnlwdG8nKTtcbnV0aWwuQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudXRpbC5kb21haW4gPSByZXF1aXJlKCdkb21haW4nKTtcbnV0aWwuc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG51dGlsLnVybCA9IHJlcXVpcmUoJ3VybCcpO1xudXRpbC5xdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG51dGlsLmVudmlyb25tZW50ID0gJ25vZGVqcyc7XG51dGlsLmNyZWF0ZUV2ZW50U3RyZWFtID0gdXRpbC5zdHJlYW0uUmVhZGFibGUgP1xuICByZXF1aXJlKCcuL2V2ZW50LXN0cmVhbS9zdHJlYW1pbmctY3JlYXRlLWV2ZW50LXN0cmVhbScpLmNyZWF0ZUV2ZW50U3RyZWFtIDogcmVxdWlyZSgnLi9ldmVudC1zdHJlYW0vYnVmZmVyZWQtY3JlYXRlLWV2ZW50LXN0cmVhbScpLmNyZWF0ZUV2ZW50U3RyZWFtO1xudXRpbC5yZWFsQ2xvY2sgPSByZXF1aXJlKCcuL3JlYWxjbG9jay9ub2RlQ2xvY2snKTtcbnV0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcgPSB7XG4gIFB1Ymxpc2hlcjogcmVxdWlyZSgnLi9wdWJsaXNoZXInKS5QdWJsaXNoZXIsXG4gIGNvbmZpZ1Byb3ZpZGVyOiByZXF1aXJlKCcuL3B1Ymxpc2hlci9jb25maWd1cmF0aW9uJyksXG59O1xudXRpbC5pbmlMb2FkZXIgPSByZXF1aXJlKCcuL3NoYXJlZC1pbmknKS5pbmlMb2FkZXI7XG51dGlsLmdldFN5c3RlbUVycm9yTmFtZSA9IHJlcXVpcmUoJ3V0aWwnKS5nZXRTeXN0ZW1FcnJvck5hbWU7XG5cbnV0aWwubG9hZENvbmZpZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGVudlZhbHVlID0gb3B0aW9ucy5lbnZpcm9ubWVudFZhcmlhYmxlU2VsZWN0b3IocHJvY2Vzcy5lbnYpO1xuICBpZiAoZW52VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlbnZWYWx1ZTtcbiAgfVxuXG4gIHZhciBjb25maWdGaWxlID0ge307XG4gIHRyeSB7XG4gICAgY29uZmlnRmlsZSA9IHV0aWwuaW5pTG9hZGVyID8gdXRpbC5pbmlMb2FkZXIubG9hZEZyb20oe1xuICAgICAgaXNDb25maWc6IHRydWUsXG4gICAgICBmaWxlbmFtZTogcHJvY2Vzcy5lbnZbdXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgIH0pIDoge307XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHZhciBzaGFyZWRGaWxlQ29uZmlnID0gY29uZmlnRmlsZVtcbiAgICBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCB1dGlsLmRlZmF1bHRQcm9maWxlXG4gIF0gfHwge307XG4gIHZhciBjb25maWdWYWx1ZSA9IG9wdGlvbnMuY29uZmlnRmlsZVNlbGVjdG9yKHNoYXJlZEZpbGVDb25maWcpO1xuICBpZiAoY29uZmlnVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb25maWdWYWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiBvcHRpb25zLmRlZmF1bHQ7XG59O1xuXG52YXIgQVdTO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2NyZWRlbnRpYWxfcHJvdmlkZXJfY2hhaW4nKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvdGVtcG9yYXJ5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2NoYWluYWJsZV90ZW1wb3JhcnlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvd2ViX2lkZW50aXR5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2NvZ25pdG9faWRlbnRpdHlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvc2FtbF9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9wcm9jZXNzX2NyZWRlbnRpYWxzJyk7XG5cbi8vIExvYWQgdGhlIHhtbDJqcyBYTUwgcGFyc2VyXG5BV1MuWE1MLlBhcnNlciA9IHJlcXVpcmUoJy4veG1sL25vZGVfcGFyc2VyJyk7XG5cbi8vIExvYWQgTm9kZSBIVFRQIGNsaWVudFxucmVxdWlyZSgnLi9odHRwL25vZGUnKTtcblxucmVxdWlyZSgnLi9zaGFyZWQtaW5pL2luaS1sb2FkZXInKTtcblxuLy8gTG9hZCBjdXN0b20gY3JlZGVudGlhbCBwcm92aWRlcnNcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvdG9rZW5fZmlsZV93ZWJfaWRlbnRpdHlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvZWMyX21ldGFkYXRhX2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3JlbW90ZV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9lY3NfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvZW52aXJvbm1lbnRfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvZmlsZV9zeXN0ZW1fY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvc2hhcmVkX2luaV9maWxlX2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3Byb2Nlc3NfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvc3NvX2NyZWRlbnRpYWxzJyk7XG5cbi8vIFNldHVwIGRlZmF1bHQgY2hhaW4gcHJvdmlkZXJzXG4vLyBJZiB0aGlzIGNoYW5nZXMsIHBsZWFzZSB1cGRhdGUgZG9jdW1lbnRhdGlvbiBmb3Jcbi8vIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzIGluXG4vLyBjcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluLmpzXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyA9IFtcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTsgfSxcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKTsgfSxcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Tc29DcmVkZW50aWFscygpOyB9LFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscygpOyB9LFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCk7IH0sXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuUHJvY2Vzc0NyZWRlbnRpYWxzKCk7IH0sXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFscygpOyB9LFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoKTsgfVxuXTtcblxudmFyIGdldFJlZ2lvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW52ID0gcHJvY2Vzcy5lbnY7XG4gIHZhciByZWdpb24gPSBlbnYuQVdTX1JFR0lPTiB8fCBlbnYuQU1BWk9OX1JFR0lPTjtcbiAgaWYgKGVudltBV1MudXRpbC5jb25maWdPcHRJbkVudl0pIHtcbiAgICB2YXIgdG9DaGVjayA9IFtcbiAgICAgIHtmaWxlbmFtZTogZW52W0FXUy51dGlsLnNoYXJlZENyZWRlbnRpYWxzRmlsZUVudl19LFxuICAgICAge2lzQ29uZmlnOiB0cnVlLCBmaWxlbmFtZTogZW52W0FXUy51dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdfVxuICAgIF07XG4gICAgdmFyIGluaUxvYWRlciA9IEFXUy51dGlsLmluaUxvYWRlcjtcbiAgICB3aGlsZSAoIXJlZ2lvbiAmJiB0b0NoZWNrLmxlbmd0aCkge1xuICAgICAgdmFyIGNvbmZpZ0ZpbGUgPSB7fTtcbiAgICAgIHZhciBmaWxlSW5mbyA9IHRvQ2hlY2suc2hpZnQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbmZpZ0ZpbGUgPSBpbmlMb2FkZXIubG9hZEZyb20oZmlsZUluZm8pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmaWxlSW5mby5pc0NvbmZpZykgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdmFyIHByb2ZpbGUgPSBjb25maWdGaWxlW2Vudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZV07XG4gICAgICByZWdpb24gPSBwcm9maWxlICYmIHByb2ZpbGUucmVnaW9uO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVnaW9uO1xufTtcblxudmFyIGdldEJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZTogdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZTogdW5kZWZpbmVkO1xufTtcblxudmFyIFVTRV9GSVBTX0VORFBPSU5UX0NPTkZJR19PUFRJT05TID0ge1xuICBlbnZpcm9ubWVudFZhcmlhYmxlU2VsZWN0b3I6IGZ1bmN0aW9uKGVudikge1xuICAgIHJldHVybiBnZXRCb29sZWFuVmFsdWUoZW52WydBV1NfVVNFX0ZJUFNfRU5EUE9JTlQnXSk7XG4gIH0sXG4gIGNvbmZpZ0ZpbGVTZWxlY3RvcjogZnVuY3Rpb24ocHJvZmlsZSkge1xuICAgIHJldHVybiBnZXRCb29sZWFuVmFsdWUocHJvZmlsZVsndXNlX2ZpcHNfZW5kcG9pbnQnXSk7XG4gIH0sXG4gIGRlZmF1bHQ6IGZhbHNlLFxufTtcblxudmFyIFVTRV9EVUFMU1RBQ0tfRU5EUE9JTlRfQ09ORklHX09QVElPTlMgPSB7XG4gIGVudmlyb25tZW50VmFyaWFibGVTZWxlY3RvcjogZnVuY3Rpb24oZW52KSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5WYWx1ZShlbnZbJ0FXU19VU0VfRFVBTFNUQUNLX0VORFBPSU5UJ10pO1xuICB9LFxuICBjb25maWdGaWxlU2VsZWN0b3I6IGZ1bmN0aW9uKHByb2ZpbGUpIHtcbiAgICByZXR1cm4gZ2V0Qm9vbGVhblZhbHVlKHByb2ZpbGVbJ3VzZV9kdWFsc3RhY2tfZW5kcG9pbnQnXSk7XG4gIH0sXG4gIGRlZmF1bHQ6IGZhbHNlLFxufTtcblxuLy8gVXBkYXRlIGNvbmZpZ3VyYXRpb24ga2V5c1xuQVdTLnV0aWwudXBkYXRlKEFXUy5Db25maWcucHJvdG90eXBlLmtleXMsIHtcbiAgY3JlZGVudGlhbHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3JlZGVudGlhbHMgPSBudWxsO1xuICAgIG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oW1xuICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTsgfSxcbiAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQU1BWk9OJyk7IH0sXG4gICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyh7IGRpc2FibGVBc3N1bWVSb2xlOiB0cnVlIH0pOyB9XG4gICAgXSkucmVzb2x2ZShmdW5jdGlvbihlcnIsIGNyZWRzKSB7XG4gICAgICBpZiAoIWVycikgY3JlZGVudGlhbHMgPSBjcmVkcztcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlZGVudGlhbHM7XG4gIH0sXG4gIGNyZWRlbnRpYWxQcm92aWRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oKTtcbiAgfSxcbiAgbG9nZ2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkFXU0pTX0RFQlVHID8gY29uc29sZSA6IG51bGw7XG4gIH0sXG4gIHJlZ2lvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZ2lvbiA9IGdldFJlZ2lvbigpO1xuICAgIHJldHVybiByZWdpb24gPyBnZXRSZWFsUmVnaW9uKHJlZ2lvbik6IHVuZGVmaW5lZDtcbiAgfSxcbiAgdXNlRmlwc0VuZHBvaW50OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVnaW9uID0gZ2V0UmVnaW9uKCk7XG4gICAgcmV0dXJuIGlzRmlwc1JlZ2lvbihyZWdpb24pXG4gICAgICA/IHRydWVcbiAgICAgIDogdXRpbC5sb2FkQ29uZmlnKFVTRV9GSVBTX0VORFBPSU5UX0NPTkZJR19PUFRJT05TKTtcbiAgfSxcbiAgdXNlRHVhbHN0YWNrRW5kcG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlsLmxvYWRDb25maWcoVVNFX0RVQUxTVEFDS19FTkRQT0lOVF9DT05GSUdfT1BUSU9OUyk7XG4gIH1cbn0pO1xuXG4vLyBSZXNldCBjb25maWd1cmF0aW9uXG5BV1MuY29uZmlnID0gbmV3IEFXUy5Db25maWcoKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlBhcmFtVmFsaWRhdG9yID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmFsaWRhdG9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHZhbGlkYXRpb24gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nIHRoZVxuICAgKiAgICAgcmVxdWVzdC4gUGFzcyBhIG1hcCB0byBlbmFibGUgYW55IG9mIHRoZSBmb2xsb3dpbmcgc3BlY2lmaWNcbiAgICogICAgIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gICAqXG4gICAqICAgICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gICAqICAgICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICAgKiAgICAgICB0byBgdHJ1ZWAuXG4gICAqICAgICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gICAqICAgICAgIGNvbnN0cmFpbnQuXG4gICAqICAgICAqICoqcGF0dGVybioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYVxuICAgKiAgICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqICAgICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gICAqICAgICAgIG9mIHRoZSBhbGxvd2FibGUgZW51bSB2YWx1ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUGFyYW1WYWxpZGF0b3IodmFsaWRhdGlvbikge1xuICAgIGlmICh2YWxpZGF0aW9uID09PSB0cnVlIHx8IHZhbGlkYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGlvbiA9IHsnbWluJzogdHJ1ZX07XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGlvbiA9IHZhbGlkYXRpb247XG4gIH0sXG5cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUsIHBhcmFtcyB8fCB7fSwgY29udGV4dCB8fCAncGFyYW1zJyk7XG5cbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyb3JzLmpvaW4oJ1xcbiogJyk7XG4gICAgICBtc2cgPSAnVGhlcmUgd2VyZSAnICsgdGhpcy5lcnJvcnMubGVuZ3RoICtcbiAgICAgICAgJyB2YWxpZGF0aW9uIGVycm9yczpcXG4qICcgKyBtc2c7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobXNnKSxcbiAgICAgICAge2NvZGU6ICdNdWx0aXBsZVZhbGlkYXRpb25FcnJvcnMnLCBlcnJvcnM6IHRoaXMuZXJyb3JzfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZmFpbDogZnVuY3Rpb24gZmFpbChjb2RlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5lcnJvcnMucHVzaChBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtjb2RlOiBjb2RlfSkpO1xuICB9LFxuXG4gIHZhbGlkYXRlU3RydWN0dXJlOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cnVjdHVyZShzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHNoYXBlLmlzRG9jdW1lbnQpIHJldHVybiB0cnVlO1xuXG4gICAgdGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbJ29iamVjdCddLCAnc3RydWN0dXJlJyk7XG4gICAgdmFyIHBhcmFtTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgc2hhcGUucmVxdWlyZWQgJiYgaSA8IHNoYXBlLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbU5hbWUgPSBzaGFwZS5yZXF1aXJlZFtpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNaXNzaW5nUmVxdWlyZWRQYXJhbWV0ZXInLFxuICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIGtleSBcXCcnICsgcGFyYW1OYW1lICsgJ1xcJyBpbiAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaGFzaCBtZW1iZXJzXG4gICAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdLFxuICAgICAgICAgIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1twYXJhbU5hbWVdO1xuXG4gICAgICBpZiAobWVtYmVyU2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbWVtYmVyQ29udGV4dCA9IFtjb250ZXh0LCBwYXJhbU5hbWVdLmpvaW4oJy4nKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihtZW1iZXJTaGFwZSwgcGFyYW1WYWx1ZSwgbWVtYmVyQ29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwYXJhbVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnVW5leHBlY3RlZFBhcmFtZXRlcicsXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQga2V5IFxcJycgKyBwYXJhbU5hbWUgKyAnXFwnIGZvdW5kIGluICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICB2YWxpZGF0ZU1lbWJlcjogZnVuY3Rpb24gdmFsaWRhdGVNZW1iZXIoc2hhcGUsIHBhcmFtLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgICBjYXNlICdzdHJ1Y3R1cmUnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cnVjdHVyZShzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTGlzdChzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNYXAoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2NhbGFyKHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlTGlzdDogZnVuY3Rpb24gdmFsaWRhdGVMaXN0KHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbQXJyYXldKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBwYXJhbXMubGVuZ3RoLCBjb250ZXh0LCAnbGlzdCBtZW1iZXIgY291bnQnKTtcbiAgICAgIC8vIHZhbGlkYXRlIGFycmF5IG1lbWJlcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUubWVtYmVyLCBwYXJhbXNbaV0sIGNvbnRleHQgKyAnWycgKyBpICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVNYXA6IGZ1bmN0aW9uIHZhbGlkYXRlTWFwKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbJ29iamVjdCddLCAnbWFwJykpIHtcbiAgICAgIC8vIEJ1aWxkIHVwIGEgY291bnQgb2YgbWFwIG1lbWJlcnMgdG8gdmFsaWRhdGUgcmFuZ2UgdHJhaXRzLlxuICAgICAgdmFyIG1hcENvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtKSkgY29udGludWU7XG4gICAgICAgIC8vIFZhbGlkYXRlIGFueSBtYXAga2V5IHRyYWl0IGNvbnN0cmFpbnRzXG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUua2V5LCBwYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1trZXk9XFwnJyArIHBhcmFtICsgJ1xcJ10nKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZS52YWx1ZSwgcGFyYW1zW3BhcmFtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1tcXCcnICsgcGFyYW0gKyAnXFwnXScpO1xuICAgICAgICBtYXBDb3VudCsrO1xuICAgICAgfVxuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBtYXBDb3VudCwgY29udGV4dCwgJ21hcCBtZW1iZXIgY291bnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVTY2FsYXI6IGZ1bmN0aW9uIHZhbGlkYXRlU2NhbGFyKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZyhzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUGF5bG9hZCh2YWx1ZSwgY29udGV4dCk7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVOdW1iZXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIFsnYm9vbGVhbiddKTtcbiAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgW0RhdGUsXG4gICAgICAgICAgL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT9aJC8sICdudW1iZXInXSxcbiAgICAgICAgICAnRGF0ZSBvYmplY3QsIElTTy04NjAxIHN0cmluZywgb3IgYSBVTklYIHRpbWVzdGFtcCcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbCgnVW5rb3duVHlwZScsICdVbmhhbmRsZWQgdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS50eXBlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbGlkVHlwZXMgPSBbJ3N0cmluZyddO1xuICAgIGlmIChzaGFwZS5pc0pzb25WYWx1ZSkge1xuICAgICAgdmFsaWRUeXBlcyA9IHZhbGlkVHlwZXMuY29uY2F0KFsnbnVtYmVyJywgJ29iamVjdCcsICdib29sZWFuJ10pO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIHZhbGlkVHlwZXMpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlRW51bShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZS5sZW5ndGgsIGNvbnRleHQsICdzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICB0aGlzLnZhbGlkYXRlUGF0dGVybihzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVVyaShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVVyaTogZnVuY3Rpb24gdmFsaWRhdGVVcmkoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHNoYXBlWydsb2NhdGlvbiddID09PSAndXJpJykge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmZhaWwoJ1VyaVBhcmFtZXRlckVycm9yJywgJ0V4cGVjdGVkIHVyaSBwYXJhbWV0ZXIgdG8gaGF2ZSBsZW5ndGggPj0gMSwnXG4gICAgICAgICAgKyAnIGJ1dCBmb3VuZCBcIicgKyB2YWx1ZSArJ1wiIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlUGF0dGVybjogZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ3BhdHRlcm4nXSAmJiBzaGFwZVsncGF0dGVybiddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghKG5ldyBSZWdFeHAoc2hhcGVbJ3BhdHRlcm4nXSkpLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnUGF0dGVybk1hdGNoRXJyb3InLCAnUHJvdmlkZWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgJ1xuICAgICAgICAgICsgJ2RvZXMgbm90IG1hdGNoIHJlZ2V4IHBhdHRlcm4gLycgKyBzaGFwZVsncGF0dGVybiddICsgJy8gZm9yICdcbiAgICAgICAgICArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVJhbmdlOiBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCwgZGVzY3JpcHRvcikge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ21pbiddKSB7XG4gICAgICBpZiAoc2hhcGVbJ21pbiddICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBzaGFwZVsnbWluJ10pIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNaW5SYW5nZUVycm9yJywgJ0V4cGVjdGVkICcgKyBkZXNjcmlwdG9yICsgJyA+PSAnXG4gICAgICAgICAgKyBzaGFwZVsnbWluJ10gKyAnLCBidXQgZm91bmQgJyArIHZhbHVlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydtYXgnXSkge1xuICAgICAgaWYgKHNoYXBlWydtYXgnXSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gc2hhcGVbJ21heCddKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWF4UmFuZ2VFcnJvcicsICdFeHBlY3RlZCAnICsgZGVzY3JpcHRvciArICcgPD0gJ1xuICAgICAgICAgICsgc2hhcGVbJ21heCddICsgJywgYnV0IGZvdW5kICcgKyB2YWx1ZSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVFbnVtOiBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ2VudW0nXSAmJiBzaGFwZVsnZW51bSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEZhaWwgaWYgdGhlIHN0cmluZyB2YWx1ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgZW51bSBsaXN0XG4gICAgICBpZiAoc2hhcGVbJ2VudW0nXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdFbnVtRXJyb3InLCAnRm91bmQgc3RyaW5nIHZhbHVlIG9mICcgKyB2YWx1ZSArICcsIGJ1dCAnXG4gICAgICAgICAgKyAnZXhwZWN0ZWQgJyArIHNoYXBlWydlbnVtJ10uam9pbignfCcpICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVR5cGU6IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgYWNjZXB0ZWRUeXBlcywgdHlwZSkge1xuICAgIC8vIFdlIHdpbGwgbm90IGxvZyBhbiBlcnJvciBmb3IgbnVsbCBvciB1bmRlZmluZWQsIGJ1dCB3ZSB3aWxsIHJldHVyblxuICAgIC8vIGZhbHNlIHNvIHRoYXQgY2FsbGVycyBrbm93IHRoYXQgdGhlIGV4cGVjdGVkIHR5cGUgd2FzIG5vdCBzdHJpY3RseSBtZXQuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBmb3VuZEludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFjY2VwdGVkVHlwZXNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IGFjY2VwdGVkVHlwZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChhY2NlcHRlZFR5cGVzW2ldIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmICgodmFsdWUgfHwgJycpLnRvU3RyaW5nKCkubWF0Y2goYWNjZXB0ZWRUeXBlc1tpXSkpIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgYWNjZXB0ZWRUeXBlc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc1R5cGUodmFsdWUsIGFjY2VwdGVkVHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0eXBlICYmICFmb3VuZEludmFsaWRUeXBlKSBhY2NlcHRlZFR5cGVzID0gYWNjZXB0ZWRUeXBlcy5zbGljZSgpO1xuICAgICAgICBhY2NlcHRlZFR5cGVzW2ldID0gQVdTLnV0aWwudHlwZU5hbWUoYWNjZXB0ZWRUeXBlc1tpXSk7XG4gICAgICB9XG4gICAgICBmb3VuZEludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYWNjZXB0ZWRUeXBlID0gdHlwZTtcbiAgICBpZiAoIWFjY2VwdGVkVHlwZSkge1xuICAgICAgYWNjZXB0ZWRUeXBlID0gYWNjZXB0ZWRUeXBlcy5qb2luKCcsICcpLnJlcGxhY2UoLywoW14sXSspJC8sICcsIG9yJDEnKTtcbiAgICB9XG5cbiAgICB2YXIgdm93ZWwgPSBhY2NlcHRlZFR5cGUubWF0Y2goL15bYWVpb3VdL2kpID8gJ24nIDogJyc7XG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYScgK1xuICAgICAgICAgICAgICB2b3dlbCArICcgJyArIGFjY2VwdGVkVHlwZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHZhbGlkYXRlTnVtYmVyOiBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY2FzdGVkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmIChjYXN0ZWRWYWx1ZS50b1N0cmluZygpID09PSB2YWx1ZSkgdmFsdWUgPSBjYXN0ZWRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCBbJ251bWJlciddKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCwgJ251bWVyaWMgdmFsdWUnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVQYXlsb2FkOiBmdW5jdGlvbiB2YWxpZGF0ZVBheWxvYWQodmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykgcmV0dXJuOyAvLyB0eXBlZCBhcnJheXNcbiAgICBpZiAoQVdTLnV0aWwuaXNOb2RlKCkpIHsgLy8gc3BlY2lhbCBjaGVjayBmb3IgYnVmZmVyL3N0cmVhbSBpbiBOb2RlLmpzXG4gICAgICB2YXIgU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlN0cmVhbTtcbiAgICAgIGlmIChBV1MudXRpbC5CdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gdm9pZCAwICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYikgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlcyA9IFsnQnVmZmVyJywgJ1N0cmVhbScsICdGaWxlJywgJ0Jsb2InLCAnQXJyYXlCdWZmZXInLCAnRGF0YVZpZXcnXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzVHlwZSh2YWx1ZSwgdHlwZXNbaV0pKSByZXR1cm47XG4gICAgICAgIGlmIChBV1MudXRpbC50eXBlTmFtZSh2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IHR5cGVzW2ldKSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYSAnICtcbiAgICAgICdzdHJpbmcsIEJ1ZmZlciwgU3RyZWFtLCBCbG9iLCBvciB0eXBlZCBhcnJheSBvYmplY3QnKTtcbiAgfVxufSk7XG4iLCJ2YXIgdXRpbCA9ICByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIFByZXBlbmQgcHJlZml4IGRlZmluZWQgYnkgQVBJIG1vZGVsIHRvIGVuZHBvaW50IHRoYXQncyBhbHJlYWR5XG4gKiBjb25zdHJ1Y3RlZC4gVGhpcyBmZWF0dXJlIGRvZXMgbm90IGFwcGx5IHRvIG9wZXJhdGlvbnMgdXNpbmdcbiAqIGVuZHBvaW50IGRpc2NvdmVyeSBhbmQgY2FuIGJlIGRpc2FibGVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlSG9zdFByZWZpeChyZXF1ZXN0KSAge1xuICB2YXIgZW5hYmxlZCA9IHJlcXVlc3Quc2VydmljZS5jb25maWcuaG9zdFByZWZpeEVuYWJsZWQ7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIHJlcXVlc3Q7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIC8vZG9uJ3QgbWFyc2hhbCBob3N0IHByZWZpeCB3aGVuIG9wZXJhdGlvbiBoYXMgZW5kcG9pbnQgZGlzY292ZXJ5IHRyYWl0c1xuICBpZiAoaGFzRW5kcG9pbnREaXNjb3ZlcihyZXF1ZXN0KSkgcmV0dXJuIHJlcXVlc3Q7XG4gIGlmIChvcGVyYXRpb25Nb2RlbC5lbmRwb2ludCAmJiBvcGVyYXRpb25Nb2RlbC5lbmRwb2ludC5ob3N0UHJlZml4KSB7XG4gICAgdmFyIGhvc3RQcmVmaXhOb3RhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50Lmhvc3RQcmVmaXg7XG4gICAgdmFyIGhvc3RQcmVmaXggPSBleHBhbmRIb3N0UHJlZml4KGhvc3RQcmVmaXhOb3RhdGlvbiwgcmVxdWVzdC5wYXJhbXMsIG9wZXJhdGlvbk1vZGVsLmlucHV0KTtcbiAgICBwcmVwZW5kRW5kcG9pbnRQcmVmaXgocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCwgaG9zdFByZWZpeCk7XG4gICAgdmFsaWRhdGVIb3N0bmFtZShyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFzRW5kcG9pbnREaXNjb3ZlcihyZXF1ZXN0KSB7XG4gIHZhciBhcGkgPSByZXF1ZXN0LnNlcnZpY2UuYXBpO1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBhcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIHZhciBpc0VuZHBvaW50T3BlcmF0aW9uID0gYXBpLmVuZHBvaW50T3BlcmF0aW9uICYmIChhcGkuZW5kcG9pbnRPcGVyYXRpb24gPT09IHV0aWwuc3RyaW5nLmxvd2VyRmlyc3Qob3BlcmF0aW9uTW9kZWwubmFtZSkpO1xuICByZXR1cm4gKG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50RGlzY292ZXJ5UmVxdWlyZWQgIT09ICdOVUxMJyB8fCBpc0VuZHBvaW50T3BlcmF0aW9uID09PSB0cnVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXhwYW5kSG9zdFByZWZpeChob3N0UHJlZml4Tm90YXRpb24sIHBhcmFtcywgc2hhcGUpIHtcbiAgdXRpbC5lYWNoKHNoYXBlLm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIGlmIChtZW1iZXIuaG9zdExhYmVsID09PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtc1tuYW1lXSAhPT0gJ3N0cmluZycgfHwgcGFyYW1zW25hbWVdID09PSAnJykge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgbWVzc2FnZTogJ1BhcmFtZXRlciAnICsgbmFtZSArICcgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgIGNvZGU6ICdJbnZhbGlkUGFyYW1ldGVyJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG5hbWUgKyAnXFxcXH0nLCAnZycpO1xuICAgICAgaG9zdFByZWZpeE5vdGF0aW9uID0gaG9zdFByZWZpeE5vdGF0aW9uLnJlcGxhY2UocmVnZXgsIHBhcmFtc1tuYW1lXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhvc3RQcmVmaXhOb3RhdGlvbjtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZEVuZHBvaW50UHJlZml4KGVuZHBvaW50LCBwcmVmaXgpIHtcbiAgaWYgKGVuZHBvaW50Lmhvc3QpIHtcbiAgICBlbmRwb2ludC5ob3N0ID0gcHJlZml4ICsgZW5kcG9pbnQuaG9zdDtcbiAgfVxuICBpZiAoZW5kcG9pbnQuaG9zdG5hbWUpIHtcbiAgICBlbmRwb2ludC5ob3N0bmFtZSA9IHByZWZpeCArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgdmFyIGxhYmVscyA9IGhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gIC8vUmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTEyMyNzZWN0aW9uLTJcbiAgdmFyIGhvc3RQYXR0ZXJuID0gL15bYS16QS1aMC05XXsxfSR8XlthLXpBLVowLTldW2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0kLztcbiAgdXRpbC5hcnJheUVhY2gobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgIGlmICghbGFiZWwubGVuZ3RoIHx8IGxhYmVsLmxlbmd0aCA8IDEgfHwgbGFiZWwubGVuZ3RoID4gNjMpIHtcbiAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ1ZhbGlkYXRpb25FcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdIb3N0bmFtZSBsYWJlbCBsZW5ndGggc2hvdWxkIGJlIGJldHdlZW4gMSB0byA2MyBjaGFyYWN0ZXJzLCBpbmNsdXNpdmUuJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaG9zdFBhdHRlcm4udGVzdChsYWJlbCkpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7Y29kZTogJ1ZhbGlkYXRpb25FcnJvcicsIG1lc3NhZ2U6IGxhYmVsICsgJyBpcyBub3QgaG9zdG5hbWUgY29tcGF0aWJsZS4nfSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBvcHVsYXRlSG9zdFByZWZpeDogcG9wdWxhdGVIb3N0UHJlZml4XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgSnNvbkJ1aWxkZXIgPSByZXF1aXJlKCcuLi9qc29uL2J1aWxkZXInKTtcbnZhciBKc29uUGFyc2VyID0gcmVxdWlyZSgnLi4vanNvbi9wYXJzZXInKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICB2YXIgYXBpID0gcmVxLnNlcnZpY2UuYXBpO1xuICB2YXIgdGFyZ2V0ID0gYXBpLnRhcmdldFByZWZpeCArICcuJyArIGFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm5hbWU7XG4gIHZhciB2ZXJzaW9uID0gYXBpLmpzb25WZXJzaW9uIHx8ICcxLjAnO1xuICB2YXIgaW5wdXQgPSBhcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcblxuICBpZiAodmVyc2lvbiA9PT0gMSkgdmVyc2lvbiA9ICcxLjAnO1xuICBodHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zIHx8IHt9LCBpbnB1dCk7XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtYW16LWpzb24tJyArIHZlcnNpb247XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVRhcmdldCddID0gdGFyZ2V0O1xuXG4gIHBvcHVsYXRlSG9zdFByZWZpeChyZXEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IocmVzcCkge1xuICB2YXIgZXJyb3IgPSB7fTtcbiAgdmFyIGh0dHBSZXNwb25zZSA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuXG4gIGVycm9yLmNvZGUgPSBodHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLWVycm9ydHlwZSddIHx8ICdVbmtub3duRXJyb3InO1xuICBpZiAodHlwZW9mIGVycm9yLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLmNvZGUuc3BsaXQoJzonKVswXTtcbiAgfVxuXG4gIGlmIChodHRwUmVzcG9uc2UuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlID0gSlNPTi5wYXJzZShodHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpKTtcbiAgICAgIHZhciBjb2RlID0gZS5fX3R5cGUgfHwgZS5jb2RlIHx8IGUuQ29kZTtcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlLnNwbGl0KCcjJykucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1JlcXVlc3RFbnRpdHlUb29MYXJnZScpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9ICdSZXF1ZXN0IGJvZHkgbXVzdCBiZSBsZXNzIHRoYW4gMSBNQic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gKGUubWVzc2FnZSB8fCBlLk1lc3NhZ2UgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwgZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpIHx8ICd7fSc7XG4gIGlmIChyZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuY29udmVydFJlc3BvbnNlVHlwZXMgPT09IGZhbHNlKSB7XG4gICAgcmVzcC5kYXRhID0gSlNPTi5wYXJzZShib2R5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIHNoYXBlID0gb3BlcmF0aW9uLm91dHB1dCB8fCB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICByZXNwLmRhdGEgPSBwYXJzZXIucGFyc2UoYm9keSwgc2hhcGUpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBRdWVyeVBhcmFtU2VyaWFsaXplciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXInKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL21vZGVsL3NoYXBlJyk7XG52YXIgcG9wdWxhdGVIb3N0UHJlZml4ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykucG9wdWxhdGVIb3N0UHJlZml4O1xuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9XG4gICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOCc7XG4gIGh0dHBSZXF1ZXN0LnBhcmFtcyA9IHtcbiAgICBWZXJzaW9uOiByZXEuc2VydmljZS5hcGkuYXBpVmVyc2lvbixcbiAgICBBY3Rpb246IG9wZXJhdGlvbi5uYW1lXG4gIH07XG5cbiAgLy8gY29udmVydCB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzIGludG8gYSBsaXN0IG9mIHF1ZXJ5IHBhcmFtcyxcbiAgLy8gZS5nLiBEZWVwbHkuTmVzdGVkUGFyYW0uMC5OYW1lPXZhbHVlXG4gIHZhciBidWlsZGVyID0gbmV3IFF1ZXJ5UGFyYW1TZXJpYWxpemVyKCk7XG4gIGJ1aWxkZXIuc2VyaWFsaXplKHJlcS5wYXJhbXMsIG9wZXJhdGlvbi5pbnB1dCwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBodHRwUmVxdWVzdC5wYXJhbXNbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG4gIGh0dHBSZXF1ZXN0LmJvZHkgPSB1dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcoaHR0cFJlcXVlc3QucGFyYW1zKTtcblxuICBwb3B1bGF0ZUhvc3RQcmVmaXgocmVxKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgdmFyIGRhdGEsIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCk7XG4gIGlmIChib2R5Lm1hdGNoKCc8VW5rbm93bk9wZXJhdGlvbkV4Y2VwdGlvbicpKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIENvZGU6ICdVbmtub3duT3BlcmF0aW9uJyxcbiAgICAgIE1lc3NhZ2U6ICdVbmtub3duIG9wZXJhdGlvbiAnICsgcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKS5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBDb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICBNZXNzYWdlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRhLnJlcXVlc3RJZCAmJiAhcmVzcC5yZXF1ZXN0SWQpIHJlc3AucmVxdWVzdElkID0gZGF0YS5yZXF1ZXN0SWQ7XG4gIGlmIChkYXRhLkVycm9ycykgZGF0YSA9IGRhdGEuRXJyb3JzO1xuICBpZiAoZGF0YS5FcnJvcikgZGF0YSA9IGRhdGEuRXJyb3I7XG4gIGlmIChkYXRhLkNvZGUpIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogZGF0YS5Db2RlLFxuICAgICAgbWVzc2FnZTogZGF0YS5NZXNzYWdlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBtZXNzYWdlOiBudWxsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBzaGFwZSA9IG9wZXJhdGlvbi5vdXRwdXQgfHwge307XG4gIHZhciBvcmlnUnVsZXMgPSBzaGFwZTtcblxuICBpZiAob3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXIpIHtcbiAgICB2YXIgdG1wID0gU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30pO1xuICAgIHRtcC5tZW1iZXJzW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXSA9IHNoYXBlO1xuICAgIHRtcC5tZW1iZXJOYW1lcyA9IFtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl07XG4gICAgdXRpbC5wcm9wZXJ0eShzaGFwZSwgJ25hbWUnLCBzaGFwZS5yZXN1bHRXcmFwcGVyKTtcbiAgICBzaGFwZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcblxuICAvLyBUT0RPOiBSZWZhY3RvciBYTUwgUGFyc2VyIHRvIHBhcnNlIFJlcXVlc3RJZCBmcm9tIHJlc3BvbnNlLlxuICBpZiAoc2hhcGUgJiYgc2hhcGUubWVtYmVycyAmJiAhc2hhcGUubWVtYmVycy5fWEFNWlJlcXVlc3RJZCkge1xuICAgIHZhciByZXF1ZXN0SWRTaGFwZSA9IFNoYXBlLmNyZWF0ZShcbiAgICAgIHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgIHsgYXBpOiB7IHByb3RvY29sOiAncXVlcnknIH0gfSxcbiAgICAgICdyZXF1ZXN0SWQnXG4gICAgKTtcbiAgICBzaGFwZS5tZW1iZXJzLl9YQU1aUmVxdWVzdElkID0gcmVxdWVzdElkU2hhcGU7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhcnNlci5wYXJzZShyZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCksIHNoYXBlKTtcbiAgcmVzcC5yZXF1ZXN0SWQgPSBkYXRhLl9YQU1aUmVxdWVzdElkIHx8IGRhdGEucmVxdWVzdElkO1xuXG4gIGlmIChkYXRhLl9YQU1aUmVxdWVzdElkKSBkZWxldGUgZGF0YS5fWEFNWlJlcXVlc3RJZDtcblxuICBpZiAob3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXIpIHtcbiAgICBpZiAoZGF0YVtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl0pIHtcbiAgICAgIHV0aWwudXBkYXRlKGRhdGEsIGRhdGFbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdKTtcbiAgICAgIGRlbGV0ZSBkYXRhW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXTtcbiAgICB9XG4gIH1cblxuICByZXNwLmRhdGEgPSBkYXRhO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWV0aG9kKHJlcSkge1xuICByZXEuaHR0cFJlcXVlc3QubWV0aG9kID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaHR0cE1ldGhvZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVUkkoZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoLCBpbnB1dCwgcGFyYW1zKSB7XG4gIHZhciB1cmkgPSBbZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoXS5qb2luKCcvJyk7XG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG5cbiAgdmFyIHF1ZXJ5U3RyaW5nID0ge30sIHF1ZXJ5U3RyaW5nU2V0ID0gZmFsc2U7XG4gIHV0aWwuZWFjaChpbnB1dC5tZW1iZXJzLCBmdW5jdGlvbiAobmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgaWYgKHBhcmFtVmFsdWUgPT09IG51bGwgfHwgcGFyYW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3VyaScpIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG1lbWJlci5uYW1lICsgJyhcXFxcKyk/XFxcXH0nKTtcbiAgICAgIHVyaSA9IHVyaS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihfLCBwbHVzKSB7XG4gICAgICAgIHZhciBmbiA9IHBsdXMgPyB1dGlsLnVyaUVzY2FwZVBhdGggOiB1dGlsLnVyaUVzY2FwZTtcbiAgICAgICAgcmV0dXJuIGZuKFN0cmluZyhwYXJhbVZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3F1ZXJ5c3RyaW5nJykge1xuICAgICAgcXVlcnlTdHJpbmdTZXQgPSB0cnVlO1xuXG4gICAgICBpZiAobWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICBxdWVyeVN0cmluZ1ttZW1iZXIubmFtZV0gPSBwYXJhbVZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC51cmlFc2NhcGUobWVtYmVyLm1lbWJlci50b1dpcmVGb3JtYXQodmFsKS50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgICB1dGlsLmVhY2gocGFyYW1WYWx1ZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IHZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwudXJpRXNjYXBlKFN0cmluZyh2YWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nW21lbWJlci5uYW1lXSA9IHV0aWwudXJpRXNjYXBlKG1lbWJlci50b1dpcmVGb3JtYXQocGFyYW1WYWx1ZSkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAocXVlcnlTdHJpbmdTZXQpIHtcbiAgICB1cmkgKz0gKHVyaS5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/Jyk7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdXRpbC5hcnJheUVhY2goT2JqZWN0LmtleXMocXVlcnlTdHJpbmcpLnNvcnQoKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocXVlcnlTdHJpbmdba2V5XSkpIHtcbiAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IFtxdWVyeVN0cmluZ1trZXldXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlTdHJpbmdba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKHV0aWwudXJpRXNjYXBlKFN0cmluZyhrZXkpKSArICc9JyArIHF1ZXJ5U3RyaW5nW2tleV1baV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVyaSArPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZVVSSShyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgaW5wdXQgPSBvcGVyYXRpb24uaW5wdXQ7XG5cbiAgdmFyIHVyaSA9IGdlbmVyYXRlVVJJKHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5wYXRoLCBvcGVyYXRpb24uaHR0cFBhdGgsIGlucHV0LCByZXEucGFyYW1zKTtcbiAgcmVxLmh0dHBSZXF1ZXN0LnBhdGggPSB1cmk7XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlSGVhZGVycyhyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB1dGlsLmVhY2gob3BlcmF0aW9uLmlucHV0Lm1lbWJlcnMsIGZ1bmN0aW9uIChuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgdmFsdWUgPSByZXEucGFyYW1zW25hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVycycgJiYgbWVtYmVyLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICB1dGlsLmVhY2godmFsdWUsIGZ1bmN0aW9uKGtleSwgbWVtYmVyVmFsdWUpIHtcbiAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbbWVtYmVyLm5hbWUgKyBrZXldID0gbWVtYmVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcicpIHtcbiAgICAgIHZhbHVlID0gbWVtYmVyLnRvV2lyZUZvcm1hdCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtZW1iZXIuaXNKc29uVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB1dGlsLmJhc2U2NC5lbmNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbbWVtYmVyLm5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICBwb3B1bGF0ZU1ldGhvZChyZXEpO1xuICBwb3B1bGF0ZVVSSShyZXEpO1xuICBwb3B1bGF0ZUhlYWRlcnMocmVxKTtcbiAgcG9wdWxhdGVIb3N0UHJlZml4KHJlcSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcigpIHtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgciA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuXG4gIC8vIG5vcm1hbGl6ZSBoZWFkZXJzIG5hbWVzIHRvIGxvd2VyLWNhc2VkIGtleXMgZm9yIG1hdGNoaW5nXG4gIHZhciBoZWFkZXJzID0ge307XG4gIHV0aWwuZWFjaChyLmhlYWRlcnMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaGVhZGVyc1trLnRvTG93ZXJDYXNlKCldID0gdjtcbiAgfSk7XG5cbiAgdXRpbC5lYWNoKG91dHB1dC5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgaGVhZGVyID0gKG1lbWJlci5uYW1lIHx8IG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcnMnICYmIG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHt9O1xuICAgICAgdmFyIGxvY2F0aW9uID0gbWVtYmVyLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyLm5hbWUgOiAnJztcbiAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXicgKyBsb2NhdGlvbiArICcoLispJywgJ2knKTtcbiAgICAgIHV0aWwuZWFjaChyLmhlYWRlcnMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBrLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YVtuYW1lXVtyZXN1bHRbMV1dID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgICBpZiAoaGVhZGVyc1toZWFkZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWVtYmVyLmlzSnNvblZhbHVlID9cbiAgICAgICAgICB1dGlsLmJhc2U2NC5kZWNvZGUoaGVhZGVyc1toZWFkZXJdKSA6XG4gICAgICAgICAgaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICBkYXRhW25hbWVdID0gbWVtYmVyLnRvVHlwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdzdGF0dXNDb2RlJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHBhcnNlSW50KHIuc3RhdHVzQ29kZSwgMTApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVzcC5kYXRhID0gZGF0YTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhLFxuICBnZW5lcmF0ZVVSSTogZ2VuZXJhdGVVUklcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSZXN0ID0gcmVxdWlyZSgnLi9yZXN0Jyk7XG52YXIgSnNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xudmFyIEpzb25CdWlsZGVyID0gcmVxdWlyZSgnLi4vanNvbi9idWlsZGVyJyk7XG52YXIgSnNvblBhcnNlciA9IHJlcXVpcmUoJy4uL2pzb24vcGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQm9keShyZXEpIHtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcbiAgdmFyIGlucHV0ID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG5cbiAgaWYgKGlucHV0LnBheWxvYWQpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgdmFyIHBheWxvYWRTaGFwZSA9IGlucHV0Lm1lbWJlcnNbaW5wdXQucGF5bG9hZF07XG4gICAgcGFyYW1zID0gcmVxLnBhcmFtc1tpbnB1dC5wYXlsb2FkXTtcblxuICAgIGlmIChwYXlsb2FkU2hhcGUudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChwYXJhbXMgfHwge30sIHBheWxvYWRTaGFwZSk7XG4gICAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbm9uLUpTT04gcGF5bG9hZFxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBwYXJhbXM7XG4gICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRTaGFwZS5pc1N0cmVhbWluZykge1xuICAgICAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zLCBpbnB1dCk7XG4gICAgYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxLCBpc0JpbmFyeSkge1xuICBpZiAoIXJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkge1xuICAgIHZhciB0eXBlID0gaXNCaW5hcnkgPyAnYmluYXJ5L29jdGV0LXN0cmVhbScgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIFJlc3QuYnVpbGRSZXF1ZXN0KHJlcSk7XG5cbiAgLy8gbmV2ZXIgc2VuZCBib2R5IHBheWxvYWQgb24gR0VUL0hFQUQvREVMRVRFXG4gIGlmIChbJ0dFVCcsICdIRUFEJywgJ0RFTEVURSddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgSnNvbi5leHRyYWN0RXJyb3IocmVzcCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RGF0YShyZXNwKTtcblxuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm91dHB1dCB8fCB7fTtcbiAgdmFyIHBhcnNlcjtcbiAgdmFyIGhhc0V2ZW50T3V0cHV0ID0gb3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0O1xuXG4gIGlmIChydWxlcy5wYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBydWxlcy5tZW1iZXJzW3J1bGVzLnBheWxvYWRdO1xuICAgIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keTtcbiAgICBpZiAocGF5bG9hZE1lbWJlci5pc0V2ZW50U3RyZWFtKSB7XG4gICAgICBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gdXRpbC5jcmVhdGVFdmVudFN0cmVhbShcbiAgICAgICAgQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIgPyByZXNwLmh0dHBSZXNwb25zZS5zdHJlYW0gOiBib2R5LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHBheWxvYWRNZW1iZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnIHx8IHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHBhcnNlci5wYXJzZShib2R5LCBwYXlsb2FkTWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ2JpbmFyeScgfHwgcGF5bG9hZE1lbWJlci5pc1N0cmVhbWluZykge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gcGF5bG9hZE1lbWJlci50b1R5cGUoYm9keSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhID0gcmVzcC5kYXRhO1xuICAgIEpzb24uZXh0cmFjdERhdGEocmVzcCk7XG4gICAgcmVzcC5kYXRhID0gdXRpbC5tZXJnZShkYXRhLCByZXNwLmRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSZXN0ID0gcmVxdWlyZSgnLi9yZXN0Jyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQm9keShyZXEpIHtcbiAgdmFyIGlucHV0ID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG4gIHZhciBidWlsZGVyID0gbmV3IEFXUy5YTUwuQnVpbGRlcigpO1xuICB2YXIgcGFyYW1zID0gcmVxLnBhcmFtcztcblxuICB2YXIgcGF5bG9hZCA9IGlucHV0LnBheWxvYWQ7XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBpbnB1dC5tZW1iZXJzW3BheWxvYWRdO1xuICAgIHBhcmFtcyA9IHBhcmFtc1twYXlsb2FkXTtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBwYXlsb2FkTWVtYmVyLm5hbWU7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIudG9YTUwocGFyYW1zLCBwYXlsb2FkTWVtYmVyLCByb290RWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHsgLy8gbm9uLXhtbCBwYXlsb2FkXG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IHBhcmFtcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLnRvWE1MKHBhcmFtcywgaW5wdXQsIGlucHV0Lm5hbWUgfHxcbiAgICAgIGlucHV0LnNoYXBlIHx8IHV0aWwuc3RyaW5nLnVwcGVyRmlyc3QocmVxLm9wZXJhdGlvbikgKyAnUmVxdWVzdCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgUmVzdC5idWlsZFJlcXVlc3QocmVxKTtcblxuICAvLyBuZXZlciBzZW5kIGJvZHkgcGF5bG9hZCBvbiBHRVQvSEVBRFxuICBpZiAoWydHRVQnLCAnSEVBRCddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RXJyb3IocmVzcCk7XG5cbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkYXRhID0ge1xuICAgICAgQ29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIE1lc3NhZ2U6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKGRhdGEuRXJyb3JzKSBkYXRhID0gZGF0YS5FcnJvcnM7XG4gIGlmIChkYXRhLkVycm9yKSBkYXRhID0gZGF0YS5FcnJvcjtcbiAgaWYgKGRhdGEuQ29kZSkge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiBkYXRhLkNvZGUsXG4gICAgICBtZXNzYWdlOiBkYXRhLk1lc3NhZ2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdERhdGEocmVzcCk7XG5cbiAgdmFyIHBhcnNlcjtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuXG4gIHZhciBoYXNFdmVudE91dHB1dCA9IG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dDtcblxuICB2YXIgcGF5bG9hZCA9IG91dHB1dC5wYXlsb2FkO1xuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gb3V0cHV0Lm1lbWJlcnNbcGF5bG9hZF07XG4gICAgaWYgKHBheWxvYWRNZW1iZXIuaXNFdmVudFN0cmVhbSkge1xuICAgICAgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSB1dGlsLmNyZWF0ZUV2ZW50U3RyZWFtKFxuICAgICAgICBBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMiA/IHJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbSA6IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHksXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgcGF5bG9hZE1lbWJlclxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHBhcnNlciA9IG5ldyBBV1MuWE1MLlBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gcGFyc2VyLnBhcnNlKGJvZHkudG9TdHJpbmcoKSwgcGF5bG9hZE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHBheWxvYWRNZW1iZXIudG9UeXBlKGJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib2R5Lmxlbmd0aCA+IDApIHtcbiAgICBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcbiAgICB2YXIgZGF0YSA9IHBhcnNlci5wYXJzZShib2R5LnRvU3RyaW5nKCksIG91dHB1dCk7XG4gICAgdXRpbC51cGRhdGUocmVzcC5kYXRhLCBkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIFJlc29sdmUgY2xpZW50LXNpZGUgbW9uaXRvcmluZyBjb25maWd1cmF0aW9uIGZyb20gZWl0aGVyIGVudmlyb25tZW50YWwgdmFyaWFibGVzXG4gKiBvciBzaGFyZWQgY29uZmlnIGZpbGUuIENvbmZpZ3VyYXRpb25zIGZyb20gZW52aXJvbm1lbnRhbCB2YXJpYWJsZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAqIHRoYW4gdGhvc2UgZnJvbSBzaGFyZWQgY29uZmlnIGZpbGUuIFRoZSByZXNvbHZlciB3aWxsIHRyeSB0byByZWFkIHRoZSBzaGFyZWQgY29uZmlnIGZpbGVcbiAqIG5vIG1hdHRlciB3aGV0aGVyIHRoZSBBV1NfU0RLX0xPQURfQ09ORklHIHZhcmlhYmxlIGlzIHNldC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlTW9uaXRvcmluZ0NvbmZpZygpIHtcbiAgdmFyIGNvbmZpZyA9IHtcbiAgICBwb3J0OiB1bmRlZmluZWQsXG4gICAgY2xpZW50SWQ6IHVuZGVmaW5lZCxcbiAgICBlbmFibGVkOiB1bmRlZmluZWQsXG4gICAgaG9zdDogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChmcm9tRW52aXJvbm1lbnQoY29uZmlnKSB8fCBmcm9tQ29uZmlnRmlsZShjb25maWcpKSByZXR1cm4gdG9KU1R5cGUoY29uZmlnKTtcbiAgcmV0dXJuIHRvSlNUeXBlKGNvbmZpZyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBjb25maWd1cmF0aW9ucyBmcm9tIGVudmlyb25tZW50YWwgdmFyaWFibGVzLlxuICogQHBhcmFtIHtvYmplY3R9IGNsaWVudCBzaWRlIG1vbml0b3JpbmcgY29uZmlnIG9iamVjdCBuZWVkcyB0byBiZSByZXNvbHZlZFxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgcmVzb2x2aW5nIGNvbmZpZ3VyYXRpb25zIGlzIGRvbmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmcm9tRW52aXJvbm1lbnQoY29uZmlnKSB7XG4gIGNvbmZpZy5wb3J0ID0gY29uZmlnLnBvcnQgfHwgcHJvY2Vzcy5lbnYuQVdTX0NTTV9QT1JUO1xuICBjb25maWcuZW5hYmxlZCA9IGNvbmZpZy5lbmFibGVkIHx8IHByb2Nlc3MuZW52LkFXU19DU01fRU5BQkxFRDtcbiAgY29uZmlnLmNsaWVudElkID0gY29uZmlnLmNsaWVudElkIHx8IHByb2Nlc3MuZW52LkFXU19DU01fQ0xJRU5UX0lEO1xuICBjb25maWcuaG9zdCA9IGNvbmZpZy5ob3N0IHx8IHByb2Nlc3MuZW52LkFXU19DU01fSE9TVDtcbiAgcmV0dXJuIGNvbmZpZy5wb3J0ICYmIGNvbmZpZy5lbmFibGVkICYmIGNvbmZpZy5jbGllbnRJZCAmJiBjb25maWcuaG9zdCB8fFxuICAgIFsnZmFsc2UnLCAnMCddLmluZGV4T2YoY29uZmlnLmVuYWJsZWQpID49IDA7IC8vbm8gbmVlZCB0byByZWFkIHNoYXJlZCBjb25maWcgZmlsZSBpZiBleHBsaWNpdGVseSBkaXNhYmxlZFxufVxuXG4vKipcbiAqIFJlc29sdmUgY29maWd1cmF0aW9ucyBmcm9tIHNoYXJlZCBjb25maWcgZmlsZSB3aXRoIHNwZWNpZmllZCByb2xlIG5hbWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGllbnQgc2lkZSBtb25pdG9yaW5nIGNvbmZpZyBvYmplY3QgbmVlZHMgdG8gYmUgcmVzb2x2ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHJlc29sdmluZyBjb25maWd1cmF0aW9ucyBpcyBkb25lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZnJvbUNvbmZpZ0ZpbGUoY29uZmlnKSB7XG4gIHZhciBzaGFyZWRGaWxlQ29uZmlnO1xuICB0cnkge1xuICAgIHZhciBjb25maWdGaWxlID0gQVdTLnV0aWwuaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgIGlzQ29uZmlnOiB0cnVlLFxuICAgICAgZmlsZW5hbWU6IHByb2Nlc3MuZW52W0FXUy51dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdXG4gICAgfSk7XG4gICAgdmFyIHNoYXJlZEZpbGVDb25maWcgPSBjb25maWdGaWxlW1xuICAgICAgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGVcbiAgICBdO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFzaGFyZWRGaWxlQ29uZmlnKSByZXR1cm4gY29uZmlnO1xuICBjb25maWcucG9ydCA9IGNvbmZpZy5wb3J0IHx8IHNoYXJlZEZpbGVDb25maWcuY3NtX3BvcnQ7XG4gIGNvbmZpZy5lbmFibGVkID0gY29uZmlnLmVuYWJsZWQgfHwgc2hhcmVkRmlsZUNvbmZpZy5jc21fZW5hYmxlZDtcbiAgY29uZmlnLmNsaWVudElkID0gY29uZmlnLmNsaWVudElkIHx8IHNoYXJlZEZpbGVDb25maWcuY3NtX2NsaWVudF9pZDtcbiAgY29uZmlnLmhvc3QgPSBjb25maWcuaG9zdCB8fCBzaGFyZWRGaWxlQ29uZmlnLmNzbV9ob3N0O1xuICByZXR1cm4gY29uZmlnLnBvcnQgJiYgY29uZmlnLmVuYWJsZWQgJiYgY29uZmlnLmNsaWVudElkICYmIGNvbmZpZy5ob3N0O1xufVxuXG4vKipcbiAqIFRyYW5zZmVyIHRoZSByZXNvbHZlZCBjb25maWd1cmF0aW9uIHZhbHVlIHRvIHByb3BlciB0eXBlczogcG9ydCBhcyBudW1iZXIsIGVuYWJsZWRcbiAqIGFzIGJvb2xlYW4gYW5kIGNsaWVudElkIGFzIHN0cmluZy4gVGhlICdlbmFibGVkJyBmbGFnIGlzIHZhbHVlZCB0byBmYWxzZSB3aGVuIHNldFxuICogdG8gJ2ZhbHNlJyBvciAnMCcuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzb2x2ZWQgY2xpZW50IHNpZGUgbW9uaXRvcmluZyBjb25maWdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0pTVHlwZShjb25maWcpIHtcbiAgICAvL2NvbmZpZy5YWFggaXMgZWl0aGVyIHVuZGVmaW5lZCBvciBzdHJpbmdcbiAgdmFyIGZhbHN5Tm90YXRpb25zID0gWydmYWxzZScsICcwJywgdW5kZWZpbmVkXTtcbiAgaWYgKCFjb25maWcuZW5hYmxlZCB8fCBmYWxzeU5vdGF0aW9ucy5pbmRleE9mKGNvbmZpZy5lbmFibGVkLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICBjb25maWcuZW5hYmxlZCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBjb25maWcucG9ydCA9IGNvbmZpZy5wb3J0ID8gcGFyc2VJbnQoY29uZmlnLnBvcnQsIDEwKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNvbmZpZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlTW9uaXRvcmluZ0NvbmZpZztcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZScpLnV0aWw7XG52YXIgZGdyYW0gPSByZXF1aXJlKCdkZ3JhbScpO1xudmFyIHN0cmluZ1RvQnVmZmVyID0gdXRpbC5idWZmZXIudG9CdWZmZXI7XG5cbnZhciBNQVhfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDg7IC8vIDggS0JcblxuLyoqXG4gKiBQdWJsaXNoZXMgbWV0cmljcyB2aWEgdWRwLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUGFyYW10ZXJzIGZvciBQdWJsaXNoZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wb3J0ID0gMzEwMDBdIFBvcnQgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xpZW50SWQgPSAnJ10gQ2xpZW50IElkZW50aWZpZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlZCA9IGZhbHNlXSBlbmFibGUgc2VuZGluZyBtZXRyaWNzIGRhdGFncmFtXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gUHVibGlzaGVyKG9wdGlvbnMpIHtcbiAgICAvLyBoYW5kbGUgY29uZmlndXJhdGlvblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZCB8fCBmYWxzZTtcbiAgICB0aGlzLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgMzEwMDA7XG4gICAgdGhpcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQgfHwgJyc7XG4gICAgdGhpcy5hZGRyZXNzID0gb3B0aW9ucy5ob3N0IHx8ICcxMjcuMC4wLjEnO1xuICAgIGlmICh0aGlzLmNsaWVudElkLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAvLyBDbGllbnRJZCBoYXMgYSBtYXggbGVuZ3RoIG9mIDI1NVxuICAgICAgICB0aGlzLmNsaWVudElkID0gdGhpcy5jbGllbnRJZC5zdWJzdHIoMCwgMjU1KTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlc0luRmxpZ2h0ID0gMDtcbn1cblxuUHVibGlzaGVyLnByb3RvdHlwZS5maWVsZHNUb1RyaW0gPSB7XG4gICAgVXNlckFnZW50OiAyNTYsXG4gICAgU2RrRXhjZXB0aW9uOiAxMjgsXG4gICAgU2RrRXhjZXB0aW9uTWVzc2FnZTogNTEyLFxuICAgIEF3c0V4Y2VwdGlvbjogMTI4LFxuICAgIEF3c0V4Y2VwdGlvbk1lc3NhZ2U6IDUxMixcbiAgICBGaW5hbFNka0V4Y2VwdGlvbjogMTI4LFxuICAgIEZpbmFsU2RrRXhjZXB0aW9uTWVzc2FnZTogNTEyLFxuICAgIEZpbmFsQXdzRXhjZXB0aW9uOiAxMjgsXG4gICAgRmluYWxBd3NFeGNlcHRpb25NZXNzYWdlOiA1MTJcblxufTtcblxuLyoqXG4gKiBUcmltcyBmaWVsZHMgdGhhdCBoYXZlIGEgc3BlY2lmaWVkIG1heCBsZW5ndGguXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQXBpQ2FsbCBvciBBcGlDYWxsQXR0ZW1wdCBldmVudC5cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUHVibGlzaGVyLnByb3RvdHlwZS50cmltRmllbGRzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdHJpbW1hYmxlRmllbGRzID0gT2JqZWN0LmtleXModGhpcy5maWVsZHNUb1RyaW0pO1xuICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gdHJpbW1hYmxlRmllbGRzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICB2YXIgZmllbGQgPSB0cmltbWFibGVGaWVsZHNbaV07XG4gICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPSB0aGlzLmZpZWxkc1RvVHJpbVtmaWVsZF07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBldmVudFtmaWVsZF07XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWUuc3Vic3RyKDAsIG1heExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIEFwaUNhbGwgYW5kIEFwaUNhbGxBdHRlbXB0IGV2ZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBhcGlDYWxsIG9yIGFwaUNhbGxBdHRlbXB0IGV2ZW50LlxuICogQGFwaSBwcml2YXRlXG4gKi9cblB1Ymxpc2hlci5wcm90b3R5cGUuZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBzZXQgdGhlIGNsaWVudElkXG4gICAgZXZlbnQuQ2xpZW50SWQgPSB0aGlzLmNsaWVudElkO1xuXG4gICAgdGhpcy50cmltRmllbGRzKGV2ZW50KTtcblxuICAgIHZhciBtZXNzYWdlID0gc3RyaW5nVG9CdWZmZXIoSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCBtZXNzYWdlLmxlbmd0aCA+IE1BWF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgICAgLy8gZHJvcCB0aGUgbWVzc2FnZSBpZiBwdWJsaXNoZXIgbm90IGVuYWJsZWQgb3IgaXQgaXMgdG9vIGxhcmdlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnB1Ymxpc2hEYXRhZ3JhbShtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogUHVibGlzaGVzIG1lc3NhZ2UgdG8gYW4gYWdlbnQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZSBKU09OIG1lc3NhZ2UgdG8gc2VuZCB0byBhZ2VudC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5QdWJsaXNoZXIucHJvdG90eXBlLnB1Ymxpc2hEYXRhZ3JhbSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG5cbiAgICB0aGlzLm1lc3NhZ2VzSW5GbGlnaHQrKztcbiAgICB0aGlzLmNsaWVudC5zZW5kKG1lc3NhZ2UsIDAsIG1lc3NhZ2UubGVuZ3RoLCB0aGlzLnBvcnQsIHRoaXMuYWRkcmVzcywgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgICBpZiAoLS1zZWxmLm1lc3NhZ2VzSW5GbGlnaHQgPD0gMCkge1xuICAgICAgICAgICAgLy8gZGVzdHJveSBleGlzdGluZyBjbGllbnQgc28gdGhlIGV2ZW50IGxvb3AgaXNuJ3Qga2VwdCBvcGVuXG4gICAgICAgICAgICBzZWxmLmRlc3Ryb3lDbGllbnQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV4aXN0aW5nIHVkcCBzb2NrZXQsIG9yIGNyZWF0ZXMgb25lIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5QdWJsaXNoZXIucHJvdG90eXBlLmdldENsaWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBkZ3JhbS5jcmVhdGVTb2NrZXQoJ3VkcDQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50O1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgdWRwIHNvY2tldC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5QdWJsaXNoZXIucHJvdG90eXBlLmRlc3Ryb3lDbGllbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSB2b2lkIDA7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHVibGlzaGVyOiBQdWJsaXNoZXJcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gUXVlcnlQYXJhbVNlcmlhbGl6ZXIoKSB7XG59XG5cblF1ZXJ5UGFyYW1TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbihwYXJhbXMsIHNoYXBlLCBmbikge1xuICBzZXJpYWxpemVTdHJ1Y3R1cmUoJycsIHBhcmFtcywgc2hhcGUsIGZuKTtcbn07XG5cbmZ1bmN0aW9uIHVjZmlyc3Qoc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmlzUXVlcnlOYW1lIHx8IHNoYXBlLmFwaS5wcm90b2NvbCAhPT0gJ2VjMicpIHtcbiAgICByZXR1cm4gc2hhcGUubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2hhcGUubmFtZVswXS50b1VwcGVyQ2FzZSgpICsgc2hhcGUubmFtZS5zdWJzdHIoMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0dXJlKHByZWZpeCwgc3RydWN0LCBydWxlcywgZm4pIHtcbiAgdXRpbC5lYWNoKHJ1bGVzLm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciB2YWx1ZSA9IHN0cnVjdFtuYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIG1lbWJlck5hbWUgPSB1Y2ZpcnN0KG1lbWJlcik7XG4gICAgbWVtYmVyTmFtZSA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIG1lbWJlck5hbWUgOiBtZW1iZXJOYW1lO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihtZW1iZXJOYW1lLCB2YWx1ZSwgbWVtYmVyLCBmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAobmFtZSwgbWFwLCBydWxlcywgZm4pIHtcbiAgdmFyIGkgPSAxO1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBwcmVmaXggPSBydWxlcy5mbGF0dGVuZWQgPyAnLicgOiAnLmVudHJ5Lic7XG4gICAgdmFyIHBvc2l0aW9uID0gcHJlZml4ICsgKGkrKykgKyAnLic7XG4gICAgdmFyIGtleU5hbWUgPSBwb3NpdGlvbiArIChydWxlcy5rZXkubmFtZSB8fCAna2V5Jyk7XG4gICAgdmFyIHZhbHVlTmFtZSA9IHBvc2l0aW9uICsgKHJ1bGVzLnZhbHVlLm5hbWUgfHwgJ3ZhbHVlJyk7XG4gICAgc2VyaWFsaXplTWVtYmVyKG5hbWUgKyBrZXlOYW1lLCBrZXksIHJ1bGVzLmtleSwgZm4pO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsgdmFsdWVOYW1lLCB2YWx1ZSwgcnVsZXMudmFsdWUsIGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUxpc3QobmFtZSwgbGlzdCwgcnVsZXMsIGZuKSB7XG4gIHZhciBtZW1iZXJSdWxlcyA9IHJ1bGVzLm1lbWJlciB8fCB7fTtcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBmbi5jYWxsKHRoaXMsIG5hbWUsIG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uICh2LCBuKSB7XG4gICAgdmFyIHN1ZmZpeCA9ICcuJyArIChuICsgMSk7XG4gICAgaWYgKHJ1bGVzLmFwaS5wcm90b2NvbCA9PT0gJ2VjMicpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIEVDMlxuICAgICAgc3VmZml4ID0gc3VmZml4ICsgJyc7IC8vIG1ha2UgbGludGVyIGhhcHB5XG4gICAgfSBlbHNlIGlmIChydWxlcy5mbGF0dGVuZWQpIHtcbiAgICAgIGlmIChtZW1iZXJSdWxlcy5uYW1lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIHBhcnRzLnB1c2godWNmaXJzdChtZW1iZXJSdWxlcykpO1xuICAgICAgICBuYW1lID0gcGFydHMuam9pbignLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWZmaXggPSAnLicgKyAobWVtYmVyUnVsZXMubmFtZSA/IG1lbWJlclJ1bGVzLm5hbWUgOiAnbWVtYmVyJykgKyBzdWZmaXg7XG4gICAgfVxuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsgc3VmZml4LCB2LCBtZW1iZXJSdWxlcywgZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWVtYmVyKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHJ1bGVzLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgc2VyaWFsaXplU3RydWN0dXJlKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLnR5cGUgPT09ICdsaXN0Jykge1xuICAgIHNlcmlhbGl6ZUxpc3QobmFtZSwgdmFsdWUsIHJ1bGVzLCBmbik7XG4gIH0gZWxzZSBpZiAocnVsZXMudHlwZSA9PT0gJ21hcCcpIHtcbiAgICBzZXJpYWxpemVNYXAobmFtZSwgdmFsdWUsIHJ1bGVzLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgZm4obmFtZSwgcnVsZXMudG9XaXJlRm9ybWF0KHZhbHVlKS50b1N0cmluZygpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5UGFyYW1TZXJpYWxpemVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vcHJvdmlkZSByZWFsdGltZSBjbG9jayBmb3IgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnRcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgdmFyIHNlY29uZCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgcmV0dXJuIHNlY29uZFswXSAqIDEwMDAgKyAoc2Vjb25kWzFdIC8gMTAwMDAwMCk7XG4gIH1cbn07XG4iLCJmdW5jdGlvbiBpc0ZpcHNSZWdpb24ocmVnaW9uKSB7XG4gIHJldHVybiB0eXBlb2YgcmVnaW9uID09PSAnc3RyaW5nJyAmJiAocmVnaW9uLnN0YXJ0c1dpdGgoJ2ZpcHMtJykgfHwgcmVnaW9uLmVuZHNXaXRoKCctZmlwcycpKTtcbn1cblxuZnVuY3Rpb24gaXNHbG9iYWxSZWdpb24ocmVnaW9uKSB7XG4gIHJldHVybiB0eXBlb2YgcmVnaW9uID09PSAnc3RyaW5nJyAmJiBbJ2F3cy1nbG9iYWwnLCAnYXdzLXVzLWdvdi1nbG9iYWwnXS5pbmNsdWRlcyhyZWdpb24pO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFsUmVnaW9uKHJlZ2lvbikge1xuICByZXR1cm4gWydmaXBzLWF3cy1nbG9iYWwnLCAnYXdzLWZpcHMnLCAnYXdzLWdsb2JhbCddLmluY2x1ZGVzKHJlZ2lvbilcbiAgICAgID8gJ3VzLWVhc3QtMSdcbiAgICAgIDogWydmaXBzLWF3cy11cy1nb3YtZ2xvYmFsJywgJ2F3cy11cy1nb3YtZ2xvYmFsJ10uaW5jbHVkZXMocmVnaW9uKVxuICAgICAgPyAndXMtZ292LXdlc3QtMSdcbiAgICAgIDogcmVnaW9uLnJlcGxhY2UoL2ZpcHMtKGRrci18cHJvZC0pP3wtZmlwcy8sICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRmlwc1JlZ2lvbjogaXNGaXBzUmVnaW9uLFxuICBpc0dsb2JhbFJlZ2lvbjogaXNHbG9iYWxSZWdpb24sXG4gIGdldFJlYWxSZWdpb246IGdldFJlYWxSZWdpb25cbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHJlZ2lvbkNvbmZpZyA9IHJlcXVpcmUoJy4vcmVnaW9uX2NvbmZpZ19kYXRhLmpzb24nKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVSZWdpb25QcmVmaXgocmVnaW9uKSB7XG4gIGlmICghcmVnaW9uKSByZXR1cm4gbnVsbDtcbiAgdmFyIHBhcnRzID0gcmVnaW9uLnNwbGl0KCctJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHBhcnRzLnNsaWNlKDAsIHBhcnRzLmxlbmd0aCAtIDIpLmpvaW4oJy0nKSArICctKic7XG59XG5cbmZ1bmN0aW9uIGRlcml2ZWRLZXlzKHNlcnZpY2UpIHtcbiAgdmFyIHJlZ2lvbiA9IHNlcnZpY2UuY29uZmlnLnJlZ2lvbjtcbiAgdmFyIHJlZ2lvblByZWZpeCA9IGdlbmVyYXRlUmVnaW9uUHJlZml4KHJlZ2lvbik7XG4gIHZhciBlbmRwb2ludFByZWZpeCA9IHNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4O1xuXG4gIHJldHVybiBbXG4gICAgW3JlZ2lvbiwgZW5kcG9pbnRQcmVmaXhdLFxuICAgIFtyZWdpb25QcmVmaXgsIGVuZHBvaW50UHJlZml4XSxcbiAgICBbcmVnaW9uLCAnKiddLFxuICAgIFtyZWdpb25QcmVmaXgsICcqJ10sXG4gICAgWycqJywgZW5kcG9pbnRQcmVmaXhdLFxuICAgIFsnKicsICcqJ11cbiAgXS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtWzBdICYmIGl0ZW1bMV0gPyBpdGVtLmpvaW4oJy8nKSA6IG51bGw7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhcHBseUNvbmZpZyhzZXJ2aWNlLCBjb25maWcpIHtcbiAgdXRpbC5lYWNoKGNvbmZpZywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09ICdnbG9iYWxFbmRwb2ludCcpIHJldHVybjtcbiAgICBpZiAoc2VydmljZS5jb25maWdba2V5XSA9PT0gdW5kZWZpbmVkIHx8IHNlcnZpY2UuY29uZmlnW2tleV0gPT09IG51bGwpIHtcbiAgICAgIHNlcnZpY2UuY29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVFbmRwb2ludChzZXJ2aWNlKSB7XG4gIHZhciBrZXlzID0gZGVyaXZlZEtleXMoc2VydmljZSk7XG4gIHZhciB1c2VGaXBzRW5kcG9pbnQgPSBzZXJ2aWNlLmNvbmZpZy51c2VGaXBzRW5kcG9pbnQ7XG4gIHZhciB1c2VEdWFsc3RhY2tFbmRwb2ludCA9IHNlcnZpY2UuY29uZmlnLnVzZUR1YWxzdGFja0VuZHBvaW50O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWtleSkgY29udGludWU7XG5cbiAgICB2YXIgcnVsZXMgPSB1c2VGaXBzRW5kcG9pbnRcbiAgICAgID8gdXNlRHVhbHN0YWNrRW5kcG9pbnRcbiAgICAgICAgPyByZWdpb25Db25maWcuZHVhbHN0YWNrRmlwc1J1bGVzXG4gICAgICAgIDogcmVnaW9uQ29uZmlnLmZpcHNSdWxlc1xuICAgICAgOiB1c2VEdWFsc3RhY2tFbmRwb2ludFxuICAgICAgPyByZWdpb25Db25maWcuZHVhbHN0YWNrUnVsZXNcbiAgICAgIDogcmVnaW9uQ29uZmlnLnJ1bGVzO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChydWxlcywga2V5KSkge1xuICAgICAgdmFyIGNvbmZpZyA9IHJ1bGVzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnID0gcmVnaW9uQ29uZmlnLnBhdHRlcm5zW2NvbmZpZ107XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBnbG9iYWwgZW5kcG9pbnRcbiAgICAgIHNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCA9ICEhY29uZmlnLmdsb2JhbEVuZHBvaW50O1xuICAgICAgaWYgKGNvbmZpZy5zaWduaW5nUmVnaW9uKSB7XG4gICAgICAgIHNlcnZpY2Uuc2lnbmluZ1JlZ2lvbiA9IGNvbmZpZy5zaWduaW5nUmVnaW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBzaWduYXR1cmUgdmVyc2lvblxuICAgICAgaWYgKCFjb25maWcuc2lnbmF0dXJlVmVyc2lvbikgY29uZmlnLnNpZ25hdHVyZVZlcnNpb24gPSAndjQnO1xuXG4gICAgICAvLyBtZXJnZSBjb25maWdcbiAgICAgIGFwcGx5Q29uZmlnKHNlcnZpY2UsIGNvbmZpZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVuZHBvaW50U3VmZml4KHJlZ2lvbikge1xuICB2YXIgcmVnaW9uUmVnZXhlcyA9IHtcbiAgICAnXih1c3xldXxhcHxzYXxjYXxtZSlcXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdhbWF6b25hd3MuY29tJyxcbiAgICAnXmNuXFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnYW1hem9uYXdzLmNvbS5jbicsXG4gICAgJ151c1xcXFwtZ292XFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnYW1hem9uYXdzLmNvbScsXG4gICAgJ151c1xcXFwtaXNvXFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnYzJzLmljLmdvdicsXG4gICAgJ151c1xcXFwtaXNvYlxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ3NjMnMuc2dvdi5nb3YnXG4gIH07XG4gIHZhciBkZWZhdWx0U3VmZml4ID0gJ2FtYXpvbmF3cy5jb20nO1xuICB2YXIgcmVnZXhlcyA9IE9iamVjdC5rZXlzKHJlZ2lvblJlZ2V4ZXMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2V4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVnaW9uUGF0dGVybiA9IFJlZ0V4cChyZWdleGVzW2ldKTtcbiAgICB2YXIgZG5zU3VmZml4ID0gcmVnaW9uUmVnZXhlc1tyZWdleGVzW2ldXTtcbiAgICBpZiAocmVnaW9uUGF0dGVybi50ZXN0KHJlZ2lvbikpIHJldHVybiBkbnNTdWZmaXg7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTdWZmaXg7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25maWd1cmVFbmRwb2ludDogY29uZmlndXJlRW5kcG9pbnQsXG4gIGdldEVuZHBvaW50U3VmZml4OiBnZXRFbmRwb2ludFN1ZmZpeCxcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgQWNjZXB0b3JTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuL3N0YXRlX21hY2hpbmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBkb21haW4gPSBBV1MudXRpbC5kb21haW47XG52YXIgam1lc3BhdGggPSByZXF1aXJlKCdqbWVzcGF0aCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgaGFyZEVycm9yU3RhdGVzID0ge3N1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMX07XG5cbmZ1bmN0aW9uIGlzVGVybWluYWxTdGF0ZShtYWNoaW5lKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGFyZEVycm9yU3RhdGVzLCBtYWNoaW5lLl9hc20uY3VycmVudFN0YXRlKTtcbn1cblxudmFyIGZzbSA9IG5ldyBBY2NlcHRvclN0YXRlTWFjaGluZSgpO1xuZnNtLnNldHVwU3RhdGVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZnVuY3Rpb24oXywgZG9uZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLl9oYWx0SGFuZGxlcnNPbkVycm9yID0gZmFsc2U7XG5cbiAgICBzZWxmLmVtaXQoc2VsZi5fYXNtLmN1cnJlbnRTdGF0ZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChpc1Rlcm1pbmFsU3RhdGUoc2VsZikpIHtcbiAgICAgICAgICBpZiAoZG9tYWluICYmIHNlbGYuZG9tYWluIGluc3RhbmNlb2YgZG9tYWluLkRvbWFpbikge1xuICAgICAgICAgICAgZXJyLmRvbWFpbkVtaXR0ZXIgPSBzZWxmO1xuICAgICAgICAgICAgZXJyLmRvbWFpbiA9IHNlbGYuZG9tYWluO1xuICAgICAgICAgICAgZXJyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5kb21haW4uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYucmVzcG9uc2UuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKHNlbGYucmVzcG9uc2UuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgdGhpcy5hZGRTdGF0ZSgndmFsaWRhdGUnLCAnYnVpbGQnLCAnZXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnYnVpbGQnLCAnYWZ0ZXJCdWlsZCcsICdyZXN0YXJ0JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2FmdGVyQnVpbGQnLCAnc2lnbicsICdyZXN0YXJ0JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3NpZ24nLCAnc2VuZCcsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdyZXRyeScsICdhZnRlclJldHJ5JywgJ2FmdGVyUmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnYWZ0ZXJSZXRyeScsICdzaWduJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3NlbmQnLCAndmFsaWRhdGVSZXNwb25zZScsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCd2YWxpZGF0ZVJlc3BvbnNlJywgJ2V4dHJhY3REYXRhJywgJ2V4dHJhY3RFcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdleHRyYWN0RXJyb3InLCAnZXh0cmFjdERhdGEnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXh0cmFjdERhdGEnLCAnc3VjY2VzcycsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdyZXN0YXJ0JywgJ2J1aWxkJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3N1Y2Nlc3MnLCAnY29tcGxldGUnLCAnY29tcGxldGUnLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXJyb3InLCAnY29tcGxldGUnLCAnY29tcGxldGUnLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnY29tcGxldGUnLCBudWxsLCBudWxsLCB0cmFuc2l0aW9uKTtcbn07XG5mc20uc2V0dXBTdGF0ZXMoKTtcblxuLyoqXG4gKiAjIyBBc3luY2hyb25vdXMgUmVxdWVzdHNcbiAqXG4gKiBBbGwgcmVxdWVzdHMgbWFkZSB0aHJvdWdoIHRoZSBTREsgYXJlIGFzeW5jaHJvbm91cyBhbmQgdXNlIGFcbiAqIGNhbGxiYWNrIGludGVyZmFjZS4gRWFjaCBzZXJ2aWNlIG1ldGhvZCB0aGF0IGtpY2tzIG9mZiBhIHJlcXVlc3RcbiAqIHJldHVybnMgYW4gYEFXUy5SZXF1ZXN0YCBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSB0byByZWdpc3RlclxuICogY2FsbGJhY2tzLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHNlcnZpY2UgbWV0aG9kIHJldHVybnMgdGhlIHJlcXVlc3RcbiAqIG9iamVjdCBhcyBcInJlcXVlc3RcIiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgY2FsbGJhY2tzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIHJlcXVlc3QgaXMgYW4gQVdTLlJlcXVlc3Qgb2JqZWN0XG4gKiB2YXIgcmVxdWVzdCA9IGVjMi5kZXNjcmliZUluc3RhbmNlcygpO1xuICpcbiAqIC8vIHJlZ2lzdGVyIGNhbGxiYWNrcyBvbiByZXF1ZXN0IHRvIHJldHJpZXZlIHJlc3BvbnNlIGRhdGFcbiAqIHJlcXVlc3Qub24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICBjb25zb2xlLmxvZyhyZXNwb25zZS5kYXRhKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogV2hlbiBhIHJlcXVlc3QgaXMgcmVhZHkgdG8gYmUgc2VudCwgdGhlIHtzZW5kfSBtZXRob2Qgc2hvdWxkXG4gKiBiZSBjYWxsZWQ6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcmVxdWVzdC5zZW5kKCk7XG4gKiBgYGBcbiAqXG4gKiBTaW5jZSByZWdpc3RlcmVkIGNhbGxiYWNrcyBtYXkgb3IgbWF5IG5vdCBiZSBpZGVtcG90ZW50LCByZXF1ZXN0cyBzaG91bGQgb25seVxuICogYmUgc2VudCBvbmNlLiBUbyBwZXJmb3JtIHRoZSBzYW1lIG9wZXJhdGlvbiBtdWx0aXBsZSB0aW1lcywgeW91IHdpbGwgbmVlZCB0b1xuICogY3JlYXRlIG11bHRpcGxlIHJlcXVlc3Qgb2JqZWN0cywgZWFjaCB3aXRoIGl0cyBvd24gcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogIyMgUmVtb3ZpbmcgRGVmYXVsdCBMaXN0ZW5lcnMgZm9yIEV2ZW50c1xuICpcbiAqIFJlcXVlc3Qgb2JqZWN0cyBhcmUgYnVpbHQgd2l0aCBkZWZhdWx0IGxpc3RlbmVycyBmb3IgdGhlIHZhcmlvdXMgZXZlbnRzLFxuICogZGVwZW5kaW5nIG9uIHRoZSBzZXJ2aWNlIHR5cGUuIEluIHNvbWUgY2FzZXMsIHlvdSBtYXkgd2FudCB0byByZW1vdmVcbiAqIHNvbWUgYnVpbHQtaW4gbGlzdGVuZXJzIHRvIGN1c3RvbWl6ZSBiZWhhdmlvdXIuIERvaW5nIHRoaXMgcmVxdWlyZXNcbiAqIGFjY2VzcyB0byB0aGUgYnVpbHQtaW4gbGlzdGVuZXIgZnVuY3Rpb25zLCB3aGljaCBhcmUgZXhwb3NlZCB0aHJvdWdoXG4gKiB0aGUge0FXUy5FdmVudExpc3RlbmVycy5Db3JlfSBuYW1lc3BhY2UuIEZvciBpbnN0YW5jZSwgeW91IG1heVxuICogd2FudCB0byBjdXN0b21pemUgdGhlIEhUVFAgaGFuZGxlciB1c2VkIHdoZW4gc2VuZGluZyBhIHJlcXVlc3QuIEluIHRoaXNcbiAqIGNhc2UsIHlvdSBjYW4gcmVtb3ZlIHRoZSBidWlsdC1pbiBsaXN0ZW5lciBhc3NvY2lhdGVkIHdpdGggdGhlICdzZW5kJ1xuICogZXZlbnQsIHRoZSB7QVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORH0gbGlzdGVuZXIgYW5kIGFkZCB5b3VyIG93bi5cbiAqXG4gKiAjIyBNdWx0aXBsZSBDYWxsYmFja3MgYW5kIENoYWluaW5nXG4gKlxuICogWW91IGNhbiByZWdpc3RlciBtdWx0aXBsZSBjYWxsYmFja3Mgb24gYW55IHJlcXVlc3Qgb2JqZWN0LiBUaGVcbiAqIGNhbGxiYWNrcyBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgZGlmZmVyZW50IGV2ZW50cywgb3IgYWxsIGZvciB0aGVcbiAqIHNhbWUgZXZlbnQuIEluIGFkZGl0aW9uLCB5b3UgY2FuIGNoYWluIGNhbGxiYWNrIHJlZ2lzdHJhdGlvbiwgZm9yXG4gKiBleGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHJlcXVlc3QuXG4gKiAgIG9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3MhXCIpO1xuICogICB9KS5cbiAqICAgb24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciFcIik7XG4gKiAgIH0pLlxuICogICBvbignY29tcGxldGUnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgIGNvbnNvbGUubG9nKFwiQWx3YXlzIVwiKTtcbiAqICAgfSkuXG4gKiAgIHNlbmQoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBleGFtcGxlIHdpbGwgcHJpbnQgZWl0aGVyIFwiU3VjY2VzcyEgQWx3YXlzIVwiLCBvciBcIkVycm9yISBBbHdheXMhXCIsXG4gKiBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgcmVxdWVzdCBzdWNjZWVkZWQgb3Igbm90LlxuICpcbiAqIEAhYXR0cmlidXRlIGh0dHBSZXF1ZXN0XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIEhUVFAgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtBV1MuSHR0cFJlcXVlc3RdIHRoZSByYXcgSFRUUCByZXF1ZXN0IG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgcmVxdWVzdCBoZWFkZXJzIGFuZCBib2R5IGluZm9ybWF0aW9uXG4gKiAgICAgc2VudCBieSB0aGUgc2VydmljZS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzdGFydFRpbWVcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbRGF0ZV0gdGhlIHRpbWUgdGhhdCB0aGUgcmVxdWVzdCBzdGFydGVkXG4gKlxuICogQCFncm91cCBSZXF1ZXN0IEJ1aWxkaW5nIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgdmFsaWRhdGUocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gYSByZXF1ZXN0IGlzIGJlaW5nIHZhbGlkYXRlZC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVxdWVzdCBzaG91bGQgbm90IGJlIHNlbnQuXG4gKiAgIEBwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgYmVpbmcgc2VudFxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX0NSRURFTlRJQUxTXG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OXG4gKiAgIEBleGFtcGxlIEVuc3VyaW5nIHRoYXQgYSBjZXJ0YWluIHBhcmFtZXRlciBpcyBzZXQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0XG4gKiAgICAgdmFyIHJlcSA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICogICAgIHJlcS5vbigndmFsaWRhdGUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIGlmICghcmVxLnBhcmFtcy5Cb2R5Lm1hdGNoKC9eSGVsbG9cXHMvKSkge1xuICogICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZHkgbXVzdCBzdGFydCB3aXRoIFwiSGVsbG8gXCInKTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICByZXEuc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICpcbiAqIEAhZXZlbnQgYnVpbGQocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgcGF5bG9hZCBpcyBiZWluZyBidWlsdC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCBmaWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gc2VuZCB0aGUgcmVxdWVzdFxuICogICBvdmVyIEhUVFAuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnZhbGlkYXRlKVxuICogICBAZXhhbXBsZSBBZGQgYSBjdXN0b20gSFRUUCBoZWFkZXIgdG8gYSByZXF1ZXN0XG4gKiAgICAgdmFyIHJlcSA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICogICAgIHJlcS5vbignYnVpbGQnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDdXN0b20tSGVhZGVyJ10gPSAndmFsdWUnO1xuICogICAgIH0pO1xuICogICAgIHJlcS5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkgeyAuLi4gfSk7XG4gKlxuICogQCFldmVudCBzaWduKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGJlaW5nIHNpZ25lZC4gTGlzdGVuZXJzIHNob3VsZFxuICogICBhZGQgdGhlIGNvcnJlY3QgYXV0aGVudGljYXRpb24gaGVhZGVycyBhbmQvb3IgYWRqdXN0IHRoZSBib2R5LFxuICogICBkZXBlbmRpbmcgb24gdGhlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBiZWluZyB1c2VkLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH52YWxpZGF0ZSlcbiAqXG4gKiBAIWdyb3VwIFJlcXVlc3QgU2VuZGluZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IHNlbmQocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIHJlYWR5IHRvIGJlIHNlbnQuIExpc3RlbmVyc1xuICogICBzaG91bGQgY2FsbCB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgbGF5ZXIgdG8gaW5pdGlhdGVcbiAqICAgdGhlIHNlbmRpbmcgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSByZXNwb25zZSBbUmVzcG9uc2VdIHRoZSByZXNwb25zZSBvYmplY3RcbiAqICAgQGNvbnRleHQgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCB0aGF0IHdhcyBzZW50XG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORFxuICpcbiAqIEAhZXZlbnQgcmV0cnkocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGEgcmVxdWVzdCBmYWlsZWQgYW5kIG1pZ2h0IG5lZWQgdG8gYmUgcmV0cmllZCBvciByZWRpcmVjdGVkLlxuICogICBJZiB0aGUgcmVzcG9uc2UgaXMgcmV0cnlhYmxlLCB0aGUgbGlzdGVuZXIgc2hvdWxkIHNldCB0aGVcbiAqICAgYHJlc3BvbnNlLmVycm9yLnJldHJ5YWJsZWAgcHJvcGVydHkgdG8gYHRydWVgLCBhbmQgb3B0aW9uYWxseSBzZXRcbiAqICAgYHJlc3BvbnNlLmVycm9yLnJldHJ5RGVsYXlgIHRvIHRoZSBtaWxsaXNlY29uZCBkZWxheSBmb3IgdGhlIG5leHQgYXR0ZW1wdC5cbiAqICAgSW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgYHJlc3BvbnNlLmVycm9yLnJlZGlyZWN0YCBzaG91bGQgYmUgc2V0IHRvXG4gKiAgIGB0cnVlYCB3aXRoIGByZXRyeURlbGF5YCBzZXQgdG8gYW4gb3B0aW9uYWwgZGVsYXkgb24gdGhlIG5leHQgcmVxdWVzdC5cbiAqXG4gKiAgIElmIGEgbGlzdGVuZXIgZGVjaWRlcyB0aGF0IGEgcmVxdWVzdCBzaG91bGQgbm90IGJlIHJldHJpZWQsXG4gKiAgIGl0IHNob3VsZCBzZXQgYm90aCBgcmV0cnlhYmxlYCBhbmQgYHJlZGlyZWN0YCB0byBmYWxzZS5cbiAqXG4gKiAgIE5vdGUgdGhhdCBhIHJldHJ5YWJsZSBlcnJvciB3aWxsIGJlIHJldHJpZWQgYXQgbW9zdFxuICogICB7QVdTLkNvbmZpZy5tYXhSZXRyaWVzfSB0aW1lcyAoYmFzZWQgb24gdGhlIHNlcnZpY2Ugb2JqZWN0J3MgY29uZmlnKS5cbiAqICAgU2ltaWxhcmx5LCBhIHJlcXVlc3QgdGhhdCBpcyByZWRpcmVjdGVkIHdpbGwgb25seSByZWRpcmVjdCBhdCBtb3N0XG4gKiAgIHtBV1MuQ29uZmlnLm1heFJlZGlyZWN0c30gdGltZXMuXG4gKlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBleGFtcGxlIEFkZGluZyBhIGN1c3RvbSByZXRyeSBmb3IgYSA0MDQgcmVzcG9uc2VcbiAqICAgICByZXF1ZXN0Lm9uKCdyZXRyeScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgICAvLyB0aGlzIHJlc291cmNlIGlzIG5vdCB5ZXQgYXZhaWxhYmxlLCB3YWl0IDEwIHNlY29uZHMgdG8gZ2V0IGl0IGFnYWluXG4gKiAgICAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCAmJiByZXNwb25zZS5lcnJvcikge1xuICogICAgICAgICByZXNwb25zZS5lcnJvci5yZXRyeWFibGUgPSB0cnVlOyAgIC8vIHJldHJ5IHRoaXMgZXJyb3JcbiAqICAgICAgICAgcmVzcG9uc2UuZXJyb3IucmV0cnlEZWxheSA9IDEwMDAwOyAvLyB3YWl0IDEwIHNlY29uZHNcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAIWdyb3VwIERhdGEgUGFyc2luZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IGV4dHJhY3RFcnJvcihyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIG9uIGFsbCBub24tMnh4IHJlcXVlc3RzIHNvIHRoYXQgbGlzdGVuZXJzIGNhbiBleHRyYWN0XG4gKiAgIGVycm9yIGRldGFpbHMgZnJvbSB0aGUgcmVzcG9uc2UgYm9keS4gTGlzdGVuZXJzIHRvIHRoaXMgZXZlbnRcbiAqICAgc2hvdWxkIHNldCB0aGUgYHJlc3BvbnNlLmVycm9yYCBwcm9wZXJ0eS5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgZXh0cmFjdERhdGEocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCBpbiBzdWNjZXNzZnVsIHJlcXVlc3RzIHRvIGFsbG93IGxpc3RlbmVycyB0b1xuICogICBkZS1zZXJpYWxpemUgdGhlIHJlc3BvbnNlIGJvZHkgaW50byBgcmVzcG9uc2UuZGF0YWAuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWdyb3VwIENvbXBsZXRpb24gRXZlbnRzXG4gKlxuICogQCFldmVudCBzdWNjZXNzKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICogICBgcmVzcG9uc2UuZGF0YWAgd2lsbCBjb250YWluIHRoZSByZXNwb25zZSBkYXRhIGFuZFxuICogICBgcmVzcG9uc2UuZXJyb3JgIHdpbGwgYmUgbnVsbC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgZXJyb3IoZXJyb3IsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgYXQgYW55IHBvaW50IGR1cmluZyB0aGVcbiAqICAgcmVxdWVzdC4gYHJlc3BvbnNlLmVycm9yYCB3aWxsIGNvbnRhaW4gZGV0YWlscyBhYm91dCB0aGUgZXJyb3JcbiAqICAgdGhhdCBvY2N1cnJlZC4gYHJlc3BvbnNlLmRhdGFgIHdpbGwgYmUgbnVsbC5cbiAqICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXRcbiAqICAgICB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgY29tcGxldGUocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuZXZlciBhIHJlcXVlc3QgY3ljbGUgY29tcGxldGVzLiBgcmVzcG9uc2UuZXJyb3JgXG4gKiAgIHNob3VsZCBiZSBjaGVja2VkLCBzaW5jZSB0aGUgcmVxdWVzdCBtYXkgaGF2ZSBmYWlsZWQuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWdyb3VwIEhUVFAgRXZlbnRzXG4gKlxuICogQCFldmVudCBodHRwSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwb25zZSwgc3RhdHVzTWVzc2FnZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gaGVhZGVycyBhcmUgc2VudCBieSB0aGUgcmVtb3RlIHNlcnZlclxuICogICBAcGFyYW0gc3RhdHVzQ29kZSBbSW50ZWdlcl0gdGhlIEhUVFAgcmVzcG9uc2UgY29kZVxuICogICBAcGFyYW0gaGVhZGVycyBbbWFwPFN0cmluZyxTdHJpbmc+XSB0aGUgcmVzcG9uc2UgaGVhZGVyc1xuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAcGFyYW0gc3RhdHVzTWVzc2FnZSBbU3RyaW5nXSBBIHN0YXR1cyBtZXNzYWdlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEhUVFBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgY29kZVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBodHRwRGF0YShjaHVuaywgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGRhdGEgaXMgc2VudCBieSB0aGUgcmVtb3RlIHNlcnZlclxuICogICBAcGFyYW0gY2h1bmsgW0J1ZmZlcl0gdGhlIGJ1ZmZlciBkYXRhIGNvbnRhaW5pbmcgdGhlIG5leHQgZGF0YSBjaHVua1xuICogICAgIGZyb20gdGhlIHNlcnZlclxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9EQVRBXG4gKlxuICogQCFldmVudCBodHRwVXBsb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGhhcyB1cGxvYWRlZCBtb3JlIGRhdGFcbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBub3RlIFRoaXMgZXZlbnQgd2lsbCBub3QgYmUgZW1pdHRlZCBpbiBOb2RlLmpzIDAuOC54LlxuICpcbiAqIEAhZXZlbnQgaHR0cERvd25sb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGhhcyBkb3dubG9hZGVkIG1vcmUgZGF0YVxuICogICBAcGFyYW0gcHJvZ3Jlc3MgW21hcF0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBsb2FkZWRgIGFuZCBgdG90YWxgIGJ5dGVzXG4gKiAgICAgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQG5vdGUgVGhpcyBldmVudCB3aWxsIG5vdCBiZSBlbWl0dGVkIGluIE5vZGUuanMgMC44LnguXG4gKlxuICogQCFldmVudCBodHRwRXJyb3IoZXJyb3IsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGZhaWxlZFxuICogICBAcGFyYW0gZXJyb3IgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHRoYXQgd2FzIHRocm93blxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBodHRwRG9uZShyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHNlcnZlciBpcyBmaW5pc2hlZCBzZW5kaW5nIGRhdGFcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEBzZWUgQVdTLlJlc3BvbnNlXG4gKi9cbkFXUy5SZXF1ZXN0ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXF1ZXN0IGZvciBhbiBvcGVyYXRpb24gb24gYSBnaXZlbiBzZXJ2aWNlIHdpdGhcbiAgICogYSBzZXQgb2YgaW5wdXQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2UgW0FXUy5TZXJ2aWNlXSB0aGUgc2VydmljZSB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24gb25cbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgb3BlcmF0aW9uIHRvIHBlcmZvcm0gb24gdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHBhcmFtcyBbT2JqZWN0XSBwYXJhbWV0ZXJzIHRvIHNlbmQgdG8gdGhlIG9wZXJhdGlvbi5cbiAgICogICBTZWUgdGhlIG9wZXJhdGlvbidzIGRvY3VtZW50YXRpb24gZm9yIHRoZSBmb3JtYXQgb2YgdGhlXG4gICAqICAgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXF1ZXN0KHNlcnZpY2UsIG9wZXJhdGlvbiwgcGFyYW1zKSB7XG4gICAgdmFyIGVuZHBvaW50ID0gc2VydmljZS5lbmRwb2ludDtcbiAgICB2YXIgcmVnaW9uID0gc2VydmljZS5jb25maWcucmVnaW9uO1xuICAgIHZhciBjdXN0b21Vc2VyQWdlbnQgPSBzZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQ7XG5cbiAgICBpZiAoc2VydmljZS5zaWduaW5nUmVnaW9uKSB7XG4gICAgICByZWdpb24gPSBzZXJ2aWNlLnNpZ25pbmdSZWdpb247XG4gICAgfSBlbHNlIGlmIChzZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnQpIHtcbiAgICAgIHJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuICAgIH1cblxuICAgIHRoaXMuZG9tYWluID0gZG9tYWluICYmIGRvbWFpbi5hY3RpdmU7XG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gbmV3IEFXUy5IdHRwUmVxdWVzdChlbmRwb2ludCwgcmVnaW9uKTtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCk7XG5cbiAgICB0aGlzLnJlc3BvbnNlID0gbmV3IEFXUy5SZXNwb25zZSh0aGlzKTtcbiAgICB0aGlzLl9hc20gPSBuZXcgQWNjZXB0b3JTdGF0ZU1hY2hpbmUoZnNtLnN0YXRlcywgJ3ZhbGlkYXRlJyk7XG4gICAgdGhpcy5faGFsdEhhbmRsZXJzT25FcnJvciA9IGZhbHNlO1xuXG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW1pdCA9IHRoaXMuZW1pdEV2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIWdyb3VwIFNlbmRpbmcgYSBSZXF1ZXN0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgc2VuZChjYWxsYmFjayA9IG51bGwpXG4gICAqICAgU2VuZHMgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKlxuICAgKiAgIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgICAgQGNvbnRleHQgW0FXUy5SZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgYmVpbmcgc2VudC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGggYSBjYWxsYmFja1xuICAgKiAgICAgcmVxdWVzdCA9IHMzLnB1dE9iamVjdCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J30pO1xuICAgKiAgICAgcmVxdWVzdC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkgeyBjb25zb2xlLmxvZyhlcnIsIGRhdGEpOyB9KTtcbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRoIG5vIGNhbGxiYWNrICh1c2luZyBldmVudCBoYW5kbGVycylcbiAgICogICAgIHJlcXVlc3QgPSBzMy5wdXRPYmplY3Qoe0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9KTtcbiAgICogICAgIHJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHsgLi4uIH0pOyAvLyByZWdpc3RlciBhIGNhbGxiYWNrXG4gICAqICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICovXG4gIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIGFwcGVuZCB0byB1c2VyIGFnZW50XG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdjYWxsYmFjaycpO1xuICAgICAgdGhpcy5vbignY29tcGxldGUnLCBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHJlc3AsIHJlc3AuZXJyb3IsIHJlc3AuZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5ydW5UbygpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBwcm9taXNlKClcbiAgICogICBTZW5kcyB0aGUgcmVxdWVzdCBhbmQgcmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbihkYXRhKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICogICAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnJvcilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnJvciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgcmVxdWVzdC5cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB1c2luZyBwcm9taXNlcy5cbiAgICogICAgIHZhciByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfSk7XG4gICAqICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5wcm9taXNlKCk7XG4gICAqICAgICByZXN1bHQudGhlbihmdW5jdGlvbihkYXRhKSB7IC4uLiB9LCBmdW5jdGlvbihlcnJvcikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJ1blRvKCdzZW5kJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJ1blRvOiBmdW5jdGlvbiBydW5UbyhzdGF0ZSwgZG9uZSkge1xuICAgIHRoaXMuX2FzbS5ydW5UbyhzdGF0ZSwgZG9uZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIHJlcXVlc3QsIGVtaXR0aW5nIHRoZSBlcnJvciBhbmQgY29tcGxldGUgZXZlbnRzLlxuICAgKlxuICAgKiBAIW1hY3JvIG5vYnJvd3NlclxuICAgKiBAZXhhbXBsZSBBYm9ydGluZyBhIHJlcXVlc3QgYWZ0ZXIgc2VuZGluZ1xuICAgKiAgIHZhciBwYXJhbXMgPSB7XG4gICAqICAgICBCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLFxuICAgKiAgICAgQm9keTogQnVmZmVyLmFsbG9jKDEwMjQgKiAxMDI0ICogNSkgLy8gNU1CIHBheWxvYWRcbiAgICogICB9O1xuICAgKiAgIHZhciByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHBhcmFtcyk7XG4gICAqICAgcmVxdWVzdC5zZW5kKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICogICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKFwiRXJyb3I6XCIsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gICAqICAgICBlbHNlIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIC8vIGFib3J0IHJlcXVlc3QgaW4gMSBzZWNvbmRcbiAgICogICBzZXRUaW1lb3V0KHJlcXVlc3QuYWJvcnQuYmluZChyZXF1ZXN0KSwgMTAwMCk7XG4gICAqXG4gICAqICAgLy8gcHJpbnRzIFwiRXJyb3I6IFJlcXVlc3RBYm9ydGVkRXJyb3IgUmVxdWVzdCBhYm9ydGVkIGJ5IHVzZXJcIlxuICAgKiBAcmV0dXJuIFtBV1MuUmVxdWVzdF0gdGhlIHNhbWUgcmVxdWVzdCBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCd2YWxpZGF0ZVJlc3BvbnNlJyk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2V4dHJhY3RFcnJvcicpO1xuICAgIHRoaXMub24oJ3ZhbGlkYXRlUmVzcG9uc2UnLCBmdW5jdGlvbiBhZGRBYm9ydGVkRXJyb3IocmVzcCkge1xuICAgICAgcmVzcC5lcnJvciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkIGJ5IHVzZXInKSwge1xuICAgICAgICAgY29kZTogJ1JlcXVlc3RBYm9ydGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmh0dHBSZXF1ZXN0LnN0cmVhbSAmJiAhdGhpcy5odHRwUmVxdWVzdC5zdHJlYW0uZGlkQ2FsbGJhY2spIHsgLy8gYWJvcnQgSFRUUCBzdHJlYW1cbiAgICAgIHRoaXMuaHR0cFJlcXVlc3Quc3RyZWFtLmFib3J0KCk7XG4gICAgICBpZiAodGhpcy5odHRwUmVxdWVzdC5fYWJvcnRDYWxsYmFjaykge1xuICAgICAgICAgdGhpcy5odHRwUmVxdWVzdC5fYWJvcnRDYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3NlbmQnKTsgLy8gaGF2ZW4ndCBzZW50IHlldCwgc28gbGV0J3Mgbm90XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgZWFjaCBwYWdlIG9mIHJlc3VsdHMgZ2l2ZW4gYSBwYWdlYWJsZSByZXF1ZXN0LCBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aXRoIGVhY2ggcGFnZSBvZiBkYXRhLiBBZnRlciBhbGwgcGFnZXMgaGF2ZSBiZWVuXG4gICAqIHJldHJpZXZlZCwgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIGBudWxsYCBkYXRhLlxuICAgKlxuICAgKiBAbm90ZSBUaGlzIG9wZXJhdGlvbiBjYW4gZ2VuZXJhdGUgbXVsdGlwbGUgcmVxdWVzdHMgdG8gYSBzZXJ2aWNlLlxuICAgKiBAZXhhbXBsZSBJdGVyYXRpbmcgb3ZlciBtdWx0aXBsZSBwYWdlcyBvZiBvYmplY3RzIGluIGFuIFMzIGJ1Y2tldFxuICAgKiAgIHZhciBwYWdlcyA9IDE7XG4gICAqICAgczMubGlzdE9iamVjdHMoKS5lYWNoUGFnZShmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgIGlmIChlcnIpIHJldHVybjtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiUGFnZVwiLCBwYWdlcysrKTtcbiAgICogICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBJdGVyYXRpbmcgb3ZlciBtdWx0aXBsZSBwYWdlcyB3aXRoIGFuIGFzeW5jaHJvbm91cyBjYWxsYmFja1xuICAgKiAgIHMzLmxpc3RPYmplY3RzKHBhcmFtcykuZWFjaFBhZ2UoZnVuY3Rpb24oZXJyLCBkYXRhLCBkb25lKSB7XG4gICAqICAgICBkb1NvbWV0aGluZ0FzeW5jQW5kT3JFeHBlbnNpdmUoZnVuY3Rpb24oKSB7XG4gICAqICAgICAgIC8vIFRoZSBuZXh0IHBhZ2Ugb2YgcmVzdWx0cyBpc24ndCBmZXRjaGVkIHVudGlsIGRvbmUgaXMgY2FsbGVkXG4gICAqICAgICAgIGRvbmUoKTtcbiAgICogICAgIH0pO1xuICAgKiAgIH0pO1xuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhLCBbZG9uZUNhbGxiYWNrXSlcbiAgICogICBDYWxsZWQgd2l0aCBlYWNoIHBhZ2Ugb2YgcmVzdWx0aW5nIGRhdGEgZnJvbSB0aGUgcmVxdWVzdC4gSWYgdGhlXG4gICAqICAgb3B0aW9uYWwgYGRvbmVDYWxsYmFja2AgaXMgcHJvdmlkZWQgaW4gdGhlIGZ1bmN0aW9uLCBpdCBtdXN0IGJlIGNhbGxlZFxuICAgKiAgIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGNvbXBsZXRlLlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvYmplY3QsIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIGEgc2luZ2xlIHBhZ2Ugb2YgcmVzcG9uc2UgZGF0YS4gSWYgdGhlcmUgaXMgbm9cbiAgICogICAgIG1vcmUgZGF0YSwgdGhpcyBvYmplY3Qgd2lsbCBiZSBgbnVsbGAuXG4gICAqICAgQHBhcmFtIGRvbmVDYWxsYmFjayBbRnVuY3Rpb25dIGFuIG9wdGlvbmFsIGRvbmUgY2FsbGJhY2suIElmIHRoaXNcbiAgICogICAgIGFyZ3VtZW50IGlzIGRlZmluZWQgaW4gdGhlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uLCBpdCBzaG91bGQgYmUgY2FsbGVkXG4gICAqICAgICB3aGVuIHRoZSBuZXh0IHBhZ2UgaXMgcmVhZHkgdG8gYmUgcmV0cmlldmVkLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogICAgIGNvbnRyb2xsaW5nIHNlcmlhbCBwYWdpbmF0aW9uIGFjcm9zcyBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy5cbiAgICogICBAcmV0dXJuIFtCb29sZWFuXSBpZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCBwYWdpbmF0aW9uIHdpbGxcbiAgICogICAgIHN0b3AuXG4gICAqXG4gICAqIEBzZWUgQVdTLlJlcXVlc3QuZWFjaEl0ZW1cbiAgICogQHNlZSBBV1MuUmVzcG9uc2UubmV4dFBhZ2VcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgZWFjaFBhZ2U6IGZ1bmN0aW9uIGVhY2hQYWdlKGNhbGxiYWNrKSB7XG4gICAgLy8gTWFrZSBhbGwgY2FsbGJhY2tzIGFzeW5jLWlzaFxuICAgIGNhbGxiYWNrID0gQVdTLnV0aWwuZm4ubWFrZUFzeW5jKGNhbGxiYWNrLCAzKTtcblxuICAgIGZ1bmN0aW9uIHdyYXBwZWRDYWxsYmFjayhyZXNwb25zZSkge1xuICAgICAgY2FsbGJhY2suY2FsbChyZXNwb25zZSwgcmVzcG9uc2UuZXJyb3IsIHJlc3BvbnNlLmRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBpZiAocmVzcG9uc2UuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgIHJlc3BvbnNlLm5leHRQYWdlKCkub24oJ2NvbXBsZXRlJywgd3JhcHBlZENhbGxiYWNrKS5zZW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChyZXNwb25zZSwgbnVsbCwgbnVsbCwgQVdTLnV0aWwuZm4ubm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMub24oJ2NvbXBsZXRlJywgd3JhcHBlZENhbGxiYWNrKS5zZW5kKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVudW1lcmF0ZXMgb3ZlciBpbmRpdmlkdWFsIGl0ZW1zIG9mIGEgcmVxdWVzdCwgcGFnaW5nIHRoZSByZXNwb25zZXMgaWZcbiAgICogbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAYXBpIGV4cGVyaW1lbnRhbFxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBlYWNoSXRlbTogZnVuY3Rpb24gZWFjaEl0ZW0oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuXG4gICAgICB2YXIgY29uZmlnID0gc2VsZi5zZXJ2aWNlLnBhZ2luYXRpb25Db25maWcoc2VsZi5vcGVyYXRpb24pO1xuICAgICAgdmFyIHJlc3VsdEtleSA9IGNvbmZpZy5yZXN1bHRLZXk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRLZXkpKSByZXN1bHRLZXkgPSByZXN1bHRLZXlbMF07XG4gICAgICB2YXIgaXRlbXMgPSBqbWVzcGF0aC5zZWFyY2goZGF0YSwgcmVzdWx0S2V5KTtcbiAgICAgIHZhciBjb250aW51ZUl0ZXJhdGlvbiA9IHRydWU7XG4gICAgICBBV1MudXRpbC5hcnJheUVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgY29udGludWVJdGVyYXRpb24gPSBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICAgICAgaWYgKGNvbnRpbnVlSXRlcmF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBBV1MudXRpbC5hYm9ydDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGludWVJdGVyYXRpb247XG4gICAgfVxuXG4gICAgdGhpcy5lYWNoUGFnZSh3cmFwcGVkQ2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBvcGVyYXRpb24gY2FuIHJldHVybiBtdWx0aXBsZSBwYWdlcyBvZlxuICAgKiAgIHJlc3BvbnNlIGRhdGEuXG4gICAqIEBzZWUgQVdTLlJlc3BvbnNlLmVhY2hQYWdlXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGlzUGFnZWFibGU6IGZ1bmN0aW9uIGlzUGFnZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKHRoaXMub3BlcmF0aW9uKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZHMgdGhlIHJlcXVlc3QgYW5kIGNvbnZlcnRzIHRoZSByZXF1ZXN0IG9iamVjdCBpbnRvIGEgcmVhZGFibGUgc3RyZWFtXG4gICAqIHRoYXQgY2FuIGJlIHJlYWQgZnJvbSBvciBwaXBlZCBpbnRvIGEgd3JpdGFibGUgc3RyZWFtLlxuICAgKlxuICAgKiBAbm90ZSBUaGUgZGF0YSByZWFkIGZyb20gYSByZWFkYWJsZSBzdHJlYW0gY29udGFpbnMgb25seVxuICAgKiAgIHRoZSByYXcgSFRUUCBib2R5IGNvbnRlbnRzLlxuICAgKiBAZXhhbXBsZSBNYW51YWxseSByZWFkaW5nIGZyb20gYSBzdHJlYW1cbiAgICogICByZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW0oKS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiR290IGRhdGE6XCIsIGRhdGEudG9TdHJpbmcoKSk7XG4gICAqICAgfSk7XG4gICAqIEBleGFtcGxlIFBpcGluZyBhIHJlcXVlc3QgYm9keSBpbnRvIGEgZmlsZVxuICAgKiAgIHZhciBvdXQgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbSgnL3BhdGgvdG8vb3V0ZmlsZS5qcGcnKTtcbiAgICogICBzMy5zZXJ2aWNlLmdldE9iamVjdChwYXJhbXMpLmNyZWF0ZVJlYWRTdHJlYW0oKS5waXBlKG91dCk7XG4gICAqIEByZXR1cm4gW1N0cmVhbV0gdGhlIHJlYWRhYmxlIHN0cmVhbSBvYmplY3QgdGhhdCBjYW4gYmUgcGlwZWRcbiAgICogICBvciByZWFkIGZyb20gKGJ5IHJlZ2lzdGVyaW5nICdkYXRhJyBldmVudCBsaXN0ZW5lcnMpLlxuICAgKiBAIW1hY3JvIG5vYnJvd3NlclxuICAgKi9cbiAgY3JlYXRlUmVhZFN0cmVhbTogZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSgpIHtcbiAgICB2YXIgc3RyZWFtcyA9IEFXUy51dGlsLnN0cmVhbTtcbiAgICB2YXIgcmVxID0gdGhpcztcbiAgICB2YXIgc3RyZWFtID0gbnVsbDtcblxuICAgIGlmIChBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMikge1xuICAgICAgc3RyZWFtID0gbmV3IHN0cmVhbXMuUGFzc1Rocm91Z2goKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHJlcS5zZW5kKCk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0gPSBuZXcgc3RyZWFtcy5TdHJlYW0oKTtcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IHRydWU7XG5cbiAgICAgIHN0cmVhbS5zZW50ID0gZmFsc2U7XG4gICAgICBzdHJlYW0ub24oJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc2VudCAmJiBldmVudCA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgc3RyZWFtLnNlbnQgPSB0cnVlO1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHJlcS5zZW5kKCk7IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2h0dHBIZWFkZXJzJywgZnVuY3Rpb24gc3RyZWFtSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwKSB7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2h0dHBEYXRhJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9EQVRBKTtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdodHRwRXJyb3InLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5IVFRQX0VSUk9SKTtcbiAgICAgICAgcmVxLm9uKCdodHRwRXJyb3InLCBmdW5jdGlvbiBzdHJlYW1IdHRwRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICByZXNwLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXhwZWN0ZWRMZW47XG4gICAgICAgIGlmIChyZXEuaHR0cFJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgICBleHBlY3RlZExlbiA9IHBhcnNlSW50KGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWRMZW4gIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4oZXhwZWN0ZWRMZW4pICYmIGV4cGVjdGVkTGVuID49IDApIHtcbiAgICAgICAgICBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSB0cnVlO1xuICAgICAgICAgIHZhciByZWNlaXZlZExlbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCA9IGZ1bmN0aW9uIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQoKSB7XG4gICAgICAgICAgaWYgKHNob3VsZENoZWNrQ29udGVudExlbmd0aCAmJiByZWNlaXZlZExlbiAhPT0gZXhwZWN0ZWRMZW4pIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ1N0cmVhbSBjb250ZW50IGxlbmd0aCBtaXNtYXRjaC4gUmVjZWl2ZWQgJyArXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRMZW4gKyAnIG9mICcgKyBleHBlY3RlZExlbiArICcgYnl0ZXMuJyksXG4gICAgICAgICAgICAgIHsgY29kZTogJ1N0cmVhbUNvbnRlbnRMZW5ndGhNaXNtYXRjaCcgfVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMikge1xuICAgICAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBodHRwU3RyZWFtID0gcmVzcC5odHRwUmVzcG9uc2UuY3JlYXRlVW5idWZmZXJlZFN0cmVhbSgpO1xuXG4gICAgICAgIGlmIChBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMikge1xuICAgICAgICAgIGlmIChzaG91bGRDaGVja0NvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhBY2N1bXVsYXRvciA9IG5ldyBzdHJlYW1zLlBhc3NUaHJvdWdoKCk7XG4gICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRMZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzdHJlYW1zLlBhc3NUaHJvdWdoLnByb3RvdHlwZS5fd3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLm9uKCdlbmQnLCBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGh0dHBTdHJlYW0udW5waXBlKGxlbmd0aEFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3IuZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBodHRwU3RyZWFtLnBpcGUobGVuZ3RoQWNjdW11bGF0b3IpLnBpcGUoc3RyZWFtLCB7IGVuZDogZmFsc2UgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0dHBTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmIChzaG91bGRDaGVja0NvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIGh0dHBTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRMZW4gKz0gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaHR0cFN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBhcmcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGh0dHBTdHJlYW0ub24oJ2VuZCcsIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaHR0cFN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSBbQXJyYXksUmVzcG9uc2VdIGFyZ3MgVGhpcyBzaG91bGQgYmUgdGhlIHJlc3BvbnNlIG9iamVjdCxcbiAgICogICBvciBhbiBhcnJheSBvZiBhcmdzIHRvIHNlbmQgdG8gdGhlIGV2ZW50LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGVtaXRFdmVudDogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIGFyZ3MsIGRvbmUpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpIHsgZG9uZSA9IGFyZ3M7IGFyZ3MgPSBudWxsOyB9XG4gICAgaWYgKCFkb25lKSBkb25lID0gZnVuY3Rpb24oKSB7IH07XG4gICAgaWYgKCFhcmdzKSBhcmdzID0gdGhpcy5ldmVudFBhcmFtZXRlcnMoZXZlbnROYW1lLCB0aGlzLnJlc3BvbnNlKTtcblxuICAgIHZhciBvcmlnRW1pdCA9IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IucHJvdG90eXBlLmVtaXQ7XG4gICAgb3JpZ0VtaXQuY2FsbCh0aGlzLCBldmVudE5hbWUsIGFyZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBlcnI7XG4gICAgICBkb25lLmNhbGwodGhpcywgZXJyKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBldmVudFBhcmFtZXRlcnM6IGZ1bmN0aW9uIGV2ZW50UGFyYW1ldGVycyhldmVudE5hbWUpIHtcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgICAgY2FzZSAncmVzdGFydCc6XG4gICAgICBjYXNlICd2YWxpZGF0ZSc6XG4gICAgICBjYXNlICdzaWduJzpcbiAgICAgIGNhc2UgJ2J1aWxkJzpcbiAgICAgIGNhc2UgJ2FmdGVyVmFsaWRhdGUnOlxuICAgICAgY2FzZSAnYWZ0ZXJCdWlsZCc6XG4gICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHJldHVybiBbdGhpcy5yZXNwb25zZS5lcnJvciwgdGhpcy5yZXNwb25zZV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3RoaXMucmVzcG9uc2VdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcmVzaWduOiBmdW5jdGlvbiBwcmVzaWduKGV4cGlyZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgZXhwaXJlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBleHBpcmVzO1xuICAgICAgZXhwaXJlcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQVdTLlNpZ25lcnMuUHJlc2lnbigpLnNpZ24odGhpcy50b0dldCgpLCBleHBpcmVzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNQcmVzaWduZWQ6IGZ1bmN0aW9uIGlzUHJlc2lnbmVkKCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5odHRwUmVxdWVzdC5oZWFkZXJzLCAncHJlc2lnbmVkLWV4cGlyZXMnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b1VuYXV0aGVudGljYXRlZDogZnVuY3Rpb24gdG9VbmF1dGhlbnRpY2F0ZWQoKSB7XG4gICAgdGhpcy5fdW5BdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX0NSRURFTlRJQUxTKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdzaWduJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0lHTik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG9HZXQ6IGZ1bmN0aW9uIHRvR2V0KCkge1xuICAgIGlmICh0aGlzLnNlcnZpY2UuYXBpLnByb3RvY29sID09PSAncXVlcnknIHx8XG4gICAgICAgIHRoaXMuc2VydmljZS5hcGkucHJvdG9jb2wgPT09ICdlYzInKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdidWlsZCcsIHRoaXMuYnVpbGRBc0dldCk7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMuYnVpbGRBc0dldCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGJ1aWxkQXNHZXQ6IGZ1bmN0aW9uIGJ1aWxkQXNHZXQocmVxdWVzdCkge1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QubWV0aG9kID0gJ0dFVCc7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5wYXRoID0gcmVxdWVzdC5zZXJ2aWNlLmVuZHBvaW50LnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc/JyArIHJlcXVlc3QuaHR0cFJlcXVlc3QuYm9keTtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmJvZHkgPSAnJztcblxuICAgIC8vIGRvbid0IG5lZWQgdGhlc2UgaGVhZGVycyBvbiBhIEdFVCByZXF1ZXN0XG4gICAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXTtcbiAgICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoYWx0SGFuZGxlcnNPbkVycm9yOiBmdW5jdGlvbiBoYWx0SGFuZGxlcnNPbkVycm9yKCkge1xuICAgIHRoaXMuX2hhbHRIYW5kbGVyc09uRXJyb3IgPSB0cnVlO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlJlcXVlc3QuYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiBwcm9taXNlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBhcHBlbmQgdG8gdXNlciBhZ2VudFxuICAgIHRoaXMuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoJ3Byb21pc2UnKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2VEZXBlbmRlbmN5KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2VsZi5vbignY29tcGxldGUnLCBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChyZXNwLmVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHJlc3AuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmluZSAkcmVzcG9uc2UgcHJvcGVydHkgc28gdGhhdCBpdCBpcyBub3QgZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgY2lyY3VsYXIgcmVmZXJlbmNlIGVycm9ycyB3aGVuIHN0cmluZ2lmeWluZyB0aGUgSlNPTiBvYmplY3RcbiAgICAgICAgICByZXNvbHZlKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIHJlc3AuZGF0YSB8fCB7fSxcbiAgICAgICAgICAgICckcmVzcG9uc2UnLFxuICAgICAgICAgICAge3ZhbHVlOiByZXNwfVxuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGYucnVuVG8oKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5SZXF1ZXN0LmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5wcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLlJlcXVlc3QpO1xuXG5BV1MudXRpbC5taXhpbihBV1MuUmVxdWVzdCwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLiBZb3VcbiAqIG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBBIGNvcHkgb2ZcbiAqIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgaHR0cDovL2F3cy5hbWF6b24uY29tL2FwYWNoZTIuMC9cbiAqXG4gKiBvciBpbiB0aGUgXCJsaWNlbnNlXCIgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXNcbiAqIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpY1xuICogbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgam1lc3BhdGggPSByZXF1aXJlKCdqbWVzcGF0aCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDSEVDS19BQ0NFUFRPUlMocmVzcCkge1xuICB2YXIgd2FpdGVyID0gcmVzcC5yZXF1ZXN0Ll93YWl0ZXI7XG4gIHZhciBhY2NlcHRvcnMgPSB3YWl0ZXIuY29uZmlnLmFjY2VwdG9ycztcbiAgdmFyIGFjY2VwdG9yTWF0Y2hlZCA9IGZhbHNlO1xuICB2YXIgc3RhdGUgPSAncmV0cnknO1xuXG4gIGFjY2VwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGFjY2VwdG9yKSB7XG4gICAgaWYgKCFhY2NlcHRvck1hdGNoZWQpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gd2FpdGVyLm1hdGNoZXJzW2FjY2VwdG9yLm1hdGNoZXJdO1xuICAgICAgaWYgKG1hdGNoZXIgJiYgbWF0Y2hlcihyZXNwLCBhY2NlcHRvci5leHBlY3RlZCwgYWNjZXB0b3IuYXJndW1lbnQpKSB7XG4gICAgICAgIGFjY2VwdG9yTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlID0gYWNjZXB0b3Iuc3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWFjY2VwdG9yTWF0Y2hlZCAmJiByZXNwLmVycm9yKSBzdGF0ZSA9ICdmYWlsdXJlJztcblxuICBpZiAoc3RhdGUgPT09ICdzdWNjZXNzJykge1xuICAgIHdhaXRlci5zZXRTdWNjZXNzKHJlc3ApO1xuICB9IGVsc2Uge1xuICAgIHdhaXRlci5zZXRFcnJvcihyZXNwLCBzdGF0ZSA9PT0gJ3JldHJ5Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlJlc291cmNlV2FpdGVyID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYSBnaXZlbiBzdGF0ZSBvbiBhIHNlcnZpY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSBzZXJ2aWNlIFtTZXJ2aWNlXSB0aGUgc2VydmljZSBvYmplY3QgdG8gd2FpdCBvblxuICAgKiBAcGFyYW0gc3RhdGUgW1N0cmluZ10gdGhlIHN0YXRlIChkZWZpbmVkIGluIHdhaXRlciBjb25maWd1cmF0aW9uKSB0byB3YWl0XG4gICAqICAgZm9yLlxuICAgKiBAZXhhbXBsZSBDcmVhdGUgYSB3YWl0ZXIgZm9yIHJ1bm5pbmcgRUMyIGluc3RhbmNlc1xuICAgKiAgIHZhciBlYzIgPSBuZXcgQVdTLkVDMjtcbiAgICogICB2YXIgd2FpdGVyID0gbmV3IEFXUy5SZXNvdXJjZVdhaXRlcihlYzIsICdpbnN0YW5jZVJ1bm5pbmcnKTtcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzdGF0ZSkge1xuICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9hZFdhaXRlckNvbmZpZyh0aGlzLnN0YXRlKTtcbiAgfSxcblxuICBzZXJ2aWNlOiBudWxsLFxuXG4gIHN0YXRlOiBudWxsLFxuXG4gIGNvbmZpZzogbnVsbCxcblxuICBtYXRjaGVyczoge1xuICAgIHBhdGg6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkLCBhcmd1bWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqbWVzcGF0aC5zdHJpY3REZWVwRXF1YWwocmVzdWx0LGV4cGVjdGVkKTtcbiAgICB9LFxuXG4gICAgcGF0aEFsbDogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICAgIHZhciBudW1SZXN1bHRzID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICBpZiAoIW51bVJlc3VsdHMpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGluZCA9IDAgOyBpbmQgPCBudW1SZXN1bHRzOyBpbmQrKykge1xuICAgICAgICBpZiAoIWptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHRzW2luZF0sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHBhdGhBbnk6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkLCBhcmd1bWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBqbWVzcGF0aC5zZWFyY2gocmVzcC5kYXRhLCBhcmd1bWVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHJlc3VsdHMgPSBbcmVzdWx0c107XG4gICAgICB2YXIgbnVtUmVzdWx0cyA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaW5kID0gMCA7IGluZCA8IG51bVJlc3VsdHM7IGluZCsrKSB7XG4gICAgICAgIGlmIChqbWVzcGF0aC5zdHJpY3REZWVwRXF1YWwocmVzdWx0c1tpbmRdLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBzdGF0dXM6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkKSB7XG4gICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICByZXR1cm4gKHR5cGVvZiBzdGF0dXNDb2RlID09PSAnbnVtYmVyJykgJiYgKHN0YXR1c0NvZGUgPT09IGV4cGVjdGVkKTtcbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiByZXNwLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gcmVzcC5lcnJvci5jb2RlO1xuICAgICAgfVxuICAgICAgLy8gaWYgZXhwZWN0ZWQgaXMgbm90IHN0cmluZywgY2FuIGJlIGJvb2xlYW4gaW5kaWNhdGluZyBwcmVzZW5jZSBvZiBlcnJvclxuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSAhIXJlc3AuZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczogbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ1JFVFJZX0NIRUNLJywgJ3JldHJ5JywgZnVuY3Rpb24ocmVzcCkge1xuICAgICAgdmFyIHdhaXRlciA9IHJlc3AucmVxdWVzdC5fd2FpdGVyO1xuICAgICAgaWYgKHJlc3AuZXJyb3IgJiYgcmVzcC5lcnJvci5jb2RlID09PSAnUmVzb3VyY2VOb3RSZWFkeScpIHtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gKHdhaXRlci5jb25maWcuZGVsYXkgfHwgMCkgKiAxMDAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdDSEVDS19PVVRQVVQnLCAnZXh0cmFjdERhdGEnLCBDSEVDS19BQ0NFUFRPUlMpO1xuXG4gICAgYWRkKCdDSEVDS19FUlJPUicsICdleHRyYWN0RXJyb3InLCBDSEVDS19BQ0NFUFRPUlMpO1xuICB9KSxcblxuICAvKipcbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdXG4gICAqL1xuICB3YWl0OiBmdW5jdGlvbiB3YWl0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7IHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy4kd2FpdGVyKSB7XG4gICAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyk7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy4kd2FpdGVyLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxheSA9IHBhcmFtcy4kd2FpdGVyLmRlbGF5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuJHdhaXRlci5tYXhBdHRlbXB0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4QXR0ZW1wdHMgPSBwYXJhbXMuJHdhaXRlci5tYXhBdHRlbXB0cztcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwYXJhbXMuJHdhaXRlcjtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCh0aGlzLmNvbmZpZy5vcGVyYXRpb24sIHBhcmFtcyk7XG4gICAgcmVxdWVzdC5fd2FpdGVyID0gdGhpcztcbiAgICByZXF1ZXN0LnJlc3BvbnNlLm1heFJldHJpZXMgPSB0aGlzLmNvbmZpZy5tYXhBdHRlbXB0cztcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVycyh0aGlzLmxpc3RlbmVycyk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHJlcXVlc3Quc2VuZChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgc2V0U3VjY2VzczogZnVuY3Rpb24gc2V0U3VjY2VzcyhyZXNwKSB7XG4gICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgcmVzcC5kYXRhID0gcmVzcC5kYXRhIHx8IHt9O1xuICAgIHJlc3AucmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2V4dHJhY3REYXRhJyk7XG4gIH0sXG5cbiAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKHJlc3AsIHJldHJ5YWJsZSkge1xuICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgcmVzcC5lcnJvciA9IEFXUy51dGlsLmVycm9yKHJlc3AuZXJyb3IgfHwgbmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6ICdSZXNvdXJjZU5vdFJlYWR5JyxcbiAgICAgIG1lc3NhZ2U6ICdSZXNvdXJjZSBpcyBub3QgaW4gdGhlIHN0YXRlICcgKyB0aGlzLnN0YXRlLFxuICAgICAgcmV0cnlhYmxlOiByZXRyeWFibGVcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgd2FpdGVyIGNvbmZpZ3VyYXRpb24gZnJvbSBBUEkgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRXYWl0ZXJDb25maWc6IGZ1bmN0aW9uIGxvYWRXYWl0ZXJDb25maWcoc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuc2VydmljZS5hcGkud2FpdGVyc1tzdGF0ZV0pIHtcbiAgICAgIHRocm93IG5ldyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnU3RhdGVOb3RGb3VuZEVycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ1N0YXRlICcgKyBzdGF0ZSArICcgbm90IGZvdW5kLidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnID0gQVdTLnV0aWwuY29weSh0aGlzLnNlcnZpY2UuYXBpLndhaXRlcnNbc3RhdGVdKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgam1lc3BhdGggPSByZXF1aXJlKCdqbWVzcGF0aCcpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSByZXNwb25zZSBpbmZvcm1hdGlvblxuICogZnJvbSBhIHNlcnZpY2UgcmVxdWVzdCBvcGVyYXRpb24gc2VudCB0aHJvdWdoIHtBV1MuUmVxdWVzdH0uXG4gKiBUaGUgcmVzcG9uc2Ugb2JqZWN0IGhhcyB0d28gbWFpbiBwcm9wZXJ0aWVzIGZvciBnZXR0aW5nIGluZm9ybWF0aW9uXG4gKiBiYWNrIGZyb20gYSByZXF1ZXN0OlxuICpcbiAqICMjIFRoZSBgZGF0YWAgcHJvcGVydHlcbiAqXG4gKiBUaGUgYHJlc3BvbnNlLmRhdGFgIHByb3BlcnR5IGNvbnRhaW5zIHRoZSBzZXJpYWxpemVkIG9iamVjdCBkYXRhXG4gKiByZXRyaWV2ZWQgZnJvbSB0aGUgc2VydmljZSByZXF1ZXN0LiBGb3IgaW5zdGFuY2UsIGZvciBhblxuICogQW1hem9uIER5bmFtb0RCIGBsaXN0VGFibGVzYCBtZXRob2QgY2FsbCwgdGhlIHJlc3BvbnNlIGRhdGEgbWlnaHRcbiAqIGxvb2sgbGlrZTpcbiAqXG4gKiBgYGBcbiAqID4gcmVzcC5kYXRhXG4gKiB7IFRhYmxlTmFtZXM6XG4gKiAgICBbICd0YWJsZTEnLCAndGFibGUyJywgLi4uIF0gfVxuICogYGBgXG4gKlxuICogVGhlIGBkYXRhYCBwcm9wZXJ0eSBjYW4gYmUgbnVsbCBpZiBhbiBlcnJvciBvY2N1cnMgKHNlZSBiZWxvdykuXG4gKlxuICogIyMgVGhlIGBlcnJvcmAgcHJvcGVydHlcbiAqXG4gKiBJbiB0aGUgZXZlbnQgb2YgYSBzZXJ2aWNlIGVycm9yIChvciB0cmFuc2ZlciBlcnJvciksIHRoZVxuICogYHJlc3BvbnNlLmVycm9yYCBwcm9wZXJ0eSB3aWxsIGJlIGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICogZXJyb3IgZGF0YSBpbiB0aGUgZm9ybTpcbiAqXG4gKiBgYGBcbiAqIHsgY29kZTogJ1NIT1JUX1VOSVFVRV9FUlJPUl9DT0RFJyxcbiAqICAgbWVzc2FnZTogJ1NvbWUgaHVtYW4gcmVhZGFibGUgZXJyb3IgbWVzc2FnZScgfVxuICogYGBgXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYW4gZXJyb3IsIHRoZSBgZGF0YWAgcHJvcGVydHkgd2lsbCBiZSBgbnVsbGAuXG4gKiBOb3RlIHRoYXQgaWYgeW91IGhhbmRsZSBldmVudHMgdGhhdCBjYW4gYmUgaW4gYSBmYWlsdXJlIHN0YXRlLFxuICogeW91IHNob3VsZCBhbHdheXMgY2hlY2sgd2hldGhlciBgcmVzcG9uc2UuZXJyb3JgIGlzIHNldFxuICogYmVmb3JlIGF0dGVtcHRpbmcgdG8gYWNjZXNzIHRoZSBgcmVzcG9uc2UuZGF0YWAgcHJvcGVydHkuXG4gKlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBEYXRhIFByb3BlcnRpZXNcbiAqICAgQG5vdGUgSW5zaWRlIG9mIGEge0FXUy5SZXF1ZXN0fmh0dHBEYXRhfSBldmVudCwgdGhpc1xuICogICAgIHByb3BlcnR5IGNvbnRhaW5zIGEgc2luZ2xlIHJhdyBwYWNrZXQgaW5zdGVhZCBvZiB0aGVcbiAqICAgICBmdWxsIGRlLXNlcmlhbGl6ZWQgc2VydmljZSByZXNwb25zZS5cbiAqICAgQHJldHVybiBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCByZXNwb25zZSBkYXRhXG4gKiAgICAgZnJvbSB0aGUgc2VydmljZS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBlcnJvclxuICogICBBbiBzdHJ1Y3R1cmUgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBhIHNlcnZpY2VcbiAqICAgb3IgbmV0d29ya2luZyBlcnJvci5cbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgRGF0YSBQcm9wZXJ0aWVzXG4gKiAgIEBub3RlIFRoaXMgYXR0cmlidXRlIGlzIG9ubHkgZmlsbGVkIGlmIGEgc2VydmljZSBvclxuICogICAgIG5ldHdvcmtpbmcgZXJyb3Igb2NjdXJzLlxuICogICBAcmV0dXJuIFtFcnJvcl1cbiAqICAgICAqIGNvZGUgW1N0cmluZ10gYSB1bmlxdWUgc2hvcnQgY29kZSByZXByZXNlbnRpbmcgdGhlXG4gKiAgICAgICBlcnJvciB0aGF0IHdhcyBlbWl0dGVkLlxuICogICAgICogbWVzc2FnZSBbU3RyaW5nXSBhIGxvbmdlciBodW1hbiByZWFkYWJsZSBlcnJvciBtZXNzYWdlXG4gKiAgICAgKiByZXRyeWFibGUgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGVycm9yIG1lc3NhZ2UgaXNcbiAqICAgICAgIHJldHJ5YWJsZS5cbiAqICAgICAqIHN0YXR1c0NvZGUgW051bWVyaWNdIGluIHRoZSBjYXNlIG9mIGEgcmVxdWVzdCB0aGF0IHJlYWNoZWQgdGhlIHNlcnZpY2UsXG4gKiAgICAgICB0aGlzIHZhbHVlIGNvbnRhaW5zIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAqICAgICAqIHRpbWUgW0RhdGVdIHRoZSBkYXRlIHRpbWUgb2JqZWN0IHdoZW4gdGhlIGVycm9yIG9jY3VycmVkLlxuICogICAgICogaG9zdG5hbWUgW1N0cmluZ10gc2V0IHdoZW4gYSBuZXR3b3JraW5nIGVycm9yIG9jY3VycyB0byBlYXNpbHlcbiAqICAgICAgIGlkZW50aWZ5IHRoZSBlbmRwb2ludCBvZiB0aGUgcmVxdWVzdC5cbiAqICAgICAqIHJlZ2lvbiBbU3RyaW5nXSBzZXQgd2hlbiBhIG5ldHdvcmtpbmcgZXJyb3Igb2NjdXJzIHRvIGVhc2lseVxuICogICAgICAgaWRlbnRpZnkgdGhlIHJlZ2lvbiBvZiB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZXF1ZXN0SWRcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgRGF0YSBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHVuaXF1ZSByZXF1ZXN0IElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzcG9uc2UuXG4gKiAgICAgTG9nIHRoaXMgdmFsdWUgd2hlbiBkZWJ1Z2dpbmcgcmVxdWVzdHMgZm9yIEFXUyBzdXBwb3J0LlxuICpcbiAqIEAhYXR0cmlidXRlIHJldHJ5Q291bnRcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiByZXRyaWVzIHRoYXQgd2VyZVxuICogICAgIGF0dGVtcHRlZCBiZWZvcmUgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZWRpcmVjdENvdW50XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIE9wZXJhdGlvbiBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBudW1iZXIgb2YgcmVkaXJlY3RzIHRoYXQgd2VyZVxuICogICAgIGZvbGxvd2VkIGJlZm9yZSB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLlxuICpcbiAqIEAhYXR0cmlidXRlIGh0dHBSZXNwb25zZVxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBIVFRQIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbQVdTLkh0dHBSZXNwb25zZV0gdGhlIHJhdyBIVFRQIHJlc3BvbnNlIG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgdGhlIHJlc3BvbnNlIGhlYWRlcnMgYW5kIGJvZHkgaW5mb3JtYXRpb25cbiAqICAgICBmcm9tIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHNlZSBBV1MuUmVxdWVzdFxuICovXG5BV1MuUmVzcG9uc2UgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMucmVkaXJlY3RDb3VudCA9IDA7XG4gICAgdGhpcy5odHRwUmVzcG9uc2UgPSBuZXcgQVdTLkh0dHBSZXNwb25zZSgpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICB0aGlzLm1heFJldHJpZXMgPSByZXF1ZXN0LnNlcnZpY2UubnVtUmV0cmllcygpO1xuICAgICAgdGhpcy5tYXhSZWRpcmVjdHMgPSByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLm1heFJlZGlyZWN0cztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcmVxdWVzdCBmb3IgdGhlIG5leHQgcGFnZSBvZiByZXNwb25zZSBkYXRhLCBjYWxsaW5nIHRoZVxuICAgKiBjYWxsYmFjayB3aXRoIHRoZSBwYWdlIGRhdGEgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBDYWxsZWQgd2hlbiBhIHBhZ2Ugb2YgZGF0YSBpcyByZXR1cm5lZCBmcm9tIHRoZSBuZXh0IHJlcXVlc3QuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9iamVjdCwgaWYgYW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIHJlcXVlc3RcbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgbmV4dCBwYWdlIG9mIGRhdGEsIG9yIG51bGwsIGlmIHRoZXJlIGFyZSBub1xuICAgKiAgICAgbW9yZSBwYWdlcyBsZWZ0LlxuICAgKiBAcmV0dXJuIFtBV1MuUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGZvciB0aGUgbmV4dCBwYWdlIG9mIGRhdGFcbiAgICogQHJldHVybiBbbnVsbF0gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQgYW5kIHRoZXJlIGFyZSBubyBwYWdlcyBsZWZ0XG4gICAqICAgdG8gcmV0cmlldmUuXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIG5leHRQYWdlOiBmdW5jdGlvbiBuZXh0UGFnZShjYWxsYmFjaykge1xuICAgIHZhciBjb25maWc7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzLnJlcXVlc3Quc2VydmljZTtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5yZXF1ZXN0Lm9wZXJhdGlvbjtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkgeyB0aGlzLmVycm9yID0gZTsgfVxuXG4gICAgaWYgKCF0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sodGhpcy5lcnJvciwgbnVsbCk7XG4gICAgICBlbHNlIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkodGhpcy5yZXF1ZXN0LnBhcmFtcyk7XG4gICAgaWYgKCF0aGlzLm5leHRQYWdlVG9rZW5zKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhudWxsLCBudWxsKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbnB1dFRva2VucyA9IGNvbmZpZy5pbnB1dFRva2VuO1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dFRva2VucyA9PT0gJ3N0cmluZycpIGlucHV0VG9rZW5zID0gW2lucHV0VG9rZW5zXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFyYW1zW2lucHV0VG9rZW5zW2ldXSA9IHRoaXMubmV4dFBhZ2VUb2tlbnNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VydmljZS5tYWtlUmVxdWVzdCh0aGlzLnJlcXVlc3Qub3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgbW9yZSBwYWdlcyBvZiBkYXRhIGNhbiBiZSByZXR1cm5lZCBieSBmdXJ0aGVyXG4gICAqICAgcmVxdWVzdHNcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgaGFzTmV4dFBhZ2U6IGZ1bmN0aW9uIGhhc05leHRQYWdlKCkge1xuICAgIHRoaXMuY2FjaGVOZXh0UGFnZVRva2VucygpO1xuICAgIGlmICh0aGlzLm5leHRQYWdlVG9rZW5zKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5uZXh0UGFnZVRva2VucyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhY2hlTmV4dFBhZ2VUb2tlbnM6IGZ1bmN0aW9uIGNhY2hlTmV4dFBhZ2VUb2tlbnMoKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnbmV4dFBhZ2VUb2tlbnMnKSkgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG4gICAgdGhpcy5uZXh0UGFnZVRva2VucyA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb25maWcgPSB0aGlzLnJlcXVlc3Quc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKHRoaXMucmVxdWVzdC5vcGVyYXRpb24pO1xuICAgIGlmICghY29uZmlnKSByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcblxuICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMgPSBudWxsO1xuICAgIGlmIChjb25maWcubW9yZVJlc3VsdHMpIHtcbiAgICAgIGlmICgham1lc3BhdGguc2VhcmNoKHRoaXMuZGF0YSwgY29uZmlnLm1vcmVSZXN1bHRzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXhwcnMgPSBjb25maWcub3V0cHV0VG9rZW47XG4gICAgaWYgKHR5cGVvZiBleHBycyA9PT0gJ3N0cmluZycpIGV4cHJzID0gW2V4cHJzXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBleHBycywgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgIHZhciBvdXRwdXQgPSBqbWVzcGF0aC5zZWFyY2godGhpcy5kYXRhLCBleHByKTtcbiAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgdGhpcy5uZXh0UGFnZVRva2VucyA9IHRoaXMubmV4dFBhZ2VUb2tlbnMgfHwgW107XG4gICAgICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMucHVzaChvdXRwdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAIW1ldGhvZCBvbihldmVudE5hbWUsIGNhbGxiYWNrKVxuICogICBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2sgZm9yIHRoZSBldmVudCBnaXZlbiBieSBgZXZlbnROYW1lYC5cbiAqICAgUGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGRlcGVuZCBvbiB0aGUgaW5kaXZpZHVhbCBldmVudFxuICogICBiZWluZyB0cmlnZ2VyZWQuIFNlZSB0aGUgZXZlbnQgZG9jdW1lbnRhdGlvbiBmb3IgdGhvc2UgcGFyYW1ldGVycy5cbiAqXG4gKiAgIEBwYXJhbSBldmVudE5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWUgdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIGZvclxuICogICBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uXSB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgQHBhcmFtIHRvSGVhZCBbQm9vbGVhbl0gYXR0YWNoIHRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byB0aGUgaGVhZCBvZiBjYWxsYmFjayBhcnJheSBpZiBzZXQgdG8gdHJ1ZS5cbiAqICAgICBEZWZhdWx0IHRvIGJlIGZhbHNlLlxuICogICBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSB0aGUgc2FtZSBvYmplY3QgZm9yIGNoYWluaW5nXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IgPSBBV1MudXRpbC5pbmhlcml0KHtcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2VxdWVudGlhbEV4ZWN1dG9yKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA/IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnNsaWNlKDApIDogW107XG4gIH0sXG5cbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCkge1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdG9IZWFkID9cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0udW5zaGlmdChsaXN0ZW5lcikgOlxuICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbkFzeW5jOiBmdW5jdGlvbiBvbkFzeW5jKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCkge1xuICAgIGxpc3RlbmVyLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyLCB0b0hlYWQpO1xuICB9LFxuXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPiAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIGV2ZW50QXJncywgZG9uZUNhbGxiYWNrKSB7XG4gICAgaWYgKCFkb25lQ2FsbGJhY2spIGRvbmVDYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIHZhciBjb3VudCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgdGhpcy5jYWxsTGlzdGVuZXJzKGxpc3RlbmVycywgZXZlbnRBcmdzLCBkb25lQ2FsbGJhY2spO1xuICAgIHJldHVybiBjb3VudCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FsbExpc3RlbmVyczogZnVuY3Rpb24gY2FsbExpc3RlbmVycyhsaXN0ZW5lcnMsIGFyZ3MsIGRvbmVDYWxsYmFjaywgcHJldkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlcnJvciA9IHByZXZFcnJvciB8fCBudWxsO1xuXG4gICAgZnVuY3Rpb24gY2FsbE5leHRMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwgZXJyKTtcbiAgICAgICAgaWYgKHNlbGYuX2hhbHRIYW5kbGVyc09uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLmNhbGxMaXN0ZW5lcnMobGlzdGVuZXJzLCBhcmdzLCBkb25lQ2FsbGJhY2ssIGVycm9yKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVycy5zaGlmdCgpO1xuICAgICAgaWYgKGxpc3RlbmVyLl9pc0FzeW5jKSB7IC8vIGFzeW5jaHJvbm91cyBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChbY2FsbE5leHRMaXN0ZW5lcl0pKTtcbiAgICAgICAgcmV0dXJuOyAvLyBzdG9wIGhlcmUsIGNhbGxOZXh0TGlzdGVuZXIgd2lsbCBjb250aW51ZVxuICAgICAgfSBlbHNlIHsgLy8gc3luY2hyb25vdXMgbGlzdGVuZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvcikge1xuICAgICAgICAgIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIGNvcGllcyBhIHNldCBvZiBsaXN0ZW5lcnMgZnJvbSBhbm90aGVyIGxpc3Qgb2ZcbiAgICogbGlzdGVuZXJzIG9yIFNlcXVlbnRpYWxFeGVjdXRvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lcnMgW21hcDxTdHJpbmcsQXJyYXk8RnVuY3Rpb24+PiwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl1cbiAgICogICBhIGxpc3Qgb2YgZXZlbnRzIGFuZCBjYWxsYmFja3MsIG9yIGFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0XG4gICAqICAgY29udGFpbmluZyBsaXN0ZW5lcnMgdG8gYWRkIHRvIHRoaXMgZW1pdHRlciBvYmplY3QuXG4gICAqIEByZXR1cm4gW0FXUy5TZXF1ZW50aWFsRXhlY3V0b3JdIHRoZSBlbWl0dGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgbGlzdGVuZXJzIGZyb20gYSBtYXAgb2YgbGlzdGVuZXJzXG4gICAqICAgZW1pdHRlci5hZGRMaXN0ZW5lcnMoe1xuICAgKiAgICAgZXZlbnQxOiBbZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbigpIHsgLi4uIH1dLFxuICAgKiAgICAgZXZlbnQyOiBbZnVuY3Rpb24oKSB7IC4uLiB9XVxuICAgKiAgIH0pO1xuICAgKiAgIGVtaXR0ZXIuZW1pdCgnZXZlbnQxJyk7IC8vIGVtaXR0ZXIgaGFzIGV2ZW50MVxuICAgKiAgIGVtaXR0ZXIuZW1pdCgnZXZlbnQyJyk7IC8vIGVtaXR0ZXIgaGFzIGV2ZW50MlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgbGlzdGVuZXJzIGZyb20gYW5vdGhlciBlbWl0dGVyIG9iamVjdFxuICAgKiAgIHZhciBlbWl0dGVyMSA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG4gICAqICAgZW1pdHRlcjEub24oJ2V2ZW50MScsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgZW1pdHRlcjEub24oJ2V2ZW50MicsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgdmFyIGVtaXR0ZXIyID0gbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKTtcbiAgICogICBlbWl0dGVyMi5hZGRMaXN0ZW5lcnMoZW1pdHRlcjEpO1xuICAgKiAgIGVtaXR0ZXIyLmVtaXQoJ2V2ZW50MScpOyAvLyBlbWl0dGVyMiBoYXMgZXZlbnQxXG4gICAqICAgZW1pdHRlcjIuZW1pdCgnZXZlbnQyJyk7IC8vIGVtaXR0ZXIyIGhhcyBldmVudDJcbiAgICovXG4gIGFkZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGlmIHBhcmFtZXRlciBpcyBhbiBTZXF1ZW50aWFsRXhlY3V0b3Igb2JqZWN0XG4gICAgaWYgKGxpc3RlbmVycy5fZXZlbnRzKSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuX2V2ZW50cztcblxuICAgIEFXUy51dGlsLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihldmVudCwgY2FsbGJhY2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2tzID0gW2NhbGxiYWNrc107XG4gICAgICBBV1MudXRpbC5hcnJheUVhY2goY2FsbGJhY2tzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBzZWxmLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgd2l0aCB7b259IGFuZCBzYXZlcyB0aGUgY2FsbGJhY2sgaGFuZGxlIGZ1bmN0aW9uXG4gICAqIGFzIGEgcHJvcGVydHkgb24gdGhlIGVtaXR0ZXIgb2JqZWN0IHVzaW5nIGEgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgcHJvcGVydHkgbmFtZSB0byBzZXQgb24gdGhpcyBvYmplY3QgY29udGFpbmluZ1xuICAgKiAgIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBoYW5kbGUgc28gdGhhdCB0aGUgbGlzdGVuZXIgY2FuIGJlIHJlbW92ZWQgaW5cbiAgICogICB0aGUgZnV0dXJlLlxuICAgKiBAcGFyYW0gKHNlZSBvbilcbiAgICogQHJldHVybiAoc2VlIG9uKVxuICAgKiBAZXhhbXBsZSBBZGRpbmcgYSBuYW1lZCBsaXN0ZW5lciBEQVRBX0NBTExCQUNLXG4gICAqICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7IGRvU29tZXRoaW5nKCk7IH07XG4gICAqICAgZW1pdHRlci5hZGROYW1lZExpc3RlbmVyKCdEQVRBX0NBTExCQUNLJywgJ2RhdGEnLCBsaXN0ZW5lcik7XG4gICAqXG4gICAqICAgLy8gdGhlIGZvbGxvd2luZyBwcmludHM6IHRydWVcbiAgICogICBjb25zb2xlLmxvZyhlbWl0dGVyLkRBVEFfQ0FMTEJBQ0sgPT0gbGlzdGVuZXIpO1xuICAgKi9cbiAgYWRkTmFtZWRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRMaXN0ZW5lcihuYW1lLCBldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpIHtcbiAgICB0aGlzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZE5hbWVkQXN5bmNMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRBc3luY0xpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCkge1xuICAgIGNhbGxiYWNrLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5hZGROYW1lZExpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgc2V0IG9mIG5hbWVkIGxpc3RlbmVycyB1c2luZ1xuICAgKiB7YWRkTmFtZWRMaXN0ZW5lcn0uIFRoZSBjYWxsYmFjayBjb250YWlucyBhIHBhcmFtZXRlclxuICAgKiB3aXRoIGEgaGFuZGxlIHRvIHRoZSBgYWRkTmFtZWRMaXN0ZW5lcmAgbWV0aG9kLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oYWRkKVxuICAgKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICAgKiAgIHRoZSBgYWRkYCBmdW5jdGlvbiB0byB0aGUgYmxvY2suIFRoaXMgc2ltcGxpZmllcyB0aGUgYWRkaXRpb24gb2ZcbiAgICogICBhIGxhcmdlIGdyb3VwIG9mIG5hbWVkIGxpc3RlbmVycy5cbiAgICogICBAcGFyYW0gYWRkIFtGdW5jdGlvbl0gdGhlIHthZGROYW1lZExpc3RlbmVyfSBmdW5jdGlvbiB0byBjYWxsXG4gICAqICAgICB3aGVuIHJlZ2lzdGVyaW5nIGxpc3RlbmVycy5cbiAgICogQGV4YW1wbGUgQWRkaW5nIGEgc2V0IG9mIG5hbWVkIGxpc3RlbmVyc1xuICAgKiAgIGVtaXR0ZXIuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAqICAgICBhZGQoJ0RBVEFfQ0FMTEJBQ0snLCAnZGF0YScsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgICBhZGQoJ09USEVSJywgJ290aGVyRXZlbnQnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgICAgYWRkKCdMQVNUJywgJ2xhc3RFdmVudCcsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gdGhlc2UgcHJvcGVydGllcyBhcmUgbm93IHNldDpcbiAgICogICBlbWl0dGVyLkRBVEFfQ0FMTEJBQ0s7XG4gICAqICAgZW1pdHRlci5PVEhFUjtcbiAgICogICBlbWl0dGVyLkxBU1Q7XG4gICAqL1xuICBhZGROYW1lZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTmFtZWRMaXN0ZW5lcnMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY2FsbGJhY2soXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5hZGROYW1lZExpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuYWRkTmFtZWRBc3luY0xpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qKlxuICoge29ufSBpcyB0aGUgcHJlZmVyZWQgbWV0aG9kLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IucHJvdG90eXBlLmFkZExpc3RlbmVyID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUub247XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvcjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBcGkgPSByZXF1aXJlKCcuL21vZGVsL2FwaScpO1xudmFyIHJlZ2lvbkNvbmZpZyA9IHJlcXVpcmUoJy4vcmVnaW9uX2NvbmZpZycpO1xuXG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgY2xpZW50Q291bnQgPSAwO1xudmFyIHJlZ2lvbl91dGlscyA9IHJlcXVpcmUoJy4vcmVnaW9uL3V0aWxzJyk7XG5cbi8qKlxuICogVGhlIHNlcnZpY2UgY2xhc3MgcmVwcmVzZW50aW5nIGFuIEFXUyBzZXJ2aWNlLlxuICpcbiAqIEBjbGFzc19hYnN0cmFjdCBUaGlzIGNsYXNzIGlzIGFuIGFic3RyYWN0IGNsYXNzLlxuICpcbiAqIEAhYXR0cmlidXRlIGFwaVZlcnNpb25zXG4gKiAgIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIHRoZSBsaXN0IG9mIEFQSSB2ZXJzaW9ucyBzdXBwb3J0ZWQgYnkgdGhpcyBzZXJ2aWNlLlxuICogICBAcmVhZG9ubHlcbiAqL1xuQVdTLlNlcnZpY2UgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJ2aWNlIG9iamVjdCB3aXRoIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTZXJ2aWNlKGNvbmZpZykge1xuICAgIGlmICghdGhpcy5sb2FkU2VydmljZUNsYXNzKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgJ1NlcnZpY2UgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGBuZXdcXCcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLnJlZ2lvbikge1xuICAgICAgICB2YXIgcmVnaW9uID0gY29uZmlnLnJlZ2lvbjtcbiAgICAgICAgaWYgKHJlZ2lvbl91dGlscy5pc0ZpcHNSZWdpb24ocmVnaW9uKSkge1xuICAgICAgICAgIGNvbmZpZy5yZWdpb24gPSByZWdpb25fdXRpbHMuZ2V0UmVhbFJlZ2lvbihyZWdpb24pO1xuICAgICAgICAgIGNvbmZpZy51c2VGaXBzRW5kcG9pbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpb25fdXRpbHMuaXNHbG9iYWxSZWdpb24ocmVnaW9uKSkge1xuICAgICAgICAgIGNvbmZpZy5yZWdpb24gPSByZWdpb25fdXRpbHMuZ2V0UmVhbFJlZ2lvbihyZWdpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy51c2VEdWFsc3RhY2sgPT09ICdib29sZWFuJ1xuICAgICAgICAmJiB0eXBlb2YgY29uZmlnLnVzZUR1YWxzdGFja0VuZHBvaW50ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgY29uZmlnLnVzZUR1YWxzdGFja0VuZHBvaW50ID0gY29uZmlnLnVzZUR1YWxzdGFjaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU2VydmljZUNsYXNzID0gdGhpcy5sb2FkU2VydmljZUNsYXNzKGNvbmZpZyB8fCB7fSk7XG4gICAgaWYgKFNlcnZpY2VDbGFzcykge1xuICAgICAgdmFyIG9yaWdpbmFsQ29uZmlnID0gQVdTLnV0aWwuY29weShjb25maWcpO1xuICAgICAgdmFyIHN2YyA9IG5ldyBTZXJ2aWNlQ2xhc3MoY29uZmlnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdmMsICdfb3JpZ2luYWxDb25maWcnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBvcmlnaW5hbENvbmZpZzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzdmMuX2NsaWVudElkID0gKytjbGllbnRDb3VudDtcbiAgICAgIHJldHVybiBzdmM7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoY29uZmlnKSB7XG4gICAgdmFyIHN2Y0NvbmZpZyA9IEFXUy5jb25maWdbdGhpcy5zZXJ2aWNlSWRlbnRpZmllcl07XG4gICAgdGhpcy5jb25maWcgPSBuZXcgQVdTLkNvbmZpZyhBV1MuY29uZmlnKTtcbiAgICBpZiAoc3ZjQ29uZmlnKSB0aGlzLmNvbmZpZy51cGRhdGUoc3ZjQ29uZmlnLCB0cnVlKTtcbiAgICBpZiAoY29uZmlnKSB0aGlzLmNvbmZpZy51cGRhdGUoY29uZmlnLCB0cnVlKTtcblxuICAgIHRoaXMudmFsaWRhdGVTZXJ2aWNlKCk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmRwb2ludCkgcmVnaW9uQ29uZmlnLmNvbmZpZ3VyZUVuZHBvaW50KHRoaXMpO1xuXG4gICAgdGhpcy5jb25maWcuZW5kcG9pbnQgPSB0aGlzLmVuZHBvaW50RnJvbVRlbXBsYXRlKHRoaXMuY29uZmlnLmVuZHBvaW50KTtcbiAgICB0aGlzLnNldEVuZHBvaW50KHRoaXMuY29uZmlnLmVuZHBvaW50KTtcbiAgICAvL2VuYWJsZSBhdHRhY2hpbmcgbGlzdGVuZXJzIHRvIHNlcnZpY2UgY2xpZW50XG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHRoaXMpO1xuICAgIEFXUy5TZXJ2aWNlLmFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzKHRoaXMpO1xuICAgIGlmICgodGhpcy5jb25maWcuY2xpZW50U2lkZU1vbml0b3JpbmcgfHwgQVdTLlNlcnZpY2UuX2NsaWVudFNpZGVNb25pdG9yaW5nKSAmJiB0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgdmFyIHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xuICAgICAgdGhpcy5hZGROYW1lZExpc3RlbmVyKCdQVUJMSVNIX0FQSV9DQUxMJywgJ2FwaUNhbGwnLCBmdW5jdGlvbiBQVUJMSVNIX0FQSV9DQUxMKGV2ZW50KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7cHVibGlzaGVyLmV2ZW50SGFuZGxlcihldmVudCk7fSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkTmFtZWRMaXN0ZW5lcignUFVCTElTSF9BUElfQVRURU1QVCcsICdhcGlDYWxsQXR0ZW1wdCcsIGZ1bmN0aW9uIFBVQkxJU0hfQVBJX0FUVEVNUFQoZXZlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtwdWJsaXNoZXIuZXZlbnRIYW5kbGVyKGV2ZW50KTt9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZVNlcnZpY2U6IGZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZSgpIHtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkU2VydmljZUNsYXNzOiBmdW5jdGlvbiBsb2FkU2VydmljZUNsYXNzKHNlcnZpY2VDb25maWcpIHtcbiAgICB2YXIgY29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICBpZiAoIUFXUy51dGlsLmlzRW1wdHkodGhpcy5hcGkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5hcGlDb25maWcpIHtcbiAgICAgIHJldHVybiBBV1MuU2VydmljZS5kZWZpbmVTZXJ2aWNlQXBpKHRoaXMuY29uc3RydWN0b3IsIGNvbmZpZy5hcGlDb25maWcpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBuZXcgQVdTLkNvbmZpZyhBV1MuY29uZmlnKTtcbiAgICAgIGNvbmZpZy51cGRhdGUoc2VydmljZUNvbmZpZywgdHJ1ZSk7XG4gICAgICB2YXIgdmVyc2lvbiA9IGNvbmZpZy5hcGlWZXJzaW9uc1t0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyXTtcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uIHx8IGNvbmZpZy5hcGlWZXJzaW9uO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0U2VydmljZUNsYXNzKHZlcnNpb24pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRMYXRlc3RTZXJ2aWNlQ2xhc3M6IGZ1bmN0aW9uIGdldExhdGVzdFNlcnZpY2VDbGFzcyh2ZXJzaW9uKSB7XG4gICAgdmVyc2lvbiA9IHRoaXMuZ2V0TGF0ZXN0U2VydmljZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXNbdmVyc2lvbl0gPT09IG51bGwpIHtcbiAgICAgIEFXUy5TZXJ2aWNlLmRlZmluZVNlcnZpY2VBcGkodGhpcy5jb25zdHJ1Y3RvciwgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXNbdmVyc2lvbl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGF0ZXN0U2VydmljZVZlcnNpb246IGZ1bmN0aW9uIGdldExhdGVzdFNlcnZpY2VWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMgfHwgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VydmljZXMgZGVmaW5lZCBvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSAnbGF0ZXN0JztcbiAgICB9IGVsc2UgaWYgKEFXUy51dGlsLmlzVHlwZSh2ZXJzaW9uLCBEYXRlKSkge1xuICAgICAgdmVyc2lvbiA9IEFXUy51dGlsLmRhdGUuaXNvODYwMSh2ZXJzaW9uKS5zcGxpdCgnVCcpWzBdO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkodGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcywgdmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcykuc29ydCgpO1xuICAgIHZhciBzZWxlY3RlZFZlcnNpb24gPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyB2ZXJzaW9ucyB0aGF0IGVuZCBpbiBcIipcIiBhcmUgbm90IGF2YWlsYWJsZSBvbiBkaXNrIGFuZCBjYW4gYmVcbiAgICAgIC8vIHNraXBwZWQsIHNvIGRvIG5vdCBjaG9vc2UgdGhlc2UgYXMgc2VsZWN0ZWRWZXJzaW9uc1xuICAgICAgaWYgKGtleXNbaV1ba2V5c1tpXS5sZW5ndGggLSAxXSAhPT0gJyonKSB7XG4gICAgICAgIHNlbGVjdGVkVmVyc2lvbiA9IGtleXNbaV07XG4gICAgICB9XG4gICAgICBpZiAoa2V5c1tpXS5zdWJzdHIoMCwgMTApIDw9IHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kICcgKyB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBBUEkgdG8gc2F0aXNmeSB2ZXJzaW9uIGNvbnN0cmFpbnQgYCcgKyB2ZXJzaW9uICsgJ1xcJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaToge30sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdFJldHJ5Q291bnQ6IDMsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3VzdG9taXplUmVxdWVzdHM6IGZ1bmN0aW9uIGN1c3RvbWl6ZVJlcXVlc3RzKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNhbGxiYWNrIHR5cGUgXFwnJyArIHR5cGVvZiBjYWxsYmFjayArICdcXCcgcHJvdmlkZWQgaW4gY3VzdG9taXplUmVxdWVzdHMnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxzIGFuIG9wZXJhdGlvbiBvbiBhIHNlcnZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRvIGNhbGwgb24gdGhlIHNlcnZpY2UuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2YgaW5wdXQgb3B0aW9ucyBmb3IgdGhlIG9wZXJhdGlvblxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgbWFrZVJlcXVlc3Q6IGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGlmICh0aGlzLmNvbmZpZy5wYXJhbXMpIHsgLy8gY29weSBvbmx5IHRvcGxldmVsIGJvdW5kIHBhcmFtc1xuICAgICAgdmFyIHJ1bGVzID0gdGhpcy5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dO1xuICAgICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcbiAgICAgICAgQVdTLnV0aWwuZWFjaCh0aGlzLmNvbmZpZy5wYXJhbXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAocnVsZXMuaW5wdXQubWVtYmVyc1trZXldKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZCB8fCBwYXJhbXNba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgQVdTLlJlcXVlc3QodGhpcywgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICAgIHRoaXMuYWRkQWxsUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KTtcbiAgICB0aGlzLmF0dGFjaE1vbml0b3JpbmdFbWl0dGVyKHJlcXVlc3QpO1xuICAgIGlmIChjYWxsYmFjaykgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbHMgYW4gb3BlcmF0aW9uIG9uIGEgc2VydmljZSB3aXRoIHRoZSBnaXZlbiBpbnB1dCBwYXJhbWV0ZXJzLCB3aXRob3V0XG4gICAqIGFueSBhdXRoZW50aWNhdGlvbiBkYXRhLiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIFwicHVibGljXCIgQVBJIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsIG9uIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIGlucHV0IG9wdGlvbnMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIG1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0OiBmdW5jdGlvbiBtYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMpLnRvVW5hdXRoZW50aWNhdGVkKCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrID8gcmVxdWVzdC5zZW5kKGNhbGxiYWNrKSA6IHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIGdpdmVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBbU3RyaW5nXSB0aGUgc3RhdGUgb24gdGhlIHNlcnZpY2UgdG8gd2FpdCBmb3JcbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBwYXJhbWV0ZXJzIHRvIHBhc3Mgd2l0aCBlYWNoIHJlcXVlc3RcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlciBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSB3YWl0ZXJcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlci5kZWxheSBbTnVtYmVyXSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHNcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlci5tYXhBdHRlbXB0cyBbTnVtYmVyXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVxdWVzdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzZW5kIHdoaWxlIHdhaXRpbmdcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIHdhaXRGb3I6IGZ1bmN0aW9uIHdhaXRGb3Ioc3RhdGUsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgd2FpdGVyID0gbmV3IEFXUy5SZXNvdXJjZVdhaXRlcih0aGlzLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHdhaXRlci53YWl0KHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZEFsbFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZEFsbFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIHZhciBsaXN0ID0gW0FXUy5ldmVudHMsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLCB0aGlzLnNlcnZpY2VJbnRlcmZhY2UoKSxcbiAgICAgICAgICAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZVBvc3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0pIHJlcXVlc3QuYWRkTGlzdGVuZXJzKGxpc3RbaV0pO1xuICAgIH1cblxuICAgIC8vIGRpc2FibGUgcGFyYW1ldGVyIHZhbGlkYXRpb25cbiAgICBpZiAoIXRoaXMuY29uZmlnLnBhcmFtVmFsaWRhdGlvbikge1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcubG9nZ2VyKSB7IC8vIGFkZCBsb2dnaW5nIGV2ZW50c1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcnMoQVdTLkV2ZW50TGlzdGVuZXJzLkxvZ2dlcik7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCk7XG4gICAgLy8gY2FsbCBwcm90b3R5cGUncyBjdXN0b21SZXF1ZXN0SGFuZGxlclxuICAgIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmN1c3RvbVJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgIH1cbiAgICAvLyBjYWxsIGluc3RhbmNlJ3MgY3VzdG9tUmVxdWVzdEhhbmRsZXJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdjdXN0b21SZXF1ZXN0SGFuZGxlcicpICYmIHR5cGVvZiB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgcmVjb3JkaW5nIG1ldHJpY3MgZm9yIGEgd2hvbGUgQVBJIGNhbGwuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGEgc3Vic2V0IG9mIGFwaSBjYWxsIG1ldHJpY3NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGlDYWxsRXZlbnQ6IGZ1bmN0aW9uIGFwaUNhbGxFdmVudChyZXF1ZXN0KSB7XG4gICAgdmFyIGFwaSA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIG1vbml0b3JpbmdFdmVudCA9IHtcbiAgICAgIFR5cGU6ICdBcGlDYWxsJyxcbiAgICAgIEFwaTogYXBpID8gYXBpLm5hbWUgOiByZXF1ZXN0Lm9wZXJhdGlvbixcbiAgICAgIFZlcnNpb246IDEsXG4gICAgICBTZXJ2aWNlOiByZXF1ZXN0LnNlcnZpY2UuYXBpLnNlcnZpY2VJZCB8fCByZXF1ZXN0LnNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4LFxuICAgICAgUmVnaW9uOiByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbixcbiAgICAgIE1heFJldHJpZXNFeGNlZWRlZDogMCxcbiAgICAgIFVzZXJBZ2VudDogcmVxdWVzdC5odHRwUmVxdWVzdC5nZXRVc2VyQWdlbnQoKSxcbiAgICB9O1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuRmluYWxIdHRwU3RhdHVzQ29kZSA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIGlmIChzdGF0dXNDb2RlID4gMjk5KSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlKSBtb25pdG9yaW5nRXZlbnQuRmluYWxBd3NFeGNlcHRpb24gPSBlcnJvci5jb2RlO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsQXdzRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lKSBtb25pdG9yaW5nRXZlbnQuRmluYWxTZGtFeGNlcHRpb24gPSBlcnJvci5jb2RlIHx8IGVycm9yLm5hbWU7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSBtb25pdG9yaW5nRXZlbnQuRmluYWxTZGtFeGNlcHRpb25NZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vbml0b3JpbmdFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgcmVjb3JkaW5nIG1ldHJpY3MgZm9yIGFuIEFQSSBjYWxsIGF0dGVtcHQuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGEgc3Vic2V0IG9mIGFwaSBjYWxsIGF0dGVtcHQgbWV0cmljc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaUF0dGVtcHRFdmVudDogZnVuY3Rpb24gYXBpQXR0ZW1wdEV2ZW50KHJlcXVlc3QpIHtcbiAgICB2YXIgYXBpID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgICB2YXIgbW9uaXRvcmluZ0V2ZW50ID0ge1xuICAgICAgVHlwZTogJ0FwaUNhbGxBdHRlbXB0JyxcbiAgICAgIEFwaTogYXBpID8gYXBpLm5hbWUgOiByZXF1ZXN0Lm9wZXJhdGlvbixcbiAgICAgIFZlcnNpb246IDEsXG4gICAgICBTZXJ2aWNlOiByZXF1ZXN0LnNlcnZpY2UuYXBpLnNlcnZpY2VJZCB8fCByZXF1ZXN0LnNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4LFxuICAgICAgRnFkbjogcmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0bmFtZSxcbiAgICAgIFVzZXJBZ2VudDogcmVxdWVzdC5odHRwUmVxdWVzdC5nZXRVc2VyQWdlbnQoKSxcbiAgICB9O1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuSHR0cFN0YXR1c0NvZGUgPSByZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXJlcXVlc3QuX3VuQXV0aGVudGljYXRlZCAmJlxuICAgICAgcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscyAmJlxuICAgICAgcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZFxuICAgICkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LkFjY2Vzc0tleSA9IHJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnMpIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gICAgaWYgKHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlNlc3Npb25Ub2tlbiA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tcmVxdWVzdGlkJ10pIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5YQW16blJlcXVlc3RJZCA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tcmVxdWVzdGlkJ107XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotcmVxdWVzdC1pZCddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuWEFtelJlcXVlc3RJZCA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1yZXF1ZXN0LWlkJ107XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotaWQtMiddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuWEFteklkMiA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1pZC0yJ107XG4gICAgfVxuICAgIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBtZXRyaWNzIG9mIGZhaWxlZCByZXF1ZXN0LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGF0dGVtcHRGYWlsRXZlbnQ6IGZ1bmN0aW9uIGF0dGVtcHRGYWlsRXZlbnQocmVxdWVzdCkge1xuICAgIHZhciBtb25pdG9yaW5nRXZlbnQgPSB0aGlzLmFwaUF0dGVtcHRFdmVudChyZXF1ZXN0KTtcbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA+IDI5OSApIHtcbiAgICAgIGlmIChlcnJvci5jb2RlKSBtb25pdG9yaW5nRXZlbnQuQXdzRXhjZXB0aW9uID0gZXJyb3IuY29kZTtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlKSBtb25pdG9yaW5nRXZlbnQuQXdzRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlcnJvci5jb2RlIHx8IGVycm9yLm5hbWUpIG1vbml0b3JpbmdFdmVudC5TZGtFeGNlcHRpb24gPSBlcnJvci5jb2RlIHx8IGVycm9yLm5hbWU7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LlNka0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdHRhY2ggbGlzdGVuZXJzIHRvIHJlcXVlc3Qgb2JqZWN0IHRvIGZldGNoIG1ldHJpY3Mgb2YgZWFjaCByZXF1ZXN0XG4gICAqIGFuZCBlbWl0IGRhdGEgb2JqZWN0IHRocm91Z2ggXFwnQXBpQ2FsbFxcJyBhbmQgXFwnQXBpQ2FsbEF0dGVtcHRcXCcgZXZlbnRzLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGF0dGFjaE1vbml0b3JpbmdFbWl0dGVyOiBmdW5jdGlvbiBhdHRhY2hNb25pdG9yaW5nRW1pdHRlcihyZXF1ZXN0KSB7XG4gICAgdmFyIGF0dGVtcHRUaW1lc3RhbXA7IC8vdGltZXN0YW1wIG1hcmtpbmcgdGhlIGJlZ2lubmluZyBvZiBhIHJlcXVlc3QgYXR0ZW1wdFxuICAgIHZhciBhdHRlbXB0U3RhcnRSZWFsVGltZTsgLy9TdGFydCB0aW1lIG9mIHJlcXVlc3QgYXR0ZW1wdC4gVXNlZCB0byBjYWxjdWxhdGluZyBhdHRlbXB0TGF0ZW5jeVxuICAgIHZhciBhdHRlbXB0TGF0ZW5jeTsgLy9sYXRlbmN5IGZyb20gcmVxdWVzdCBzZW50IG91dCB0byBodHRwIHJlc3BvbnNlIHJlYWNoaW5nIFNES1xuICAgIHZhciBjYWxsU3RhcnRSZWFsVGltZTsgLy9TdGFydCB0aW1lIG9mIEFQSSBjYWxsLiBVc2VkIHRvIGNhbGN1bGF0aW5nIEFQSSBjYWxsIGxhdGVuY3lcbiAgICB2YXIgYXR0ZW1wdENvdW50ID0gMDsgLy9yZXF1ZXN0LnJldHJ5Q291bnQgaXMgbm90IHJlbGlhYmxlIGhlcmVcbiAgICB2YXIgcmVnaW9uOyAvL3JlZ2lvbiBjYWNoZSByZWdpb24gZm9yIGVhY2ggYXR0ZW1wdCBzaW5jZSBpdCBjYW4gYmUgdXBkYXRlZCBpbiBwbGFzZSAoZS5nLiBzMylcbiAgICB2YXIgY2FsbFRpbWVzdGFtcDsgLy90aW1lc3RhbXAgd2hlbiB0aGUgcmVxdWVzdCBpcyBjcmVhdGVkXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhZGRUb0hlYWQgPSB0cnVlO1xuXG4gICAgcmVxdWVzdC5vbigndmFsaWRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsU3RhcnRSZWFsVGltZSA9IEFXUy51dGlsLnJlYWxDbG9jay5ub3coKTtcbiAgICAgIGNhbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH0sIGFkZFRvSGVhZCk7XG4gICAgcmVxdWVzdC5vbignc2lnbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF0dGVtcHRTdGFydFJlYWxUaW1lID0gQVdTLnV0aWwucmVhbENsb2NrLm5vdygpO1xuICAgICAgYXR0ZW1wdFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICByZWdpb24gPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbjtcbiAgICAgIGF0dGVtcHRDb3VudCsrO1xuICAgIH0sIGFkZFRvSGVhZCk7XG4gICAgcmVxdWVzdC5vbigndmFsaWRhdGVSZXNwb25zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgYXR0ZW1wdExhdGVuY3kgPSBNYXRoLnJvdW5kKEFXUy51dGlsLnJlYWxDbG9jay5ub3coKSAtIGF0dGVtcHRTdGFydFJlYWxUaW1lKTtcbiAgICB9KTtcbiAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0FQSV9DQUxMX0FUVEVNUFQnLCAnc3VjY2VzcycsIGZ1bmN0aW9uIEFQSV9DQUxMX0FUVEVNUFQoKSB7XG4gICAgICB2YXIgYXBpQXR0ZW1wdEV2ZW50ID0gc2VsZi5hcGlBdHRlbXB0RXZlbnQocmVxdWVzdCk7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuVGltZXN0YW1wID0gYXR0ZW1wdFRpbWVzdGFtcDtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5BdHRlbXB0TGF0ZW5jeSA9IGF0dGVtcHRMYXRlbmN5ID49IDAgPyBhdHRlbXB0TGF0ZW5jeSA6IDA7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuUmVnaW9uID0gcmVnaW9uO1xuICAgICAgc2VsZi5lbWl0KCdhcGlDYWxsQXR0ZW1wdCcsIFthcGlBdHRlbXB0RXZlbnRdKTtcbiAgICB9KTtcbiAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0FQSV9DQUxMX0FUVEVNUFRfUkVUUlknLCAncmV0cnknLCBmdW5jdGlvbiBBUElfQ0FMTF9BVFRFTVBUX1JFVFJZKCkge1xuICAgICAgdmFyIGFwaUF0dGVtcHRFdmVudCA9IHNlbGYuYXR0ZW1wdEZhaWxFdmVudChyZXF1ZXN0KTtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5UaW1lc3RhbXAgPSBhdHRlbXB0VGltZXN0YW1wO1xuICAgICAgLy9hdHRlbXB0TGF0ZW5jeSBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBmYWlsIGJlZm9yZSByZXNwb25zZVxuICAgICAgYXR0ZW1wdExhdGVuY3kgPSBhdHRlbXB0TGF0ZW5jeSB8fFxuICAgICAgICBNYXRoLnJvdW5kKEFXUy51dGlsLnJlYWxDbG9jay5ub3coKSAtIGF0dGVtcHRTdGFydFJlYWxUaW1lKTtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5BdHRlbXB0TGF0ZW5jeSA9IGF0dGVtcHRMYXRlbmN5ID49IDAgPyBhdHRlbXB0TGF0ZW5jeSA6IDA7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuUmVnaW9uID0gcmVnaW9uO1xuICAgICAgc2VsZi5lbWl0KCdhcGlDYWxsQXR0ZW1wdCcsIFthcGlBdHRlbXB0RXZlbnRdKTtcbiAgICB9KTtcbiAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0FQSV9DQUxMJywgJ2NvbXBsZXRlJywgZnVuY3Rpb24gQVBJX0NBTEwoKSB7XG4gICAgICB2YXIgYXBpQ2FsbEV2ZW50ID0gc2VsZi5hcGlDYWxsRXZlbnQocmVxdWVzdCk7XG4gICAgICBhcGlDYWxsRXZlbnQuQXR0ZW1wdENvdW50ID0gYXR0ZW1wdENvdW50O1xuICAgICAgaWYgKGFwaUNhbGxFdmVudC5BdHRlbXB0Q291bnQgPD0gMCkgcmV0dXJuO1xuICAgICAgYXBpQ2FsbEV2ZW50LlRpbWVzdGFtcCA9IGNhbGxUaW1lc3RhbXA7XG4gICAgICB2YXIgbGF0ZW5jeSA9IE1hdGgucm91bmQoQVdTLnV0aWwucmVhbENsb2NrLm5vdygpIC0gY2FsbFN0YXJ0UmVhbFRpbWUpO1xuICAgICAgYXBpQ2FsbEV2ZW50LkxhdGVuY3kgPSBsYXRlbmN5ID49IDAgPyBsYXRlbmN5IDogMDtcbiAgICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgIHJlc3BvbnNlLmVycm9yLnJldHJ5YWJsZSAmJlxuICAgICAgICB0eXBlb2YgcmVzcG9uc2UucmV0cnlDb3VudCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIHJlc3BvbnNlLm1heFJldHJpZXMgPT09ICdudW1iZXInICYmXG4gICAgICAgIChyZXNwb25zZS5yZXRyeUNvdW50ID49IHJlc3BvbnNlLm1heFJldHJpZXMpXG4gICAgICApIHtcbiAgICAgICAgYXBpQ2FsbEV2ZW50Lk1heFJldHJpZXNFeGNlZWRlZCA9IDE7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ2FwaUNhbGwnLCBbYXBpQ2FsbEV2ZW50XSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHNldHVwIGFueSBjdXN0b20gcmVxdWVzdCBsaXN0ZW5lcnMgZm9yIGVhY2hcbiAgICogbmV3IHJlcXVlc3QgdG8gdGhlIHNlcnZpY2UuXG4gICAqXG4gICAqIEBtZXRob2RfYWJzdHJhY3QgVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QuXG4gICAqL1xuICBzZXR1cFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KSB7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpZ25pbmcgbmFtZSBmb3IgYSBnaXZlbiByZXF1ZXN0XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmluZ05hbWU6IGZ1bmN0aW9uIGdldFNpZ25pbmdOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmFwaS5zaWduaW5nTmFtZSB8fCB0aGlzLmFwaS5lbmRwb2ludFByZWZpeDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2lnbmVyIGNsYXNzIGZvciBhIGdpdmVuIHJlcXVlc3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduZXJDbGFzczogZnVuY3Rpb24gZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCkge1xuICAgIHZhciB2ZXJzaW9uO1xuICAgIC8vIGdldCBvcGVyYXRpb24gYXV0aHR5cGUgaWYgcHJlc2VudFxuICAgIHZhciBvcGVyYXRpb24gPSBudWxsO1xuICAgIHZhciBhdXRodHlwZSA9ICcnO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9ucyB8fCB7fTtcbiAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIHx8IG51bGw7XG4gICAgICBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb247XG4gICAgfSBlbHNlIGlmIChhdXRodHlwZSA9PT0gJ3Y0JyB8fCBhdXRodHlwZSA9PT0gJ3Y0LXVuc2lnbmVkLWJvZHknKSB7XG4gICAgICB2ZXJzaW9uID0gJ3Y0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdmVyc2lvbiA9IHRoaXMuYXBpLnNpZ25hdHVyZVZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmdldFZlcnNpb24odmVyc2lvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2VydmljZUludGVyZmFjZTogZnVuY3Rpb24gc2VydmljZUludGVyZmFjZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdlYzInOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlF1ZXJ5O1xuICAgICAgY2FzZSAncXVlcnknOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlF1ZXJ5O1xuICAgICAgY2FzZSAnanNvbic6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuSnNvbjtcbiAgICAgIGNhc2UgJ3Jlc3QtanNvbic6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUmVzdEpzb247XG4gICAgICBjYXNlICdyZXN0LXhtbCc6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUmVzdFhtbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBgcHJvdG9jb2xcXCcgJyArXG4gICAgICAgIHRoaXMuYXBpLnByb3RvY29sICsgJyBpbiBBUEkgY29uZmlnJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZTogZnVuY3Rpb24gc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3ApIHtcbiAgICByZXR1cm4gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDMwMDtcbiAgfSxcblxuICAvKipcbiAgICogSG93IG1hbnkgdGltZXMgYSBmYWlsZWQgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZCBiZWZvcmUgZ2l2aW5nIHVwLlxuICAgKiB0aGUgZGVmYXVsdFJldHJ5Q291bnQgY2FuIGJlIG92ZXJyaWRlbiBieSBzZXJ2aWNlIGNsYXNzZXMuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbnVtUmV0cmllczogZnVuY3Rpb24gbnVtUmV0cmllcygpIHtcbiAgICBpZiAodGhpcy5jb25maWcubWF4UmV0cmllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4UmV0cmllcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJldHJ5Q291bnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5RGVsYXlzOiBmdW5jdGlvbiByZXRyeURlbGF5cyhyZXRyeUNvdW50LCBlcnIpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCB0aGlzLmNvbmZpZy5yZXRyeURlbGF5T3B0aW9ucywgZXJyKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXRyeWFibGVFcnJvcjogZnVuY3Rpb24gcmV0cnlhYmxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0RXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5uZXR3b3JraW5nRXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5leHBpcmVkQ3JlZGVudGlhbHNFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLnRocm90dGxlZEVycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGVycm9yLnN0YXR1c0NvZGUgPj0gNTAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbmV0d29ya2luZ0Vycm9yOiBmdW5jdGlvbiBuZXR3b3JraW5nRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSA9PT0gJ05ldHdvcmtpbmdFcnJvcic7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdGltZW91dEVycm9yOiBmdW5jdGlvbiB0aW1lb3V0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSA9PT0gJ1RpbWVvdXRFcnJvcic7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXhwaXJlZENyZWRlbnRpYWxzRXJyb3I6IGZ1bmN0aW9uIGV4cGlyZWRDcmVkZW50aWFsc0Vycm9yKGVycm9yKSB7XG4gICAgLy8gVE9ETyA6IHRoaXMgb25seSBoYW5kbGVzICpvbmUqIG9mIHRoZSBleHBpcmVkIGNyZWRlbnRpYWwgY29kZXNcbiAgICByZXR1cm4gKGVycm9yLmNvZGUgPT09ICdFeHBpcmVkVG9rZW5FeGNlcHRpb24nKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbG9ja1NrZXdFcnJvcjogZnVuY3Rpb24gY2xvY2tTa2V3RXJyb3IoZXJyb3IpIHtcbiAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgIGNhc2UgJ1JlcXVlc3RUaW1lVG9vU2tld2VkJzpcbiAgICAgIGNhc2UgJ1JlcXVlc3RFeHBpcmVkJzpcbiAgICAgIGNhc2UgJ0ludmFsaWRTaWduYXR1cmVFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnU2lnbmF0dXJlRG9lc05vdE1hdGNoJzpcbiAgICAgIGNhc2UgJ0F1dGhGYWlsdXJlJzpcbiAgICAgIGNhc2UgJ1JlcXVlc3RJblRoZUZ1dHVyZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTa2V3Q29ycmVjdGVkRGF0ZTogZnVuY3Rpb24gZ2V0U2tld0NvcnJlY3RlZERhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUubm93KCkgKyB0aGlzLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBwbHlDbG9ja09mZnNldDogZnVuY3Rpb24gYXBwbHlDbG9ja09mZnNldChuZXdTZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKG5ld1NlcnZlclRpbWUpIHtcbiAgICAgIHRoaXMuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0ID0gbmV3U2VydmVyVGltZSAtIERhdGUubm93KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzQ2xvY2tTa2V3ZWQ6IGZ1bmN0aW9uIGlzQ2xvY2tTa2V3ZWQobmV3U2VydmVyVGltZSkge1xuICAgIGlmIChuZXdTZXJ2ZXJUaW1lKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpLmdldFRpbWUoKSAtIG5ld1NlcnZlclRpbWUpID49IDMwMDAwMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdGhyb3R0bGVkRXJyb3I6IGZ1bmN0aW9uIHRocm90dGxlZEVycm9yKGVycm9yKSB7XG4gICAgLy8gdGhpcyBsb2dpYyB2YXJpZXMgYmV0d2VlbiBzZXJ2aWNlc1xuICAgIGlmIChlcnJvci5zdGF0dXNDb2RlID09PSA0MjkpIHJldHVybiB0cnVlO1xuICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgY2FzZSAnUHJvdmlzaW9uZWRUaHJvdWdocHV0RXhjZWVkZWRFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnVGhyb3R0bGluZyc6XG4gICAgICBjYXNlICdUaHJvdHRsaW5nRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1JlcXVlc3RMaW1pdEV4Y2VlZGVkJzpcbiAgICAgIGNhc2UgJ1JlcXVlc3RUaHJvdHRsZWQnOlxuICAgICAgY2FzZSAnUmVxdWVzdFRocm90dGxlZEV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdUb29NYW55UmVxdWVzdHNFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnVHJhbnNhY3Rpb25JblByb2dyZXNzRXhjZXB0aW9uJzogLy9keW5hbW9kYlxuICAgICAgY2FzZSAnRUMyVGhyb3R0bGVkRXhjZXB0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGVuZHBvaW50RnJvbVRlbXBsYXRlOiBmdW5jdGlvbiBlbmRwb2ludEZyb21UZW1wbGF0ZShlbmRwb2ludCkge1xuICAgIGlmICh0eXBlb2YgZW5kcG9pbnQgIT09ICdzdHJpbmcnKSByZXR1cm4gZW5kcG9pbnQ7XG5cbiAgICB2YXIgZSA9IGVuZHBvaW50O1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3NlcnZpY2VcXH0vZywgdGhpcy5hcGkuZW5kcG9pbnRQcmVmaXgpO1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3JlZ2lvblxcfS9nLCB0aGlzLmNvbmZpZy5yZWdpb24pO1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3NjaGVtZVxcfS9nLCB0aGlzLmNvbmZpZy5zc2xFbmFibGVkID8gJ2h0dHBzJyA6ICdodHRwJyk7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0RW5kcG9pbnQ6IGZ1bmN0aW9uIHNldEVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgdGhpcy5lbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnQsIHRoaXMuY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYWdpbmF0aW9uQ29uZmlnOiBmdW5jdGlvbiBwYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdGhyb3dFeGNlcHRpb24pIHtcbiAgICB2YXIgcGFnaW5hdG9yID0gdGhpcy5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dLnBhZ2luYXRvcjtcbiAgICBpZiAoIXBhZ2luYXRvcikge1xuICAgICAgaWYgKHRocm93RXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKGUsICdObyBwYWdpbmF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yICcgKyBvcGVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2luYXRvcjtcbiAgfVxufSk7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuU2VydmljZSwge1xuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBtZXRob2QgZm9yIGVhY2ggb3BlcmF0aW9uIGRlc2NyaWJlZCBpbiB0aGUgYXBpIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZpbmVNZXRob2RzOiBmdW5jdGlvbiBkZWZpbmVNZXRob2RzKHN2Yykge1xuICAgIEFXUy51dGlsLmVhY2goc3ZjLnByb3RvdHlwZS5hcGkub3BlcmF0aW9ucywgZnVuY3Rpb24gaXRlcmF0b3IobWV0aG9kKSB7XG4gICAgICBpZiAoc3ZjLnByb3RvdHlwZVttZXRob2RdKSByZXR1cm47XG4gICAgICB2YXIgb3BlcmF0aW9uID0gc3ZjLnByb3RvdHlwZS5hcGkub3BlcmF0aW9uc1ttZXRob2RdO1xuICAgICAgaWYgKG9wZXJhdGlvbi5hdXRodHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lcyBhIG5ldyBTZXJ2aWNlIGNsYXNzIHVzaW5nIGEgc2VydmljZSBpZGVudGlmaWVyIGFuZCBsaXN0IG9mIHZlcnNpb25zXG4gICAqIGluY2x1ZGluZyBhbiBvcHRpb25hbCBzZXQgb2YgZmVhdHVyZXMgKGZ1bmN0aW9ucykgdG8gYXBwbHkgdG8gdGhlIGNsYXNzXG4gICAqIHByb3RvdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2VJZGVudGlmaWVyIFtTdHJpbmddIHRoZSBpZGVudGlmaWVyIGZvciB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gdmVyc2lvbnMgW0FycmF5PFN0cmluZz5dIGEgbGlzdCBvZiB2ZXJzaW9ucyB0aGF0IHdvcmsgd2l0aCB0aGlzXG4gICAqICAgc2VydmljZVxuICAgKiBAcGFyYW0gZmVhdHVyZXMgW09iamVjdF0gYW4gb2JqZWN0IHRvIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlXG4gICAqIEByZXR1cm4gW0NsYXNzPFNlcnZpY2U+XSB0aGUgc2VydmljZSBjbGFzcyBkZWZpbmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAqL1xuICBkZWZpbmVTZXJ2aWNlOiBmdW5jdGlvbiBkZWZpbmVTZXJ2aWNlKHNlcnZpY2VJZGVudGlmaWVyLCB2ZXJzaW9ucywgZmVhdHVyZXMpIHtcbiAgICBBV1MuU2VydmljZS5fc2VydmljZU1hcFtzZXJ2aWNlSWRlbnRpZmllcl0gPSB0cnVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJzaW9ucykpIHtcbiAgICAgIGZlYXR1cmVzID0gdmVyc2lvbnM7XG4gICAgICB2ZXJzaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBzdmMgPSBpbmhlcml0KEFXUy5TZXJ2aWNlLCBmZWF0dXJlcyB8fCB7fSk7XG5cbiAgICBpZiAodHlwZW9mIHNlcnZpY2VJZGVudGlmaWVyID09PSAnc3RyaW5nJykge1xuICAgICAgQVdTLlNlcnZpY2UuYWRkVmVyc2lvbnMoc3ZjLCB2ZXJzaW9ucyk7XG5cbiAgICAgIHZhciBpZGVudGlmaWVyID0gc3ZjLnNlcnZpY2VJZGVudGlmaWVyIHx8IHNlcnZpY2VJZGVudGlmaWVyO1xuICAgICAgc3ZjLnNlcnZpY2VJZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB9IGVsc2UgeyAvLyBkZWZpbmVTZXJ2aWNlIGNhbGxlZCB3aXRoIGFuIEFQSVxuICAgICAgc3ZjLnByb3RvdHlwZS5hcGkgPSBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgIEFXUy5TZXJ2aWNlLmRlZmluZU1ldGhvZHMoc3ZjKTtcbiAgICB9XG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHRoaXMucHJvdG90eXBlKTtcbiAgICAvL3V0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcgaXMgb25seSBhdmFpbGFibGUgaW4gbm9kZVxuICAgIGlmICghdGhpcy5wcm90b3R5cGUucHVibGlzaGVyICYmIEFXUy51dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nKSB7XG4gICAgICB2YXIgUHVibGlzaGVyID0gQVdTLnV0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcuUHVibGlzaGVyO1xuICAgICAgdmFyIGNvbmZpZ1Byb3ZpZGVyID0gQVdTLnV0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcuY29uZmlnUHJvdmlkZXI7XG4gICAgICB2YXIgcHVibGlzaGVyQ29uZmlnID0gY29uZmlnUHJvdmlkZXIoKTtcbiAgICAgIHRoaXMucHJvdG90eXBlLnB1Ymxpc2hlciA9IG5ldyBQdWJsaXNoZXIocHVibGlzaGVyQ29uZmlnKTtcbiAgICAgIGlmIChwdWJsaXNoZXJDb25maWcuZW5hYmxlZCkge1xuICAgICAgICAvL2lmIGNzbSBpcyBlbmFibGVkIGluIGVudmlyb25tZW50LCBTREsgc2hvdWxkIHNlbmQgYWxsIG1ldHJpY3NcbiAgICAgICAgQVdTLlNlcnZpY2UuX2NsaWVudFNpZGVNb25pdG9yaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHN2Yy5wcm90b3R5cGUpO1xuICAgIEFXUy5TZXJ2aWNlLmFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzKHN2Yy5wcm90b3R5cGUpO1xuICAgIHJldHVybiBzdmM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkVmVyc2lvbnM6IGZ1bmN0aW9uIGFkZFZlcnNpb25zKHN2YywgdmVyc2lvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVyc2lvbnMpKSB2ZXJzaW9ucyA9IFt2ZXJzaW9uc107XG5cbiAgICBzdmMuc2VydmljZXMgPSBzdmMuc2VydmljZXMgfHwge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN2Yy5zZXJ2aWNlc1t2ZXJzaW9uc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdmMuc2VydmljZXNbdmVyc2lvbnNbaV1dID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdmMuYXBpVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhzdmMuc2VydmljZXMpLnNvcnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZpbmVTZXJ2aWNlQXBpOiBmdW5jdGlvbiBkZWZpbmVTZXJ2aWNlQXBpKHN1cGVyY2xhc3MsIHZlcnNpb24sIGFwaUNvbmZpZykge1xuICAgIHZhciBzdmMgPSBpbmhlcml0KHN1cGVyY2xhc3MsIHtcbiAgICAgIHNlcnZpY2VJZGVudGlmaWVyOiBzdXBlcmNsYXNzLnNlcnZpY2VJZGVudGlmaWVyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzZXRBcGkoYXBpKSB7XG4gICAgICBpZiAoYXBpLmlzQXBpKSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gYXBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ZjLnByb3RvdHlwZS5hcGkgPSBuZXcgQXBpKGFwaSwge1xuICAgICAgICAgIHNlcnZpY2VJZGVudGlmaWVyOiBzdXBlcmNsYXNzLnNlcnZpY2VJZGVudGlmaWVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChhcGlDb25maWcpIHtcbiAgICAgICAgc2V0QXBpKGFwaUNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEFwaShBV1MuYXBpTG9hZGVyKHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXIsIHZlcnNpb24pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoZXJyLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGZpbmQgQVBJIGNvbmZpZ3VyYXRpb24gJyArXG4gICAgICAgICAgICAgIHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXIgKyAnLScgKyB2ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN1cGVyY2xhc3Muc2VydmljZXMsIHZlcnNpb24pKSB7XG4gICAgICAgIHN1cGVyY2xhc3MuYXBpVmVyc2lvbnMgPSBzdXBlcmNsYXNzLmFwaVZlcnNpb25zLmNvbmNhdCh2ZXJzaW9uKS5zb3J0KCk7XG4gICAgICB9XG4gICAgICBzdXBlcmNsYXNzLnNlcnZpY2VzW3ZlcnNpb25dID0gc3ZjO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRBcGkodmVyc2lvbik7XG4gICAgfVxuXG4gICAgQVdTLlNlcnZpY2UuZGVmaW5lTWV0aG9kcyhzdmMpO1xuICAgIHJldHVybiBzdmM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFzU2VydmljZTogZnVuY3Rpb24oaWRlbnRpZmllcikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQVdTLlNlcnZpY2UuX3NlcnZpY2VNYXAsIGlkZW50aWZpZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0YWNoT24gYXR0YWNoIGRlZmF1bHQgbW9uaXRvcmluZyBsaXN0ZW5lcnMgdG8gb2JqZWN0XG4gICAqXG4gICAqIEVhY2ggbW9uaXRvcmluZyBldmVudCBzaG91bGQgYmUgZW1pdHRlZCBmcm9tIHNlcnZpY2UgY2xpZW50IHRvIHNlcnZpY2UgY29uc3RydWN0b3IgcHJvdG90eXBlIGFuZCB0aGVuXG4gICAqIHRvIGdsb2JhbCBzZXJ2aWNlIHByb3RvdHlwZSBsaWtlIGJ1YmJsaW5nIHVwLiBUaGVzZSBkZWZhdWx0IG1vbml0b3JpbmcgZXZlbnRzIGxpc3RlbmVyIHdpbGwgdHJhbnNmZXJcbiAgICogdGhlIG1vbml0b3JpbmcgZXZlbnRzIHRvIHRoZSB1cHBlciBsYXllci5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVyczogZnVuY3Rpb24gYWRkRGVmYXVsdE1vbml0b3JpbmdMaXN0ZW5lcnMoYXR0YWNoT24pIHtcbiAgICBhdHRhY2hPbi5hZGROYW1lZExpc3RlbmVyKCdNT05JVE9SX0VWRU5UU19CVUJCTEUnLCAnYXBpQ2FsbEF0dGVtcHQnLCBmdW5jdGlvbiBFVkVOVFNfQlVCQkxFKGV2ZW50KSB7XG4gICAgICB2YXIgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGF0dGFjaE9uKTtcbiAgICAgIGlmIChiYXNlQ2xhc3MuX2V2ZW50cykgYmFzZUNsYXNzLmVtaXQoJ2FwaUNhbGxBdHRlbXB0JywgW2V2ZW50XSk7XG4gICAgfSk7XG4gICAgYXR0YWNoT24uYWRkTmFtZWRMaXN0ZW5lcignQ0FMTF9FVkVOVFNfQlVCQkxFJywgJ2FwaUNhbGwnLCBmdW5jdGlvbiBDQUxMX0VWRU5UU19CVUJCTEUoZXZlbnQpIHtcbiAgICAgIHZhciBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXR0YWNoT24pO1xuICAgICAgaWYgKGJhc2VDbGFzcy5fZXZlbnRzKSBiYXNlQ2xhc3MuZW1pdCgnYXBpQ2FsbCcsIFtldmVudF0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9zZXJ2aWNlTWFwOiB7fVxufSk7XG5cbkFXUy51dGlsLm1peGluKEFXUy5TZXJ2aWNlLCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2VydmljZTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5yZXF1aXJlKCcuLi9keW5hbW9kYi9kb2N1bWVudF9jbGllbnQnKTtcblxuQVdTLnV0aWwudXBkYXRlKEFXUy5EeW5hbW9EQi5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0dXBSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBzZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmR5bmFtb0RiQ3JjMzIpIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgQVdTLkV2ZW50TGlzdGVuZXJzLkpzb24uRVhUUkFDVF9EQVRBKTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgdGhpcy5jaGVja0NyYzMyKTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgQVdTLkV2ZW50TGlzdGVuZXJzLkpzb24uRVhUUkFDVF9EQVRBKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tDcmMzMjogZnVuY3Rpb24gY2hlY2tDcmMzMihyZXNwKSB7XG4gICAgaWYgKCFyZXNwLmh0dHBSZXNwb25zZS5zdHJlYW1pbmcgJiYgIXJlc3AucmVxdWVzdC5zZXJ2aWNlLmNyYzMySXNWYWxpZChyZXNwKSkge1xuICAgICAgcmVzcC5kYXRhID0gbnVsbDtcbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnQ1JDMzJDaGVja0ZhaWxlZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdDUkMzMiBpbnRlZ3JpdHkgY2hlY2sgZmFpbGVkJyxcbiAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlc3AucmVxdWVzdC5oYWx0SGFuZGxlcnNPbkVycm9yKCk7XG4gICAgICB0aHJvdyAocmVzcC5lcnJvcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyYzMySXNWYWxpZDogZnVuY3Rpb24gY3JjMzJJc1ZhbGlkKHJlc3ApIHtcbiAgICB2YXIgY3JjID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotY3JjMzInXTtcbiAgICBpZiAoIWNyYykgcmV0dXJuIHRydWU7IC8vIG5vICh2YWxpZCkgQ1JDMzIgaGVhZGVyXG4gICAgcmV0dXJuIHBhcnNlSW50KGNyYywgMTApID09PSBBV1MudXRpbC5jcnlwdG8uY3JjMzIocmVzcC5odHRwUmVzcG9uc2UuYm9keSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdFJldHJ5Q291bnQ6IDEwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5RGVsYXlzOiBmdW5jdGlvbiByZXRyeURlbGF5cyhyZXRyeUNvdW50LCBlcnIpIHtcbiAgICB2YXIgcmV0cnlEZWxheU9wdGlvbnMgPSBBV1MudXRpbC5jb3B5KHRoaXMuY29uZmlnLnJldHJ5RGVsYXlPcHRpb25zKTtcblxuICAgIGlmICh0eXBlb2YgcmV0cnlEZWxheU9wdGlvbnMuYmFzZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0cnlEZWxheU9wdGlvbnMuYmFzZSA9IDUwOyAvLyBkZWZhdWx0IGZvciBkeW5hbW9kYlxuICAgIH1cbiAgICB2YXIgZGVsYXkgPSBBV1MudXRpbC5jYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIHJldHJ5RGVsYXlPcHRpb25zLCBlcnIpO1xuICAgIHJldHVybiBkZWxheTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcgPSByZXF1aXJlKCcuLi9jb25maWdfcmVnaW9uYWxfZW5kcG9pbnQnKTtcbnZhciBFTlZfUkVHSU9OQUxfRU5EUE9JTlRfRU5BQkxFRCA9ICdBV1NfU1RTX1JFR0lPTkFMX0VORFBPSU5UUyc7XG52YXIgQ09ORklHX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQgPSAnc3RzX3JlZ2lvbmFsX2VuZHBvaW50cyc7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuU1RTLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQG92ZXJsb2FkIGNyZWRlbnRpYWxzRnJvbShkYXRhLCBjcmVkZW50aWFscyA9IG51bGwpXG4gICAqICAgQ3JlYXRlcyBhIGNyZWRlbnRpYWxzIG9iamVjdCBmcm9tIFNUUyByZXNwb25zZSBkYXRhIGNvbnRhaW5pbmdcbiAgICogICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbi4gVXNlZnVsIGZvciBxdWlja2x5IHNldHRpbmcgQVdTIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiAgIEBub3RlIFRoaXMgaXMgYSBsb3ctbGV2ZWwgdXRpbGl0eSBmdW5jdGlvbi4gSWYgeW91IHdhbnQgdG8gbG9hZCB0ZW1wb3JhcnlcbiAgICogICAgIGNyZWRlbnRpYWxzIGludG8geW91ciBwcm9jZXNzIGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzIHRvIEFXUyByZXNvdXJjZXMsXG4gICAqICAgICB5b3Ugc2hvdWxkIHVzZSB7QVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzfSBpbnN0ZWFkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFttYXBdIGRhdGEgcmV0cmlldmVkIGZyb20gYSBjYWxsIHRvIHtnZXRGZWRlcmF0ZWRUb2tlbn0sXG4gICAqICAgICB7Z2V0U2Vzc2lvblRva2VufSwge2Fzc3VtZVJvbGV9LCBvciB7YXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uXG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIGFuIG9wdGlvbmFsIGNyZWRlbnRpYWxzIG9iamVjdCB0b1xuICAgKiAgICAgZmlsbCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9iamVjdC4gVXNlZnVsIHdoZW4gbW9kaWZ5aW5nIGFuXG4gICAqICAgICBleGlzdGluZyBjcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIHJlZnJlc2ggY2FsbC5cbiAgICogICBAcmV0dXJuIFtBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHNdIHRoZSBzZXQgb2YgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgICBsb2FkZWQgZnJvbSBhIHJhdyBTVFMgb3BlcmF0aW9uIHJlc3BvbnNlLlxuICAgKiAgIEBleGFtcGxlIFVzaW5nIGNyZWRlbnRpYWxzRnJvbSB0byBsb2FkIGdsb2JhbCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBzdHMgPSBuZXcgQVdTLlNUUygpO1xuICAgKiAgICAgc3RzLmdldFNlc3Npb25Ub2tlbihmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKFwiRXJyb3IgZ2V0dGluZyBjcmVkZW50aWFsc1wiKTtcbiAgICogICAgICAgZWxzZSB7XG4gICAqICAgICAgICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IHN0cy5jcmVkZW50aWFsc0Zyb20oZGF0YSk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKiAgIEBzZWUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzXG4gICAqL1xuICBjcmVkZW50aWFsc0Zyb206IGZ1bmN0aW9uIGNyZWRlbnRpYWxzRnJvbShkYXRhLCBjcmVkZW50aWFscykge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFjcmVkZW50aWFscykgY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkID0gZGF0YS5DcmVkZW50aWFscy5BY2Nlc3NLZXlJZDtcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLkNyZWRlbnRpYWxzLlNlY3JldEFjY2Vzc0tleTtcbiAgICBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVUaW1lID0gZGF0YS5DcmVkZW50aWFscy5FeHBpcmF0aW9uO1xuICAgIHJldHVybiBjcmVkZW50aWFscztcbiAgfSxcblxuICBhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5OiBmdW5jdGlvbiBhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eScsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGFzc3VtZVJvbGVXaXRoU0FNTDogZnVuY3Rpb24gYXNzdW1lUm9sZVdpdGhTQU1MKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnYXNzdW1lUm9sZVdpdGhTQU1MJywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0dXBSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBzZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy5vcHRJblJlZ2lvbmFsRW5kcG9pbnQsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG9wdEluUmVnaW9uYWxFbmRwb2ludDogZnVuY3Rpb24gb3B0SW5SZWdpb25hbEVuZHBvaW50KHJlcSkge1xuICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgdmFyIGNvbmZpZyA9IHNlcnZpY2UuY29uZmlnO1xuICAgIGNvbmZpZy5zdHNSZWdpb25hbEVuZHBvaW50cyA9IHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcoc2VydmljZS5fb3JpZ2luYWxDb25maWcsIHtcbiAgICAgIGVudjogRU5WX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQsXG4gICAgICBzaGFyZWRDb25maWc6IENPTkZJR19SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVELFxuICAgICAgY2xpZW50Q29uZmlnOiAnc3RzUmVnaW9uYWxFbmRwb2ludHMnXG4gICAgfSk7XG4gICAgaWYgKFxuICAgICAgY29uZmlnLnN0c1JlZ2lvbmFsRW5kcG9pbnRzID09PSAncmVnaW9uYWwnICYmXG4gICAgICBzZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnRcbiAgICApIHtcbiAgICAgIC8vY2xpZW50IHdpbGwgdGhyb3cgaWYgcmVnaW9uIGlzIG5vdCBzdXBwbGllZDsgcmVxdWVzdCB3aWxsIGJlIHNpZ25lZCB3aXRoIHNwZWNpZmllZCByZWdpb25cbiAgICAgIGlmICghY29uZmlnLnJlZ2lvbikge1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7Y29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgcmVnaW9uIGluIGNvbmZpZyd9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnNlcnRQb2ludCA9IGNvbmZpZy5lbmRwb2ludC5pbmRleE9mKCcuYW1hem9uYXdzLmNvbScpO1xuICAgICAgdmFyIHJlZ2lvbmFsRW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKDAsIGluc2VydFBvaW50KSArXG4gICAgICAgICcuJyArIGNvbmZpZy5yZWdpb24gKyBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKGluc2VydFBvaW50KTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChyZWdpb25hbEVuZHBvaW50KTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5yZWdpb24gPSBjb25maWcucmVnaW9uO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBJbmlMb2FkZXIgPSByZXF1aXJlKCcuL2luaS1sb2FkZXInKS5JbmlMb2FkZXI7XG4vKipcbiAqIFNpbmdsZXRvbiBvYmplY3QgdG8gbG9hZCBzcGVjaWZpZWQgY29uZmlnL2NyZWRlbnRpYWxzIGZpbGVzLlxuICogSXQgd2lsbCBjYWNoZSBhbGwgdGhlIGZpbGVzIGV2ZXIgbG9hZGVkO1xuICovXG5tb2R1bGUuZXhwb3J0cy5pbmlMb2FkZXIgPSBuZXcgSW5pTG9hZGVyKCk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIG9zID0gcmVxdWlyZSgnb3MnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBwYXJzZUZpbGUoZmlsZW5hbWUsIGlzQ29uZmlnKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBBV1MudXRpbC5pbmkucGFyc2UoQVdTLnV0aWwucmVhZEZpbGVTeW5jKGZpbGVuYW1lKSk7XG4gICAgdmFyIHRtcENvbnRlbnQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjb250ZW50KS5mb3JFYWNoKGZ1bmN0aW9uKHByb2ZpbGVOYW1lKSB7XG4gICAgICB2YXIgcHJvZmlsZUNvbnRlbnQgPSBjb250ZW50W3Byb2ZpbGVOYW1lXTtcbiAgICAgIHByb2ZpbGVOYW1lID0gaXNDb25maWcgPyBwcm9maWxlTmFtZS5yZXBsYWNlKC9ecHJvZmlsZVxccy8sICcnKSA6IHByb2ZpbGVOYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRtcENvbnRlbnQsIHByb2ZpbGVOYW1lLCB7XG4gICAgICAgIHZhbHVlOiBwcm9maWxlQ29udGVudCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRtcENvbnRlbnQ7XG59XG5cbi8qKlxuICogSW5pIGZpbGUgbG9hZGVyIGNsYXNzIHRoZSBzYW1lIGFzIHRoYXQgdXNlZCBpbiB0aGUgU0RLLiBJdCBsb2FkcyBhbmRcbiAqIHBhcnNlcyBjb25maWcgYW5kIGNyZWRlbnRpYWxzIGZpbGVzIGluIC5pbmkgZm9ybWF0IGFuZCBjYWNoZSB0aGUgY29udGVudFxuICogdG8gYXNzdXJlIGZpbGVzIGFyZSBvbmx5IHJlYWQgb25jZS5cbiAqIE5vdGUgdGhhdCBjYWxsaW5nIG9wZXJhdGlvbnMgb24gdGhlIGluc3RhbmNlIGluc3RhbnRpYXRlZCBmcm9tIHRoaXMgY2xhc3NcbiAqIHdvbid0IGFmZmVjdCB0aGUgYmVoYXZpb3Igb2YgU0RLIHNpbmNlIFNESyB1c2VzIGFuIGludGVybmFsIHNpbmdsZXRvbiBvZlxuICogdGhpcyBjbGFzcy5cbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5JbmlMb2FkZXIgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEluaUxvYWRlcigpIHtcbiAgICB0aGlzLnJlc29sdmVkUHJvZmlsZXMgPSB7fTtcbiAgfSxcblxuICAvKiogUmVtb3ZlIGFsbCBjYWNoZWQgZmlsZXMuIFVzZWQgYWZ0ZXIgY29uZmlnIGZpbGVzIGFyZSB1cGRhdGVkLiAqL1xuICBjbGVhckNhY2hlZEZpbGVzOiBmdW5jdGlvbiBjbGVhckNhY2hlZEZpbGVzKCkge1xuICAgIHRoaXMucmVzb2x2ZWRQcm9maWxlcyA9IHt9O1xuICB9LFxuXG4vKipcbiAqIExvYWQgY29uZmlndXJhdGlvbnMgZnJvbSBjb25maWcvY3JlZGVudGlhbHMgZmlsZXMgYW5kIGNhY2hlIHRoZW1cbiAqIGZvciBsYXRlciB1c2UuIElmIG5vIGZpbGUgaXMgc3BlY2lmaWVkIGl0IHdpbGwgdHJ5IHRvIGxvYWQgZGVmYXVsdFxuICogZmlsZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyBbbWFwXSBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIHRoZSBmaWxlXG4gKiBAb3B0aW9uIG9wdGlvbnMgZmlsZW5hbWUgW1N0cmluZ10gKCd+Ly5hd3MvY3JlZGVudGlhbHMnIG9yIGRlZmluZWQgYnlcbiAqICAgQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFIHByb2Nlc3MgZW52IHZhciBvciAnfi8uYXdzL2NvbmZpZycgaWZcbiAqICAgaXNDb25maWcgaXMgc2V0IHRvIHRydWUpXG4gKiAgIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgcmVhZC5cbiAqIEBvcHRpb24gb3B0aW9ucyBpc0NvbmZpZyBbQm9vbGVhbl0gKGZhbHNlKSBUcnVlIHRvIHJlYWQgY29uZmlnIGZpbGUuXG4gKiBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dIG9iamVjdCBjb250YWluaW5nIGNvbnRlbnRzIGZyb20gZmlsZSBpbiBrZXktdmFsdWVcbiAqICAgcGFpcnMuXG4gKi9cbiAgbG9hZEZyb206IGZ1bmN0aW9uIGxvYWRGcm9tKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgaXNDb25maWcgPSBvcHRpb25zLmlzQ29uZmlnID09PSB0cnVlO1xuICAgIHZhciBmaWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWUgfHwgdGhpcy5nZXREZWZhdWx0RmlsZVBhdGgoaXNDb25maWcpO1xuICAgIGlmICghdGhpcy5yZXNvbHZlZFByb2ZpbGVzW2ZpbGVuYW1lXSkge1xuICAgICAgdmFyIGZpbGVDb250ZW50ID0gdGhpcy5wYXJzZUZpbGUoZmlsZW5hbWUsIGlzQ29uZmlnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc29sdmVkUHJvZmlsZXMsIGZpbGVuYW1lLCB7IHZhbHVlOiBmaWxlQ29udGVudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQcm9maWxlc1tmaWxlbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFyc2VGaWxlOiBwYXJzZUZpbGUsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGVmYXVsdEZpbGVQYXRoOiBmdW5jdGlvbiBnZXREZWZhdWx0RmlsZVBhdGgoaXNDb25maWcpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKFxuICAgICAgdGhpcy5nZXRIb21lRGlyKCksXG4gICAgICAnLmF3cycsXG4gICAgICBpc0NvbmZpZyA/ICdjb25maWcnIDogJ2NyZWRlbnRpYWxzJ1xuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SG9tZURpcjogZnVuY3Rpb24gZ2V0SG9tZURpcigpIHtcbiAgICB2YXIgZW52ID0gcHJvY2Vzcy5lbnY7XG4gICAgdmFyIGhvbWUgPSBlbnYuSE9NRSB8fFxuICAgICAgZW52LlVTRVJQUk9GSUxFIHx8XG4gICAgICAoZW52LkhPTUVQQVRIID8gKChlbnYuSE9NRURSSVZFIHx8ICdDOi8nKSArIGVudi5IT01FUEFUSCkgOiBudWxsKTtcblxuICAgIGlmIChob21lKSB7XG4gICAgICByZXR1cm4gaG9tZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9zLmhvbWVkaXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcy5ob21lZGlyKCk7XG4gICAgfVxuXG4gICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIGNyZWRlbnRpYWxzLCBIT01FIHBhdGggbm90IHNldCcpXG4gICAgKTtcbiAgfVxufSk7XG5cbnZhciBJbmlMb2FkZXIgPSBBV1MuSW5pTG9hZGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW5pTG9hZGVyOiBJbmlMb2FkZXIsXG4gIHBhcnNlRmlsZTogcGFyc2VGaWxlLFxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBleHBpcmVzSGVhZGVyID0gJ3ByZXNpZ25lZC1leHBpcmVzJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2lnbmVkVXJsQnVpbGRlcihyZXF1ZXN0KSB7XG4gIHZhciBleHBpcmVzID0gcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdO1xuICB2YXIgc2lnbmVyQ2xhc3MgPSByZXF1ZXN0LnNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCk7XG5cbiAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snVXNlci1BZ2VudCddO1xuICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1Vc2VyLUFnZW50J107XG5cbiAgaWYgKHNpZ25lckNsYXNzID09PSBBV1MuU2lnbmVycy5WNCkge1xuICAgIGlmIChleHBpcmVzID4gNjA0ODAwKSB7IC8vIG9uZSB3ZWVrIGV4cGlyeSBpcyBpbnZhbGlkXG4gICAgICB2YXIgbWVzc2FnZSA9ICdQcmVzaWduaW5nIGRvZXMgbm90IHN1cHBvcnQgZXhwaXJ5IHRpbWUgZ3JlYXRlciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoYW4gYSB3ZWVrIHdpdGggU2lnVjQgc2lnbmluZy4nO1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRFeHBpcnlUaW1lJywgbWVzc2FnZTogbWVzc2FnZSwgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSA9IGV4cGlyZXM7XG4gIH0gZWxzZSBpZiAoc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlMzKSB7XG4gICAgdmFyIG5vdyA9IHJlcXVlc3Quc2VydmljZSA/IHJlcXVlc3Quc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpIDogQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCk7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gcGFyc2VJbnQoXG4gICAgICBBV1MudXRpbC5kYXRlLnVuaXhUaW1lc3RhbXAobm93KSArIGV4cGlyZXMsIDEwKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBtZXNzYWdlOiAnUHJlc2lnbmluZyBvbmx5IHN1cHBvcnRzIFMzIG9yIFNpZ1Y0IHNpZ25pbmcuJyxcbiAgICAgIGNvZGU6ICdVbnN1cHBvcnRlZFNpZ25lcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaWduZWRVcmxTaWduZXIocmVxdWVzdCkge1xuICB2YXIgZW5kcG9pbnQgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICB2YXIgcGFyc2VkVXJsID0gQVdTLnV0aWwudXJsUGFyc2UocmVxdWVzdC5odHRwUmVxdWVzdC5wYXRoKTtcbiAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XG5cbiAgaWYgKHBhcnNlZFVybC5zZWFyY2gpIHtcbiAgICBxdWVyeVBhcmFtcyA9IEFXUy51dGlsLnF1ZXJ5U3RyaW5nUGFyc2UocGFyc2VkVXJsLnNlYXJjaC5zdWJzdHIoMSkpO1xuICB9XG5cbiAgdmFyIGF1dGggPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXS5zcGxpdCgnICcpO1xuICBpZiAoYXV0aFswXSA9PT0gJ0FXUycpIHtcbiAgICBhdXRoID0gYXV0aFsxXS5zcGxpdCgnOicpO1xuICAgIHF1ZXJ5UGFyYW1zWydTaWduYXR1cmUnXSA9IGF1dGgucG9wKCk7XG4gICAgcXVlcnlQYXJhbXNbJ0FXU0FjY2Vzc0tleUlkJ10gPSBhdXRoLmpvaW4oJzonKTtcblxuICAgIEFXUy51dGlsLmVhY2gocmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PT0gZXhwaXJlc0hlYWRlcikga2V5ID0gJ0V4cGlyZXMnO1xuICAgICAgaWYgKGtleS5pbmRleE9mKCd4LWFtei1tZXRhLScpID09PSAwKSB7XG4gICAgICAgIC8vIERlbGV0ZSBleGlzdGluZywgcG90ZW50aWFsbHkgbm90IG5vcm1hbGl6ZWQga2V5XG4gICAgICAgIGRlbGV0ZSBxdWVyeVBhcmFtc1trZXldO1xuICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdO1xuICAgIGRlbGV0ZSBxdWVyeVBhcmFtc1snQXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBxdWVyeVBhcmFtc1snSG9zdCddO1xuICB9IGVsc2UgaWYgKGF1dGhbMF0gPT09ICdBV1M0LUhNQUMtU0hBMjU2JykgeyAvLyBTaWdWNCBzaWduaW5nXG4gICAgYXV0aC5zaGlmdCgpO1xuICAgIHZhciByZXN0ID0gYXV0aC5qb2luKCcgJyk7XG4gICAgdmFyIHNpZ25hdHVyZSA9IHJlc3QubWF0Y2goL1NpZ25hdHVyZT0oLio/KSg/Oix8XFxzfFxccj9cXG58JCkvKVsxXTtcbiAgICBxdWVyeVBhcmFtc1snWC1BbXotU2lnbmF0dXJlJ10gPSBzaWduYXR1cmU7XG4gICAgZGVsZXRlIHF1ZXJ5UGFyYW1zWydFeHBpcmVzJ107XG4gIH1cblxuICAvLyBidWlsZCBVUkxcbiAgZW5kcG9pbnQucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gIGVuZHBvaW50LnNlYXJjaCA9IEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXVlcnlQYXJhbXMpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5QcmVzaWduID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNpZ246IGZ1bmN0aW9uIHNpZ24ocmVxdWVzdCwgZXhwaXJlVGltZSwgY2FsbGJhY2spIHtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPSBleHBpcmVUaW1lIHx8IDM2MDA7XG4gICAgcmVxdWVzdC5vbignYnVpbGQnLCBzaWduZWRVcmxCdWlsZGVyKTtcbiAgICByZXF1ZXN0Lm9uKCdzaWduJywgc2lnbmVkVXJsU2lnbmVyKTtcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdhZnRlckJ1aWxkJyxcbiAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFVF9DT05URU5UX0xFTkdUSCk7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsXG4gICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX1NIQTI1Nik7XG5cbiAgICByZXF1ZXN0LmVtaXQoJ2JlZm9yZVByZXNpZ24nLCBbcmVxdWVzdF0pO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXF1ZXN0LmJ1aWxkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZS5lcnJvcikgY2FsbGJhY2sodGhpcy5yZXNwb25zZS5lcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEFXUy51dGlsLnVybEZvcm1hdChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmJ1aWxkKCk7XG4gICAgICBpZiAocmVxdWVzdC5yZXNwb25zZS5lcnJvcikgdGhyb3cgcmVxdWVzdC5yZXNwb25zZS5lcnJvcjtcbiAgICAgIHJldHVybiBBV1MudXRpbC51cmxGb3JtYXQocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5QcmVzaWduO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyID0gaW5oZXJpdCh7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXF1ZXN0U2lnbmVyKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB9LFxuXG4gIHNldFNlcnZpY2VDbGllbnRJZDogZnVuY3Rpb24gc2V0U2VydmljZUNsaWVudElkKGlkKSB7XG4gICAgdGhpcy5zZXJ2aWNlQ2xpZW50SWQgPSBpZDtcbiAgfSxcblxuICBnZXRTZXJ2aWNlQ2xpZW50SWQ6IGZ1bmN0aW9uIGdldFNlcnZpY2VDbGllbnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlQ2xpZW50SWQ7XG4gIH1cbn0pO1xuXG5BV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmdldFZlcnNpb24gPSBmdW5jdGlvbiBnZXRWZXJzaW9uKHZlcnNpb24pIHtcbiAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAndjInOiByZXR1cm4gQVdTLlNpZ25lcnMuVjI7XG4gICAgY2FzZSAndjMnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjM7XG4gICAgY2FzZSAnczN2NCc6IHJldHVybiBBV1MuU2lnbmVycy5WNDtcbiAgICBjYXNlICd2NCc6IHJldHVybiBBV1MuU2lnbmVycy5WNDtcbiAgICBjYXNlICdzMyc6IHJldHVybiBBV1MuU2lnbmVycy5TMztcbiAgICBjYXNlICd2M2h0dHBzJzogcmV0dXJuIEFXUy5TaWduZXJzLlYzSHR0cHM7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHNpZ25pbmcgdmVyc2lvbiAnICsgdmVyc2lvbik7XG59O1xuXG5yZXF1aXJlKCcuL3YyJyk7XG5yZXF1aXJlKCcuL3YzJyk7XG5yZXF1aXJlKCcuL3YzaHR0cHMnKTtcbnJlcXVpcmUoJy4vdjQnKTtcbnJlcXVpcmUoJy4vczMnKTtcbnJlcXVpcmUoJy4vcHJlc2lnbicpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuUzMgPSBpbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgLyoqXG4gICAqIFdoZW4gYnVpbGRpbmcgdGhlIHN0cmluZ1RvU2lnbiwgdGhlc2Ugc3ViIHJlc291cmNlIHBhcmFtcyBzaG91bGQgYmVcbiAgICogcGFydCBvZiB0aGUgY2Fub25pY2FsIHJlc291cmNlIHN0cmluZyB3aXRoIHRoZWlyIE5PTi1kZWNvZGVkIHZhbHVlc1xuICAgKi9cbiAgc3ViUmVzb3VyY2VzOiB7XG4gICAgJ2FjbCc6IDEsXG4gICAgJ2FjY2VsZXJhdGUnOiAxLFxuICAgICdhbmFseXRpY3MnOiAxLFxuICAgICdjb3JzJzogMSxcbiAgICAnbGlmZWN5Y2xlJzogMSxcbiAgICAnZGVsZXRlJzogMSxcbiAgICAnaW52ZW50b3J5JzogMSxcbiAgICAnbG9jYXRpb24nOiAxLFxuICAgICdsb2dnaW5nJzogMSxcbiAgICAnbWV0cmljcyc6IDEsXG4gICAgJ25vdGlmaWNhdGlvbic6IDEsXG4gICAgJ3BhcnROdW1iZXInOiAxLFxuICAgICdwb2xpY3knOiAxLFxuICAgICdyZXF1ZXN0UGF5bWVudCc6IDEsXG4gICAgJ3JlcGxpY2F0aW9uJzogMSxcbiAgICAncmVzdG9yZSc6IDEsXG4gICAgJ3RhZ2dpbmcnOiAxLFxuICAgICd0b3JyZW50JzogMSxcbiAgICAndXBsb2FkSWQnOiAxLFxuICAgICd1cGxvYWRzJzogMSxcbiAgICAndmVyc2lvbklkJzogMSxcbiAgICAndmVyc2lvbmluZyc6IDEsXG4gICAgJ3ZlcnNpb25zJzogMSxcbiAgICAnd2Vic2l0ZSc6IDFcbiAgfSxcblxuICAvLyB3aGVuIGJ1aWxkaW5nIHRoZSBzdHJpbmdUb1NpZ24sIHRoZXNlIHF1ZXJ5c3RyaW5nIHBhcmFtcyBzaG91bGQgYmVcbiAgLy8gcGFydCBvZiB0aGUgY2Fub25pY2FsIHJlc291cmNlIHN0cmluZyB3aXRoIHRoZWlyIE5PTi1lbmNvZGVkIHZhbHVlc1xuICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAncmVzcG9uc2UtY29udGVudC10eXBlJzogMSxcbiAgICAncmVzcG9uc2UtY29udGVudC1sYW5ndWFnZSc6IDEsXG4gICAgJ3Jlc3BvbnNlLWV4cGlyZXMnOiAxLFxuICAgICdyZXNwb25zZS1jYWNoZS1jb250cm9sJzogMSxcbiAgICAncmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbic6IDEsXG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtZW5jb2RpbmcnOiAxXG4gIH0sXG5cbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuICAgIGlmICghdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3ByZXNpZ25lZC1leHBpcmVzJ10pIHtcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBBV1MudXRpbC5kYXRlLnJmYzgyMihkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICAvLyBwcmVzaWduZWQgVVJMcyByZXF1aXJlIHRoaXMgaGVhZGVyIHRvIGJlIGxvd2VyY2FzZWRcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnNpZ24oY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCB0aGlzLnN0cmluZ1RvU2lnbigpKTtcbiAgICB2YXIgYXV0aCA9ICdBV1MgJyArIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJzonICsgc2lnbmF0dXJlO1xuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGF1dGg7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHIubWV0aG9kKTtcbiAgICBwYXJ0cy5wdXNoKHIuaGVhZGVyc1snQ29udGVudC1NRDUnXSB8fCAnJyk7XG4gICAgcGFydHMucHVzaChyLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8ICcnKTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIFwiRGF0ZVwiIGhlYWRlciwgYnV0IHdlIHVzZSBYLUFtei1EYXRlLlxuICAgIC8vIFRoZSBTMyBzaWduaW5nIG1lY2hhbmlzbSByZXF1aXJlcyB1cyB0byBwYXNzIGFuIGVtcHR5XG4gICAgLy8gc3RyaW5nIGZvciB0aGlzIERhdGUgaGVhZGVyIHJlZ2FyZGxlc3MuXG4gICAgcGFydHMucHVzaChyLmhlYWRlcnNbJ3ByZXNpZ25lZC1leHBpcmVzJ10gfHwgJycpO1xuXG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLmNhbm9uaWNhbGl6ZWRBbXpIZWFkZXJzKCk7XG4gICAgaWYgKGhlYWRlcnMpIHBhcnRzLnB1c2goaGVhZGVycyk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNhbm9uaWNhbGl6ZWRSZXNvdXJjZSgpKTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcblxuICB9LFxuXG4gIGNhbm9uaWNhbGl6ZWRBbXpIZWFkZXJzOiBmdW5jdGlvbiBjYW5vbmljYWxpemVkQW16SGVhZGVycygpIHtcblxuICAgIHZhciBhbXpIZWFkZXJzID0gW107XG5cbiAgICBBV1MudXRpbC5lYWNoKHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUubWF0Y2goL154LWFtei0vaSkpXG4gICAgICAgIGFtekhlYWRlcnMucHVzaChuYW1lKTtcbiAgICB9KTtcblxuICAgIGFtekhlYWRlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEudG9Mb3dlckNhc2UoKSA8IGIudG9Mb3dlckNhc2UoKSA/IC0xIDogMTtcbiAgICB9KTtcblxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIGFtekhlYWRlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwYXJ0cy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSArICc6JyArIFN0cmluZyh0aGlzLnJlcXVlc3QuaGVhZGVyc1tuYW1lXSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuXG4gIH0sXG5cbiAgY2Fub25pY2FsaXplZFJlc291cmNlOiBmdW5jdGlvbiBjYW5vbmljYWxpemVkUmVzb3VyY2UoKSB7XG5cbiAgICB2YXIgciA9IHRoaXMucmVxdWVzdDtcblxuICAgIHZhciBwYXJ0cyA9IHIucGF0aC5zcGxpdCgnPycpO1xuICAgIHZhciBwYXRoID0gcGFydHNbMF07XG4gICAgdmFyIHF1ZXJ5c3RyaW5nID0gcGFydHNbMV07XG5cbiAgICB2YXIgcmVzb3VyY2UgPSAnJztcblxuICAgIGlmIChyLnZpcnR1YWxIb3N0ZWRCdWNrZXQpXG4gICAgICByZXNvdXJjZSArPSAnLycgKyByLnZpcnR1YWxIb3N0ZWRCdWNrZXQ7XG5cbiAgICByZXNvdXJjZSArPSBwYXRoO1xuXG4gICAgaWYgKHF1ZXJ5c3RyaW5nKSB7XG5cbiAgICAgIC8vIGNvbGxlY3QgYSBsaXN0IG9mIHN1YiByZXNvdXJjZXMgYW5kIHF1ZXJ5IHBhcmFtcyB0aGF0IG5lZWQgdG8gYmUgc2lnbmVkXG4gICAgICB2YXIgcmVzb3VyY2VzID0gW107XG5cbiAgICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIHF1ZXJ5c3RyaW5nLnNwbGl0KCcmJyksIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcmFtLnNwbGl0KCc9JylbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtLnNwbGl0KCc9JylbMV07XG4gICAgICAgIGlmICh0aGlzLnN1YlJlc291cmNlc1tuYW1lXSB8fCB0aGlzLnJlc3BvbnNlSGVhZGVyc1tuYW1lXSkge1xuICAgICAgICAgIHZhciBzdWJyZXNvdXJjZSA9IHsgbmFtZTogbmFtZSB9O1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJSZXNvdXJjZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgc3VicmVzb3VyY2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YnJlc291cmNlLnZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb3VyY2VzLnB1c2goc3VicmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVzb3VyY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubmFtZSA8IGIubmFtZSA/IC0xIDogMTsgfSk7XG5cbiAgICAgIGlmIChyZXNvdXJjZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgcXVlcnlzdHJpbmcgPSBbXTtcbiAgICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKHJlc291cmNlcywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIGlmIChyZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnlzdHJpbmcucHVzaChyZXMubmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnB1c2gocmVzLm5hbWUgKyAnPScgKyByZXMudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzb3VyY2UgKz0gJz8nICsgcXVlcnlzdHJpbmcuam9pbignJicpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc291cmNlO1xuXG4gIH0sXG5cbiAgc2lnbjogZnVuY3Rpb24gc2lnbihzZWNyZXQsIHN0cmluZykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhzZWNyZXQsIHN0cmluZywgJ2Jhc2U2NCcsICdzaGExJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlMzO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjIgPSBpbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuXG4gICAgaWYgKCFkYXRlKSBkYXRlID0gQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCk7XG5cbiAgICB2YXIgciA9IHRoaXMucmVxdWVzdDtcblxuICAgIHIucGFyYW1zLlRpbWVzdGFtcCA9IEFXUy51dGlsLmRhdGUuaXNvODYwMShkYXRlKTtcbiAgICByLnBhcmFtcy5TaWduYXR1cmVWZXJzaW9uID0gJzInO1xuICAgIHIucGFyYW1zLlNpZ25hdHVyZU1ldGhvZCA9ICdIbWFjU0hBMjU2JztcbiAgICByLnBhcmFtcy5BV1NBY2Nlc3NLZXlJZCA9IGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkO1xuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgci5wYXJhbXMuU2VjdXJpdHlUb2tlbiA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICBkZWxldGUgci5wYXJhbXMuU2lnbmF0dXJlOyAvLyBkZWxldGUgb2xkIFNpZ25hdHVyZSBmb3IgcmUtc2lnbmluZ1xuICAgIHIucGFyYW1zLlNpZ25hdHVyZSA9IHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzKTtcblxuICAgIHIuYm9keSA9IEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcoci5wYXJhbXMpO1xuICAgIHIuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IHIuYm9keS5sZW5ndGg7XG4gIH0sXG5cbiAgc2lnbmF0dXJlOiBmdW5jdGlvbiBzaWduYXR1cmUoY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCB0aGlzLnN0cmluZ1RvU2lnbigpLCAnYmFzZTY0Jyk7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QubWV0aG9kKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5lbmRwb2ludC5ob3N0LnRvTG93ZXJDYXNlKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0LnBhdGhuYW1lKCkpO1xuICAgIHBhcnRzLnB1c2goQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyh0aGlzLnJlcXVlc3QucGFyYW1zKSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlYyO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjMgPSBpbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuXG4gICAgdmFyIGRhdGV0aW1lID0gQVdTLnV0aWwuZGF0ZS5yZmM4MjIoZGF0ZSk7XG5cbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddID0gZGF0ZXRpbWU7XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXpuLUF1dGhvcml6YXRpb24nXSA9XG4gICAgICB0aGlzLmF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGV0aW1lKTtcblxuICB9LFxuXG4gIGF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gJ0FXUzMgJyArXG4gICAgICAnQVdTQWNjZXNzS2V5SWQ9JyArIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJywnICtcbiAgICAgICdBbGdvcml0aG09SG1hY1NIQTI1NiwnICtcbiAgICAgICdTaWduZWRIZWFkZXJzPScgKyB0aGlzLnNpZ25lZEhlYWRlcnMoKSArICcsJyArXG4gICAgICAnU2lnbmF0dXJlPScgKyB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscyk7XG4gIH0sXG5cbiAgc2lnbmVkSGVhZGVyczogZnVuY3Rpb24gc2lnbmVkSGVhZGVycygpIHtcbiAgICB2YXIgaGVhZGVycyA9IFtdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaCh0aGlzLmhlYWRlcnNUb1NpZ24oKSwgZnVuY3Rpb24gaXRlcmF0b3IoaCkge1xuICAgICAgaGVhZGVycy5wdXNoKGgudG9Mb3dlckNhc2UoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnMuc29ydCgpLmpvaW4oJzsnKTtcbiAgfSxcblxuICBjYW5vbmljYWxIZWFkZXJzOiBmdW5jdGlvbiBjYW5vbmljYWxIZWFkZXJzKCkge1xuICAgIHZhciBoZWFkZXJzID0gdGhpcy5yZXF1ZXN0LmhlYWRlcnM7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoKHRoaXMuaGVhZGVyc1RvU2lnbigpLCBmdW5jdGlvbiBpdGVyYXRvcihoKSB7XG4gICAgICBwYXJ0cy5wdXNoKGgudG9Mb3dlckNhc2UoKS50cmltKCkgKyAnOicgKyBTdHJpbmcoaGVhZGVyc1toXSkudHJpbSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHMuc29ydCgpLmpvaW4oJ1xcbicpICsgJ1xcbic7XG4gIH0sXG5cbiAgaGVhZGVyc1RvU2lnbjogZnVuY3Rpb24gaGVhZGVyc1RvU2lnbigpIHtcbiAgICB2YXIgaGVhZGVycyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2godGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIGl0ZXJhdG9yKGspIHtcbiAgICAgIGlmIChrID09PSAnSG9zdCcgfHwgayA9PT0gJ0NvbnRlbnQtRW5jb2RpbmcnIHx8IGsubWF0Y2goL15YLUFtei9pKSkge1xuICAgICAgICBoZWFkZXJzLnB1c2goayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sXG5cbiAgc2lnbmF0dXJlOiBmdW5jdGlvbiBzaWduYXR1cmUoY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCB0aGlzLnN0cmluZ1RvU2lnbigpLCAnYmFzZTY0Jyk7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QubWV0aG9kKTtcbiAgICBwYXJ0cy5wdXNoKCcvJyk7XG4gICAgcGFydHMucHVzaCgnJyk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNhbm9uaWNhbEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QuYm9keSk7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5zaGEyNTYocGFydHMuam9pbignXFxuJykpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlYzO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxucmVxdWlyZSgnLi92MycpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WM0h0dHBzID0gaW5oZXJpdChBV1MuU2lnbmVycy5WMywge1xuICBhdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuICdBV1MzLUhUVFBTICcgK1xuICAgICAgJ0FXU0FjY2Vzc0tleUlkPScgKyBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcsJyArXG4gICAgICAnQWxnb3JpdGhtPUhtYWNTSEEyNTYsJyArXG4gICAgICAnU2lnbmF0dXJlPScgKyB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscyk7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ107XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlYzSHR0cHM7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHY0Q3JlZGVudGlhbHMgPSByZXF1aXJlKCcuL3Y0X2NyZWRlbnRpYWxzJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBleHBpcmVzSGVhZGVyID0gJ3ByZXNpZ25lZC1leHBpcmVzJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjQgPSBpbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFY0KHJlcXVlc3QsIHNlcnZpY2VOYW1lLCBvcHRpb25zKSB7XG4gICAgQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5jYWxsKHRoaXMsIHJlcXVlc3QpO1xuICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnNpZ25hdHVyZUNhY2hlID0gdHlwZW9mIG9wdGlvbnMuc2lnbmF0dXJlQ2FjaGUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2lnbmF0dXJlQ2FjaGUgOiB0cnVlO1xuICAgIHRoaXMub3BlcmF0aW9uID0gb3B0aW9ucy5vcGVyYXRpb247XG4gICAgdGhpcy5zaWduYXR1cmVWZXJzaW9uID0gb3B0aW9ucy5zaWduYXR1cmVWZXJzaW9uO1xuICB9LFxuXG4gIGFsZ29yaXRobTogJ0FXUzQtSE1BQy1TSEEyNTYnLFxuXG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcbiAgICB2YXIgZGF0ZXRpbWUgPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEoZGF0ZSkucmVwbGFjZSgvWzpcXC1dfFxcLlxcZHszfS9nLCAnJyk7XG5cbiAgICBpZiAodGhpcy5pc1ByZXNpZ25lZCgpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZvclByZXNpZ25lZChjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEhlYWRlcnMoY3JlZGVudGlhbHMsIGRhdGV0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID1cbiAgICAgIHRoaXMuYXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuICB9LFxuXG4gIGFkZEhlYWRlcnM6IGZ1bmN0aW9uIGFkZEhlYWRlcnMoY3JlZGVudGlhbHMsIGRhdGV0aW1lKSB7XG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXSA9IGRhdGV0aW1lO1xuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVGb3JQcmVzaWduZWQ6IGZ1bmN0aW9uIHVwZGF0ZUZvclByZXNpZ25lZChjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB2YXIgY3JlZFN0cmluZyA9IHRoaXMuY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSk7XG4gICAgdmFyIHFzID0ge1xuICAgICAgJ1gtQW16LURhdGUnOiBkYXRldGltZSxcbiAgICAgICdYLUFtei1BbGdvcml0aG0nOiB0aGlzLmFsZ29yaXRobSxcbiAgICAgICdYLUFtei1DcmVkZW50aWFsJzogY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyBjcmVkU3RyaW5nLFxuICAgICAgJ1gtQW16LUV4cGlyZXMnOiB0aGlzLnJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSxcbiAgICAgICdYLUFtei1TaWduZWRIZWFkZXJzJzogdGhpcy5zaWduZWRIZWFkZXJzKClcbiAgICB9O1xuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgcXNbJ1gtQW16LVNlY3VyaXR5LVRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkge1xuICAgICAgcXNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTUQ1J10pIHtcbiAgICAgIHFzWydDb250ZW50LU1ENSddID0gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTUQ1J107XG4gICAgfVxuICAgIGlmICh0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ2FjaGUtQ29udHJvbCddKSB7XG4gICAgICBxc1snQ2FjaGUtQ29udHJvbCddID0gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHRvIHB1bGwgaW4gYW55IG90aGVyIFgtQW16LSogaGVhZGVyc1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PT0gZXhwaXJlc0hlYWRlcikgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNTaWduYWJsZUhlYWRlcihrZXkpKSB7XG4gICAgICAgIHZhciBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBNZXRhZGF0YSBzaG91bGQgYmUgbm9ybWFsaXplZFxuICAgICAgICBpZiAobG93ZXJLZXkuaW5kZXhPZigneC1hbXotbWV0YS0nKSA9PT0gMCkge1xuICAgICAgICAgIHFzW2xvd2VyS2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGxvd2VyS2V5LmluZGV4T2YoJ3gtYW16LScpID09PSAwKSB7XG4gICAgICAgICAgcXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgc2VwID0gdGhpcy5yZXF1ZXN0LnBhdGguaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPyc7XG4gICAgdGhpcy5yZXF1ZXN0LnBhdGggKz0gc2VwICsgQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhxcyk7XG4gIH0sXG5cbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgY3JlZFN0cmluZyA9IHRoaXMuY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmFsZ29yaXRobSArICcgQ3JlZGVudGlhbD0nICtcbiAgICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJy8nICsgY3JlZFN0cmluZyk7XG4gICAgcGFydHMucHVzaCgnU2lnbmVkSGVhZGVycz0nICsgdGhpcy5zaWduZWRIZWFkZXJzKCkpO1xuICAgIHBhcnRzLnB1c2goJ1NpZ25hdHVyZT0nICsgdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMsIGRhdGV0aW1lKSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJywgJyk7XG4gIH0sXG5cbiAgc2lnbmF0dXJlOiBmdW5jdGlvbiBzaWduYXR1cmUoY3JlZGVudGlhbHMsIGRhdGV0aW1lKSB7XG4gICAgdmFyIHNpZ25pbmdLZXkgPSB2NENyZWRlbnRpYWxzLmdldFNpZ25pbmdLZXkoXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGRhdGV0aW1lLnN1YnN0cigwLCA4KSxcbiAgICAgIHRoaXMucmVxdWVzdC5yZWdpb24sXG4gICAgICB0aGlzLnNlcnZpY2VOYW1lLFxuICAgICAgdGhpcy5zaWduYXR1cmVDYWNoZVxuICAgICk7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKHNpZ25pbmdLZXksIHRoaXMuc3RyaW5nVG9TaWduKGRhdGV0aW1lKSwgJ2hleCcpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKGRhdGV0aW1lKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgcGFydHMucHVzaCgnQVdTNC1ITUFDLVNIQTI1NicpO1xuICAgIHBhcnRzLnB1c2goZGF0ZXRpbWUpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmhleEVuY29kZWRIYXNoKHRoaXMuY2Fub25pY2FsU3RyaW5nKCkpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsU3RyaW5nOiBmdW5jdGlvbiBjYW5vbmljYWxTdHJpbmcoKSB7XG4gICAgdmFyIHBhcnRzID0gW10sIHBhdGhuYW1lID0gdGhpcy5yZXF1ZXN0LnBhdGhuYW1lKCk7XG4gICAgaWYgKHRoaXMuc2VydmljZU5hbWUgIT09ICdzMycgJiYgdGhpcy5zaWduYXR1cmVWZXJzaW9uICE9PSAnczN2NCcpIHBhdGhuYW1lID0gQVdTLnV0aWwudXJpRXNjYXBlUGF0aChwYXRobmFtZSk7XG5cbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2gocGF0aG5hbWUpO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0LnNlYXJjaCgpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY2Fub25pY2FsSGVhZGVycygpICsgJ1xcbicpO1xuICAgIHBhcnRzLnB1c2godGhpcy5zaWduZWRIZWFkZXJzKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5oZXhFbmNvZGVkQm9keUhhc2goKSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGNhbm9uaWNhbEhlYWRlcnM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlcnMoKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChrZXksIGl0ZW0pIHtcbiAgICAgIGhlYWRlcnMucHVzaChba2V5LCBpdGVtXSk7XG4gICAgfSk7XG4gICAgaGVhZGVycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYVswXS50b0xvd2VyQ2FzZSgpIDwgYlswXS50b0xvd2VyQ2FzZSgpID8gLTEgOiAxO1xuICAgIH0pO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIGhlYWRlcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIga2V5ID0gaXRlbVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuaXNTaWduYWJsZUhlYWRlcihrZXkpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1bMV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignSGVhZGVyICcgKyBrZXkgKyAnIGNvbnRhaW5zIGludmFsaWQgdmFsdWUnKSwge1xuICAgICAgICAgICAgY29kZTogJ0ludmFsaWRIZWFkZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChrZXkgKyAnOicgK1xuICAgICAgICAgIHRoaXMuY2Fub25pY2FsSGVhZGVyVmFsdWVzKHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsSGVhZGVyVmFsdWVzOiBmdW5jdGlvbiBjYW5vbmljYWxIZWFkZXJWYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICB9LFxuXG4gIHNpZ25lZEhlYWRlcnM6IGZ1bmN0aW9uIHNpZ25lZEhlYWRlcnMoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuaXNTaWduYWJsZUhlYWRlcihrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cy5zb3J0KCkuam9pbignOycpO1xuICB9LFxuXG4gIGNyZWRlbnRpYWxTdHJpbmc6IGZ1bmN0aW9uIGNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpIHtcbiAgICByZXR1cm4gdjRDcmVkZW50aWFscy5jcmVhdGVTY29wZShcbiAgICAgIGRhdGV0aW1lLnN1YnN0cigwLCA4KSxcbiAgICAgIHRoaXMucmVxdWVzdC5yZWdpb24sXG4gICAgICB0aGlzLnNlcnZpY2VOYW1lXG4gICAgKTtcbiAgfSxcblxuICBoZXhFbmNvZGVkSGFzaDogZnVuY3Rpb24gaGFzaChzdHJpbmcpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLnNoYTI1NihzdHJpbmcsICdoZXgnKTtcbiAgfSxcblxuICBoZXhFbmNvZGVkQm9keUhhc2g6IGZ1bmN0aW9uIGhleEVuY29kZWRCb2R5SGFzaCgpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdDtcbiAgICBpZiAodGhpcy5pc1ByZXNpZ25lZCgpICYmIChbJ3MzJywgJ3MzLW9iamVjdC1sYW1iZGEnXS5pbmRleE9mKHRoaXMuc2VydmljZU5hbWUpID4gLTEpICYmICFyZXF1ZXN0LmJvZHkpIHtcbiAgICAgIHJldHVybiAnVU5TSUdORUQtUEFZTE9BRCc7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10pIHtcbiAgICAgIHJldHVybiByZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhleEVuY29kZWRIYXNoKHRoaXMucmVxdWVzdC5ib2R5IHx8ICcnKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5zaWduYWJsZUhlYWRlcnM6IFtcbiAgICAnYXV0aG9yaXphdGlvbicsXG4gICAgJ2NvbnRlbnQtdHlwZScsXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgICAndXNlci1hZ2VudCcsXG4gICAgZXhwaXJlc0hlYWRlcixcbiAgICAnZXhwZWN0JyxcbiAgICAneC1hbXpuLXRyYWNlLWlkJ1xuICBdLFxuXG4gIGlzU2lnbmFibGVIZWFkZXI6IGZ1bmN0aW9uIGlzU2lnbmFibGVIZWFkZXIoa2V5KSB7XG4gICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3gtYW16LScpID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25hYmxlSGVhZGVycy5pbmRleE9mKGtleSkgPCAwO1xuICB9LFxuXG4gIGlzUHJlc2lnbmVkOiBmdW5jdGlvbiBpc1ByZXNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPyB0cnVlIDogZmFsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjQ7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgY2FjaGVkU2VjcmV0ID0ge307XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBjYWNoZVF1ZXVlID0gW107XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBtYXhDYWNoZUVudHJpZXMgPSA1MDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIHY0SWRlbnRpZmllciA9ICdhd3M0X3JlcXVlc3QnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBbU3RyaW5nXVxuICAgKiBAcGFyYW0gcmVnaW9uIFtTdHJpbmddXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBbU3RyaW5nXVxuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBjcmVhdGVTY29wZTogZnVuY3Rpb24gY3JlYXRlU2NvcGUoZGF0ZSwgcmVnaW9uLCBzZXJ2aWNlTmFtZSkge1xuICAgIHJldHVybiBbXG4gICAgICBkYXRlLnN1YnN0cigwLCA4KSxcbiAgICAgIHJlZ2lvbixcbiAgICAgIHNlcnZpY2VOYW1lLFxuICAgICAgdjRJZGVudGlmaWVyXG4gICAgXS5qb2luKCcvJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgW0NyZWRlbnRpYWxzXVxuICAgKiBAcGFyYW0gZGF0ZSBbU3RyaW5nXVxuICAgKiBAcGFyYW0gcmVnaW9uIFtTdHJpbmddXG4gICAqIEBwYXJhbSBzZXJ2aWNlIFtTdHJpbmddXG4gICAqIEBwYXJhbSBzaG91bGRDYWNoZSBbQm9vbGVhbl1cbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgZ2V0U2lnbmluZ0tleTogZnVuY3Rpb24gZ2V0U2lnbmluZ0tleShcbiAgICBjcmVkZW50aWFscyxcbiAgICBkYXRlLFxuICAgIHJlZ2lvbixcbiAgICBzZXJ2aWNlLFxuICAgIHNob3VsZENhY2hlXG4gICkge1xuICAgIHZhciBjcmVkc0lkZW50aWZpZXIgPSBBV1MudXRpbC5jcnlwdG9cbiAgICAgIC5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQsICdiYXNlNjQnKTtcbiAgICB2YXIgY2FjaGVLZXkgPSBbY3JlZHNJZGVudGlmaWVyLCBkYXRlLCByZWdpb24sIHNlcnZpY2VdLmpvaW4oJ18nKTtcbiAgICBzaG91bGRDYWNoZSA9IHNob3VsZENhY2hlICE9PSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkQ2FjaGUgJiYgKGNhY2hlS2V5IGluIGNhY2hlZFNlY3JldCkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRTZWNyZXRbY2FjaGVLZXldO1xuICAgIH1cblxuICAgIHZhciBrRGF0ZSA9IEFXUy51dGlsLmNyeXB0by5obWFjKFxuICAgICAgJ0FXUzQnICsgY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LFxuICAgICAgZGF0ZSxcbiAgICAgICdidWZmZXInXG4gICAgKTtcbiAgICB2YXIga1JlZ2lvbiA9IEFXUy51dGlsLmNyeXB0by5obWFjKGtEYXRlLCByZWdpb24sICdidWZmZXInKTtcbiAgICB2YXIga1NlcnZpY2UgPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhrUmVnaW9uLCBzZXJ2aWNlLCAnYnVmZmVyJyk7XG5cbiAgICB2YXIgc2lnbmluZ0tleSA9IEFXUy51dGlsLmNyeXB0by5obWFjKGtTZXJ2aWNlLCB2NElkZW50aWZpZXIsICdidWZmZXInKTtcbiAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgIGNhY2hlZFNlY3JldFtjYWNoZUtleV0gPSBzaWduaW5nS2V5O1xuICAgICAgY2FjaGVRdWV1ZS5wdXNoKGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZVF1ZXVlLmxlbmd0aCA+IG1heENhY2hlRW50cmllcykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBlbnRyeSAobm90IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkKVxuICAgICAgICBkZWxldGUgY2FjaGVkU2VjcmV0W2NhY2hlUXVldWUuc2hpZnQoKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ25pbmdLZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKlxuICAgKiBFbXB0aWVzIHRoZSBkZXJpdmVkIHNpZ25pbmcga2V5IGNhY2hlLiBNYWRlIGF2YWlsYWJsZSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgKiBvbmx5LlxuICAgKi9cbiAgZW1wdHlDYWNoZTogZnVuY3Rpb24gZW1wdHlDYWNoZSgpIHtcbiAgICBjYWNoZWRTZWNyZXQgPSB7fTtcbiAgICBjYWNoZVF1ZXVlID0gW107XG4gIH1cbn07XG4iLCJmdW5jdGlvbiBBY2NlcHRvclN0YXRlTWFjaGluZShzdGF0ZXMsIHN0YXRlKSB7XG4gIHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGUgfHwgbnVsbDtcbiAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXMgfHwge307XG59XG5cbkFjY2VwdG9yU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5ydW5UbyA9IGZ1bmN0aW9uIHJ1blRvKGZpbmFsU3RhdGUsIGRvbmUsIGJpbmRPYmplY3QsIGlucHV0RXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBmaW5hbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5wdXRFcnJvciA9IGJpbmRPYmplY3Q7IGJpbmRPYmplY3QgPSBkb25lO1xuICAgIGRvbmUgPSBmaW5hbFN0YXRlOyBmaW5hbFN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0YXRlID0gc2VsZi5zdGF0ZXNbc2VsZi5jdXJyZW50U3RhdGVdO1xuICBzdGF0ZS5mbi5jYWxsKGJpbmRPYmplY3QgfHwgc2VsZiwgaW5wdXRFcnJvciwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKHN0YXRlLmZhaWwpIHNlbGYuY3VycmVudFN0YXRlID0gc3RhdGUuZmFpbDtcbiAgICAgIGVsc2UgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCwgZXJyKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHQpIHNlbGYuY3VycmVudFN0YXRlID0gc3RhdGUuYWNjZXB0O1xuICAgICAgZWxzZSByZXR1cm4gZG9uZSA/IGRvbmUuY2FsbChiaW5kT2JqZWN0KSA6IG51bGw7XG4gICAgfVxuICAgIGlmIChzZWxmLmN1cnJlbnRTdGF0ZSA9PT0gZmluYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCwgZXJyKSA6IG51bGw7XG4gICAgfVxuXG4gICAgc2VsZi5ydW5UbyhmaW5hbFN0YXRlLCBkb25lLCBiaW5kT2JqZWN0LCBlcnIpO1xuICB9KTtcbn07XG5cbkFjY2VwdG9yU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5hZGRTdGF0ZSA9IGZ1bmN0aW9uIGFkZFN0YXRlKG5hbWUsIGFjY2VwdFN0YXRlLCBmYWlsU3RhdGUsIGZuKSB7XG4gIGlmICh0eXBlb2YgYWNjZXB0U3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGFjY2VwdFN0YXRlOyBhY2NlcHRTdGF0ZSA9IG51bGw7IGZhaWxTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZhaWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZmFpbFN0YXRlOyBmYWlsU3RhdGUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSkgdGhpcy5jdXJyZW50U3RhdGUgPSBuYW1lO1xuICB0aGlzLnN0YXRlc1tuYW1lXSA9IHsgYWNjZXB0OiBhY2NlcHRTdGF0ZSwgZmFpbDogZmFpbFN0YXRlLCBmbjogZm4gfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFjY2VwdG9yU3RhdGVNYWNoaW5lO1xuIiwiLyogZXNsaW50IGd1YXJkLWZvci1pbjowICovXG52YXIgQVdTO1xuXG4vKipcbiAqIEEgc2V0IG9mIHV0aWxpdHkgbWV0aG9kcyBmb3IgdXNlIHdpdGggdGhlIEFXUyBTREsuXG4gKlxuICogQCFhdHRyaWJ1dGUgYWJvcnRcbiAqICAgUmV0dXJuIHRoaXMgdmFsdWUgZnJvbSBhbiBpdGVyYXRvciBmdW5jdGlvbiB7ZWFjaH0gb3Ige2FycmF5RWFjaH1cbiAqICAgdG8gYnJlYWsgb3V0IG9mIHRoZSBpdGVyYXRpb24uXG4gKiAgIEBleGFtcGxlIEJyZWFraW5nIG91dCBvZiBhbiBpdGVyYXRvciBmdW5jdGlvblxuICogICAgIEFXUy51dGlsLmVhY2goe2E6IDEsIGI6IDIsIGM6IDN9LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gKiAgICAgICBpZiAoa2V5ID09ICdiJykgcmV0dXJuIEFXUy51dGlsLmFib3J0O1xuICogICAgIH0pO1xuICogICBAc2VlIGVhY2hcbiAqICAgQHNlZSBhcnJheUVhY2hcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgdXRpbCA9IHtcbiAgZW52aXJvbm1lbnQ6ICdub2RlanMnLFxuICBlbmdpbmU6IGZ1bmN0aW9uIGVuZ2luZSgpIHtcbiAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmdpbmUgPSBwcm9jZXNzLnBsYXRmb3JtICsgJy8nICsgcHJvY2Vzcy52ZXJzaW9uO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkFXU19FWEVDVVRJT05fRU5WKSB7XG4gICAgICAgIGVuZ2luZSArPSAnIGV4ZWMtZW52LycgKyBwcm9jZXNzLmVudi5BV1NfRVhFQ1VUSU9OX0VOVjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfVxuICB9LFxuXG4gIHVzZXJBZ2VudDogZnVuY3Rpb24gdXNlckFnZW50KCkge1xuICAgIHZhciBuYW1lID0gdXRpbC5lbnZpcm9ubWVudDtcbiAgICB2YXIgYWdlbnQgPSAnYXdzLXNkay0nICsgbmFtZSArICcvJyArIHJlcXVpcmUoJy4vY29yZScpLlZFUlNJT047XG4gICAgaWYgKG5hbWUgPT09ICdub2RlanMnKSBhZ2VudCArPSAnICcgKyB1dGlsLmVuZ2luZSgpO1xuICAgIHJldHVybiBhZ2VudDtcbiAgfSxcblxuICB1cmlFc2NhcGU6IGZ1bmN0aW9uIHVyaUVzY2FwZShzdHJpbmcpIHtcbiAgICB2YXIgb3V0cHV0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZyk7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1teQS1aYS16MC05Xy5+XFwtJV0rL2csIGVzY2FwZSk7XG5cbiAgICAvLyBBV1MgcGVyY2VudC1lbmNvZGVzIHNvbWUgZXh0cmEgbm9uLXN0YW5kYXJkIGNoYXJhY3RlcnMgaW4gYSBVUklcbiAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvWypdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gJyUnICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgdXJpRXNjYXBlUGF0aDogZnVuY3Rpb24gdXJpRXNjYXBlUGF0aChzdHJpbmcpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB1dGlsLmFycmF5RWFjaChzdHJpbmcuc3BsaXQoJy8nKSwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHBhcnRzLnB1c2godXRpbC51cmlFc2NhcGUocGFydCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XG4gIH0sXG5cbiAgdXJsUGFyc2U6IGZ1bmN0aW9uIHVybFBhcnNlKHVybCkge1xuICAgIHJldHVybiB1dGlsLnVybC5wYXJzZSh1cmwpO1xuICB9LFxuXG4gIHVybEZvcm1hdDogZnVuY3Rpb24gdXJsRm9ybWF0KHVybCkge1xuICAgIHJldHVybiB1dGlsLnVybC5mb3JtYXQodXJsKTtcbiAgfSxcblxuICBxdWVyeVN0cmluZ1BhcnNlOiBmdW5jdGlvbiBxdWVyeVN0cmluZ1BhcnNlKHFzKSB7XG4gICAgcmV0dXJuIHV0aWwucXVlcnlzdHJpbmcucGFyc2UocXMpO1xuICB9LFxuXG4gIHF1ZXJ5UGFyYW1zVG9TdHJpbmc6IGZ1bmN0aW9uIHF1ZXJ5UGFyYW1zVG9TdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIGVzY2FwZSA9IHV0aWwudXJpRXNjYXBlO1xuICAgIHZhciBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCk7XG5cbiAgICB1dGlsLmFycmF5RWFjaChzb3J0ZWRLZXlzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgICB2YXIgZW5hbWUgPSBlc2NhcGUobmFtZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gZW5hbWUgKyAnPSc7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgdXRpbC5hcnJheUVhY2godmFsdWUsIGZ1bmN0aW9uKGl0ZW0pIHsgdmFscy5wdXNoKGVzY2FwZShpdGVtKSk7IH0pO1xuICAgICAgICByZXN1bHQgPSBlbmFtZSArICc9JyArIHZhbHMuc29ydCgpLmpvaW4oJyYnICsgZW5hbWUgKyAnPScpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGVuYW1lICsgJz0nICsgZXNjYXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBpdGVtcy5qb2luKCcmJyk7XG4gIH0sXG5cbiAgcmVhZEZpbGVTeW5jOiBmdW5jdGlvbiByZWFkRmlsZVN5bmMocGF0aCkge1xuICAgIGlmICh1dGlsLmlzQnJvd3NlcigpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0Zi04Jyk7XG4gIH0sXG5cbiAgYmFzZTY0OiB7XG4gICAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGU2NChzdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignQ2Fubm90IGJhc2U2NCBlbmNvZGUgbnVtYmVyICcgKyBzdHJpbmcpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgdHlwZW9mIHN0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBidWYgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihzdHJpbmcpO1xuICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSxcblxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlNjQoc3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBiYXNlNjQgZGVjb2RlIG51bWJlciAnICsgc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nLCAnYmFzZTY0Jyk7XG4gICAgfVxuXG4gIH0sXG5cbiAgYnVmZmVyOiB7XG4gICAgLyoqXG4gICAgICogQnVmZmVyIGNvbnN0cnVjdG9yIGZvciBOb2RlIGJ1ZmZlciBhbmQgYnVmZmVyIHBvbGx5ZmlsbFxuICAgICAqL1xuICAgIHRvQnVmZmVyOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuICh0eXBlb2YgdXRpbC5CdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsLkJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pID9cbiAgICAgICAgdXRpbC5CdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZykgOiBuZXcgdXRpbC5CdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgIH0sXG5cbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaXplIHBhc3NlZCB0byBhbGxvYyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB1dGlsLkJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyB1dGlsLkJ1ZmZlcihzaXplKTtcbiAgICAgICAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYnVmLmZpbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBidWYuZmlsbChmaWxsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRvU3RyZWFtOiBmdW5jdGlvbiB0b1N0cmVhbShidWZmZXIpIHtcbiAgICAgIGlmICghdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkgYnVmZmVyID0gIHV0aWwuYnVmZmVyLnRvQnVmZmVyKGJ1ZmZlcik7XG5cbiAgICAgIHZhciByZWFkYWJsZSA9IG5ldyAodXRpbC5zdHJlYW0uUmVhZGFibGUpKCk7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBpZiAocG9zID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiByZWFkYWJsZS5wdXNoKG51bGwpO1xuXG4gICAgICAgIHZhciBlbmQgPSBwb3MgKyBzaXplO1xuICAgICAgICBpZiAoZW5kID4gYnVmZmVyLmxlbmd0aCkgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgcmVhZGFibGUucHVzaChidWZmZXIuc2xpY2UocG9zLCBlbmQpKTtcbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlYWRhYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25jYXRlbmF0ZXMgYSBsaXN0IG9mIEJ1ZmZlciBvYmplY3RzLlxuICAgICAqL1xuICAgIGNvbmNhdDogZnVuY3Rpb24oYnVmZmVycykge1xuICAgICAgdmFyIGxlbmd0aCA9IDAsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBidWZmZXIgPSBudWxsLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGggKz0gYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlciA9IHV0aWwuYnVmZmVyLmFsbG9jKGxlbmd0aCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0uY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBidWZmZXJzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH0sXG5cbiAgc3RyaW5nOiB7XG4gICAgYnl0ZUxlbmd0aDogZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSBzdHJpbmcgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihzdHJpbmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0cmluZy5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmluZy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNpemU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJ2ZzJykubHN0YXRTeW5jKHN0cmluZy5wYXRoKS5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlcm1pbmUgbGVuZ3RoIG9mICcgKyBzdHJpbmcpLFxuICAgICAgICAgIHsgb2JqZWN0OiBzdHJpbmcgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwcGVyRmlyc3Q6IGZ1bmN0aW9uIHVwcGVyRmlyc3Qoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyKDEpO1xuICAgIH0sXG5cbiAgICBsb3dlckZpcnN0OiBmdW5jdGlvbiBsb3dlckZpcnN0KHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZ1swXS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pOiB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uIHN0cmluZyhpbmkpIHtcbiAgICAgIHZhciBjdXJyZW50U2VjdGlvbiwgbWFwID0ge307XG4gICAgICB1dGlsLmFycmF5RWFjaChpbmkuc3BsaXQoL1xccj9cXG4vKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBsaW5lID0gbGluZS5zcGxpdCgvKF58XFxzKVs7I10vKVswXTsgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgICAgIHZhciBzZWN0aW9uID0gbGluZS5tYXRjaCgvXlxccypcXFsoW15cXFtcXF1dKylcXF1cXHMqJC8pO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gc2VjdGlvblsxXTtcbiAgICAgICAgICBpZiAoY3VycmVudFNlY3Rpb24gPT09ICdfX3Byb3RvX18nIHx8IGN1cnJlbnRTZWN0aW9uLnNwbGl0KC9cXHMvKVsxXSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgIHRocm93IHV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignQ2Fubm90IGxvYWQgcHJvZmlsZSBuYW1lIFxcJycgKyBjdXJyZW50U2VjdGlvbiArICdcXCcgZnJvbSBzaGFyZWQgaW5pIGZpbGUuJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBsaW5lLm1hdGNoKC9eXFxzKiguKz8pXFxzKj1cXHMqKC4rPylcXHMqJC8pO1xuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBtYXBbY3VycmVudFNlY3Rpb25dID0gbWFwW2N1cnJlbnRTZWN0aW9uXSB8fCB7fTtcbiAgICAgICAgICAgIG1hcFtjdXJyZW50U2VjdGlvbl1baXRlbVsxXV0gPSBpdGVtWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICB9LFxuXG4gIGZuOiB7XG4gICAgbm9vcDogZnVuY3Rpb24oKSB7fSxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJuIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBhcyBcImFzeW5jXCIgZnVuY3Rpb24gYnkgbWFraW5nIGl0IGNhbGxcbiAgICAgKiBhIGNhbGxiYWNrLiBUaGUgdW5kZXJseWluZyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhbGwgYnV0IHRoZSBsYXN0IGFyZ3VtZW50LFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHBhc3NlZCBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogb2YgbnVsbCBvbiBzdWNjZXNzIHRvIG1pbWljayBzdGFuZGFyZCBub2RlIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBtYWtlQXN5bmM6IGZ1bmN0aW9uIG1ha2VBc3luYyhmbiwgZXhwZWN0ZWRBcmdzKSB7XG4gICAgICBpZiAoZXhwZWN0ZWRBcmdzICYmIGV4cGVjdGVkQXJncyA8PSBmbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERhdGUgYW5kIHRpbWUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gICAqL1xuICBkYXRlOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtEYXRlXSB0aGUgY3VycmVudCBKYXZhU2NyaXB0IGRhdGUgb2JqZWN0LiBTaW5jZSBhbGxcbiAgICAgKiAgIEFXUyBzZXJ2aWNlcyByZWx5IG9uIHRoaXMgZGF0ZSBvYmplY3QsIHlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiAgIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBhIHNwZWNpYWwgdGltZSB2YWx1ZSB0byBBV1Mgc2VydmljZVxuICAgICAqICAgcmVxdWVzdHMuXG4gICAgICovXG4gICAgZ2V0RGF0ZTogZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgICAgIGlmICghQVdTKSBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbiAgICAgIGlmIChBV1MuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0KSB7IC8vIHVzZSBvZmZzZXQgd2hlbiBub24temVyb1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgKyBBV1MuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBkYXRlIGluIElTTy04NjAxIGZvcm1hdFxuICAgICAqL1xuICAgIGlzbzg2MDE6IGZ1bmN0aW9uIGlzbzg2MDEoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkgeyBkYXRlID0gdXRpbC5kYXRlLmdldERhdGUoKTsgfVxuICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9cXC5cXGR7M31aJC8sICdaJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gW1N0cmluZ10gdGhlIGRhdGUgaW4gUkZDIDgyMiBmb3JtYXRcbiAgICAgKi9cbiAgICByZmM4MjI6IGZ1bmN0aW9uIHJmYzgyMihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IGRhdGUgPSB1dGlsLmRhdGUuZ2V0RGF0ZSgpOyB9XG4gICAgICByZXR1cm4gZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgVU5JWCB0aW1lc3RhbXAgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgKi9cbiAgICB1bml4VGltZXN0YW1wOiBmdW5jdGlvbiB1bml4VGltZXN0YW1wKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHsgZGF0ZSA9IHV0aWwuZGF0ZS5nZXREYXRlKCk7IH1cbiAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbU3RyaW5nLG51bWJlcixEYXRlXSBkYXRlXG4gICAgICogQHJldHVybiBbRGF0ZV1cbiAgICAgKi9cbiAgICBmcm9tOiBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSAqIDEwMDApOyAvLyB1bml4IHRpbWVzdGFtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIERhdGUgb3IgZGF0ZS1saWtlIHZhbHVlLCB0aGlzIGZ1bmN0aW9uIGZvcm1hdHMgdGhlXG4gICAgICogZGF0ZSBpbnRvIGEgc3RyaW5nIG9mIHRoZSByZXF1ZXN0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIFtTdHJpbmcsbnVtYmVyLERhdGVdIGRhdGVcbiAgICAgKiBAcGFyYW0gW1N0cmluZ10gZm9ybWF0dGVyIFZhbGlkIGZvcm1hdHMgYXJlOlxuICAgICAjICAgKiAnaXNvODYwMSdcbiAgICAgIyAgICogJ3JmYzgyMidcbiAgICAgIyAgICogJ3VuaXhUaW1lc3RhbXAnXG4gICAgICogQHJldHVybiBbU3RyaW5nXVxuICAgICAqL1xuICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KGRhdGUsIGZvcm1hdHRlcikge1xuICAgICAgaWYgKCFmb3JtYXR0ZXIpIGZvcm1hdHRlciA9ICdpc284NjAxJztcbiAgICAgIHJldHVybiB1dGlsLmRhdGVbZm9ybWF0dGVyXSh1dGlsLmRhdGUuZnJvbShkYXRlKSk7XG4gICAgfSxcblxuICAgIHBhcnNlVGltZXN0YW1wOiBmdW5jdGlvbiBwYXJzZVRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHsgLy8gdW5peCB0aW1lc3RhbXAgKG51bWJlcilcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFxkKyQvKSkgeyAvLyB1bml4IHRpbWVzdGFtcFxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUgKiAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubWF0Y2goL15cXGR7NH0vKSkgeyAvLyBpc284NjAxXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFx3ezN9LC8pKSB7IC8vIHJmYzgyMlxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ3VuaGFuZGxlZCB0aW1lc3RhbXAgZm9ybWF0OiAnICsgdmFsdWUpLFxuICAgICAgICAgIHtjb2RlOiAnVGltZXN0YW1wUGFyc2VyRXJyb3InfSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0sXG5cbiAgY3J5cHRvOiB7XG4gICAgY3JjMzJUYWJsZTogW1xuICAgICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweEVFMEU2MTJDLCAweDk5MDk1MUJBLCAweDA3NkRDNDE5LFxuICAgICAweDcwNkFGNDhGLCAweEU5NjNBNTM1LCAweDlFNjQ5NUEzLCAweDBFREI4ODMyLCAweDc5RENCOEE0LFxuICAgICAweEUwRDVFOTFFLCAweDk3RDJEOTg4LCAweDA5QjY0QzJCLCAweDdFQjE3Q0JELCAweEU3QjgyRDA3LFxuICAgICAweDkwQkYxRDkxLCAweDFEQjcxMDY0LCAweDZBQjAyMEYyLCAweEYzQjk3MTQ4LCAweDg0QkU0MURFLFxuICAgICAweDFBREFENDdELCAweDZERERFNEVCLCAweEY0RDRCNTUxLCAweDgzRDM4NUM3LCAweDEzNkM5ODU2LFxuICAgICAweDY0NkJBOEMwLCAweEZENjJGOTdBLCAweDhBNjVDOUVDLCAweDE0MDE1QzRGLCAweDYzMDY2Q0Q5LFxuICAgICAweEZBMEYzRDYzLCAweDhEMDgwREY1LCAweDNCNkUyMEM4LCAweDRDNjkxMDVFLCAweEQ1NjA0MUU0LFxuICAgICAweEEyNjc3MTcyLCAweDNDMDNFNEQxLCAweDRCMDRENDQ3LCAweEQyMEQ4NUZELCAweEE1MEFCNTZCLFxuICAgICAweDM1QjVBOEZBLCAweDQyQjI5ODZDLCAweERCQkJDOUQ2LCAweEFDQkNGOTQwLCAweDMyRDg2Q0UzLFxuICAgICAweDQ1REY1Qzc1LCAweERDRDYwRENGLCAweEFCRDEzRDU5LCAweDI2RDkzMEFDLCAweDUxREUwMDNBLFxuICAgICAweEM4RDc1MTgwLCAweEJGRDA2MTE2LCAweDIxQjRGNEI1LCAweDU2QjNDNDIzLCAweENGQkE5NTk5LFxuICAgICAweEI4QkRBNTBGLCAweDI4MDJCODlFLCAweDVGMDU4ODA4LCAweEM2MENEOUIyLCAweEIxMEJFOTI0LFxuICAgICAweDJGNkY3Qzg3LCAweDU4Njg0QzExLCAweEMxNjExREFCLCAweEI2NjYyRDNELCAweDc2REM0MTkwLFxuICAgICAweDAxREI3MTA2LCAweDk4RDIyMEJDLCAweEVGRDUxMDJBLCAweDcxQjE4NTg5LCAweDA2QjZCNTFGLFxuICAgICAweDlGQkZFNEE1LCAweEU4QjhENDMzLCAweDc4MDdDOUEyLCAweDBGMDBGOTM0LCAweDk2MDlBODhFLFxuICAgICAweEUxMEU5ODE4LCAweDdGNkEwREJCLCAweDA4NkQzRDJELCAweDkxNjQ2Qzk3LCAweEU2NjM1QzAxLFxuICAgICAweDZCNkI1MUY0LCAweDFDNkM2MTYyLCAweDg1NjUzMEQ4LCAweEYyNjIwMDRFLCAweDZDMDY5NUVELFxuICAgICAweDFCMDFBNTdCLCAweDgyMDhGNEMxLCAweEY1MEZDNDU3LCAweDY1QjBEOUM2LCAweDEyQjdFOTUwLFxuICAgICAweDhCQkVCOEVBLCAweEZDQjk4ODdDLCAweDYyREQxRERGLCAweDE1REEyRDQ5LCAweDhDRDM3Q0YzLFxuICAgICAweEZCRDQ0QzY1LCAweDREQjI2MTU4LCAweDNBQjU1MUNFLCAweEEzQkMwMDc0LCAweEQ0QkIzMEUyLFxuICAgICAweDRBREZBNTQxLCAweDNERDg5NUQ3LCAweEE0RDFDNDZELCAweEQzRDZGNEZCLCAweDQzNjlFOTZBLFxuICAgICAweDM0NkVEOUZDLCAweEFENjc4ODQ2LCAweERBNjBCOEQwLCAweDQ0MDQyRDczLCAweDMzMDMxREU1LFxuICAgICAweEFBMEE0QzVGLCAweEREMEQ3Q0M5LCAweDUwMDU3MTNDLCAweDI3MDI0MUFBLCAweEJFMEIxMDEwLFxuICAgICAweEM5MEMyMDg2LCAweDU3NjhCNTI1LCAweDIwNkY4NUIzLCAweEI5NjZENDA5LCAweENFNjFFNDlGLFxuICAgICAweDVFREVGOTBFLCAweDI5RDlDOTk4LCAweEIwRDA5ODIyLCAweEM3RDdBOEI0LCAweDU5QjMzRDE3LFxuICAgICAweDJFQjQwRDgxLCAweEI3QkQ1QzNCLCAweEMwQkE2Q0FELCAweEVEQjg4MzIwLCAweDlBQkZCM0I2LFxuICAgICAweDAzQjZFMjBDLCAweDc0QjFEMjlBLCAweEVBRDU0NzM5LCAweDlERDI3N0FGLCAweDA0REIyNjE1LFxuICAgICAweDczREMxNjgzLCAweEUzNjMwQjEyLCAweDk0NjQzQjg0LCAweDBENkQ2QTNFLCAweDdBNkE1QUE4LFxuICAgICAweEU0MEVDRjBCLCAweDkzMDlGRjlELCAweDBBMDBBRTI3LCAweDdEMDc5RUIxLCAweEYwMEY5MzQ0LFxuICAgICAweDg3MDhBM0QyLCAweDFFMDFGMjY4LCAweDY5MDZDMkZFLCAweEY3NjI1NzVELCAweDgwNjU2N0NCLFxuICAgICAweDE5NkMzNjcxLCAweDZFNkIwNkU3LCAweEZFRDQxQjc2LCAweDg5RDMyQkUwLCAweDEwREE3QTVBLFxuICAgICAweDY3REQ0QUNDLCAweEY5QjlERjZGLCAweDhFQkVFRkY5LCAweDE3QjdCRTQzLCAweDYwQjA4RUQ1LFxuICAgICAweEQ2RDZBM0U4LCAweEExRDE5MzdFLCAweDM4RDhDMkM0LCAweDRGREZGMjUyLCAweEQxQkI2N0YxLFxuICAgICAweEE2QkM1NzY3LCAweDNGQjUwNkRELCAweDQ4QjIzNjRCLCAweEQ4MEQyQkRBLCAweEFGMEExQjRDLFxuICAgICAweDM2MDM0QUY2LCAweDQxMDQ3QTYwLCAweERGNjBFRkMzLCAweEE4NjdERjU1LCAweDMxNkU4RUVGLFxuICAgICAweDQ2NjlCRTc5LCAweENCNjFCMzhDLCAweEJDNjY4MzFBLCAweDI1NkZEMkEwLCAweDUyNjhFMjM2LFxuICAgICAweENDMEM3Nzk1LCAweEJCMEI0NzAzLCAweDIyMDIxNkI5LCAweDU1MDUyNjJGLCAweEM1QkEzQkJFLFxuICAgICAweEIyQkQwQjI4LCAweDJCQjQ1QTkyLCAweDVDQjM2QTA0LCAweEMyRDdGRkE3LCAweEI1RDBDRjMxLFxuICAgICAweDJDRDk5RThCLCAweDVCREVBRTFELCAweDlCNjRDMkIwLCAweEVDNjNGMjI2LCAweDc1NkFBMzlDLFxuICAgICAweDAyNkQ5MzBBLCAweDlDMDkwNkE5LCAweEVCMEUzNjNGLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLFxuICAgICAweDk1QkY0QTgyLCAweEUyQjg3QTE0LCAweDdCQjEyQkFFLCAweDBDQjYxQjM4LCAweDkyRDI4RTlCLFxuICAgICAweEU1RDVCRTBELCAweDdDRENFRkI3LCAweDBCREJERjIxLCAweDg2RDNEMkQ0LCAweEYxRDRFMjQyLFxuICAgICAweDY4RERCM0Y4LCAweDFGREE4MzZFLCAweDgxQkUxNkNELCAweEY2QjkyNjVCLCAweDZGQjA3N0UxLFxuICAgICAweDE4Qjc0Nzc3LCAweDg4MDg1QUU2LCAweEZGMEY2QTcwLCAweDY2MDYzQkNBLCAweDExMDEwQjVDLFxuICAgICAweDhGNjU5RUZGLCAweEY4NjJBRTY5LCAweDYxNkJGRkQzLCAweDE2NkNDRjQ1LCAweEEwMEFFMjc4LFxuICAgICAweEQ3MEREMkVFLCAweDRFMDQ4MzU0LCAweDM5MDNCM0MyLCAweEE3NjcyNjYxLCAweEQwNjAxNkY3LFxuICAgICAweDQ5Njk0NzRELCAweDNFNkU3N0RCLCAweEFFRDE2QTRBLCAweEQ5RDY1QURDLCAweDQwREYwQjY2LFxuICAgICAweDM3RDgzQkYwLCAweEE5QkNBRTUzLCAweERFQkI5RUM1LCAweDQ3QjJDRjdGLCAweDMwQjVGRkU5LFxuICAgICAweEJEQkRGMjFDLCAweENBQkFDMjhBLCAweDUzQjM5MzMwLCAweDI0QjRBM0E2LCAweEJBRDAzNjA1LFxuICAgICAweENERDcwNjkzLCAweDU0REU1NzI5LCAweDIzRDk2N0JGLCAweEIzNjY3QTJFLCAweEM0NjE0QUI4LFxuICAgICAweDVENjgxQjAyLCAweDJBNkYyQjk0LCAweEI0MEJCRTM3LCAweEMzMEM4RUExLCAweDVBMDVERjFCLFxuICAgICAweDJEMDJFRjhEXSxcblxuICAgIGNyYzMyOiBmdW5jdGlvbiBjcmMzMihkYXRhKSB7XG4gICAgICB2YXIgdGJsID0gdXRpbC5jcnlwdG8uY3JjMzJUYWJsZTtcbiAgICAgIHZhciBjcmMgPSAwIF4gLTE7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBkYXRhLnJlYWRVSW50OChpKTtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YmxbKGNyYyBeIGNvZGUpICYgMHhGRl07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGNyYyBeIC0xKSA+Pj4gMDtcbiAgICB9LFxuXG4gICAgaG1hYzogZnVuY3Rpb24gaG1hYyhrZXksIHN0cmluZywgZGlnZXN0LCBmbikge1xuICAgICAgaWYgKCFkaWdlc3QpIGRpZ2VzdCA9ICdiaW5hcnknO1xuICAgICAgaWYgKGRpZ2VzdCA9PT0gJ2J1ZmZlcicpIHsgZGlnZXN0ID0gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAoIWZuKSBmbiA9ICdzaGEyNTYnO1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSBzdHJpbmcgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihzdHJpbmcpO1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmxpYi5jcmVhdGVIbWFjKGZuLCBrZXkpLnVwZGF0ZShzdHJpbmcpLmRpZ2VzdChkaWdlc3QpO1xuICAgIH0sXG5cbiAgICBtZDU6IGZ1bmN0aW9uIG1kNShkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8uaGFzaCgnbWQ1JywgZGF0YSwgZGlnZXN0LCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIHNoYTI1NjogZnVuY3Rpb24gc2hhMjU2KGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5oYXNoKCdzaGEyNTYnLCBkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgaGFzaDogZnVuY3Rpb24oYWxnb3JpdGhtLCBkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGFzaCA9IHV0aWwuY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKTtcbiAgICAgIGlmICghZGlnZXN0KSB7IGRpZ2VzdCA9ICdiaW5hcnknOyB9XG4gICAgICBpZiAoZGlnZXN0ID09PSAnYnVmZmVyJykgeyBkaWdlc3QgPSB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIGRhdGEgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihkYXRhKTtcbiAgICAgIHZhciBzbGljZUZuID0gdXRpbC5hcnJheVNsaWNlRm4oZGF0YSk7XG4gICAgICB2YXIgaXNCdWZmZXIgPSB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgICAgIC8vSWRlbnRpZnlpbmcgb2JqZWN0cyB3aXRoIGFuIEFycmF5QnVmZmVyIGFzIGJ1ZmZlcnNcbiAgICAgIGlmICh1dGlsLmlzQnJvd3NlcigpICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSAmJiBkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBpc0J1ZmZlciA9IHRydWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICB0eXBlb2YgZGF0YS5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNCdWZmZXIpIHtcbiAgICAgICAgZGF0YS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7IGhhc2gudXBkYXRlKGNodW5rKTsgfSk7XG4gICAgICAgIGRhdGEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xuICAgICAgICBkYXRhLm9uKCdlbmQnLCBmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCwgaGFzaC5kaWdlc3QoZGlnZXN0KSk7IH0pO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAmJiBzbGljZUZuICYmICFpc0J1ZmZlciAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZVJlYWRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBhIEZpbGUvQmxvYlxuICAgICAgICB2YXIgaW5kZXggPSAwLCBzaXplID0gMTAyNCAqIDUxMjtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBkYXRhLicpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBidWYgPSBuZXcgdXRpbC5CdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCkpO1xuICAgICAgICAgIGhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgICAgaW5kZXggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgICByZWFkZXIuX2NvbnRpbnVlUmVhZGluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIuX2NvbnRpbnVlUmVhZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBkYXRhLnNpemUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhc2guZGlnZXN0KGRpZ2VzdCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBiYWNrID0gaW5kZXggKyBzaXplO1xuICAgICAgICAgIGlmIChiYWNrID4gZGF0YS5zaXplKSBiYWNrID0gZGF0YS5zaXplO1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihzbGljZUZuLmNhbGwoZGF0YSwgaW5kZXgsIGJhY2spKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIuX2NvbnRpbnVlUmVhZGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICFpc0J1ZmZlcikge1xuICAgICAgICAgIGRhdGEgPSBuZXcgdXRpbC5CdWZmZXIobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBoYXNoLnVwZGF0ZShkYXRhKS5kaWdlc3QoZGlnZXN0KTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b0hleDogZnVuY3Rpb24gdG9IZXgoZGF0YSkge1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKCgnMCcgKyBkYXRhLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gICAgfSxcblxuICAgIGNyZWF0ZUhhc2g6IGZ1bmN0aW9uIGNyZWF0ZUhhc2goYWxnb3JpdGhtKSB7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8ubGliLmNyZWF0ZUhhc2goYWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgfSxcblxuICAvKiogQCFpZ25vcmUgKi9cblxuICAvKiBBYm9ydCBjb25zdGFudCAqL1xuICBhYm9ydDoge30sXG5cbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmplY3QsIGl0ZXJGdW5jdGlvbikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIHZhciByZXQgPSBpdGVyRnVuY3Rpb24uY2FsbCh0aGlzLCBrZXksIG9iamVjdFtrZXldKTtcbiAgICAgICAgaWYgKHJldCA9PT0gdXRpbC5hYm9ydCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFycmF5RWFjaDogZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyRnVuY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpZHggaW4gYXJyYXkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGlkeCkpIHtcbiAgICAgICAgdmFyIHJldCA9IGl0ZXJGdW5jdGlvbi5jYWxsKHRoaXMsIGFycmF5W2lkeF0sIHBhcnNlSW50KGlkeCwgMTApKTtcbiAgICAgICAgaWYgKHJldCA9PT0gdXRpbC5hYm9ydCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iajEsIG9iajIpIHtcbiAgICB1dGlsLmVhY2gob2JqMiwgZnVuY3Rpb24gaXRlcmF0b3Ioa2V5LCBpdGVtKSB7XG4gICAgICBvYmoxW2tleV0gPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmoxO1xuICB9LFxuXG4gIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShvYmoxLCBvYmoyKSB7XG4gICAgcmV0dXJuIHV0aWwudXBkYXRlKHV0aWwuY29weShvYmoxKSwgb2JqMik7XG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gY29weShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gb2JqZWN0O1xuICAgIHZhciBkdXBlID0ge307XG4gICAgLy8ganNoaW50IGZvcmluOmZhbHNlXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgZHVwZVtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIHJldHVybiBkdXBlO1xuICB9LFxuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGFycmF5U2xpY2VGbjogZnVuY3Rpb24gYXJyYXlTbGljZUZuKG9iaikge1xuICAgIHZhciBmbiA9IG9iai5zbGljZSB8fCBvYmoud2Via2l0U2xpY2UgfHwgb2JqLm1velNsaWNlO1xuICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IG51bGw7XG4gIH0sXG5cbiAgaXNUeXBlOiBmdW5jdGlvbiBpc1R5cGUob2JqLCB0eXBlKSB7XG4gICAgLy8gaGFuZGxlIGNyb3NzLVwiZnJhbWVcIiBvYmplY3RzXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB0eXBlID0gdXRpbC50eXBlTmFtZSh0eXBlKTtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nO1xuICB9LFxuXG4gIHR5cGVOYW1lOiBmdW5jdGlvbiB0eXBlTmFtZSh0eXBlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLCAnbmFtZScpKSByZXR1cm4gdHlwZS5uYW1lO1xuICAgIHZhciBzdHIgPSB0eXBlLnRvU3RyaW5nKCk7XG4gICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKC9eXFxzKmZ1bmN0aW9uICguKylcXCgvKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IHN0cjtcbiAgfSxcblxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoZXJyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRXJyb3IgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGVyci5tZXNzYWdlICE9PSAnJykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyB8fCAob3B0aW9ucyAmJiBvcHRpb25zLm1lc3NhZ2UpKSB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3IgPSB1dGlsLmNvcHkoZXJyKTtcbiAgICAgICAgb3JpZ2luYWxFcnJvci5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UgfHwgbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICB1dGlsLnVwZGF0ZShlcnIsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSlcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICBpZiAob3B0aW9ucy5jb2RlIHx8IG9wdGlvbnMubmFtZSlcbiAgICAgICAgZXJyLmNvZGUgPSBvcHRpb25zLmNvZGUgfHwgb3B0aW9ucy5uYW1lO1xuICAgICAgaWYgKG9wdGlvbnMuc3RhY2spXG4gICAgICAgIGVyci5zdGFjayA9IG9wdGlvbnMuc3RhY2s7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICduYW1lJywge3dyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZX0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ21lc3NhZ2UnLCB7ZW51bWVyYWJsZTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGVyci5uYW1lID0gU3RyaW5nKG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lIHx8IGVyci5uYW1lIHx8IGVyci5jb2RlIHx8ICdFcnJvcicpO1xuICAgIGVyci50aW1lID0gbmV3IERhdGUoKTtcblxuICAgIGlmIChvcmlnaW5hbEVycm9yKSBlcnIub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG5cbiAgICByZXR1cm4gZXJyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGluaGVyaXQ6IGZ1bmN0aW9uIGluaGVyaXQoa2xhc3MsIGZlYXR1cmVzKSB7XG4gICAgdmFyIG5ld09iamVjdCA9IG51bGw7XG4gICAgaWYgKGZlYXR1cmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZlYXR1cmVzID0ga2xhc3M7XG4gICAgICBrbGFzcyA9IE9iamVjdDtcbiAgICAgIG5ld09iamVjdCA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3RvciA9IGZ1bmN0aW9uIENvbnN0cnVjdG9yV3JhcHBlcigpIHt9O1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBrbGFzcy5wcm90b3R5cGU7XG4gICAgICBuZXdPYmplY3QgPSBuZXcgY3RvcigpO1xuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdG9yIG5vdCBzdXBwbGllZCwgY3JlYXRlIHBhc3MtdGhyb3VnaCBjdG9yXG4gICAgaWYgKGZlYXR1cmVzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChrbGFzcyAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGtsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZmVhdHVyZXMuY29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3T2JqZWN0O1xuICAgIHV0aWwudXBkYXRlKGZlYXR1cmVzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZmVhdHVyZXMpO1xuICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yLl9fc3VwZXJfXyA9IGtsYXNzO1xuICAgIHJldHVybiBmZWF0dXJlcy5jb25zdHJ1Y3RvcjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBtaXhpbjogZnVuY3Rpb24gbWl4aW4oKSB7XG4gICAgdmFyIGtsYXNzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBqc2hpbnQgZm9yaW46ZmFsc2VcbiAgICAgIGZvciAodmFyIHByb3AgaW4gYXJndW1lbnRzW2ldLnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbaV0ucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wXSA9IGZuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoaWRlUHJvcGVydGllczogZnVuY3Rpb24gaGlkZVByb3BlcnRpZXMob2JqLCBwcm9wcykge1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICB1dGlsLmFycmF5RWFjaChwcm9wcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByb3BlcnR5OiBmdW5jdGlvbiBwcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlLCBlbnVtZXJhYmxlLCBpc1ZhbHVlKSB7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlICE9PSB1bmRlZmluZWQgPyBlbnVtZXJhYmxlIDogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNWYWx1ZSkge1xuICAgICAgb3B0cy5nZXQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRzLnZhbHVlID0gdmFsdWU7IG9wdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIG9wdHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1lbW9pemVkUHJvcGVydHk6IGZ1bmN0aW9uIG1lbW9pemVkUHJvcGVydHkob2JqLCBuYW1lLCBnZXQsIGVudW1lcmFibGUpIHtcbiAgICB2YXIgY2FjaGVkVmFsdWUgPSBudWxsO1xuXG4gICAgLy8gYnVpbGQgZW51bWVyYWJsZSBhdHRyaWJ1dGUgZm9yIGVhY2ggdmFsdWUgd2l0aCBsYXp5IGFjY2Vzc29yLlxuICAgIHV0aWwucHJvcGVydHkob2JqLCBuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYWNoZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZWRWYWx1ZSA9IGdldCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICAgIH0sIGVudW1lcmFibGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUT0RPIFJlbW92ZSBpbiBtYWpvciB2ZXJzaW9uIHJldmlzaW9uXG4gICAqIFRoaXMgYmFja2ZpbGwgcG9wdWxhdGVzIHJlc3BvbnNlIGRhdGEgd2l0aG91dCB0aGVcbiAgICogdG9wLWxldmVsIHBheWxvYWQgbmFtZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBob2lzdFBheWxvYWRNZW1iZXI6IGZ1bmN0aW9uIGhvaXN0UGF5bG9hZE1lbWJlcihyZXNwKSB7XG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IHJlcS5vcGVyYXRpb247XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbk5hbWVdO1xuICAgIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuICAgIGlmIChvdXRwdXQucGF5bG9hZCAmJiAhb3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0KSB7XG4gICAgICB2YXIgcGF5bG9hZE1lbWJlciA9IG91dHB1dC5tZW1iZXJzW291dHB1dC5wYXlsb2FkXTtcbiAgICAgIHZhciByZXNwb25zZVBheWxvYWQgPSByZXNwLmRhdGFbb3V0cHV0LnBheWxvYWRdO1xuICAgICAgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgICAgdXRpbC5lYWNoKHJlc3BvbnNlUGF5bG9hZCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHV0aWwucHJvcGVydHkocmVzcC5kYXRhLCBrZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZSBTSEEtMjU2IGNoZWNrc3VtcyBvZiBzdHJlYW1zXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0ZVNoYTI1NjogZnVuY3Rpb24gY29tcHV0ZVNoYTI1Nihib2R5LCBkb25lKSB7XG4gICAgaWYgKHV0aWwuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBTdHJlYW0gPSB1dGlsLnN0cmVhbS5TdHJlYW07XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgaWYgKHR5cGVvZiBTdHJlYW0gPT09ICdmdW5jdGlvbicgJiYgYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkucGF0aCA9PT0gJ3N0cmluZycpIHsgLy8gYXNzdW1lIGZpbGUgb2JqZWN0XG4gICAgICAgICAgdmFyIHNldHRpbmdzID0ge307XG4gICAgICAgICAgaWYgKHR5cGVvZiBib2R5LnN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2V0dGluZ3Muc3RhcnQgPSBib2R5LnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHkuZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuZW5kID0gYm9keS5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGJvZHkucGF0aCwgc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUT0RPIHN1cHBvcnQgb3RoZXIgc3RyZWFtIHR5cGVzXG4gICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdOb24tZmlsZSBzdHJlYW0gb2JqZWN0cyBhcmUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3Qgc3VwcG9ydGVkIHdpdGggU2lnVjQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsLmNyeXB0by5zaGEyNTYoYm9keSwgJ2hleCcsIGZ1bmN0aW9uKGVyciwgc2hhKSB7XG4gICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICBlbHNlIGRvbmUobnVsbCwgc2hhKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0Nsb2NrU2tld2VkOiBmdW5jdGlvbiBpc0Nsb2NrU2tld2VkKHNlcnZlclRpbWUpIHtcbiAgICBpZiAoc2VydmVyVGltZSkge1xuICAgICAgdXRpbC5wcm9wZXJ0eShBV1MuY29uZmlnLCAnaXNDbG9ja1NrZXdlZCcsXG4gICAgICAgIE1hdGguYWJzKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc2VydmVyVGltZSkgPj0gMzAwMDAwLCBmYWxzZSk7XG4gICAgICByZXR1cm4gQVdTLmNvbmZpZy5pc0Nsb2NrU2tld2VkO1xuICAgIH1cbiAgfSxcblxuICBhcHBseUNsb2NrT2Zmc2V0OiBmdW5jdGlvbiBhcHBseUNsb2NrT2Zmc2V0KHNlcnZlclRpbWUpIHtcbiAgICBpZiAoc2VydmVyVGltZSlcbiAgICAgIEFXUy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQgPSBzZXJ2ZXJUaW1lIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdFJlcXVlc3RJZDogZnVuY3Rpb24gZXh0cmFjdFJlcXVlc3RJZChyZXNwKSB7XG4gICAgdmFyIHJlcXVlc3RJZCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LXJlcXVlc3QtaWQnXSB8fFxuICAgICAgICAgICAgICAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLXJlcXVlc3RpZCddO1xuXG4gICAgaWYgKCFyZXF1ZXN0SWQgJiYgcmVzcC5kYXRhICYmIHJlc3AuZGF0YS5SZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICByZXF1ZXN0SWQgPSByZXNwLmRhdGEuUmVzcG9uc2VNZXRhZGF0YS5SZXF1ZXN0SWQ7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RJZCkge1xuICAgICAgcmVzcC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuXG4gICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgIHJlc3AuZXJyb3IucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRQcm9taXNlczogZnVuY3Rpb24gYWRkUHJvbWlzZXMoY29uc3RydWN0b3JzLCBQcm9taXNlRGVwZW5kZW5jeSkge1xuICAgIHZhciBkZWxldGVQcm9taXNlcyA9IGZhbHNlO1xuICAgIGlmIChQcm9taXNlRGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkICYmIEFXUyAmJiBBV1MuY29uZmlnKSB7XG4gICAgICBQcm9taXNlRGVwZW5kZW5jeSA9IEFXUy5jb25maWcuZ2V0UHJvbWlzZXNEZXBlbmRlbmN5KCk7XG4gICAgfVxuICAgIGlmIChQcm9taXNlRGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgUHJvbWlzZURlcGVuZGVuY3kgPSBQcm9taXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFByb21pc2VEZXBlbmRlbmN5ICE9PSAnZnVuY3Rpb24nKSBkZWxldGVQcm9taXNlcyA9IHRydWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnN0cnVjdG9ycykpIGNvbnN0cnVjdG9ycyA9IFtjb25zdHJ1Y3RvcnNdO1xuXG4gICAgZm9yICh2YXIgaW5kID0gMDsgaW5kIDwgY29uc3RydWN0b3JzLmxlbmd0aDsgaW5kKyspIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yc1tpbmRdO1xuICAgICAgaWYgKGRlbGV0ZVByb21pc2VzKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvci5kZWxldGVQcm9taXNlc0Zyb21DbGFzcykge1xuICAgICAgICAgIGNvbnN0cnVjdG9yLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IuYWRkUHJvbWlzZXNUb0NsYXNzKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yLmFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhIHByb21pc2Ugd2hvc2UgZmF0ZSBpcyBkZWNpZGVkIGJ5IHRoZVxuICAgKiBjYWxsYmFjayBiZWhhdmlvciBvZiB0aGUgZ2l2ZW4gbWV0aG9kIHdpdGggYG1ldGhvZE5hbWVgLiBUaGUgbWV0aG9kIHRvIGJlXG4gICAqIHByb21pc2lmaWVkIHNob3VsZCBjb25mb3JtIHRvIG5vZGUuanMgY29udmVudGlvbiBvZiBhY2NlcHRpbmcgYSBjYWxsYmFjayBhc1xuICAgKiBsYXN0IGFyZ3VtZW50IGFuZCBjYWxsaW5nIHRoYXQgY2FsbGJhY2sgd2l0aCBlcnJvciBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogYW5kIHN1Y2Nlc3MgdmFsdWUgb24gdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICovXG4gIHByb21pc2lmeU1ldGhvZDogZnVuY3Rpb24gcHJvbWlzaWZ5TWV0aG9kKG1ldGhvZE5hbWUsIFByb21pc2VEZXBlbmRlbmN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2VEZXBlbmRlbmN5KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNEdWFsc3RhY2tBdmFpbGFibGU6IGZ1bmN0aW9uIGlzRHVhbHN0YWNrQXZhaWxhYmxlKHNlcnZpY2UpIHtcbiAgICBpZiAoIXNlcnZpY2UpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuLi9hcGlzL21ldGFkYXRhLmpzb24nKTtcbiAgICBpZiAodHlwZW9mIHNlcnZpY2UgIT09ICdzdHJpbmcnKSBzZXJ2aWNlID0gc2VydmljZS5zZXJ2aWNlSWRlbnRpZmllcjtcbiAgICBpZiAodHlwZW9mIHNlcnZpY2UgIT09ICdzdHJpbmcnIHx8ICFtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShzZXJ2aWNlKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAhIW1ldGFkYXRhW3NlcnZpY2VdLmR1YWxzdGFja0F2YWlsYWJsZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVSZXRyeURlbGF5OiBmdW5jdGlvbiBjYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIHJldHJ5RGVsYXlPcHRpb25zLCBlcnIpIHtcbiAgICBpZiAoIXJldHJ5RGVsYXlPcHRpb25zKSByZXRyeURlbGF5T3B0aW9ucyA9IHt9O1xuICAgIHZhciBjdXN0b21CYWNrb2ZmID0gcmV0cnlEZWxheU9wdGlvbnMuY3VzdG9tQmFja29mZiB8fCBudWxsO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tQmFja29mZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGN1c3RvbUJhY2tvZmYocmV0cnlDb3VudCwgZXJyKTtcbiAgICB9XG4gICAgdmFyIGJhc2UgPSB0eXBlb2YgcmV0cnlEZWxheU9wdGlvbnMuYmFzZSA9PT0gJ251bWJlcicgPyByZXRyeURlbGF5T3B0aW9ucy5iYXNlIDogMTAwO1xuICAgIHZhciBkZWxheSA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiBiYXNlKTtcbiAgICByZXR1cm4gZGVsYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzOiBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0V2l0aFJldHJpZXMoaHR0cFJlcXVlc3QsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGh0dHAgPSBBV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBodHRwT3B0aW9ucyA9IG9wdGlvbnMuaHR0cE9wdGlvbnMgfHwge307XG4gICAgdmFyIHJldHJ5Q291bnQgPSAwO1xuXG4gICAgdmFyIGVyckNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICB2YXIgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyB8fCAwO1xuICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ1RpbWVvdXRFcnJvcicpIGVyci5yZXRyeWFibGUgPSB0cnVlO1xuXG4gICAgICAvLyBDYWxsIGBjYWxjdWxhdGVSZXRyeURlbGF5KClgIG9ubHkgd2hlbiByZWxldmFudCwgc2VlICMzNDAxXG4gICAgICBpZiAoZXJyICYmIGVyci5yZXRyeWFibGUgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gdXRpbC5jYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIG9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMsIGVycik7XG4gICAgICAgIGlmIChkZWxheSA+PSAwKSB7XG4gICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgIHNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIGRlbGF5ICsgKGVyci5yZXRyeUFmdGVyIHx8IDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNiKGVycik7XG4gICAgfTtcblxuICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgPSAnJztcbiAgICAgIGh0dHAuaGFuZGxlUmVxdWVzdChodHRwUmVxdWVzdCwgaHR0cE9wdGlvbnMsIGZ1bmN0aW9uKGh0dHBSZXNwb25zZSkge1xuICAgICAgICBodHRwUmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykgeyBkYXRhICs9IGNodW5rLnRvU3RyaW5nKCk7IH0pO1xuICAgICAgICBodHRwUmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmV0cnlBZnRlciA9IHBhcnNlSW50KGh0dHBSZXNwb25zZS5oZWFkZXJzWydyZXRyeS1hZnRlciddLCAxMCkgKiAxMDAwIHx8IDA7XG4gICAgICAgICAgICB2YXIgZXJyID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgcmV0cnlhYmxlOiBzdGF0dXNDb2RlID49IDUwMCB8fCBzdGF0dXNDb2RlID09PSA0MjlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyICYmIGVyci5yZXRyeWFibGUpIGVyci5yZXRyeUFmdGVyID0gcmV0cnlBZnRlcjtcbiAgICAgICAgICAgIGVyckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVyckNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgQVdTLnV0aWwuZGVmZXIoc2VuZFJlcXVlc3QpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHV1aWQ6IHtcbiAgICB2NDogZnVuY3Rpb24gdXVpZFY0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ3V1aWQnKS52NCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb252ZXJ0UGF5bG9hZFRvU3RyaW5nOiBmdW5jdGlvbiBjb252ZXJ0UGF5bG9hZFRvU3RyaW5nKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb24gPSByZXEub3BlcmF0aW9uO1xuICAgIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0ub3V0cHV0IHx8IHt9O1xuICAgIGlmIChydWxlcy5wYXlsb2FkICYmIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSkge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFJlcXVlc3RQYXlsb2FkU2hhcGU6IGZ1bmN0aW9uIGdldFJlcXVlc3RQYXlsb2FkU2hhcGUocmVxKSB7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucztcbiAgICBpZiAoIW9wZXJhdGlvbnMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG9wZXJhdGlvbiA9IChvcGVyYXRpb25zIHx8IHt9KVtyZXEub3BlcmF0aW9uXTtcbiAgICBpZiAoIW9wZXJhdGlvbiB8fCAhb3BlcmF0aW9uLmlucHV0IHx8ICFvcGVyYXRpb24uaW5wdXQucGF5bG9hZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gb3BlcmF0aW9uLmlucHV0Lm1lbWJlcnNbb3BlcmF0aW9uLmlucHV0LnBheWxvYWRdO1xuICB9LFxuXG4gIGdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZzogZnVuY3Rpb24gZ2V0UHJvZmlsZXNGcm9tU2hhcmVkQ29uZmlnKGluaUxvYWRlciwgZmlsZW5hbWUpIHtcbiAgICB2YXIgcHJvZmlsZXMgPSB7fTtcbiAgICB2YXIgcHJvZmlsZXNGcm9tQ29uZmlnID0ge307XG4gICAgaWYgKHByb2Nlc3MuZW52W3V0aWwuY29uZmlnT3B0SW5FbnZdKSB7XG4gICAgICB2YXIgcHJvZmlsZXNGcm9tQ29uZmlnID0gaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgICAgaXNDb25maWc6IHRydWUsXG4gICAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudlt1dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByb2ZpbGVzRnJvbUNyZWRzPSB7fTtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb2ZpbGVzRnJvbUNyZWRzID0gaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lIHx8XG4gICAgICAgICAgKHByb2Nlc3MuZW52W3V0aWwuY29uZmlnT3B0SW5FbnZdICYmIHByb2Nlc3MuZW52W3V0aWwuc2hhcmVkQ3JlZGVudGlhbHNGaWxlRW52XSlcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBpZiB1c2luZyBjb25maWcsIGFzc3VtZSBpdCBpcyBmdWxseSBkZXNjcmlwdGl2ZSB3aXRob3V0IGEgY3JlZGVudGlhbHMgZmlsZTpcbiAgICAgIGlmICghcHJvY2Vzcy5lbnZbdXRpbC5jb25maWdPcHRJbkVudl0pIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgcHJvZmlsZU5hbWVzID0gT2JqZWN0LmtleXMocHJvZmlsZXNGcm9tQ29uZmlnKTsgaSA8IHByb2ZpbGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvZmlsZXNbcHJvZmlsZU5hbWVzW2ldXSA9IG9iamVjdEFzc2lnbihwcm9maWxlc1twcm9maWxlTmFtZXNbaV1dIHx8IHt9LCBwcm9maWxlc0Zyb21Db25maWdbcHJvZmlsZU5hbWVzW2ldXSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBwcm9maWxlTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9maWxlc0Zyb21DcmVkcyk7IGkgPCBwcm9maWxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gPSBvYmplY3RBc3NpZ24ocHJvZmlsZXNbcHJvZmlsZU5hbWVzW2ldXSB8fCB7fSwgcHJvZmlsZXNGcm9tQ3JlZHNbcHJvZmlsZU5hbWVzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9maWxlcztcblxuICAgIC8qKlxuICAgICAqIFJvdWdobHkgdGhlIHNlbWFudGljcyBvZiBgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlgXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0QXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldFtrZXlzW2ldXSA9IHNvdXJjZVtrZXlzW2ldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIEFSTjoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZUFSTihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIgJiYgc3RyLmluZGV4T2YoJ2FybjonKSA9PT0gMCAmJiBzdHIuc3BsaXQoJzonKS5sZW5ndGggPj0gNjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZUFSTihhcm4pIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYXJuLnNwbGl0KCc6Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0aXRpb246IG1hdGNoZWRbMV0sXG4gICAgICAgIHNlcnZpY2U6IG1hdGNoZWRbMl0sXG4gICAgICAgIHJlZ2lvbjogbWF0Y2hlZFszXSxcbiAgICAgICAgYWNjb3VudElkOiBtYXRjaGVkWzRdLFxuICAgICAgICByZXNvdXJjZTogbWF0Y2hlZC5zbGljZSg1KS5qb2luKCc6JylcbiAgICAgIH07XG4gICAgfSxcbiAgICBidWlsZDogZnVuY3Rpb24gYnVpbGRBUk4oYXJuT2JqZWN0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGFybk9iamVjdC5zZXJ2aWNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJuT2JqZWN0LnJlZ2lvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFybk9iamVjdC5hY2NvdW50SWQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhcm5PYmplY3QucmVzb3VyY2UgPT09IHVuZGVmaW5lZFxuICAgICAgKSB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignSW5wdXQgQVJOIG9iamVjdCBpcyBpbnZhbGlkJykpO1xuICAgICAgcmV0dXJuICdhcm46JysgKGFybk9iamVjdC5wYXJ0aXRpb24gfHwgJ2F3cycpICsgJzonICsgYXJuT2JqZWN0LnNlcnZpY2UgK1xuICAgICAgICAnOicgKyBhcm5PYmplY3QucmVnaW9uICsgJzonICsgYXJuT2JqZWN0LmFjY291bnRJZCArICc6JyArIGFybk9iamVjdC5yZXNvdXJjZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdFByb2ZpbGU6ICdkZWZhdWx0JyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25maWdPcHRJbkVudjogJ0FXU19TREtfTE9BRF9DT05GSUcnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNoYXJlZENyZWRlbnRpYWxzRmlsZUVudjogJ0FXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRScsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2hhcmVkQ29uZmlnRmlsZUVudjogJ0FXU19DT05GSUdfRklMRScsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW1kc0Rpc2FibGVkRW52OiAnQVdTX0VDMl9NRVRBREFUQV9ESVNBQkxFRCdcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFhtbE5vZGUgPSByZXF1aXJlKCcuL3htbC1ub2RlJykuWG1sTm9kZTtcbnZhciBYbWxUZXh0ID0gcmVxdWlyZSgnLi94bWwtdGV4dCcpLlhtbFRleHQ7XG5cbmZ1bmN0aW9uIFhtbEJ1aWxkZXIoKSB7IH1cblxuWG1sQnVpbGRlci5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihwYXJhbXMsIHNoYXBlLCByb290RWxlbWVudCwgbm9FbXB0eSkge1xuICB2YXIgeG1sID0gbmV3IFhtbE5vZGUocm9vdEVsZW1lbnQpO1xuICBhcHBseU5hbWVzcGFjZXMoeG1sLCBzaGFwZSwgdHJ1ZSk7XG4gIHNlcmlhbGl6ZSh4bWwsIHBhcmFtcywgc2hhcGUpO1xuICByZXR1cm4geG1sLmNoaWxkcmVuLmxlbmd0aCA+IDAgfHwgbm9FbXB0eSA/IHhtbC50b1N0cmluZygpIDogJyc7XG59O1xuXG5mdW5jdGlvbiBzZXJpYWxpemUoeG1sLCB2YWx1ZSwgc2hhcGUpIHtcbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHNlcmlhbGl6ZVN0cnVjdHVyZSh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHNlcmlhbGl6ZU1hcCh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiBzZXJpYWxpemVMaXN0KHhtbCwgdmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gc2VyaWFsaXplU2NhbGFyKHhtbCwgdmFsdWUsIHNoYXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3R1cmUoeG1sLCBwYXJhbXMsIHNoYXBlKSB7XG4gIHV0aWwuYXJyYXlFYWNoKHNoYXBlLm1lbWJlck5hbWVzLCBmdW5jdGlvbihtZW1iZXJOYW1lKSB7XG4gICAgdmFyIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1ttZW1iZXJOYW1lXTtcbiAgICBpZiAobWVtYmVyU2hhcGUubG9jYXRpb24gIT09ICdib2R5JykgcmV0dXJuO1xuXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW21lbWJlck5hbWVdO1xuICAgIHZhciBuYW1lID0gbWVtYmVyU2hhcGUubmFtZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1lbWJlclNoYXBlLmlzWG1sQXR0cmlidXRlKSB7XG4gICAgICAgIHhtbC5hZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChtZW1iZXJTaGFwZS5mbGF0dGVuZWQpIHtcbiAgICAgICAgc2VyaWFsaXplKHhtbCwgdmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gbmV3IFhtbE5vZGUobmFtZSk7XG4gICAgICAgIHhtbC5hZGRDaGlsZE5vZGUoZWxlbWVudCk7XG4gICAgICAgIGFwcGx5TmFtZXNwYWNlcyhlbGVtZW50LCBtZW1iZXJTaGFwZSk7XG4gICAgICAgIHNlcmlhbGl6ZShlbGVtZW50LCB2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1hcCh4bWwsIG1hcCwgc2hhcGUpIHtcbiAgdmFyIHhtbEtleSA9IHNoYXBlLmtleS5uYW1lIHx8ICdrZXknO1xuICB2YXIgeG1sVmFsdWUgPSBzaGFwZS52YWx1ZS5uYW1lIHx8ICd2YWx1ZSc7XG5cbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IG5ldyBYbWxOb2RlKHNoYXBlLmZsYXR0ZW5lZCA/IHNoYXBlLm5hbWUgOiAnZW50cnknKTtcbiAgICB4bWwuYWRkQ2hpbGROb2RlKGVudHJ5KTtcblxuICAgIHZhciBlbnRyeUtleSA9IG5ldyBYbWxOb2RlKHhtbEtleSk7XG4gICAgdmFyIGVudHJ5VmFsdWUgPSBuZXcgWG1sTm9kZSh4bWxWYWx1ZSk7XG4gICAgZW50cnkuYWRkQ2hpbGROb2RlKGVudHJ5S2V5KTtcbiAgICBlbnRyeS5hZGRDaGlsZE5vZGUoZW50cnlWYWx1ZSk7XG5cbiAgICBzZXJpYWxpemUoZW50cnlLZXksIGtleSwgc2hhcGUua2V5KTtcbiAgICBzZXJpYWxpemUoZW50cnlWYWx1ZSwgdmFsdWUsIHNoYXBlLnZhbHVlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUxpc3QoeG1sLCBsaXN0LCBzaGFwZSkge1xuICBpZiAoc2hhcGUuZmxhdHRlbmVkKSB7XG4gICAgdXRpbC5hcnJheUVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBuYW1lID0gc2hhcGUubWVtYmVyLm5hbWUgfHwgc2hhcGUubmFtZTtcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IFhtbE5vZGUobmFtZSk7XG4gICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgc2VyaWFsaXplKGVsZW1lbnQsIHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNoYXBlLm1lbWJlci5uYW1lIHx8ICdtZW1iZXInO1xuICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgWG1sTm9kZShuYW1lKTtcbiAgICAgIHhtbC5hZGRDaGlsZE5vZGUoZWxlbWVudCk7XG4gICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU2NhbGFyKHhtbCwgdmFsdWUsIHNoYXBlKSB7XG4gIHhtbC5hZGRDaGlsZE5vZGUoXG4gICAgbmV3IFhtbFRleHQoc2hhcGUudG9XaXJlRm9ybWF0KHZhbHVlKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlOYW1lc3BhY2VzKHhtbCwgc2hhcGUsIGlzUm9vdCkge1xuICB2YXIgdXJpLCBwcmVmaXggPSAneG1sbnMnO1xuICBpZiAoc2hhcGUueG1sTmFtZXNwYWNlVXJpKSB7XG4gICAgdXJpID0gc2hhcGUueG1sTmFtZXNwYWNlVXJpO1xuICAgIGlmIChzaGFwZS54bWxOYW1lc3BhY2VQcmVmaXgpIHByZWZpeCArPSAnOicgKyBzaGFwZS54bWxOYW1lc3BhY2VQcmVmaXg7XG4gIH0gZWxzZSBpZiAoaXNSb290ICYmIHNoYXBlLmFwaS54bWxOYW1lc3BhY2VVcmkpIHtcbiAgICB1cmkgPSBzaGFwZS5hcGkueG1sTmFtZXNwYWNlVXJpO1xuICB9XG5cbiAgaWYgKHVyaSkgeG1sLmFkZEF0dHJpYnV0ZShwcmVmaXgsIHVyaSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gWG1sQnVpbGRlcjtcbiIsIi8qKlxuICogRXNjYXBlcyBjaGFyYWN0ZXJzIHRoYXQgY2FuIG5vdCBiZSBpbiBhbiBYTUwgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBlc2NhcGVBdHRyaWJ1dGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC8nL2csICcmYXBvczsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXNjYXBlQXR0cmlidXRlOiBlc2NhcGVBdHRyaWJ1dGVcbn07XG4iLCIvKipcbiAqIEVzY2FwZXMgY2hhcmFjdGVycyB0aGF0IGNhbiBub3QgYmUgaW4gYW4gWE1MIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUVsZW1lbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnJiN4MEQ7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICcmI3gwQTsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMDg1L2csICcmI3g4NTsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4LywgJyYjeDIwMjg7Jyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVzY2FwZUVsZW1lbnQ6IGVzY2FwZUVsZW1lbnRcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHV0aWwgPSBBV1MudXRpbDtcbnZhciBTaGFwZSA9IEFXUy5Nb2RlbC5TaGFwZTtcblxudmFyIHhtbDJqcyA9IHJlcXVpcmUoJ3htbDJqcycpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgb3B0aW9ucyA9IHsgIC8vIG9wdGlvbnMgcGFzc2VkIHRvIHhtbDJqcyBwYXJzZXJcbiAgZXhwbGljaXRDaGFya2V5OiBmYWxzZSwgLy8gdW5kb2N1bWVudGVkXG4gIHRyaW06IGZhbHNlLCAgICAgICAgICAgIC8vIHRyaW0gdGhlIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIHRleHQgbm9kZXNcbiAgbm9ybWFsaXplOiBmYWxzZSwgICAgICAgLy8gdHJpbSBpbnRlcmlvciB3aGl0ZXNwYWNlIGluc2lkZSB0ZXh0IG5vZGVzXG4gIGV4cGxpY2l0Um9vdDogZmFsc2UsICAgIC8vIHJldHVybiB0aGUgcm9vdCBub2RlIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0P1xuICBlbXB0eVRhZzogbnVsbCwgICAgICAgICAvLyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgZW1wdHkgbm9kZXNcbiAgZXhwbGljaXRBcnJheTogdHJ1ZSwgICAgLy8gYWx3YXlzIHB1dCBjaGlsZCBub2RlcyBpbiBhbiBhcnJheVxuICBpZ25vcmVBdHRyczogZmFsc2UsICAgICAvLyBpZ25vcmUgYXR0cmlidXRlcywgb25seSBjcmVhdGUgdGV4dCBub2Rlc1xuICBtZXJnZUF0dHJzOiBmYWxzZSwgICAgICAvLyBtZXJnZSBhdHRyaWJ1dGVzIGFuZCBjaGlsZCBlbGVtZW50c1xuICB2YWxpZGF0b3I6IG51bGwgICAgICAgICAvLyBhIGNhbGxhYmxlIHZhbGlkYXRvclxufTtcblxuZnVuY3Rpb24gTm9kZVhtbFBhcnNlcigpIHsgfVxuXG5Ob2RlWG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHhtbCwgc2hhcGUpIHtcbiAgc2hhcGUgPSBzaGFwZSB8fCB7fTtcblxuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGVycm9yID0gbnVsbDtcblxuICB2YXIgcGFyc2VyID0gbmV3IHhtbDJqcy5QYXJzZXIob3B0aW9ucyk7XG4gIHBhcnNlci5wYXJzZVN0cmluZyh4bWwsIGZ1bmN0aW9uIChlLCByKSB7XG4gICAgZXJyb3IgPSBlO1xuICAgIHJlc3VsdCA9IHI7XG4gIH0pO1xuXG4gIGlmIChyZXN1bHQpIHtcbiAgICB2YXIgZGF0YSA9IHBhcnNlWG1sKHJlc3VsdCwgc2hhcGUpO1xuICAgIGlmIChyZXN1bHQuUmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgZGF0YS5SZXNwb25zZU1ldGFkYXRhID0gcGFyc2VYbWwocmVzdWx0LlJlc3BvbnNlTWV0YWRhdGFbMF0sIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyB1dGlsLmVycm9yKGVycm9yLCB7Y29kZTogJ1hNTFBhcnNlckVycm9yJywgcmV0cnlhYmxlOiB0cnVlfSk7XG4gIH0gZWxzZSB7IC8vIGVtcHR5IHhtbCBkb2N1bWVudFxuICAgIHJldHVybiBwYXJzZVhtbCh7fSwgc2hhcGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZVhtbCh4bWwsIHNoYXBlKSB7XG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiBwYXJzZVN0cnVjdHVyZSh4bWwsIHNoYXBlKTtcbiAgICBjYXNlICdtYXAnOiByZXR1cm4gcGFyc2VNYXAoeG1sLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiBwYXJzZUxpc3QoeG1sLCBzaGFwZSk7XG4gICAgY2FzZSB1bmRlZmluZWQ6IGNhc2UgbnVsbDogcmV0dXJuIHBhcnNlVW5rbm93bih4bWwpO1xuICAgIGRlZmF1bHQ6IHJldHVybiBwYXJzZVNjYWxhcih4bWwsIHNoYXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cnVjdHVyZSh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0ge307XG4gIGlmICh4bWwgPT09IG51bGwpIHJldHVybiBkYXRhO1xuXG4gIHV0aWwuZWFjaChzaGFwZS5tZW1iZXJzLCBmdW5jdGlvbihtZW1iZXJOYW1lLCBtZW1iZXJTaGFwZSkge1xuICAgIHZhciB4bWxOYW1lID0gbWVtYmVyU2hhcGUubmFtZTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHhtbCwgeG1sTmFtZSkgJiYgQXJyYXkuaXNBcnJheSh4bWxbeG1sTmFtZV0pKSB7XG4gICAgICB2YXIgeG1sQ2hpbGQgPSB4bWxbeG1sTmFtZV07XG4gICAgICBpZiAoIW1lbWJlclNoYXBlLmZsYXR0ZW5lZCkgeG1sQ2hpbGQgPSB4bWxDaGlsZFswXTtcblxuICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IHBhcnNlWG1sKHhtbENoaWxkLCBtZW1iZXJTaGFwZSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXJTaGFwZS5pc1htbEF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgICAgeG1sLiQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHhtbC4kLCB4bWxOYW1lKSkge1xuICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IHBhcnNlU2NhbGFyKHhtbC4kW3htbE5hbWVdLCBtZW1iZXJTaGFwZSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXJTaGFwZS50eXBlID09PSAnbGlzdCcgJiYgIXNoYXBlLmFwaS54bWxOb0RlZmF1bHRMaXN0cykge1xuICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IG1lbWJlclNoYXBlLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hcCh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0ge307XG4gIGlmICh4bWwgPT09IG51bGwpIHJldHVybiBkYXRhO1xuXG4gIHZhciB4bWxLZXkgPSBzaGFwZS5rZXkubmFtZSB8fCAna2V5JztcbiAgdmFyIHhtbFZhbHVlID0gc2hhcGUudmFsdWUubmFtZSB8fCAndmFsdWUnO1xuICB2YXIgaXRlcmFibGUgPSBzaGFwZS5mbGF0dGVuZWQgPyB4bWwgOiB4bWwuZW50cnk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgdXRpbC5hcnJheUVhY2goaXRlcmFibGUsIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBkYXRhW2NoaWxkW3htbEtleV1bMF1dID0gcGFyc2VYbWwoY2hpbGRbeG1sVmFsdWVdWzBdLCBzaGFwZS52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXN0KHhtbCwgc2hhcGUpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdmFyIG5hbWUgPSBzaGFwZS5tZW1iZXIubmFtZSB8fCAnbWVtYmVyJztcbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHV0aWwuYXJyYXlFYWNoKHhtbCwgZnVuY3Rpb24oeG1sQ2hpbGQpIHtcbiAgICAgIGRhdGEucHVzaChwYXJzZVhtbCh4bWxDaGlsZCwgc2hhcGUubWVtYmVyKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoeG1sICYmIEFycmF5LmlzQXJyYXkoeG1sW25hbWVdKSkge1xuICAgIHV0aWwuYXJyYXlFYWNoKHhtbFtuYW1lXSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGRhdGEucHVzaChwYXJzZVhtbChjaGlsZCwgc2hhcGUubWVtYmVyKSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTY2FsYXIodGV4dCwgc2hhcGUpIHtcbiAgaWYgKHRleHQgJiYgdGV4dC4kICYmIHRleHQuJC5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICBzaGFwZSA9IG5ldyBTaGFwZS5jcmVhdGUoe3R5cGU6IHRleHQuJC5lbmNvZGluZ30pO1xuICB9XG4gIGlmICh0ZXh0ICYmIHRleHQuXykgdGV4dCA9IHRleHQuXztcblxuICBpZiAodHlwZW9mIHNoYXBlLnRvVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaGFwZS50b1R5cGUodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VVbmtub3duKHhtbCkge1xuICBpZiAoeG1sID09PSB1bmRlZmluZWQgfHwgeG1sID09PSBudWxsKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgeG1sID09PSAnc3RyaW5nJykgcmV0dXJuIHhtbDtcblxuICAvLyBwYXJzZSBhIGxpc3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoeG1sKSkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeG1sLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIucHVzaChwYXJzZVhtbCh4bWxbaV0sIHt9KSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICAvLyBlbXB0eSBvYmplY3RcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh4bWwpLCBpO1xuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgfHwgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICckJykpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBvYmplY3QsIHBhcnNlIGFzIHN0cnVjdHVyZVxuICB2YXIgZGF0YSA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IHhtbFtrZXldO1xuICAgIGlmIChrZXkgPT09ICckJykgY29udGludWU7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHsgLy8gdGhpcyBtZW1iZXIgaXMgYSBsaXN0XG4gICAgICBkYXRhW2tleV0gPSBwYXJzZUxpc3QodmFsdWUsIHttZW1iZXI6IHt9fSk7XG4gICAgfSBlbHNlIHsgLy8gdGhpcyBtZW1iZXIgaXMgYSBzaW5nbGUgaXRlbVxuICAgICAgZGF0YVtrZXldID0gcGFyc2VYbWwodmFsdWVbMF0sIHt9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTm9kZVhtbFBhcnNlcjtcbiIsInZhciBlc2NhcGVBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2VzY2FwZS1hdHRyaWJ1dGUnKS5lc2NhcGVBdHRyaWJ1dGU7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBYTUwgbm9kZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBYbWxOb2RlKG5hbWUsIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xufVxuWG1sTm9kZS5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuWG1sTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGROb2RlID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5YbWxOb2RlLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuWG1sTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc0NoaWxkcmVuID0gQm9vbGVhbih0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgdmFyIHhtbFRleHQgPSAnPCcgKyB0aGlzLm5hbWU7XG4gICAgLy8gYWRkIGF0dHJpYnV0ZXNcbiAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMCwgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTsgaSA8IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB4bWxUZXh0ICs9ICcgJyArIGF0dHJpYnV0ZU5hbWUgKyAnPVxcXCInICsgZXNjYXBlQXR0cmlidXRlKCcnICsgYXR0cmlidXRlKSArICdcXFwiJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geG1sVGV4dCArPSAhaGFzQ2hpbGRyZW4gPyAnLz4nIDogJz4nICsgdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9TdHJpbmcoKTsgfSkuam9pbignJykgKyAnPC8nICsgdGhpcy5uYW1lICsgJz4nO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgWG1sTm9kZTogWG1sTm9kZVxufTtcbiIsInZhciBlc2NhcGVFbGVtZW50ID0gcmVxdWlyZSgnLi9lc2NhcGUtZWxlbWVudCcpLmVzY2FwZUVsZW1lbnQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBYTUwgdGV4dCB2YWx1ZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBYbWxUZXh0KHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5YbWxUZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXNjYXBlRWxlbWVudCgnJyArIHRoaXMudmFsdWUpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgWG1sVGV4dDogWG1sVGV4dFxufTtcbiIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiBub2RlLmpzXG4vLyB0aGlzIGlzIHByZXR0eSBzdHJhaWdodC1mb3J3YXJkIC0gd2UgdXNlIHRoZSBjcnlwdG8gQVBJLlxuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9kZVJORygpIHtcbiAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcygxNik7XG59O1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTFJVXzEgPSByZXF1aXJlKFwiLi91dGlscy9MUlVcIik7XG52YXIgQ0FDSEVfU0laRSA9IDEwMDA7XG4vKipcbiAqIEluc3BpcmVkIG5vZGUtbHJ1LWNhY2hlW2h0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1scnUtY2FjaGVdXG4gKi9cbnZhciBFbmRwb2ludENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVuZHBvaW50Q2FjaGUobWF4U2l6ZSkge1xuICAgICAgICBpZiAobWF4U2l6ZSA9PT0gdm9pZCAwKSB7IG1heFNpemUgPSBDQUNIRV9TSVpFOyB9XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTFJVXzEuTFJVQ2FjaGUobWF4U2l6ZSk7XG4gICAgfVxuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGtleVN0cmluZyA9IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnID8gRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcoa2V5KSA6IGtleTtcbiAgICAgICAgdmFyIGVuZHBvaW50UmVjb3JkID0gdGhpcy5wb3B1bGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jYWNoZS5wdXQoa2V5U3RyaW5nLCBlbmRwb2ludFJlY29yZCk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIga2V5U3RyaW5nID0gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgPyBFbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhrZXkpIDoga2V5O1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLmNhY2hlLmdldChrZXlTdHJpbmcpO1xuICAgICAgICBpZiAocmVjb3Jkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJlY29yZHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5FeHBpcmUgPCBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5yZW1vdmUoa2V5U3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgICB2YXIgaWRlbnRpZmllck5hbWVzID0gT2JqZWN0LmtleXMoa2V5KS5zb3J0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRlbnRpZmllck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllck5hbWUgPSBpZGVudGlmaWVyTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5W2lkZW50aWZpZXJOYW1lXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaChrZXlbaWRlbnRpZmllck5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRlbnRpZmllcnMuam9pbignICcpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucG9wdWxhdGVWYWx1ZSA9IGZ1bmN0aW9uIChlbmRwb2ludHMpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBlbmRwb2ludHMubWFwKGZ1bmN0aW9uIChlbmRwb2ludCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIEFkZHJlc3M6IGVuZHBvaW50LkFkZHJlc3MgfHwgJycsXG4gICAgICAgICAgICBFeHBpcmU6IG5vdyArIChlbmRwb2ludC5DYWNoZVBlcmlvZEluTWludXRlcyB8fCAxKSAqIDYwICogMTAwMFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5lbXB0eSgpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGtleVN0cmluZyA9IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnID8gRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcoa2V5KSA6IGtleTtcbiAgICAgICAgdGhpcy5jYWNoZS5yZW1vdmUoa2V5U3RyaW5nKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmRwb2ludENhY2hlO1xufSgpKTtcbmV4cG9ydHMuRW5kcG9pbnRDYWNoZSA9IEVuZHBvaW50Q2FjaGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlua2VkTGlzdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdE5vZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTGlua2VkTGlzdE5vZGU7XG59KCkpO1xudmFyIExSVUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExSVUNhY2hlKHNpemUpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwID0ge307XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicgfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FjaGUgc2l6ZSBjYW4gb25seSBiZSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVMaW1pdCA9IHNpemU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucHJlcGVuZFRvTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWxOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZGVyTm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlck5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmVGcm9tVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhaWxOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy50YWlsTm9kZTtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gbm9kZS5wcmV2O1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgIHByZXZOb2RlLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRhaWxOb2RlID0gcHJldk5vZGU7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5kZXRhY2hGcm9tTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlck5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YWlsTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgdGhpcy50YWlsTm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wcmV2KSB7XG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgICAgICB0aGlzLmRldGFjaEZyb21MaXN0KG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcmVwZW5kVG9MaXN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVNYXBba2V5XSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRnJvbUxpc3Qobm9kZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaXplID09PSB0aGlzLnNpemVMaW1pdCkge1xuICAgICAgICAgICAgdmFyIHRhaWxOb2RlID0gdGhpcy5yZW1vdmVGcm9tVGFpbCgpO1xuICAgICAgICAgICAgdmFyIGtleV8xID0gdGFpbE5vZGUua2V5O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZU1hcFtrZXlfMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGUgPSBuZXcgTGlua2VkTGlzdE5vZGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubm9kZU1hcFtrZXldID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5wcmVwZW5kVG9MaXN0KG5ld05vZGUpO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZU1hcCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hGcm9tTGlzdChub2RlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExSVUNhY2hlO1xufSgpKTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTsiLCIoZnVuY3Rpb24oZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIGlmIChvYmogIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaWN0RGVlcEVxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAvLyBDaGVjayB0aGUgc2NhbGFyIGNhc2UgZmlyc3QuXG4gICAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXkgYXJlIHRoZSBzYW1lIHR5cGUuXG4gICAgdmFyIGZpcnN0VHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmaXJzdCk7XG4gICAgaWYgKGZpcnN0VHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlY29uZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2Uga25vdyB0aGF0IGZpcnN0IGFuZCBzZWNvbmQgaGF2ZSB0aGUgc2FtZSB0eXBlIHNvIHdlIGNhbiBqdXN0IGNoZWNrIHRoZVxuICAgIC8vIGZpcnN0IHR5cGUgZnJvbSBub3cgb24uXG4gICAgaWYgKGlzQXJyYXkoZmlyc3QpID09PSB0cnVlKSB7XG4gICAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHRoZXkncmUgbm90IHRoZSBzYW1lIGxlbmd0aDtcbiAgICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyaWN0RGVlcEVxdWFsKGZpcnN0W2ldLCBzZWNvbmRbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIEFuIG9iamVjdCBpcyBlcXVhbCBpZiBpdCBoYXMgdGhlIHNhbWUga2V5L3ZhbHVlIHBhaXJzLlxuICAgICAgdmFyIGtleXNTZWVuID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZmlyc3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZmlyc3QsIGtleSkpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0RGVlcEVxdWFsKGZpcnN0W2tleV0sIHNlY29uZFtrZXldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5c1NlZW5ba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE5vdyBjaGVjayB0aGF0IHRoZXJlIGFyZW4ndCBhbnkga2V5cyBpbiBzZWNvbmQgdGhhdCB3ZXJlbid0XG4gICAgICAvLyBpbiBmaXJzdC5cbiAgICAgIGZvciAodmFyIGtleTIgaW4gc2Vjb25kKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNlY29uZCwga2V5MikpIHtcbiAgICAgICAgICBpZiAoa2V5c1NlZW5ba2V5Ml0gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhbHNlKG9iaikge1xuICAgIC8vIEZyb20gdGhlIHNwZWM6XG4gICAgLy8gQSBmYWxzZSB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICAvLyBFbXB0eSBsaXN0XG4gICAgLy8gRW1wdHkgb2JqZWN0XG4gICAgLy8gRW1wdHkgc3RyaW5nXG4gICAgLy8gRmFsc2UgYm9vbGVhblxuICAgIC8vIG51bGwgdmFsdWVcblxuICAgIC8vIEZpcnN0IGNoZWNrIHRoZSBzY2FsYXIgdmFsdWVzLlxuICAgIGlmIChvYmogPT09IFwiXCIgfHwgb2JqID09PSBmYWxzZSB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgYW4gZW1wdHkgYXJyYXkuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGtleXMsIHRoZW5cbiAgICAgICAgICAgIC8vIHRoZSBvYmplY3QgaXMgbm90IGVtcHR5IHNvIHRoZSBvYmplY3RcbiAgICAgICAgICAgIC8vIGlzIG5vdCBmYWxzZS5cbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9ialZhbHVlcyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBhW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkyIGluIGIpIHtcbiAgICAgICAgICBtZXJnZWRba2V5Ml0gPSBiW2tleTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuXG4gIHZhciB0cmltTGVmdDtcbiAgaWYgKHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW1MZWZ0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltTGVmdCgpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdHJpbUxlZnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIubWF0Y2goL15cXHMqKC4qKS8pWzFdO1xuICAgIH07XG4gIH1cblxuICAvLyBUeXBlIGNvbnN0YW50cyB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gIHZhciBUWVBFX05VTUJFUiA9IDA7XG4gIHZhciBUWVBFX0FOWSA9IDE7XG4gIHZhciBUWVBFX1NUUklORyA9IDI7XG4gIHZhciBUWVBFX0FSUkFZID0gMztcbiAgdmFyIFRZUEVfT0JKRUNUID0gNDtcbiAgdmFyIFRZUEVfQk9PTEVBTiA9IDU7XG4gIHZhciBUWVBFX0VYUFJFRiA9IDY7XG4gIHZhciBUWVBFX05VTEwgPSA3O1xuICB2YXIgVFlQRV9BUlJBWV9OVU1CRVIgPSA4O1xuICB2YXIgVFlQRV9BUlJBWV9TVFJJTkcgPSA5O1xuICB2YXIgVFlQRV9OQU1FX1RBQkxFID0ge1xuICAgIDA6ICdudW1iZXInLFxuICAgIDE6ICdhbnknLFxuICAgIDI6ICdzdHJpbmcnLFxuICAgIDM6ICdhcnJheScsXG4gICAgNDogJ29iamVjdCcsXG4gICAgNTogJ2Jvb2xlYW4nLFxuICAgIDY6ICdleHByZXNzaW9uJyxcbiAgICA3OiAnbnVsbCcsXG4gICAgODogJ0FycmF5PG51bWJlcj4nLFxuICAgIDk6ICdBcnJheTxzdHJpbmc+J1xuICB9O1xuXG4gIHZhciBUT0tfRU9GID0gXCJFT0ZcIjtcbiAgdmFyIFRPS19VTlFVT1RFRElERU5USUZJRVIgPSBcIlVucXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1FVT1RFRElERU5USUZJRVIgPSBcIlF1b3RlZElkZW50aWZpZXJcIjtcbiAgdmFyIFRPS19SQlJBQ0tFVCA9IFwiUmJyYWNrZXRcIjtcbiAgdmFyIFRPS19SUEFSRU4gPSBcIlJwYXJlblwiO1xuICB2YXIgVE9LX0NPTU1BID0gXCJDb21tYVwiO1xuICB2YXIgVE9LX0NPTE9OID0gXCJDb2xvblwiO1xuICB2YXIgVE9LX1JCUkFDRSA9IFwiUmJyYWNlXCI7XG4gIHZhciBUT0tfTlVNQkVSID0gXCJOdW1iZXJcIjtcbiAgdmFyIFRPS19DVVJSRU5UID0gXCJDdXJyZW50XCI7XG4gIHZhciBUT0tfRVhQUkVGID0gXCJFeHByZWZcIjtcbiAgdmFyIFRPS19QSVBFID0gXCJQaXBlXCI7XG4gIHZhciBUT0tfT1IgPSBcIk9yXCI7XG4gIHZhciBUT0tfQU5EID0gXCJBbmRcIjtcbiAgdmFyIFRPS19FUSA9IFwiRVFcIjtcbiAgdmFyIFRPS19HVCA9IFwiR1RcIjtcbiAgdmFyIFRPS19MVCA9IFwiTFRcIjtcbiAgdmFyIFRPS19HVEUgPSBcIkdURVwiO1xuICB2YXIgVE9LX0xURSA9IFwiTFRFXCI7XG4gIHZhciBUT0tfTkUgPSBcIk5FXCI7XG4gIHZhciBUT0tfRkxBVFRFTiA9IFwiRmxhdHRlblwiO1xuICB2YXIgVE9LX1NUQVIgPSBcIlN0YXJcIjtcbiAgdmFyIFRPS19GSUxURVIgPSBcIkZpbHRlclwiO1xuICB2YXIgVE9LX0RPVCA9IFwiRG90XCI7XG4gIHZhciBUT0tfTk9UID0gXCJOb3RcIjtcbiAgdmFyIFRPS19MQlJBQ0UgPSBcIkxicmFjZVwiO1xuICB2YXIgVE9LX0xCUkFDS0VUID0gXCJMYnJhY2tldFwiO1xuICB2YXIgVE9LX0xQQVJFTj0gXCJMcGFyZW5cIjtcbiAgdmFyIFRPS19MSVRFUkFMPSBcIkxpdGVyYWxcIjtcblxuICAvLyBUaGUgXCImXCIsIFwiW1wiLCBcIjxcIiwgXCI+XCIgdG9rZW5zXG4gIC8vIGFyZSBub3QgaW4gYmFzaWNUb2tlbiBiZWNhdXNlXG4gIC8vIHRoZXJlIGFyZSB0d28gdG9rZW4gdmFyaWFudHNcbiAgLy8gKFwiJiZcIiwgXCJbP1wiLCBcIjw9XCIsIFwiPj1cIikuICBUaGlzIGlzIHNwZWNpYWxseSBoYW5kbGVkXG4gIC8vIGJlbG93LlxuXG4gIHZhciBiYXNpY1Rva2VucyA9IHtcbiAgICBcIi5cIjogVE9LX0RPVCxcbiAgICBcIipcIjogVE9LX1NUQVIsXG4gICAgXCIsXCI6IFRPS19DT01NQSxcbiAgICBcIjpcIjogVE9LX0NPTE9OLFxuICAgIFwie1wiOiBUT0tfTEJSQUNFLFxuICAgIFwifVwiOiBUT0tfUkJSQUNFLFxuICAgIFwiXVwiOiBUT0tfUkJSQUNLRVQsXG4gICAgXCIoXCI6IFRPS19MUEFSRU4sXG4gICAgXCIpXCI6IFRPS19SUEFSRU4sXG4gICAgXCJAXCI6IFRPS19DVVJSRU5UXG4gIH07XG5cbiAgdmFyIG9wZXJhdG9yU3RhcnRUb2tlbiA9IHtcbiAgICAgIFwiPFwiOiB0cnVlLFxuICAgICAgXCI+XCI6IHRydWUsXG4gICAgICBcIj1cIjogdHJ1ZSxcbiAgICAgIFwiIVwiOiB0cnVlXG4gIH07XG5cbiAgdmFyIHNraXBDaGFycyA9IHtcbiAgICAgIFwiIFwiOiB0cnVlLFxuICAgICAgXCJcXHRcIjogdHJ1ZSxcbiAgICAgIFwiXFxuXCI6IHRydWVcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzQWxwaGEoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIGNoID09PSBcIl9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTnVtKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID49IFwiMFwiICYmIGNoIDw9IFwiOVwiKSB8fFxuICAgICAgICAgICAgIGNoID09PSBcIi1cIjtcbiAgfVxuICBmdW5jdGlvbiBpc0FscGhhTnVtKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID49IFwiYVwiICYmIGNoIDw9IFwielwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIkFcIiAmJiBjaCA8PSBcIlpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gTGV4ZXIoKSB7XG4gIH1cbiAgTGV4ZXIucHJvdG90eXBlID0ge1xuICAgICAgdG9rZW5pemU6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gMDtcbiAgICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgICAgdmFyIGlkZW50aWZpZXI7XG4gICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50IDwgc3RyZWFtLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaXNBbHBoYShzdHJlYW1bdGhpcy5fY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19VTlFVT1RFRElERU5USUZJRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFzaWNUb2tlbnNbc3RyZWFtW3RoaXMuX2N1cnJlbnRdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogYmFzaWNUb2tlbnNbc3RyZWFtW3RoaXMuX2N1cnJlbnRdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdHJlYW1bdGhpcy5fY3VycmVudF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5fY3VycmVudH0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTnVtKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5fY29uc3VtZU51bWJlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gaW5jcmVtZW50IHRoaXMuX2N1cnJlbnQuICBUaGlzIGhhcHBlbnNcbiAgICAgICAgICAgICAgICAgIC8vIGluIF9jb25zdW1lTEJyYWNrZXRcbiAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5fY29uc3VtZUxCcmFja2V0KHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIlxcXCJcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHRoaXMuX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1FVT1RFRElERU5USUZJRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHRoaXMuX2NvbnN1bWVSYXdTdHJpbmdMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcImBcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0aGlzLl9jb25zdW1lTGl0ZXJhbChzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19MSVRFUkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yU3RhcnRUb2tlbltzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMuX2NvbnN1bWVPcGVyYXRvcihzdHJlYW0pKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChza2lwQ2hhcnNbc3RyZWFtW3RoaXMuX2N1cnJlbnRdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIiZcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0FORCwgdmFsdWU6IFwiJiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfRVhQUkVGLCB2YWx1ZTogXCImXCIsIHN0YXJ0OiBzdGFydH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwifFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfT1IsIHZhbHVlOiBcInx8XCIsIHN0YXJ0OiBzdGFydH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1BJUEUsIHZhbHVlOiBcInxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbmtub3duIGNoYXJhY3RlcjpcIiArIHN0cmVhbVt0aGlzLl9jdXJyZW50XSk7XG4gICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJMZXhlckVycm9yXCI7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVVbnF1b3RlZElkZW50aWZpZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50IDwgc3RyZWFtLmxlbmd0aCAmJiBpc0FscGhhTnVtKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lUXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSAhPT0gXCJcXFwiXCIgJiYgdGhpcy5fY3VycmVudCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBZb3UgY2FuIGVzY2FwZSBhIGRvdWJsZSBxdW90ZSBhbmQgeW91IGNhbiBlc2NhcGUgYW4gZXNjYXBlLlxuICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgIGlmIChzdHJlYW1bY3VycmVudF0gPT09IFwiXFxcXFwiICYmIChzdHJlYW1bY3VycmVudCArIDFdID09PSBcIlxcXFxcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1bY3VycmVudCArIDFdID09PSBcIlxcXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmVhbS5zbGljZShzdGFydCwgdGhpcy5fY3VycmVudCkpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVSYXdTdHJpbmdMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIidcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgc2luZ2xlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiJ1wiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIGxpdGVyYWwgPSBzdHJlYW0uc2xpY2Uoc3RhcnQgKyAxLCB0aGlzLl9jdXJyZW50IC0gMSk7XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwucmVwbGFjZShcIlxcXFwnXCIsIFwiJ1wiKTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTnVtYmVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTlVNQkVSLCB2YWx1ZTogdmFsdWUsIHN0YXJ0OiBzdGFydH07XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZUxCcmFja2V0OiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj9cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZJTFRFUiwgdmFsdWU6IFwiWz9cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19GTEFUVEVOLCB2YWx1ZTogXCJbXVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xCUkFDS0VULCB2YWx1ZTogXCJbXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVPcGVyYXRvcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFyID0gc3RyZWFtW3N0YXJ0XTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX05FLCB2YWx1ZTogXCIhPVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX05PVCwgdmFsdWU6IFwiIVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXIgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19MVEUsIHZhbHVlOiBcIjw9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19MVCwgdmFsdWU6IFwiPFwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19HVEUsIHZhbHVlOiBcIj49XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19HVCwgdmFsdWU6IFwiPlwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19FUSwgdmFsdWU6IFwiPT1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTGl0ZXJhbDogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGxpdGVyYWw7XG4gICAgICAgICAgd2hpbGUoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcImBcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgbGl0ZXJhbCBjaGFyIG9yIHlvdSBjYW4gZXNjYXBlIHRoZSBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiYFwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGl0ZXJhbFN0cmluZyA9IHRyaW1MZWZ0KHN0cmVhbS5zbGljZShzdGFydCwgdGhpcy5fY3VycmVudCkpO1xuICAgICAgICAgIGxpdGVyYWxTdHJpbmcgPSBsaXRlcmFsU3RyaW5nLnJlcGxhY2UoXCJcXFxcYFwiLCBcImBcIik7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2tzTGlrZUpTT04obGl0ZXJhbFN0cmluZykpIHtcbiAgICAgICAgICAgICAgbGl0ZXJhbCA9IEpTT04ucGFyc2UobGl0ZXJhbFN0cmluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIEpTT04gcGFyc2UgaXQgYXMgXCI8bGl0ZXJhbD5cIlxuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShcIlxcXCJcIiArIGxpdGVyYWxTdHJpbmcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vICsxIGdldHMgdXMgdG8gdGhlIGVuZGluZyBcImBcIiwgKzEgdG8gbW92ZSBvbiB0byB0aGUgbmV4dCBjaGFyLlxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbDtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rc0xpa2VKU09OOiBmdW5jdGlvbihsaXRlcmFsU3RyaW5nKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0aW5nQ2hhcnMgPSBcIlt7XFxcIlwiO1xuICAgICAgICAgIHZhciBqc29uTGl0ZXJhbHMgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJudWxsXCJdO1xuICAgICAgICAgIHZhciBudW1iZXJMb29raW5nID0gXCItMDEyMzQ1Njc4OVwiO1xuXG4gICAgICAgICAgaWYgKGxpdGVyYWxTdHJpbmcgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmdDaGFycy5pbmRleE9mKGxpdGVyYWxTdHJpbmdbMF0pID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChqc29uTGl0ZXJhbHMuaW5kZXhPZihsaXRlcmFsU3RyaW5nKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyTG9va2luZy5pbmRleE9mKGxpdGVyYWxTdHJpbmdbMF0pID49IDApIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UobGl0ZXJhbFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgICAgIHZhciBiaW5kaW5nUG93ZXIgPSB7fTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRU9GXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1VOUVVPVEVESURFTlRJRklFUl0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDS0VUXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JQQVJFTl0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19DT01NQV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19SQlJBQ0VdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTlVNQkVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NVUlJFTlRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVhQUkVGXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1BJUEVdID0gMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfT1JdID0gMjtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQU5EXSA9IDM7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0VRXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0dUXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xUXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0dURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19MVEVdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTkVdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRkxBVFRFTl0gPSA5O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19TVEFSXSA9IDIwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GSUxURVJdID0gMjE7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0RPVF0gPSA0MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTk9UXSA9IDQ1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19MQlJBQ0VdID0gNTA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDS0VUXSA9IDU1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19MUEFSRU5dID0gNjA7XG5cbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICAgIHBhcnNlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy5fbG9hZFRva2VucyhleHByZXNzaW9uKTtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19FT0YpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHRva2VuIHR5cGU6IFwiICsgdC50eXBlICsgXCIsIHZhbHVlOiBcIiArIHQudmFsdWUpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH0sXG5cbiAgICAgIF9sb2FkVG9rZW5zOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgdmFyIGxleGVyID0gbmV3IExleGVyKCk7XG4gICAgICAgICAgdmFyIHRva2VucyA9IGxleGVyLnRva2VuaXplKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfRU9GLCB2YWx1ZTogXCJcIiwgc3RhcnQ6IGV4cHJlc3Npb24ubGVuZ3RofSk7XG4gICAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgbGVmdFRva2VuID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5udWQobGVmdFRva2VuKTtcbiAgICAgICAgICB2YXIgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIHdoaWxlIChyYnAgPCBiaW5kaW5nUG93ZXJbY3VycmVudFRva2VuXSkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLmxlZChjdXJyZW50VG9rZW4sIGxlZnQpO1xuICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfSxcblxuICAgICAgX2xvb2thaGVhZDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdLnR5cGU7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkVG9rZW46IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmluZGV4ICsgbnVtYmVyXTtcbiAgICAgIH0sXG5cbiAgICAgIF9hZHZhbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICB9LFxuXG4gICAgICBudWQ6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIHZhciBsZWZ0O1xuICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFRPS19MSVRFUkFMOlxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IHRva2VuLnZhbHVlfTtcbiAgICAgICAgICBjYXNlIFRPS19VTlFVT1RFRElERU5USUZJRVI6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1FVT1RFRElERU5USUZJRVI6XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHt0eXBlOiBcIkZpZWxkXCIsIG5hbWU6IHRva2VuLnZhbHVlfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19MUEFSRU4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdW90ZWQgaWRlbnRpZmllciBub3QgYWxsb3dlZCBmb3IgZnVuY3Rpb24gbmFtZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfTk9UOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk5vdCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTm90RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW3JpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfU1RBUjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhIG11bHRpc2VsZWN0LFxuICAgICAgICAgICAgICAgIC8vIFthLCBiLCAqXVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0ge3R5cGU6IFwiSWRlbnRpdHlcIn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJWYWx1ZVByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZCh0b2tlbi50eXBlLCB7dHlwZTogXCJJZGVudGl0eVwifSk7XG4gICAgICAgICAgY2FzZSBUT0tfTEJSQUNFOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogVE9LX0ZMQVRURU4sIGNoaWxkcmVuOiBbe3R5cGU6IFwiSWRlbnRpdHlcIn1dfTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GbGF0dGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19OVU1CRVIgfHwgdGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlSW5kZXhFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RJZlNsaWNlKHt0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1NUQVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkKDEpID09PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifSwgcmlnaHRdfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0TGlzdCgpO1xuICAgICAgICAgIGNhc2UgVE9LX0NVUlJFTlQ6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19DVVJSRU5UfTtcbiAgICAgICAgICBjYXNlIFRPS19FWFBSRUY6XG4gICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5FeHByZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkV4cHJlc3Npb25SZWZlcmVuY2VcIiwgY2hpbGRyZW46IFtleHByZXNzaW9uXX07XG4gICAgICAgICAgY2FzZSBUT0tfTFBBUkVOOlxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19SUEFSRU4pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0NVUlJFTlQpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0ge3R5cGU6IFRPS19DVVJSRU5UfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9lcnJvclRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbGVkOiBmdW5jdGlvbih0b2tlbk5hbWUsIGxlZnQpIHtcbiAgICAgICAgdmFyIHJpZ2h0O1xuICAgICAgICBzd2l0Y2godG9rZW5OYW1lKSB7XG4gICAgICAgICAgY2FzZSBUT0tfRE9UOlxuICAgICAgICAgICAgdmFyIHJicCA9IGJpbmRpbmdQb3dlci5Eb3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfU1RBUikge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VEb3RSSFMocmJwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiU3ViZXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGluZyBhIHByb2plY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlUHJvamVjdGlvblJIUyhyYnApO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfUElQRTpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5QaXBlKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX1BJUEUsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19PUjpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5Pcik7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiT3JFeHByZXNzaW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19BTkQ6XG4gICAgICAgICAgICByaWdodCA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuQW5kKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJBbmRFeHByZXNzaW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19MUEFSRU46XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGxlZnQubmFtZTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiwgbm9kZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19SUEFSRU4pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0NVUlJFTlQpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0ge3R5cGU6IFRPS19DVVJSRU5UfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09NTUEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfQ09NTUEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SUEFSRU4pO1xuICAgICAgICAgICAgbm9kZSA9IHt0eXBlOiBcIkZ1bmN0aW9uXCIsIG5hbWU6IG5hbWUsIGNoaWxkcmVuOiBhcmdzfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIGNhc2UgVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0ZMQVRURU4pIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkZpbHRlclByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodCwgY29uZGl0aW9uXX07XG4gICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgIHZhciBsZWZ0Tm9kZSA9IHt0eXBlOiBUT0tfRkxBVFRFTiwgY2hpbGRyZW46IFtsZWZ0XX07XG4gICAgICAgICAgICB2YXIgcmlnaHROb2RlID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GbGF0dGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdE5vZGUsIHJpZ2h0Tm9kZV19O1xuICAgICAgICAgIGNhc2UgVE9LX0VROlxuICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgIGNhc2UgVE9LX0dURTpcbiAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICBjYXNlIFRPS19MVEU6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VDb21wYXJhdG9yKGxlZnQsIHRva2VuTmFtZSk7XG4gICAgICAgICAgY2FzZSBUT0tfTEJSQUNLRVQ6XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUT0tfTlVNQkVSIHx8IHRva2VuLnR5cGUgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VJbmRleEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdElmU2xpY2UobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1NUQVIpO1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0aGlzLl9sb29rYWhlYWRUb2tlbigwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9tYXRjaDogZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gdG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIiArIHRva2VuVHlwZSArIFwiLCBnb3Q6IFwiICsgdC50eXBlKTtcbiAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2Vycm9yVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50eXBlICsgXCIpOiBcXFwiXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcblxuXG4gICAgICBfcGFyc2VJbmRleEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTiB8fCB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VTbGljZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9sb29rYWhlYWRUb2tlbigwKS52YWx1ZX07XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3Byb2plY3RJZlNsaWNlOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBpbmRleEV4cHIgPSB7dHlwZTogXCJJbmRleEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBcIlNsaWNlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtpbmRleEV4cHIsIHRoaXMuX3BhcnNlUHJvamVjdGlvblJIUyhiaW5kaW5nUG93ZXIuU3RhcildXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4RXhwcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VTbGljZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gd2hlcmUgZWFjaCBwYXJ0IGlzIG9wdGlvbmFsLCBhcyB3ZWxsIGFzIHRoZSBsYXN0XG4gICAgICAgICAgLy8gY29sb24uXG4gICAgICAgICAgdmFyIHBhcnRzID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudFRva2VuICE9PSBUT0tfUkJSQUNLRVQgJiYgaW5kZXggPCAzKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVuZXhwZWN0ZWQgdG9rZW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnRzXG4gICAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZUNvbXBhcmF0b3I6IGZ1bmN0aW9uKGxlZnQsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlcltjb21wYXJhdG9yXSk7XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJDb21wYXJhdG9yXCIsIG5hbWU6IGNvbXBhcmF0b3IsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZURvdFJIUzogZnVuY3Rpb24ocmJwKSB7XG4gICAgICAgICAgdmFyIGxvb2thaGVhZCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB2YXIgZXhwclRva2VucyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUiwgVE9LX1NUQVJdO1xuICAgICAgICAgIGlmIChleHByVG9rZW5zLmluZGV4T2YobG9va2FoZWFkKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZCA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0TGlzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNFKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0UpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VQcm9qZWN0aW9uUkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgICAgaWYgKGJpbmRpbmdQb3dlclt0aGlzLl9sb29rYWhlYWQoMCldIDwgMTApIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19GSUxURVIpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0RPVCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfRE9UKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5dGFueCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52YWx1ZSArIFwiKFwiICsgdC50eXBlICsgXCIpXCIpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFJicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0TGlzdFwiLCBjaGlsZHJlbjogZXhwcmVzc2lvbnN9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIHZhciBpZGVudGlmaWVyVHlwZXMgPSBbVE9LX1VOUVVPVEVESURFTlRJRklFUiwgVE9LX1FVT1RFRElERU5USUZJRVJdO1xuICAgICAgICB2YXIga2V5VG9rZW4sIGtleU5hbWUsIHZhbHVlLCBub2RlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAga2V5VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllclR5cGVzLmluZGV4T2Yoa2V5VG9rZW4udHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW4gaWRlbnRpZmllciB0b2tlbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VG9rZW4udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU5hbWUgPSBrZXlUb2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTE9OKTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICBub2RlID0ge3R5cGU6IFwiS2V5VmFsdWVQYWlyXCIsIG5hbWU6IGtleU5hbWUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgICAgcGFpcnMucHVzaChub2RlKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09NTUEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJNdWx0aVNlbGVjdEhhc2hcIiwgY2hpbGRyZW46IHBhaXJzfTtcbiAgICAgIH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIFRyZWVJbnRlcnByZXRlcihydW50aW1lKSB7XG4gICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgfVxuXG4gIFRyZWVJbnRlcnByZXRlci5wcm90b3R5cGUgPSB7XG4gICAgICBzZWFyY2g6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZSwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZWQsIGN1cnJlbnQsIHJlc3VsdCwgZmlyc3QsIHNlY29uZCwgZmllbGQsIGxlZnQsIHJpZ2h0LCBjb2xsZWN0ZWQsIGk7XG4gICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGaWVsZFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZCA9IHZhbHVlW25vZGUubmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFwiU3ViZXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIkluZGV4RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBsZWZ0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBsZWZ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSBcIkluZGV4XCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBub2RlLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB2YWx1ZS5sZW5ndGggKyBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJTbGljZVwiOlxuICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHNsaWNlUGFyYW1zID0gbm9kZS5jaGlsZHJlbi5zbGljZSgwKTtcbiAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gdGhpcy5jb21wdXRlU2xpY2VQYXJhbXModmFsdWUubGVuZ3RoLCBzbGljZVBhcmFtcyk7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IGNvbXB1dGVkWzBdO1xuICAgICAgICAgICAgICB2YXIgc3RvcCA9IGNvbXB1dGVkWzFdO1xuICAgICAgICAgICAgICB2YXIgc3RlcCA9IGNvbXB1dGVkWzJdO1xuICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0b3A7IGkgKz0gc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpID4gc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiUHJvamVjdGlvblwiOlxuICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBsZWZ0IGNoaWxkLlxuICAgICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoYmFzZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb2xsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiVmFsdWVQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gb2JqVmFsdWVzKGJhc2UpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgdmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiRmlsdGVyUHJvamVjdGlvblwiOlxuICAgICAgICAgICAgICBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xuICAgICAgICAgICAgICB2YXIgZmluYWxSZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsyXSwgYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbHRlcmVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgZmlsdGVyZWRbal0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsUmVzdWx0cztcbiAgICAgICAgICAgIGNhc2UgXCJDb21wYXJhdG9yXCI6XG4gICAgICAgICAgICAgIGZpcnN0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHNlY29uZCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBzd2l0Y2gobm9kZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19ORTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0ID4gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPj0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFQ6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA8IHNlY29uZDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDw9IHNlY29uZDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbXBhcmF0b3I6IFwiICsgbm9kZS5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbWVyZ2VkID0gW107XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBvcmlnaW5hbFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2guYXBwbHkobWVyZ2VkLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgICAgICBjYXNlIFwiSWRlbnRpdHlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcIk11bHRpU2VsZWN0TGlzdFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb2xsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5wdXNoKHRoaXMudmlzaXQobm9kZS5jaGlsZHJlbltpXSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk11bHRpU2VsZWN0SGFzaFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb2xsZWN0ZWQgPSB7fTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRbY2hpbGQubmFtZV0gPSB0aGlzLnZpc2l0KGNoaWxkLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJPckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoaXNGYWxzZShtYXRjaGVkKSkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgICAgY2FzZSBcIkFuZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAoaXNGYWxzZShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcIk5vdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzRmFsc2UoZmlyc3QpO1xuICAgICAgICAgICAgY2FzZSBcIkxpdGVyYWxcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgICBsZWZ0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgY2FzZSBUT0tfQ1VSUkVOVDpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgIHZhciByZXNvbHZlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXJncy5wdXNoKHRoaXMudmlzaXQobm9kZS5jaGlsZHJlbltpXSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lLmNhbGxGdW5jdGlvbihub2RlLm5hbWUsIHJlc29sdmVkQXJncyk7XG4gICAgICAgICAgICBjYXNlIFwiRXhwcmVzc2lvblJlZmVyZW5jZVwiOlxuICAgICAgICAgICAgICB2YXIgcmVmTm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgIC8vIFRhZyB0aGUgbm9kZSB3aXRoIGEgc3BlY2lmaWMgYXR0cmlidXRlIHNvIHRoZSB0eXBlXG4gICAgICAgICAgICAgIC8vIGNoZWNrZXIgdmVyaWZ5IHRoZSB0eXBlLlxuICAgICAgICAgICAgICByZWZOb2RlLmptZXNwYXRoVHlwZSA9IFRPS19FWFBSRUY7XG4gICAgICAgICAgICAgIHJldHVybiByZWZOb2RlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbm9kZS50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlU2xpY2VQYXJhbXM6IGZ1bmN0aW9uKGFycmF5TGVuZ3RoLCBzbGljZVBhcmFtcykge1xuICAgICAgICB2YXIgc3RhcnQgPSBzbGljZVBhcmFtc1swXTtcbiAgICAgICAgdmFyIHN0b3AgPSBzbGljZVBhcmFtc1sxXTtcbiAgICAgICAgdmFyIHN0ZXAgPSBzbGljZVBhcmFtc1syXTtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIHNsaWNlLCBzdGVwIGNhbm5vdCBiZSAwXCIpO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwVmFsdWVOZWdhdGl2ZSA9IHN0ZXAgPCAwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGVwVmFsdWVOZWdhdGl2ZSA/IGFycmF5TGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuY2FwU2xpY2VSYW5nZShhcnJheUxlbmd0aCwgc3RhcnQsIHN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0b3AgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGVwVmFsdWVOZWdhdGl2ZSA/IC0xIDogYXJyYXlMZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9wID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdG9wLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZFswXSA9IHN0YXJ0O1xuICAgICAgICBjb21wdXRlZFsxXSA9IHN0b3A7XG4gICAgICAgIGNvbXB1dGVkWzJdID0gc3RlcDtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgICAgfSxcblxuICAgICAgY2FwU2xpY2VSYW5nZTogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIGFjdHVhbFZhbHVlLCBzdGVwKSB7XG4gICAgICAgICAgaWYgKGFjdHVhbFZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSArPSBhcnJheUxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGFjdHVhbFZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgYWN0dWFsVmFsdWUgPSBzdGVwIDwgMCA/IC0xIDogMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsVmFsdWUgPj0gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgYWN0dWFsVmFsdWUgPSBzdGVwIDwgMCA/IGFycmF5TGVuZ3RoIC0gMSA6IGFycmF5TGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWN0dWFsVmFsdWU7XG4gICAgICB9XG5cbiAgfTtcblxuICBmdW5jdGlvbiBSdW50aW1lKGludGVycHJldGVyKSB7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIgPSBpbnRlcnByZXRlcjtcbiAgICB0aGlzLmZ1bmN0aW9uVGFibGUgPSB7XG4gICAgICAgIC8vIG5hbWU6IFtmdW5jdGlvbiwgPHNpZ25hdHVyZT5dXG4gICAgICAgIC8vIFRoZSA8c2lnbmF0dXJlPiBjYW4gYmU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBhcmdzOiBbW3R5cGUxLCB0eXBlMl0sIFt0eXBlMSwgdHlwZTJdXSxcbiAgICAgICAgLy8gICB2YXJpYWRpYzogdHJ1ZXxmYWxzZVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVhY2ggYXJnIGluIHRoZSBhcmcgbGlzdCBpcyBhIGxpc3Qgb2YgdmFsaWQgdHlwZXNcbiAgICAgICAgLy8gKGlmIHRoZSBmdW5jdGlvbiBpcyBvdmVybG9hZGVkIGFuZCBzdXBwb3J0cyBtdWx0aXBsZVxuICAgICAgICAvLyB0eXBlcy4gIElmIHRoZSB0eXBlIGlzIFwiYW55XCIgdGhlbiBubyB0eXBlIGNoZWNraW5nXG4gICAgICAgIC8vIG9jY3VycyBvbiB0aGUgYXJndW1lbnQuICBWYXJpYWRpYyBpcyBvcHRpb25hbFxuICAgICAgICAvLyBhbmQgaWYgbm90IHByb3ZpZGVkIGlzIGFzc3VtZWQgdG8gYmUgZmFsc2UuXG4gICAgICAgIGFiczoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkFicywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfTlVNQkVSXX1dfSxcbiAgICAgICAgYXZnOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQXZnLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVJdfV19LFxuICAgICAgICBjZWlsOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ2VpbCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfTlVNQkVSXX1dfSxcbiAgICAgICAgY29udGFpbnM6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkNvbnRhaW5zLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HLCBUWVBFX0FSUkFZXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwiZW5kc193aXRoXCI6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkVuZHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgZmxvb3I6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25GbG9vciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfTlVNQkVSXX1dfSxcbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25MZW5ndGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVksIFRZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXAsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9FWFBSRUZdfSwge3R5cGVzOiBbVFlQRV9BUlJBWV19XX0sXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uTWF4LFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSLCBUWVBFX0FSUkFZX1NUUklOR119XX0sXG4gICAgICAgIFwibWVyZ2VcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uTWVyZ2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdLCB2YXJpYWRpYzogdHJ1ZX1dXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4X2J5XCI6IHtcbiAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXhCeSxcbiAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV19LCB7dHlwZXM6IFtUWVBFX0VYUFJFRl19XVxuICAgICAgICB9LFxuICAgICAgICBzdW06IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25TdW0sIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic3RhcnRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU3RhcnRzV2l0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklOR119LCB7dHlwZXM6IFtUWVBFX1NUUklOR119XX0sXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uTWluLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSLCBUWVBFX0FSUkFZX1NUUklOR119XX0sXG4gICAgICAgIFwibWluX2J5XCI6IHtcbiAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW5CeSxcbiAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV19LCB7dHlwZXM6IFtUWVBFX0VYUFJFRl19XVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVHlwZSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAga2V5czoge19mdW5jOiB0aGlzLl9mdW5jdGlvbktleXMsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF19XX0sXG4gICAgICAgIHZhbHVlczoge19mdW5jOiB0aGlzLl9mdW5jdGlvblZhbHVlcywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgc29ydDoge19mdW5jOiB0aGlzLl9mdW5jdGlvblNvcnQsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklORywgVFlQRV9BUlJBWV9OVU1CRVJdfV19LFxuICAgICAgICBcInNvcnRfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblNvcnRCeSxcbiAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV19LCB7dHlwZXM6IFtUWVBFX0VYUFJFRl19XVxuICAgICAgICB9LFxuICAgICAgICBqb2luOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Kb2luLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfU1RSSU5HXX0sXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9BUlJBWV9TVFJJTkddfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25SZXZlcnNlLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HLCBUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgXCJ0b19hcnJheVwiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9BcnJheSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJ0b19zdHJpbmdcIjoge19mdW5jOiB0aGlzLl9mdW5jdGlvblRvU3RyaW5nLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX251bWJlclwiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9OdW1iZXIsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwibm90X251bGxcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uTm90TnVsbCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfVxuICAgIH07XG4gIH1cblxuICBSdW50aW1lLnByb3RvdHlwZSA9IHtcbiAgICBjYWxsRnVuY3Rpb246IGZ1bmN0aW9uKG5hbWUsIHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIGZ1bmN0aW9uRW50cnkgPSB0aGlzLmZ1bmN0aW9uVGFibGVbbmFtZV07XG4gICAgICBpZiAoZnVuY3Rpb25FbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmdW5jdGlvbjogXCIgKyBuYW1lICsgXCIoKVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZhbGlkYXRlQXJncyhuYW1lLCByZXNvbHZlZEFyZ3MsIGZ1bmN0aW9uRW50cnkuX3NpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb25FbnRyeS5fZnVuYy5jYWxsKHRoaXMsIHJlc29sdmVkQXJncyk7XG4gICAgfSxcblxuICAgIF92YWxpZGF0ZUFyZ3M6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSkge1xuICAgICAgICAvLyBWYWxpZGF0aW5nIHRoZSBhcmdzIHJlcXVpcmVzIHZhbGlkYXRpbmdcbiAgICAgICAgLy8gdGhlIGNvcnJlY3QgYXJpdHkgYW5kIHRoZSBjb3JyZWN0IHR5cGUgb2YgZWFjaCBhcmcuXG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGRlY2xhcmVkIGFzIHZhcmlhZGljLCB0aGVuIHdlIG5lZWRcbiAgICAgICAgLy8gYSBtaW5pbXVtIG51bWJlciBvZiBhcmdzIHRvIGJlIHJlcXVpcmVkLiAgT3RoZXJ3aXNlIGl0IGhhcyB0b1xuICAgICAgICAvLyBiZSBhbiBleGFjdCBhbW91bnQuXG4gICAgICAgIHZhciBwbHVyYWxpemVkO1xuICAgICAgICBpZiAoc2lnbmF0dXJlW3NpZ25hdHVyZS5sZW5ndGggLSAxXS52YXJpYWRpYykge1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBsdXJhbGl6ZWQgPSBzaWduYXR1cmUubGVuZ3RoID09PSAxID8gXCIgYXJndW1lbnRcIiA6IFwiIGFyZ3VtZW50c1wiO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRha2VzIGF0IGxlYXN0XCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGJ1dCByZWNlaXZlZCBcIiArIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCAhPT0gc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudEVycm9yOiBcIiArIG5hbWUgKyBcIigpIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRha2VzIFwiICsgc2lnbmF0dXJlLmxlbmd0aCArIHBsdXJhbGl6ZWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGJ1dCByZWNlaXZlZCBcIiArIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFNwZWM7XG4gICAgICAgIHZhciBhY3R1YWxUeXBlO1xuICAgICAgICB2YXIgdHlwZU1hdGNoZWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0eXBlTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY3VycmVudFNwZWMgPSBzaWduYXR1cmVbaV0udHlwZXM7XG4gICAgICAgICAgICBhY3R1YWxUeXBlID0gdGhpcy5fZ2V0VHlwZU5hbWUoYXJnc1tpXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJlbnRTcGVjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGVNYXRjaGVzKGFjdHVhbFR5cGUsIGN1cnJlbnRTcGVjW2pdLCBhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHlwZU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSBjdXJyZW50U3BlY1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHR5cGVJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9OQU1FX1RBQkxFW3R5cGVJZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlRXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIGFyZ3VtZW50IFwiICsgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHRvIGJlIHR5cGUgXCIgKyBleHBlY3RlZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGJ1dCByZWNlaXZlZCB0eXBlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVFlQRV9OQU1FX1RBQkxFW2FjdHVhbFR5cGVdICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3R5cGVNYXRjaGVzOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBhcmdWYWx1ZSkge1xuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQU5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HIHx8XG4gICAgICAgICAgICBleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9OVU1CRVIgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgdHlwZSBjYW4gZWl0aGVyIGp1c3QgYmUgYXJyYXksXG4gICAgICAgICAgICAvLyBvciBpdCBjYW4gcmVxdWlyZSBhIHNwZWNpZmljIHN1YnR5cGUgKGFycmF5IG9mIG51bWJlcnMpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGVzdCBjYXNlIGlzIGlmIFwiYXJyYXlcIiB3aXRoIG5vIHN1YnR5cGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gVFlQRV9BUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2hlY2sgc3VidHlwZXMuXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIGhhcyBwb3RlbnRpYWwgdG8gYmUgaW1wcm92ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgc3VidHlwZSA9IFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90eXBlTWF0Y2hlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRUeXBlTmFtZShhcmdWYWx1ZVtpXSksIHN1YnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0VHlwZU5hbWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX1NUUklORztcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQk9PTEVBTjtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bGxdXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX05VTEw7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwcmVmLiAgSWYgaXQgaGFzLCBpdCdzIGJlZW5cbiAgICAgICAgICAgICAgLy8gdGFnZ2VkIHdpdGggYSBqbWVzcGF0aFR5cGUgYXR0ciBvZiAnRXhwcmVmJztcbiAgICAgICAgICAgICAgaWYgKG9iai5qbWVzcGF0aFR5cGUgPT09IFRPS19FWFBSRUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9FWFBSRUY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfT0JKRUNUO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU3RhcnRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGFzdEluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uRW5kc1dpdGg6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgc3VmZml4ID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gc2VhcmNoU3RyLmluZGV4T2Yoc3VmZml4LCBzZWFyY2hTdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25SZXZlcnNlOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgIHZhciBvcmlnaW5hbFN0ciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgcmV2ZXJzZWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBvcmlnaW5hbFN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICByZXZlcnNlZFN0ciArPSBvcmlnaW5hbFN0cltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkU3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXZlcnNlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdLnNsaWNlKDApO1xuICAgICAgICAgIHJldmVyc2VkQXJyYXkucmV2ZXJzZSgpO1xuICAgICAgICAgIHJldHVybiByZXZlcnNlZEFycmF5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkFiczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ2VpbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQXZnOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBpbnB1dEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBpbnB1dEFycmF5Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ29udGFpbnM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA+PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25GbG9vcjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkxlbmd0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgaWYgKCFpc09iamVjdChyZXNvbHZlZEFyZ3NbMF0pKSB7XG4gICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQXMgZmFyIGFzIEkgY2FuIHRlbGwsIHRoZXJlJ3Mgbm8gd2F5IHRvIGdldCB0aGUgbGVuZ3RoXG4gICAgICAgICAvLyBvZiBhbiBvYmplY3Qgd2l0aG91dCBPKG4pIGl0ZXJhdGlvbiB0aHJvdWdoIHRoZSBvYmplY3QuXG4gICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKS5sZW5ndGg7XG4gICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXA6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIGludGVycHJldGVyID0gdGhpcy5faW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXBwZWQucHVzaChpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBlbGVtZW50c1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWVyZ2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWF4RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1heEVsZW1lbnQubG9jYWxlQ29tcGFyZShlbGVtZW50c1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXhFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1heEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWluRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmxvY2FsZUNvbXBhcmUobWluRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtaW5FbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pbkVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdW06IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgbGlzdFRvU3VtID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0VG9TdW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGxpc3RUb1N1bVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIGNhc2UgVFlQRV9BUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX09CSkVDVDpcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9FWFBSRUY6XG4gICAgICAgICAgICByZXR1cm4gXCJleHByZWZcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTDpcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25LZXlzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblZhbHVlczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uSm9pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBqb2luQ2hhciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RKb2luID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gbGlzdEpvaW4uam9pbihqb2luQ2hhcik7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvQXJyYXk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSA9PT0gVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzb2x2ZWRBcmdzWzBdXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvTnVtYmVyOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSArcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjb252ZXJ0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk5vdE51bGw6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1tpXSkgIT09IFRZUEVfTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnQ6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIHNvcnRlZEFycmF5LnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Tb3J0Qnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIGlmIChzb3J0ZWRBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHZhciByZXF1aXJlZFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShcbiAgICAgICAgICAgIGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHNvcnRlZEFycmF5WzBdKSk7XG4gICAgICAgIGlmIChbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXS5pbmRleE9mKHJlcXVpcmVkVHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYSBzdGFibGUgc29ydCBvdXQgb2YgYW4gdW5zdGFibGVcbiAgICAgICAgLy8gc29ydCBhbGdvcml0aG0sIHdlIGRlY29yYXRlL3NvcnQvdW5kZWNvcmF0ZSAoRFNVKVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG5ldyBsaXN0IG9mIFtpbmRleCwgZWxlbWVudF0gcGFpcnMuXG4gICAgICAgIC8vIEluIHRoZSBjbXAgZnVuY3Rpb24sIGlmIHRoZSBldmFsdWF0ZWQgZWxlbWVudHMgYXJlXG4gICAgICAgIC8vIGVxdWFsLCB0aGVuIHRoZSBpbmRleCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRpZWJyZWFrZXIuXG4gICAgICAgIC8vIEFmdGVyIHRoZSBkZWNvcmF0ZWQgbGlzdCBoYXMgYmVlbiBzb3J0ZWQsIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdG8gZXh0cmFjdCB0aGUgb3JpZ2luYWwgZWxlbWVudHMuXG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY29yYXRlZC5wdXNoKFtpLCBzb3J0ZWRBcnJheVtpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICB2YXIgZXhwckEgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBhWzFdKTtcbiAgICAgICAgICB2YXIgZXhwckIgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBiWzFdKTtcbiAgICAgICAgICBpZiAodGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpICE9PSByZXF1aXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUeXBlRXJyb3I6IGV4cGVjdGVkIFwiICsgcmVxdWlyZWRUeXBlICsgXCIsIHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFR5cGVOYW1lKGV4cHJBKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQikgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cHJBID4gZXhwckIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwckEgPCBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGVxdWFsIGNvbXBhcmUgdGhlIGl0ZW1zIGJ5IHRoZWlyXG4gICAgICAgICAgICAvLyBvcmRlciB0byBtYWludGFpbiByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBrZXlzXG4gICAgICAgICAgICAvLyAoaS5lLiB0byBnZXQgYSBzdGFibGUgc29ydCkuXG4gICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5kZWNvcmF0ZTogZXh0cmFjdCBvdXQgdGhlIG9yaWdpbmFsIGxpc3QgZWxlbWVudHMuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVjb3JhdGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc29ydGVkQXJyYXlbal0gPSBkZWNvcmF0ZWRbal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXhCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIHZhciByZXNvbHZlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXSk7XG4gICAgICB2YXIgbWF4TnVtYmVyID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heFJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiBtYXhOdW1iZXIpIHtcbiAgICAgICAgICBtYXhOdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1heFJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhSZWNvcmQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbkJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtaW5OdW1iZXIgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5SZWNvcmQ7XG4gICAgICB2YXIgY3VycmVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0ga2V5RnVuY3Rpb24ocmVzb2x2ZWRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgbWluTnVtYmVyKSB7XG4gICAgICAgICAgbWluTnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICBtaW5SZWNvcmQgPSByZXNvbHZlZEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUmVjb3JkO1xuICAgIH0sXG5cbiAgICBjcmVhdGVLZXlGdW5jdGlvbjogZnVuY3Rpb24oZXhwcmVmTm9kZSwgYWxsb3dlZFR5cGVzKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBrZXlGdW5jID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHgpO1xuICAgICAgICBpZiAoYWxsb3dlZFR5cGVzLmluZGV4T2YodGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCkpIDwgMCkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgb25lIG9mIFwiICsgYWxsb3dlZFR5cGVzICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHJlY2VpdmVkIFwiICsgdGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGtleUZ1bmM7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZShzdHJlYW0pIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2Uoc3RyZWFtKTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyZWFtKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgIHJldHVybiBsZXhlci50b2tlbml6ZShzdHJlYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKGRhdGEsIGV4cHJlc3Npb24pIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGltcHJvdmVkLiAgQm90aCB0aGUgaW50ZXJwcmV0ZXIgYW5kIHJ1bnRpbWUgZGVwZW5kIG9uXG4gICAgICAvLyBlYWNoIG90aGVyLiAgVGhlIHJ1bnRpbWUgbmVlZHMgdGhlIGludGVycHJldGVyIHRvIHN1cHBvcnQgZXhwcmVmcy5cbiAgICAgIC8vIFRoZXJlJ3MgbGlrZWx5IGEgY2xlYW4gd2F5IHRvIGF2b2lkIHRoZSBjeWNsaWMgZGVwZW5kZW5jeS5cbiAgICAgIHZhciBydW50aW1lID0gbmV3IFJ1bnRpbWUoKTtcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IG5ldyBUcmVlSW50ZXJwcmV0ZXIocnVudGltZSk7XG4gICAgICBydW50aW1lLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgICAgdmFyIG5vZGUgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXIuc2VhcmNoKG5vZGUsIGRhdGEpO1xuICB9XG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xuICBleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuICBleHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcbiAgZXhwb3J0cy5zdHJpY3REZWVwRXF1YWwgPSBzdHJpY3REZWVwRXF1YWw7XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuam1lc3BhdGggPSB7fSA6IGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9TZXJ2aWNlQ2lyY3VsYXJSZWZlcmVuY2VFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V4Y2VwdGlvbi9TZXJ2aWNlQ2lyY3VsYXJSZWZlcmVuY2VFeGNlcHRpb25cIikpO1xuXG52YXIgX1Bhc3NDb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1Bhc3NDb25maWdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQ29tcGlsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtDb250YWluZXJCdWlsZGVyfSBjb250YWluZXJcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBpbGVyKGNvbnRhaW5lcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21waWxlcik7XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29tcGlsZXIsIFt7XG4gICAga2V5OiBcInJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lci5mcm96ZW4pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkRXh0ZW5zaW9ucygpO1xuXG4gICAgICAgICAgdGhpcy5fb3B0aW1pemUoKTtcblxuICAgICAgICAgIHRoaXMuX3JlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IF9TZXJ2aWNlQ2lyY3VsYXJSZWZlcmVuY2VFeGNlcHRpb25bXCJkZWZhdWx0XCJdKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkRXh0ZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZEV4dGVuc2lvbnMoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fY29udGFpbmVyLmV4dGVuc2lvbnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBleHRlbnNpb24gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBleHRlbnNpb24ubG9hZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcHRpbWl6ZSgpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5fY29tcGlsZXJQYXNzLnByb2Nlc3MoX1Bhc3NDb25maWdbXCJkZWZhdWx0XCJdLlRZUEVfQkVGT1JFX09QVElNSVpBVElPTik7XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5fY29tcGlsZXJQYXNzLnByb2Nlc3MoX1Bhc3NDb25maWdbXCJkZWZhdWx0XCJdLlRZUEVfT1BUSU1JWkUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlKCkge1xuICAgICAgdGhpcy5fY29udGFpbmVyLl9jb21waWxlclBhc3MucHJvY2VzcyhfUGFzc0NvbmZpZ1tcImRlZmF1bHRcIl0uVFlQRV9CRUZPUkVfUkVNT1ZJTkcpO1xuXG4gICAgICB0aGlzLl9jb250YWluZXIuX2NvbXBpbGVyUGFzcy5wcm9jZXNzKF9QYXNzQ29uZmlnW1wiZGVmYXVsdFwiXS5UWVBFX1JFTU9WRSk7XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5fY29tcGlsZXJQYXNzLnByb2Nlc3MoX1Bhc3NDb25maWdbXCJkZWZhdWx0XCJdLlRZUEVfQUZURVJfUkVNT1ZJTkcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb21waWxlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb21waWxlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBEZWNvcmF0ZVBhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNvcmF0ZVBhc3MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY29yYXRlUGFzcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGVjb3JhdGVQYXNzLCBbe1xuICAgIGtleTogXCJfcHJvY2Vzc0RlZmluaXRpb25LZXlzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlZmluaXRpb25JZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3Byb2Nlc3NEZWZpbml0aW9uS2V5cyhkZWZpbml0aW9uSWQpIHtcbiAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5fY29udGFpbmVyLmRlZmluaXRpb25zLmdldChkZWZpbml0aW9uSWQpO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5kZWNvcmF0aW9uUHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy5fcHJpb3JpdHlbZGVmaW5pdGlvbi5kZWNvcmF0aW9uUHJpb3JpdHldID0ge1xuICAgICAgICAgIG5hbWU6IGRlZmluaXRpb25JZCxcbiAgICAgICAgICBkZWZpbml0aW9uOiBkZWZpbml0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24uZGVjb3JhdGVkU2VydmljZSAmJiAhZGVmaW5pdGlvbklkLmluY2x1ZGVzKERlY29yYXRlUGFzcy5QT1NURklYX0lOTkVSKSkge1xuICAgICAgICB0aGlzLl9wcmlvcml0eS5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBkZWZpbml0aW9uSWQsXG4gICAgICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRlY29yYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzRGVjb3JhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzRGVjb3JhdGVzKGRlY29yYXRlKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuc2V0RGVmaW5pdGlvbihcIlwiLmNvbmNhdChkZWNvcmF0ZS5uYW1lLCBcIi5cIikuY29uY2F0KERlY29yYXRlUGFzcy5QT1NURklYX0lOTkVSKSwgdGhpcy5fY29udGFpbmVyLmRlZmluaXRpb25zLmdldChkZWNvcmF0ZS5kZWZpbml0aW9uLmRlY29yYXRlZFNlcnZpY2UpKTtcblxuICAgICAgZGVjb3JhdGUuZGVmaW5pdGlvbltcInB1YmxpY1wiXSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXREZWZpbml0aW9uKGRlY29yYXRlLmRlZmluaXRpb24uZGVjb3JhdGVkU2VydmljZSwgZGVjb3JhdGUuZGVmaW5pdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29udGFpbmVyQnVpbGRlcn0gY29udGFpbmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoY29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLl9wcmlvcml0eSA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29udGFpbmVyLmRlZmluaXRpb25zLmtleXMoKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGRlZmluaXRpb25JZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdGhpcy5fcHJvY2Vzc0RlZmluaXRpb25LZXlzKGRlZmluaXRpb25JZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlY29yYXRlcyA9IHRoaXMuX3ByaW9yaXR5LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRlY29yYXRlcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkZWNvcmF0ZSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NEZWNvcmF0ZXMoZGVjb3JhdGUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJQT1NURklYX0lOTkVSXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ2lubmVyJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVjb3JhdGVQYXNzO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERlY29yYXRlUGFzczsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyB0aHJvdyBfZTI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIE9wdGltaXplUGFzcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9wdGltaXplUGFzcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW1pemVQYXNzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPcHRpbWl6ZVBhc3MsIFt7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvbnRhaW5lckJ1aWxkZXJ9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3MoY29udGFpbmVyKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29udGFpbmVyLmRlZmluaXRpb25zKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGRlZmluaXRpb24gPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICghY29udGFpbmVyLmlzU2V0KGlkKSAmJiAhZGVmaW5pdGlvbi5sYXp5ICYmICFkZWZpbml0aW9uW1wiYWJzdHJhY3RcIl0pIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNvbnRhaW5lci5pbnN0YW5jZU1hbmFnZXIuZ2V0SW5zdGFuY2VGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY29udGFpbmVyLmZyb3plbiA9IHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9wdGltaXplUGFzcztcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBPcHRpbWl6ZVBhc3M7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UzKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMzsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBSZW1vdmVQYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVtb3ZlUGFzcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVtb3ZlUGFzcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVtb3ZlUGFzcywgW3tcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29udGFpbmVyQnVpbGRlcn0gY29udGFpbmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzcyhjb250YWluZXIpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb250YWluZXIuZGVmaW5pdGlvbnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25bXCJwdWJsaWNcIl0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVtb3ZlUGFzcztcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZW1vdmVQYXNzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfUGFzc0NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL1Bhc3NDb25maWdcIikpO1xuXG52YXIgX09wdGltaXplUGFzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vT3B0aW1pemVQYXNzXCIpKTtcblxudmFyIF9SZW1vdmVQYXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZW1vdmVQYXNzXCIpKTtcblxudmFyIF9EZWNvcmF0ZVBhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0RlY29yYXRlUGFzc1wiKSk7XG5cbnZhciBfUHJvY2Vzc01ldGhvZE5vdEZvdW5kRXhjZXB0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vRXhjZXB0aW9uL1Byb2Nlc3NNZXRob2ROb3RGb3VuZEV4Y2VwdGlvblwiKSk7XG5cbnZhciBfV3JvbmdDb21waWxlclBhc3NUeXBlRXhjZXB0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vRXhjZXB0aW9uL1dyb25nQ29tcGlsZXJQYXNzVHlwZUV4Y2VwdGlvblwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBDb21waWxlclBhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtDb250YWluZXJCdWlsZGVyfSBjb250YWluZXJcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBpbGVyUGFzcyhjb250YWluZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGlsZXJQYXNzKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmJlZm9yZU9wdGltaXphdGlvbiA9IFtdO1xuICAgIHRoaXMub3B0aW1pemUgPSBbXTtcbiAgICB0aGlzLmJlZm9yZVJlbW92aW5nID0gW107XG4gICAgdGhpcy5yZW1vdmUgPSBbXTtcbiAgICB0aGlzLmFmdGVyUmVtb3ZpbmcgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbXBpbGVyUGFzcywgW3tcbiAgICBrZXk6IFwiX2dldENvbXBpbGVyUGFzc1ByaW9yaXR5TnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb21waWxlclBhc3NQcmlvcml0eU51bWJlcih0eXBlLCBwcmlvcml0eSkge1xuICAgICAgaWYgKHRoaXNbdHlwZV1bcHJpb3JpdHldKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb21waWxlclBhc3NQcmlvcml0eU51bWJlcih0eXBlLCBwcmlvcml0eSArIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJpb3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGlsZXJQYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbXBpbGVyUGFzcywgdHlwZSwgcHJpb3JpdHkpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcGlsZXJQYXNzLnByb2Nlc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9Qcm9jZXNzTWV0aG9kTm90Rm91bmRFeGNlcHRpb25bXCJkZWZhdWx0XCJdKGNvbXBpbGVyUGFzcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfUGFzc0NvbmZpZ1tcImRlZmF1bHRcIl0uaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9Xcm9uZ0NvbXBpbGVyUGFzc1R5cGVFeGNlcHRpb25bXCJkZWZhdWx0XCJdKHR5cGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyYXlMZXZlbCA9IHRoaXMuX2dldENvbXBpbGVyUGFzc1ByaW9yaXR5TnVtYmVyKHR5cGUsIHByaW9yaXR5KTtcblxuICAgICAgdGhpc1t0eXBlXVthcnJheUxldmVsXSA9IGNvbXBpbGVyUGFzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrQW5kQWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0FuZEFkZCh0eXBlKSB7XG4gICAgICBpZiAodGhpcy5fY29udGFpbmVyLl9jb21waWxlclBhc3NbdHlwZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBfUGFzc0NvbmZpZ1tcImRlZmF1bHRcIl0uVFlQRV9CRUZPUkVfT1BUSU1JWkFUSU9OKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcihuZXcgX0RlY29yYXRlUGFzc1tcImRlZmF1bHRcIl0oKSwgdHlwZSwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gX1Bhc3NDb25maWdbXCJkZWZhdWx0XCJdLlRZUEVfT1BUSU1JWkUpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyKG5ldyBfT3B0aW1pemVQYXNzW1wiZGVmYXVsdFwiXSgpLCB0eXBlLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBfUGFzc0NvbmZpZ1tcImRlZmF1bHRcIl0uVFlQRV9SRU1PVkUpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyKG5ldyBfUmVtb3ZlUGFzc1tcImRlZmF1bHRcIl0oKSwgdHlwZSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyh0eXBlKSB7XG4gICAgICB0aGlzLl9jaGVja0FuZEFkZCh0eXBlKTtcblxuICAgICAgdGhpc1t0eXBlXSA9IHRoaXNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpICE9PSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzW3R5cGVdKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY29tcGlsZXJQYXNzID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgY29tcGlsZXJQYXNzLnByb2Nlc3ModGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb21waWxlclBhc3M7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tcGlsZXJQYXNzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfRGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRGVmaW5pdGlvblwiKSk7XG5cbnZhciBfUGFzc0NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUGFzc0NvbmZpZ1wiKSk7XG5cbnZhciBfQ29tcGlsZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0NvbXBpbGVyXCIpKTtcblxudmFyIF9Db21waWxlclBhc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0NvbXBpbGVyUGFzc1wiKSk7XG5cbnZhciBfSW5zdGFuY2VNYW5hZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9JbnN0YW5jZU1hbmFnZXJcIikpO1xuXG52YXIgX0RlZmluaXRpb25Ob3RGb3VuZEV4Y2VwdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRXhjZXB0aW9uL0RlZmluaXRpb25Ob3RGb3VuZEV4Y2VwdGlvblwiKSk7XG5cbnZhciBfTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9FeGNlcHRpb24vTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uXCIpKTtcblxudmFyIF9Mb2dnZXJXYXJuTWV0aG9kTm90Rm91bmRFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V4Y2VwdGlvbi9Mb2dnZXJXYXJuTWV0aG9kTm90Rm91bmRFeGNlcHRpb25cIikpO1xuXG52YXIgX1dyb25nRGVmaW5pdGlvbkV4Y2VwdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRXhjZXB0aW9uL1dyb25nRGVmaW5pdGlvbkV4Y2VwdGlvblwiKSk7XG5cbnZhciBfRnJvemVuQ29udGFpbmVyRXhjZXB0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9FeGNlcHRpb24vRnJvemVuQ29udGFpbmVyRXhjZXB0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UzKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMzsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBDb250YWluZXJCdWlsZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29udGFpbmVyUmVmZXJlbmNlQXNTZXJ2aWNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0RGlyXG4gICAqL1xuICBmdW5jdGlvbiBDb250YWluZXJCdWlsZGVyKCkge1xuICAgIHZhciBjb250YWluZXJSZWZlcmVuY2VBc1NlcnZpY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBkZWZhdWx0RGlyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lckJ1aWxkZXIpO1xuXG4gICAgdGhpcy5fZGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9hbGlhcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5fY29tcGlsZXJQYXNzID0gbmV3IF9Db21waWxlclBhc3NbXCJkZWZhdWx0XCJdKHRoaXMpO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBbXTtcbiAgICB0aGlzLl9sb2dnZXIgPSBjb25zb2xlO1xuICAgIHRoaXMuX2luc3RhbmNlTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jb250YWluZXJSZWZlcmVuY2VBc1NlcnZpY2UgPSBjb250YWluZXJSZWZlcmVuY2VBc1NlcnZpY2U7XG4gICAgdGhpcy5fZGVmYXVsdERpciA9IGRlZmF1bHREaXI7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRhaW5lckJ1aWxkZXIsIFt7XG4gICAga2V5OiBcImRlZmF1bHREaXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RGlyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnRhaW5lclJlZmVyZW5jZUFzU2VydmljZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclJlZmVyZW5jZUFzU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01hcH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmluaXRpb25zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvemVuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnJvemVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9mcm96ZW4gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7SW5zdGFuY2VNYW5hZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zdGFuY2VNYW5hZ2VyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2luc3RhbmNlTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZU1hbmFnZXIgPSBuZXcgX0luc3RhbmNlTWFuYWdlcltcImRlZmF1bHRcIl0odGhpcywgdGhpcy5fZGVmaW5pdGlvbnMsIHRoaXMuX2FsaWFzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5zaW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4dGVuc2lvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtDb25zb2xlfCp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2dnZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2dnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29uc29sZXwqfSB2YWx1ZVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZS53YXJuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBfTG9nZ2VyV2Fybk1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uW1wiZGVmYXVsdFwiXSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sb2dnZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7TWFwfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VydmljZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7KnxudWxsfSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICogQHJldHVybnMge0RlZmluaXRpb259XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihpZCkge1xuICAgICAgdmFyIG9iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblxuICAgICAgaWYgKCF0aGlzLmZyb3plbikge1xuICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IG5ldyBfRGVmaW5pdGlvbltcImRlZmF1bHRcIl0oKTtcbiAgICAgICAgZGVmaW5pdGlvbi5PYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIGRlZmluaXRpb24uYXJncyA9IGFyZ3M7XG5cbiAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zZXREZWZpbml0aW9uKGlkLCBkZWZpbml0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IF9Gcm96ZW5Db250YWluZXJFeGNlcHRpb25bXCJkZWZhdWx0XCJdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VNYW5hZ2VyLmdldEluc3RhbmNlKGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgICAgbmV3IF9Db21waWxlcltcImRlZmF1bHRcIl0odGhpcykucnVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGlsZXJQYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZENvbXBpbGVyUGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb21waWxlclBhc3MoY29tcGlsZXJQYXNzKSB7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX1Bhc3NDb25maWdbXCJkZWZhdWx0XCJdLlRZUEVfQkVGT1JFX09QVElNSVpBVElPTjtcbiAgICAgIHZhciBwcmlvcml0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgICAgdGhpcy5fY29tcGlsZXJQYXNzLnJlZ2lzdGVyKGNvbXBpbGVyUGFzcywgdHlwZSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEFsaWFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFsaWFzKGFsaWFzLCBpZCkge1xuICAgICAgdGhpcy5fYWxpYXMuc2V0KGFsaWFzLCBpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7RGVmaW5pdGlvbn0gZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zIHtEZWZpbml0aW9ufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWZpbml0aW9uKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIF9EZWZpbml0aW9uW1wiZGVmYXVsdFwiXSkge1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9ucy5zZXQoaWQsIGRlZmluaXRpb24pO1xuXG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgX1dyb25nRGVmaW5pdGlvbkV4Y2VwdGlvbltcImRlZmF1bHRcIl0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFRhZ2dlZFNlcnZpY2VJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFRhZ2dlZFNlcnZpY2VJZHMobmFtZSkge1xuICAgICAgdmFyIHRhZ2dlZFNlcnZpY2VzID0gbmV3IE1hcCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fZGVmaW5pdGlvbnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb24udGFncy5zb21lKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGFnZ2VkU2VydmljZXMuc2V0KGlkLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhZ2dlZFNlcnZpY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8fEFycmF5fGJvb2xlYW58T2JqZWN0fSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGFyYW1ldGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhcmFtZXRlcihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgJiYgX3R5cGVvZih2YWx1ZSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBleHBlY3RlZCB2YWx1ZSBpcyBub3QgYSBmbGF0IHN0cmluZywgYW4gYXJyYXksIGEgYm9vbGVhbiBvciBhbiBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyYW1ldGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfEFycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFyYW1ldGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcmFtZXRlcihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzLmdldChrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNQYXJhbWV0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUGFyYW1ldGVyKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlcnMuaGFzKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhc0RlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRGVmaW5pdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9ucy5oYXMoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9ucy5oYXMoa2V5KSB8fCB0aGlzLl9wYXJhbWV0ZXJzLmhhcyhrZXkpIHx8IHRoaXMuX2FsaWFzLmhhcyhrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtEZWZpbml0aW9ufGJvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZpbml0aW9uKG1ldGhvZCwga2V5KSB7XG4gICAgICBpZiAodGhpcy5fZGVmaW5pdGlvbnMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25zW21ldGhvZF0oa2V5KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IF9EZWZpbml0aW9uTm90Rm91bmRFeGNlcHRpb25bXCJkZWZhdWx0XCJdKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7RGVmaW5pdGlvbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uKCdnZXQnLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVEZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZURlZmluaXRpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbignZGVsZXRlJywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtEZWZpbml0aW9ufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZERlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZERlZmluaXRpb24oa2V5KSB7XG4gICAgICBrZXkgPSB0aGlzLl9hbGlhcy5nZXQoa2V5KSB8fCBrZXk7XG5cbiAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9ucy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnMuZ2V0KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBfRGVmaW5pdGlvbk5vdEZvdW5kRXhjZXB0aW9uW1wiZGVmYXVsdFwiXShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGV4dGVuc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJFeHRlbnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi5sb2FkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBfTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uW1wiZGVmYXVsdFwiXShleHRlbnNpb24uY29uc3RydWN0b3IubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMucHVzaChleHRlbnNpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0geyp9IGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGlkLCBpbnN0YW5jZSkge1xuICAgICAgdGhpcy5fY29udGFpbmVyLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lcltcImRlbGV0ZVwiXShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZXQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuaGFzKGlkKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGFpbmVyQnVpbGRlcjtcbn0oKTtcblxudmFyIF9kZWZhdWx0ID0gQ29udGFpbmVyQnVpbGRlcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9NZXRob2RDYWxsRW1wdHlFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V4Y2VwdGlvbi9NZXRob2RDYWxsRW1wdHlFeGNlcHRpb25cIikpO1xuXG52YXIgX0F0dHJpYnV0ZXNNYXBFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V4Y2VwdGlvbi9BdHRyaWJ1dGVzTWFwRXhjZXB0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIERlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHsqfG51bGx9IE9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAqL1xuICBmdW5jdGlvbiBEZWZpbml0aW9uKCkge1xuICAgIHZhciBPYmplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmluaXRpb24pO1xuXG4gICAgdGhpcy5fT2JqZWN0ID0gT2JqZWN0O1xuICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgIHRoaXMuX2NhbGxzID0gW107XG4gICAgdGhpcy5fdGFncyA9IFtdO1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbGF6eSA9IGZhbHNlO1xuICAgIHRoaXMuX2RlcHJlY2F0ZWQgPSBudWxsO1xuICAgIHRoaXMuX2ZhY3RvcnkgPSBudWxsO1xuICAgIHRoaXMuX3B1YmxpYyA9IHRydWU7XG4gICAgdGhpcy5fc3ludGhldGljID0gZmFsc2U7XG4gICAgdGhpcy5fZGVjb3JhdGVkU2VydmljZSA9IG51bGw7XG4gICAgdGhpcy5fZGVjb3JhdGlvblByaW9yaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9zaGFyZWQgPSB0cnVlO1xuICAgIHRoaXMuX2Fic3RyYWN0ID0gZmFsc2U7XG4gICAgdGhpcy5fYXBwZW5kQXJncyA9IFtdO1xuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERlZmluaXRpb24sIFt7XG4gICAga2V5OiBcImFic3RyYWN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWJzdHJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX2Fic3RyYWN0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWNvcmF0ZWRTZXJ2aWNlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjb3JhdGVkU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9kZWNvcmF0ZWRTZXJ2aWNlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlY29yYXRpb25Qcmlvcml0eVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlY29yYXRpb25Qcmlvcml0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9kZWNvcmF0aW9uUHJpb3JpdHkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdWJsaWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3B1YmxpYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVsbHx7T2JqZWN0OiAoT2JqZWN0fFJlZmVyZW5jZSksIG1ldGhvZDogc3RyaW5nfXwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjdG9yeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlcHJlY2F0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXByZWNhdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGVwcmVjYXRlZCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxhenlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXp5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9sYXp5ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiT2JqZWN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fT2JqZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9PYmplY3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXJnc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FyZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJncykge1xuICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FsbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRhZ3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90YWdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvcGVydGllc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kQXJnc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZEFyZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFwcGVuZEFyZ3NcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYXBwZW5kQXJncykge1xuICAgICAgdGhpcy5fYXBwZW5kQXJncyA9IGFwcGVuZEFyZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3ludGhldGljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3ludGhldGljO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9zeW50aGV0aWMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaGFyZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFyZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NoYXJlZCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fcGFyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFJlZmVyZW5jZX0gT2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmFjdG9yeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGYWN0b3J5KE9iamVjdCwgbWV0aG9kKSB7XG4gICAgICB0aGlzLl9mYWN0b3J5ID0ge1xuICAgICAgICBPYmplY3Q6IE9iamVjdCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7RGVmaW5pdGlvbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEFyZ3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFyZ3VtZW50KGFyZ3VtZW50KSB7XG4gICAgICB0aGlzLl9hcmdzLnB1c2goYXJndW1lbnQpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZE1ldGhvZENhbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWV0aG9kQ2FsbChtZXRob2QpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgICAgaWYgKG1ldGhvZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IF9NZXRob2RDYWxsRW1wdHlFeGNlcHRpb25bXCJkZWZhdWx0XCJdKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhbGxzLnB1c2goe1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7TWFwfSBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge0RlZmluaXRpb259XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGFnKG5hbWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgTWFwKCk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHRoaXMuX3RhZ3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgX0F0dHJpYnV0ZXNNYXBFeGNlcHRpb25bXCJkZWZhdWx0XCJdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0RlZmluaXRpb259XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRQcm9wZXJ0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYnlwYXNzUHVibGljXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzUHVibGljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUHVibGljKCkge1xuICAgICAgdmFyIGJ5cGFzc1B1YmxpYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICByZXR1cm4gdGhpc1tcInB1YmxpY1wiXSB8fCAhYnlwYXNzUHVibGljICYmIHRoaXNbXCJwdWJsaWNcIl07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlZmluaXRpb247XG59KCk7XG5cbnZhciBfZGVmYXVsdCA9IERlZmluaXRpb247XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBBYnN0cmFjdFNlcnZpY2VFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqL1xuICBmdW5jdGlvbiBBYnN0cmFjdFNlcnZpY2VFeGNlcHRpb24oaWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJUaGUgc2VydmljZSBcIi5jb25jYXQoaWQsIFwiIGlzIGFic3RyYWN0XCIpKTtcbiAgICBfdGhpcy5uYW1lID0gJ0Fic3RyYWN0U2VydmljZUV4Y2VwdGlvbic7XG4gICAgX3RoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBYnN0cmFjdFNlcnZpY2VFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIEF0dHJpYnV0ZXNNYXBFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQXR0cmlidXRlc01hcEV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEF0dHJpYnV0ZXNNYXBFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZXNNYXBFeGNlcHRpb24oKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJpYnV0ZXNNYXBFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0cmlidXRlcyBpcyBub3QgdHlwZSBNYXAnKTtcbiAgICBfdGhpcy5uYW1lID0gJ0F0dHJpYnV0ZXNNYXBFeGNlcHRpb24nO1xuICAgIF90aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZXNNYXBFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEF0dHJpYnV0ZXNNYXBFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIENvbmZpZ3VyYXRpb25GaWxlTm90Rm91bmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQ29uZmlndXJhdGlvbkZpbGVOb3RGb3VuZEV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbmZpZ3VyYXRpb25GaWxlTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbkZpbGVOb3RGb3VuZEV4Y2VwdGlvbihwYXRoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRpb25GaWxlTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkZpbGUgXCIuY29uY2F0KHBhdGgsIFwiIG5vdCBmb3VuZFwiKSk7XG4gICAgX3RoaXMubmFtZSA9ICdDb25maWd1cmF0aW9uRmlsZU5vdEZvdW5kRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBDb25maWd1cmF0aW9uRmlsZU5vdEZvdW5kRXhjZXB0aW9uO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb25maWd1cmF0aW9uRmlsZU5vdEZvdW5kRXhjZXB0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBEZWZpbml0aW9uTm90Rm91bmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoRGVmaW5pdGlvbk5vdEZvdW5kRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVmaW5pdGlvbk5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqL1xuICBmdW5jdGlvbiBEZWZpbml0aW9uTm90Rm91bmRFeGNlcHRpb24oaWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmaW5pdGlvbk5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJcIi5jb25jYXQoaWQsIFwiIGRlZmluaXRpb24gbm90IGZvdW5kXCIpKTtcbiAgICBfdGhpcy5uYW1lID0gJ0RlZmluaXRpb25Ob3RGb3VuZEV4Y2VwdGlvbic7XG4gICAgX3RoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRGVmaW5pdGlvbk5vdEZvdW5kRXhjZXB0aW9uO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEZWZpbml0aW9uTm90Rm91bmRFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIEZyb3plbkNvbnRhaW5lckV4Y2VwdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhGcm96ZW5Db250YWluZXJFeGNlcHRpb24sIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihGcm96ZW5Db250YWluZXJFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIEZyb3plbkNvbnRhaW5lckV4Y2VwdGlvbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJvemVuQ29udGFpbmVyRXhjZXB0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ1lvdSBjYW5ub3QgcmVnaXN0ZXIgbW9yZSBzZXJ2aWNlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgZnJvemVuJyk7XG4gICAgX3RoaXMubmFtZSA9ICdGcm96ZW5Db250YWluZXJFeGNlcHRpb24nO1xuICAgIF90aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEZyb3plbkNvbnRhaW5lckV4Y2VwdGlvbjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRnJvemVuQ29udGFpbmVyRXhjZXB0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBMb2FkTWV0aG9kTm90Rm91bmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvblxuICAgKi9cbiAgZnVuY3Rpb24gTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uKGV4dGVuc2lvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkTWV0aG9kTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIlRoZSBleHRlbnNpb24gXCIuY29uY2F0KGV4dGVuc2lvbiwgXCIgZG9lcyBub3QgaGF2ZSB0aGUgbG9hZCBtZXRob2RcIikpO1xuICAgIF90aGlzLm5hbWUgPSAnTG9hZE1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBMb2FkTWV0aG9kTm90Rm91bmRFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExvYWRNZXRob2ROb3RGb3VuZEV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgTG9nZ2VyV2Fybk1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKExvZ2dlcldhcm5NZXRob2ROb3RGb3VuZEV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKExvZ2dlcldhcm5NZXRob2ROb3RGb3VuZEV4Y2VwdGlvbik7XG5cbiAgZnVuY3Rpb24gTG9nZ2VyV2Fybk1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2dnZXJXYXJuTWV0aG9kTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnVGhlIGxvZ2dlciBpbnN0YW5jZSBkb2VzIG5vdCBpbXBsZW1lbnRzIHRoZSB3YXJuIG1ldGhvZCcpO1xuICAgIF90aGlzLm5hbWUgPSAnTG9nZ2VyV2Fybk1ldGhvZE5vdEZvdW5kRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBMb2dnZXJXYXJuTWV0aG9kTm90Rm91bmRFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExvZ2dlcldhcm5NZXRob2ROb3RGb3VuZEV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgTWV0aG9kQ2FsbEVtcHR5RXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKE1ldGhvZENhbGxFbXB0eUV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE1ldGhvZENhbGxFbXB0eUV4Y2VwdGlvbik7XG5cbiAgZnVuY3Rpb24gTWV0aG9kQ2FsbEVtcHR5RXhjZXB0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXRob2RDYWxsRW1wdHlFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnTWV0aG9kIG5hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgX3RoaXMubmFtZSA9ICdNZXRob2RDYWxsRW1wdHlFeGNlcHRpb24nO1xuICAgIF90aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE1ldGhvZENhbGxFbXB0eUV4Y2VwdGlvbjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTWV0aG9kQ2FsbEVtcHR5RXhjZXB0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBNZXRob2RDYWxsTm90Rm91bmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoTWV0aG9kQ2FsbE5vdEZvdW5kRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTWV0aG9kQ2FsbE5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgKi9cbiAgZnVuY3Rpb24gTWV0aG9kQ2FsbE5vdEZvdW5kRXhjZXB0aW9uKG1ldGhvZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXRob2RDYWxsTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIk1ldGhvZCBcIi5jb25jYXQobWV0aG9kLCBcIiBub3QgZm91bmRcIikpO1xuICAgIF90aGlzLm5hbWUgPSAnTWV0aG9kQ2FsbE5vdEZvdW5kRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBNZXRob2RDYWxsTm90Rm91bmRFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1ldGhvZENhbGxOb3RGb3VuZEV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgTm90QWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKE5vdEFic3RyYWN0U2VydmljZUV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vdEFic3RyYWN0U2VydmljZUV4Y2VwdGlvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKi9cbiAgZnVuY3Rpb24gTm90QWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uKGlkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vdEFic3RyYWN0U2VydmljZUV4Y2VwdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiVGhlIHBhcmVudCBzZXJ2aWNlIFwiLmNvbmNhdChpZCwgXCIgaXMgbm90IGFic3RyYWN0XCIpKTtcbiAgICBfdGhpcy5uYW1lID0gJ05vdEFic3RyYWN0U2VydmljZUV4Y2VwdGlvbic7XG4gICAgX3RoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTm90QWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBOb3RBYnN0cmFjdFNlcnZpY2VFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFByaXZhdGVTZXJ2aWNlRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFByaXZhdGVTZXJ2aWNlRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHJpdmF0ZVNlcnZpY2VFeGNlcHRpb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICovXG4gIGZ1bmN0aW9uIFByaXZhdGVTZXJ2aWNlRXhjZXB0aW9uKGlkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByaXZhdGVTZXJ2aWNlRXhjZXB0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJUaGUgc2VydmljZSBcIi5jb25jYXQoaWQsIFwiIGlzIHByaXZhdGVcIikpO1xuICAgIF90aGlzLm5hbWUgPSAnUHJpdmF0ZVNlcnZpY2VFeGNlcHRpb24nO1xuICAgIF90aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFByaXZhdGVTZXJ2aWNlRXhjZXB0aW9uO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcml2YXRlU2VydmljZUV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgUHJvY2Vzc01ldGhvZE5vdEZvdW5kRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFByb2Nlc3NNZXRob2ROb3RGb3VuZEV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFByb2Nlc3NNZXRob2ROb3RGb3VuZEV4Y2VwdGlvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21waWxlclBhc3NcbiAgICovXG4gIGZ1bmN0aW9uIFByb2Nlc3NNZXRob2ROb3RGb3VuZEV4Y2VwdGlvbihjb21waWxlclBhc3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvY2Vzc01ldGhvZE5vdEZvdW5kRXhjZXB0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJUaGUgY29tcGlsZXIgcGFzcyBcIi5jb25jYXQoY29tcGlsZXJQYXNzLCBcIiBkb2VzIG5vdCBoYXZlIHRoZSBwcm9jZXNzIG1ldGhvZFwiKSk7XG4gICAgX3RoaXMubmFtZSA9ICdQcm9jZXNzTWV0aG9kTm90Rm91bmRFeGNlcHRpb24nO1xuICAgIF90aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFByb2Nlc3NNZXRob2ROb3RGb3VuZEV4Y2VwdGlvbjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJvY2Vzc01ldGhvZE5vdEZvdW5kRXhjZXB0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBTZXJ2aWNlQ2lyY3VsYXJSZWZlcmVuY2VFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoU2VydmljZUNpcmN1bGFyUmVmZXJlbmNlRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2VydmljZUNpcmN1bGFyUmVmZXJlbmNlRXhjZXB0aW9uKTtcblxuICBmdW5jdGlvbiBTZXJ2aWNlQ2lyY3VsYXJSZWZlcmVuY2VFeGNlcHRpb24oKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcnZpY2VDaXJjdWxhclJlZmVyZW5jZUV4Y2VwdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQnKTtcbiAgICBfdGhpcy5uYW1lID0gJ1NlcnZpY2VDaXJjdWxhclJlZmVyZW5jZUV4Y2VwdGlvbic7XG4gICAgX3RoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU2VydmljZUNpcmN1bGFyUmVmZXJlbmNlRXhjZXB0aW9uO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTZXJ2aWNlQ2lyY3VsYXJSZWZlcmVuY2VFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFNlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoU2VydmljZUZpbGVOb3RGb3VuZEV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIFNlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb24oZmlsZU5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VydmljZUZpbGVOb3RGb3VuZEV4Y2VwdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiU2VydmljZSBmaWxlIFwiLmNvbmNhdChmaWxlTmFtZSwgXCIgbm90IGZvdW5kXCIpKTtcbiAgICBfdGhpcy5uYW1lID0gJ1NlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb24nO1xuICAgIF90aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFNlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFNlcnZpY2VGaWxlTm90TG9hZGVkRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFNlcnZpY2VGaWxlTm90TG9hZGVkRXhjZXB0aW9uLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2VydmljZUZpbGVOb3RMb2FkZWRFeGNlcHRpb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIFNlcnZpY2VGaWxlTm90TG9hZGVkRXhjZXB0aW9uKHJlYXNvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJ2aWNlRmlsZU5vdExvYWRlZEV4Y2VwdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiU2VydmljZSBmaWxlIGNvdWxkIG5vdCBiZSBsb2FkZWQuIFwiLmNvbmNhdChyZWFzb24pKTtcbiAgICBfdGhpcy5uYW1lID0gJ1NlcnZpY2VGaWxlTm90TG9hZGVkRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTZXJ2aWNlRmlsZU5vdExvYWRlZEV4Y2VwdGlvbjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2VydmljZUZpbGVOb3RMb2FkZWRFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFNlcnZpY2VOb3RGb3VuZEV4Y2VwdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhTZXJ2aWNlTm90Rm91bmRFeGNlcHRpb24sIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTZXJ2aWNlTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICovXG4gIGZ1bmN0aW9uIFNlcnZpY2VOb3RGb3VuZEV4Y2VwdGlvbihpZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJ2aWNlTm90Rm91bmRFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIlRoZSBzZXJ2aWNlIFwiLmNvbmNhdChpZCwgXCIgaXMgbm90IHJlZ2lzdGVyZWRcIikpO1xuICAgIF90aGlzLm5hbWUgPSAnU2VydmljZU5vdEZvdW5kRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTZXJ2aWNlTm90Rm91bmRFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFNlcnZpY2VOb3RGb3VuZEV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgV3JvbmdDb21waWxlclBhc3NUeXBlRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFdyb25nQ29tcGlsZXJQYXNzVHlwZUV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdyb25nQ29tcGlsZXJQYXNzVHlwZUV4Y2VwdGlvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqL1xuICBmdW5jdGlvbiBXcm9uZ0NvbXBpbGVyUGFzc1R5cGVFeGNlcHRpb24odHlwZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXcm9uZ0NvbXBpbGVyUGFzc1R5cGVFeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdCh0eXBlLCBcIiBpcyBhIHdyb25nIGNvbXBpbGVyIHBhc3MgY29uZmlnIHR5cGVcIikpO1xuICAgIF90aGlzLm5hbWUgPSAnV3JvbmdDb21waWxlclBhc3NUeXBlRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBXcm9uZ0NvbXBpbGVyUGFzc1R5cGVFeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFdyb25nQ29tcGlsZXJQYXNzVHlwZUV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgV3JvbmdEZWZpbml0aW9uRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFdyb25nRGVmaW5pdGlvbkV4Y2VwdGlvbiwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdyb25nRGVmaW5pdGlvbkV4Y2VwdGlvbik7XG5cbiAgZnVuY3Rpb24gV3JvbmdEZWZpbml0aW9uRXhjZXB0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXcm9uZ0RlZmluaXRpb25FeGNlcHRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnWW91IGNhbm5vdCByZWdpc3RlciBub3QgdmFsaWQgZGVmaW5pdGlvbicpO1xuICAgIF90aGlzLm5hbWUgPSAnV3JvbmdEZWZpbml0aW9uRXhjZXB0aW9uJztcbiAgICBfdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBXcm9uZ0RlZmluaXRpb25FeGNlcHRpb247XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFdyb25nRGVmaW5pdGlvbkV4Y2VwdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX1JlZmVyZW5jZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVmZXJlbmNlXCIpKTtcblxudmFyIF9UYWdSZWZlcmVuY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1RhZ1JlZmVyZW5jZVwiKSk7XG5cbnZhciBfUGFja2FnZVJlZmVyZW5jZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUGFja2FnZVJlZmVyZW5jZVwiKSk7XG5cbnZhciBfUHJpdmF0ZVNlcnZpY2VFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V4Y2VwdGlvbi9Qcml2YXRlU2VydmljZUV4Y2VwdGlvblwiKSk7XG5cbnZhciBfU2VydmljZU5vdEZvdW5kRXhjZXB0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9FeGNlcHRpb24vU2VydmljZU5vdEZvdW5kRXhjZXB0aW9uXCIpKTtcblxudmFyIF9Ob3RBYnN0cmFjdFNlcnZpY2VFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V4Y2VwdGlvbi9Ob3RBYnN0cmFjdFNlcnZpY2VFeGNlcHRpb25cIikpO1xuXG52YXIgX01ldGhvZENhbGxOb3RGb3VuZEV4Y2VwdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRXhjZXB0aW9uL01ldGhvZENhbGxOb3RGb3VuZEV4Y2VwdGlvblwiKSk7XG5cbnZhciBfQWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9FeGNlcHRpb24vQWJzdHJhY3RTZXJ2aWNlRXhjZXB0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgSW5zdGFuY2VNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGFpbmVyQnVpbGRlcn0gY29udGFpbmVyQnVpbGRlclxuICAgKiBAcGFyYW0ge01hcH0gZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtNYXB9IGFsaWFzXG4gICAqL1xuICBmdW5jdGlvbiBJbnN0YW5jZU1hbmFnZXIoY29udGFpbmVyQnVpbGRlciwgZGVmaW5pdGlvbnMsIGFsaWFzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluc3RhbmNlTWFuYWdlcik7XG5cbiAgICB0aGlzLl9jb250YWluZXJCdWlsZGVyID0gY29udGFpbmVyQnVpbGRlcjtcbiAgICB0aGlzLl9kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgIHRoaXMuX2FsaWFzID0gYWxpYXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJ5cGFzc1B1YmxpY1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSW5zdGFuY2VNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJnZXRJbnN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICAgICAgdmFyIGJ5cGFzc1B1YmxpYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBpZCA9IHRoaXMuX2FsaWFzLmdldChpZCkgfHwgaWQ7XG5cbiAgICAgIGlmIChpZCA9PT0gJ3NlcnZpY2VfY29udGFpbmVyJyAmJiB0aGlzLl9jb250YWluZXJCdWlsZGVyLmNvbnRhaW5lclJlZmVyZW5jZUFzU2VydmljZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyQnVpbGRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb25zLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEluc3RhbmNlRnJvbUlkKGlkLCBieXBhc3NQdWJsaWMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb250YWluZXJCdWlsZGVyLmxvZ2dlci53YXJuKFwiVGhlIHNlcnZpY2UgXCIuY29uY2F0KGlkLCBcIiBpcyBub3QgcmVnaXN0ZXJlZFwiKSk7XG5cbiAgICAgIHRocm93IG5ldyBfU2VydmljZU5vdEZvdW5kRXhjZXB0aW9uW1wiZGVmYXVsdFwiXShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYnlwYXNzUHVibGljXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRJbnN0YW5jZUZyb21JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5zdGFuY2VGcm9tSWQoaWQpIHtcbiAgICAgIHZhciBieXBhc3NQdWJsaWMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMuX2RlZmluaXRpb25zLmdldChpZCk7XG5cbiAgICAgIGlmICghZGVmaW5pdGlvbltcInB1YmxpY1wiXSAmJiAhYnlwYXNzUHVibGljKSB7XG4gICAgICAgIHRocm93IG5ldyBfUHJpdmF0ZVNlcnZpY2VFeGNlcHRpb25bXCJkZWZhdWx0XCJdKGlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb25bXCJhYnN0cmFjdFwiXSkge1xuICAgICAgICB0aHJvdyBuZXcgX0Fic3RyYWN0U2VydmljZUV4Y2VwdGlvbltcImRlZmF1bHRcIl0oaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5kZXByZWNhdGVkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckJ1aWxkZXIubG9nZ2VyLndhcm4oJ0RFUFJFQ0FURUQnLCBkZWZpbml0aW9uLmRlcHJlY2F0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5PYmplY3QgfHwgZGVmaW5pdGlvbi5mYWN0b3J5IHx8ICFkZWZpbml0aW9uLk9iamVjdCAmJiBkZWZpbml0aW9uLnN5bnRoZXRpYykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXhpc3RpbmdJbnN0YW5jZUZyb21JZChpZCwgYnlwYXNzUHVibGljKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29udGFpbmVyQnVpbGRlci5sb2dnZXIud2FybihcIlRoZSBzZXJ2aWNlIFwiLmNvbmNhdChpZCwgXCIgaXMgbm90IHJlZ2lzdGVyZWRcIikpO1xuXG4gICAgICB0aHJvdyBuZXcgX1NlcnZpY2VOb3RGb3VuZEV4Y2VwdGlvbltcImRlZmF1bHRcIl0oaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJ5cGFzc1B1YmxpY1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RXhpc3RpbmdJbnN0YW5jZUZyb21JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RXhpc3RpbmdJbnN0YW5jZUZyb21JZChpZCkge1xuICAgICAgdmFyIGJ5cGFzc1B1YmxpYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5fZGVmaW5pdGlvbnMuZ2V0KGlkKTtcblxuICAgICAgaWYgKGRlZmluaXRpb24uc2hhcmVkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZUZyb21EZWZpbml0aW9uKGRlZmluaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29udGFpbmVyQnVpbGRlci5zZXJ2aWNlcy5oYXMoaWQpICYmIGRlZmluaXRpb24uaXNQdWJsaWMoYnlwYXNzUHVibGljKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyQnVpbGRlci5zZXJ2aWNlcy5nZXQoaWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbik7XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lckJ1aWxkZXIuc2VydmljZXMuc2V0KGlkLCBpbnN0YW5jZSk7XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEZWZpbml0aW9ufSBkZWZpbml0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbnN0YW5jZUZyb21EZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICAgICAgaWYgKGRlZmluaXRpb24uZmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5zdGFuY2VGcm9tRmFjdG9yeShkZWZpbml0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZWZpbml0aW9uLnN5bnRoZXRpYykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Tm90U3ludGhldGljSW5zdGFuY2VGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEZWZpbml0aW9ufSBkZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE5vdFN5bnRoZXRpY0luc3RhbmNlRnJvbURlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE5vdFN5bnRoZXRpY0luc3RhbmNlRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLl9yZXNvbHZlQXJndW1lbnRzKGRlZmluaXRpb24uYXJncyk7XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLnBhcmVudCkge1xuICAgICAgICBhcmdzID0gdGhpcy5fYXBwZW5kUGFyZW50QXJndW1lbnRzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnN0YW5jZSA9IF9jb25zdHJ1Y3QoZGVmaW5pdGlvbi5PYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkZWZpbml0aW9uLnByb3BlcnRpZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgICBpbnN0YW5jZVtrZXldID0gdGhpcy5fcmVzb2x2ZVNlcnZpY2VzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRlZmluaXRpb24uY2FsbHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY2FsbCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHRoaXMuX2NhbGxNZXRob2QoaW5zdGFuY2UsIGNhbGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RlZmluaXRpb259IGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SW5zdGFuY2VGcm9tRmFjdG9yeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5zdGFuY2VGcm9tRmFjdG9yeShkZWZpbml0aW9uKSB7XG4gICAgICB2YXIgX2RlZmluaXRpb24kZmFjdG9yeSRPO1xuXG4gICAgICB2YXIgYXJncyA9IHRoaXMuX3Jlc29sdmVBcmd1bWVudHMoZGVmaW5pdGlvbi5hcmdzKTtcblxuICAgICAgaWYgKGRlZmluaXRpb24uZmFjdG9yeS5PYmplY3QgaW5zdGFuY2VvZiBfUmVmZXJlbmNlW1wiZGVmYXVsdFwiXSkge1xuICAgICAgICB2YXIgX2ZhY3RvcnlTZXJ2aWNlJGNvbnN0O1xuXG4gICAgICAgIHZhciBmYWN0b3J5U2VydmljZSA9IHRoaXMuX2NvbnRhaW5lckJ1aWxkZXIuZ2V0KGRlZmluaXRpb24uZmFjdG9yeS5PYmplY3QuaWQpO1xuXG4gICAgICAgIHJldHVybiAoX2ZhY3RvcnlTZXJ2aWNlJGNvbnN0ID0gZmFjdG9yeVNlcnZpY2UuY29uc3RydWN0b3IpW2RlZmluaXRpb24uZmFjdG9yeS5tZXRob2RdLmFwcGx5KF9mYWN0b3J5U2VydmljZSRjb25zdCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfZGVmaW5pdGlvbiRmYWN0b3J5JE8gPSBkZWZpbml0aW9uLmZhY3RvcnkuT2JqZWN0KVtkZWZpbml0aW9uLmZhY3RvcnkubWV0aG9kXS5hcHBseShfZGVmaW5pdGlvbiRmYWN0b3J5JE8sIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc29sdmVBcmd1bWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVBcmd1bWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgcmVzb2x2ZWRBcmd1bWVudCA9IFtdO1xuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICByZXNvbHZlZEFyZ3VtZW50LnB1c2goX3RoaXMuX3Jlc29sdmVTZXJ2aWNlcyhhcmd1bWVudCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRBcmd1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEZWZpbml0aW9ufSBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kUGFyZW50QXJndW1lbnRzRnJvbURlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZFBhcmVudEFyZ3VtZW50c0Zyb21EZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgICAgdmFyIHBhcmVudERlZmluaXRpb24gPSB0aGlzLl9kZWZpbml0aW9ucy5nZXQoZGVmaW5pdGlvbi5wYXJlbnQpO1xuXG4gICAgICBpZiAoIXBhcmVudERlZmluaXRpb25bXCJhYnN0cmFjdFwiXSkge1xuICAgICAgICB0aHJvdyBuZXcgX05vdEFic3RyYWN0U2VydmljZUV4Y2VwdGlvbltcImRlZmF1bHRcIl0oZGVmaW5pdGlvbi5wYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncy5jb25jYXQodGhpcy5fcmVzb2x2ZUFyZ3VtZW50cyhwYXJlbnREZWZpbml0aW9uLmFwcGVuZEFyZ3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWZlcmVuY2V8UGFja2FnZVJlZmVyZW5jZXwqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNvbHZlU2VydmljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVTZXJ2aWNlcyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX1JlZmVyZW5jZVtcImRlZmF1bHRcIl0pIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5udWxsYWJsZSB8fCB2YWx1ZS5udWxsYWJsZSAmJiB0aGlzLl9jb250YWluZXJCdWlsZGVyLmhhc0RlZmluaXRpb24odmFsdWUuaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodmFsdWUuaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgX1BhY2thZ2VSZWZlcmVuY2VbXCJkZWZhdWx0XCJdKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKHZhbHVlLmlkKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBfVGFnUmVmZXJlbmNlW1wiZGVmYXVsdFwiXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFRhZ2dlZFNlcnZpY2VzKHZhbHVlLm5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRUYWdnZWRTZXJ2aWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFRhZ2dlZFNlcnZpY2VzKHRhZ05hbWUpIHtcbiAgICAgIHZhciB0YWdnZWRTZXJ2aWNlcyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX2RlZmluaXRpb25zKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBkZWZpbml0aW9uID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb24udGFncy5zb21lKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcubmFtZSA9PT0gdGFnTmFtZTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdmFyIHNlcnZpY2VJbnN0YW5jZSA9IHRoaXMuZ2V0SW5zdGFuY2UoaWQpO1xuICAgICAgICAgICAgdGFnZ2VkU2VydmljZXMucHVzaChzZXJ2aWNlSW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWdnZWRTZXJ2aWNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHt7bWV0aG9kLCBhcmdzfX0gY2FsbFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxsTWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsTWV0aG9kKHNlcnZpY2UsIGNhbGwpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VydmljZVtjYWxsLm1ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9NZXRob2RDYWxsTm90Rm91bmRFeGNlcHRpb25bXCJkZWZhdWx0XCJdKGNhbGwubWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3MgPSB0aGlzLl9yZXNvbHZlQXJndW1lbnRzKGNhbGwuYXJncyk7XG5cbiAgICAgIHNlcnZpY2VbY2FsbC5tZXRob2RdLmFwcGx5KHNlcnZpY2UsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluc3RhbmNlTWFuYWdlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBJbnN0YW5jZU1hbmFnZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9wYXRoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnZhciBfUmVmZXJlbmNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi8uLi9SZWZlcmVuY2VcIikpO1xuXG52YXIgX1BhY2thZ2VSZWZlcmVuY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLy4uL1BhY2thZ2VSZWZlcmVuY2VcIikpO1xuXG52YXIgX1RhZ1JlZmVyZW5jZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vLi4vVGFnUmVmZXJlbmNlXCIpKTtcblxudmFyIF9EZWZpbml0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi8uLi9EZWZpbml0aW9uXCIpKTtcblxudmFyIF92YWxpZGF0ZU5wbVBhY2thZ2VOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidmFsaWRhdGUtbnBtLXBhY2thZ2UtbmFtZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBGaWxlTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGFpbmVyQnVpbGRlcn0gY29udGFpbmVyXG4gICAqL1xuICBmdW5jdGlvbiBGaWxlTG9hZGVyKGNvbnRhaW5lcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlTG9hZGVyKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge0NvbnRhaW5lckJ1aWxkZXJ9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVMb2FkZXIsIFt7XG4gICAga2V5OiBcImNvbnRhaW5lclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbGVQYXRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlsZVBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fZmlsZVBhdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMgTWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja0ZpbGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY2hlY2tGaWxlKGZpbGUpIHtcbiAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5PCo+fSBzZXJ2aWNlc1xuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlRGVmaW5pdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlRGVmaW5pdGlvbnMoKSB7XG4gICAgICB2YXIgc2VydmljZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiBzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLl9wYXJzZURlZmluaXRpb24oc2VydmljZXMsIGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzZXJ2aWNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VEZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZURlZmluaXRpb24oc2VydmljZXMsIGlkKSB7XG4gICAgICB2YXIgc2VydmljZSA9IHNlcnZpY2VzW2lkXTtcblxuICAgICAgaWYgKHR5cGVvZiBzZXJ2aWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zZXRBbGlhcyhpZCwgc2VydmljZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlcnZpY2UuZmFjdG9yeSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zZXREZWZpbml0aW9uKGlkLCB0aGlzLl9nZXRGYWN0b3J5RGVmaW5pdGlvbihzZXJ2aWNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zZXREZWZpbml0aW9uKGlkLCB0aGlzLl9nZXREZWZpbml0aW9uKHNlcnZpY2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzZXJ2aWNlXG4gICAgICogQHJldHVybnMge0RlZmluaXRpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGYWN0b3J5RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RmFjdG9yeURlZmluaXRpb24oc2VydmljZSkge1xuICAgICAgdmFyIG9iamVjdCA9IG51bGw7XG5cbiAgICAgIGlmIChzZXJ2aWNlLmZhY3RvcnlbXCJjbGFzc1wiXS5pbmNsdWRlcygnQCcsIDApKSB7XG4gICAgICAgIG9iamVjdCA9IG5ldyBfUmVmZXJlbmNlW1wiZGVmYXVsdFwiXShzZXJ2aWNlLmZhY3RvcnlbXCJjbGFzc1wiXS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9yZXF1aXJlQ2xhc3NOYW1lRnJvbVBhdGgoc2VydmljZS5mYWN0b3J5W1wiY2xhc3NcIl0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmaW5pdGlvbiA9IG5ldyBfRGVmaW5pdGlvbltcImRlZmF1bHRcIl0oKTtcbiAgICAgIGRlZmluaXRpb24uc2hhcmVkID0gc2VydmljZS5zaGFyZWQ7XG4gICAgICBkZWZpbml0aW9uLnNldEZhY3Rvcnkob2JqZWN0LCBzZXJ2aWNlLmZhY3RvcnkubWV0aG9kKTtcbiAgICAgIGRlZmluaXRpb24uYXJncyA9IHRoaXMuX2dldFBhcnNlZEFyZ3VtZW50cyhzZXJ2aWNlLmFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzZXJ2aWNlXG4gICAgICogQHJldHVybnMge0RlZmluaXRpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZpbml0aW9uKHNlcnZpY2UpIHtcbiAgICAgIHZhciBkZWZpbml0aW9uO1xuXG4gICAgICBpZiAoIXNlcnZpY2Uuc3ludGhldGljKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9yZXF1aXJlQ2xhc3NOYW1lRnJvbVBhdGgoc2VydmljZVtcImNsYXNzXCJdLCBzZXJ2aWNlLm1haW4pO1xuXG4gICAgICAgIGRlZmluaXRpb24gPSBuZXcgX0RlZmluaXRpb25bXCJkZWZhdWx0XCJdKG9iamVjdCk7XG4gICAgICAgIGRlZmluaXRpb24ubGF6eSA9IHNlcnZpY2UubGF6eSB8fCBmYWxzZTtcbiAgICAgICAgZGVmaW5pdGlvbltcInB1YmxpY1wiXSA9IHNlcnZpY2VbXCJwdWJsaWNcIl0gIT09IGZhbHNlO1xuICAgICAgICBkZWZpbml0aW9uW1wiYWJzdHJhY3RcIl0gPSBzZXJ2aWNlW1wiYWJzdHJhY3RcIl0gfHwgZmFsc2U7XG4gICAgICAgIGRlZmluaXRpb24ucGFyZW50ID0gc2VydmljZS5wYXJlbnQ7XG4gICAgICAgIGRlZmluaXRpb24uZGVjb3JhdGVkU2VydmljZSA9IHNlcnZpY2UuZGVjb3JhdGVzO1xuICAgICAgICBkZWZpbml0aW9uLmRlY29yYXRpb25Qcmlvcml0eSA9IHNlcnZpY2UuZGVjb3JhdGlvbl9wcmlvcml0eTtcbiAgICAgICAgZGVmaW5pdGlvbi5kZXByZWNhdGVkID0gc2VydmljZS5kZXByZWNhdGVkO1xuICAgICAgICBkZWZpbml0aW9uLnNoYXJlZCA9IHNlcnZpY2Uuc2hhcmVkO1xuXG4gICAgICAgIHRoaXMuX3BhcnNlQXJndW1lbnRzKGRlZmluaXRpb24sIHNlcnZpY2UuYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnRpZXMoZGVmaW5pdGlvbiwgc2VydmljZS5wcm9wZXJ0aWVzKTtcblxuICAgICAgICB0aGlzLl9wYXJzZUNhbGxzKGRlZmluaXRpb24sIHNlcnZpY2UuY2FsbHMpO1xuXG4gICAgICAgIHRoaXMuX3BhcnNlVGFncyhkZWZpbml0aW9uLCBzZXJ2aWNlLnRhZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IG5ldyBfRGVmaW5pdGlvbltcImRlZmF1bHRcIl0oKTtcbiAgICAgICAgZGVmaW5pdGlvbi5zeW50aGV0aWMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEZWZpbml0aW9ufSBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2FsbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlQ2FsbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlQ2FsbHMoZGVmaW5pdGlvbikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNhbGxzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIGNhbGxzLmZvckVhY2goZnVuY3Rpb24gKGNhbGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbi5hZGRNZXRob2RDYWxsKGNhbGwubWV0aG9kLCBfdGhpcy5fZ2V0UGFyc2VkQXJndW1lbnRzKGNhbGwuYXJndW1lbnRzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEZWZpbml0aW9ufSBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFnc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVRhZ3MoZGVmaW5pdGlvbikge1xuICAgICAgdmFyIHRhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgZGVmaW5pdGlvbi5hZGRUYWcodGFnLm5hbWUsIEZpbGVMb2FkZXIuX3BhcnNlVGFnQXR0cmlidXRlcyh0YWcuYXR0cmlidXRlcykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRQYXJzZWRBcmd1bWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFBhcnNlZEFyZ3VtZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgcGFyc2VkQXJndW1lbnRzID0gW107XG4gICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgIHBhcnNlZEFyZ3VtZW50cy5wdXNoKF90aGlzMi5fcGFyc2VBcmd1bWVudChhcmd1bWVudCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VkQXJndW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RlZmluaXRpb259IGRlZmluaXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VQcm9wZXJ0aWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVByb3BlcnRpZXMoZGVmaW5pdGlvbikge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eUtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGRlZmluaXRpb24uYWRkUHJvcGVydHkocHJvcGVydHlLZXksIHRoaXMuX3BhcnNlQXJndW1lbnQocHJvcGVydGllc1twcm9wZXJ0eUtleV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTx7cmVzb3VyY2V9Pn0gaW1wb3J0c1xuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlSW1wb3J0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VJbXBvcnRzKCkge1xuICAgICAgdmFyIGltcG9ydHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW1wb3J0cyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGZpbGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgd29ya2luZ1BhdGggPSB0aGlzLmZpbGVQYXRoO1xuICAgICAgICAgIHRoaXMubG9hZChfcGF0aFtcImRlZmF1bHRcIl0uam9pbihfcGF0aFtcImRlZmF1bHRcIl0uZGlybmFtZSh0aGlzLmZpbGVQYXRoKSwgZmlsZS5yZXNvdXJjZSkpO1xuICAgICAgICAgIHRoaXMuZmlsZVBhdGggPSB3b3JraW5nUGF0aDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wYXJzZVBhcmFtZXRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUGFyYW1ldGVycygpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldFBhcmFtZXRlcihrZXksIHBhcmFtZXRlcnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGVmaW5pdGlvbn0gZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VBcmd1bWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlQXJndW1lbnRzKGRlZmluaXRpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBhcmd1bWVudCA9IGRlZmluaXRpb25bXCJhYnN0cmFjdFwiXSA/ICdhcHBlbmRBcmdzJyA6ICdhcmdzJztcbiAgICAgIGRlZmluaXRpb25bYXJndW1lbnRdID0gdGhpcy5fZ2V0UGFyc2VkQXJndW1lbnRzKGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VBcmd1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VBcmd1bWVudChhcmd1bWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50LnNsaWNlKDAsIDIpID09PSAnQD8nKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1JlZmVyZW5jZVtcImRlZmF1bHRcIl0oYXJndW1lbnQuc2xpY2UoMiksIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudC5zbGljZSgwLCAxKSA9PT0gJ0AnKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1JlZmVyZW5jZVtcImRlZmF1bHRcIl0oYXJndW1lbnQuc2xpY2UoMSkpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudC5zbGljZSgwLCAxKSA9PT0gJyUnICYmIGFyZ3VtZW50LnNsaWNlKC0xKSA9PT0gJyUnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBcmd1bWVudFBhcmFtZXRlcihhcmd1bWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LnNsaWNlKDAsIDEpID09PSAnJScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUGFja2FnZVJlZmVyZW5jZVtcImRlZmF1bHRcIl0oYXJndW1lbnQuc2xpY2UoMSkpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudC5zbGljZSgwLCA3KSA9PT0gJyF0YWdnZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1RhZ1JlZmVyZW5jZVtcImRlZmF1bHRcIl0oYXJndW1lbnQuc2xpY2UoOCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJndW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBcmd1bWVudFBhcmFtZXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXJndW1lbnRQYXJhbWV0ZXIoYXJndW1lbnQpIHtcbiAgICAgIGlmIChhcmd1bWVudC5zbGljZSgxLCA0KSA9PT0gJ2VudicpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52W2FyZ3VtZW50LnNsaWNlKDUsIC0yKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLmdldFBhcmFtZXRlcihhcmd1bWVudC5zbGljZSgxLCAtMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NPYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFpbkNsYXNzTmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1aXJlQ2xhc3NOYW1lRnJvbVBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVpcmVDbGFzc05hbWVGcm9tUGF0aChjbGFzc09iamVjdCwgbWFpbkNsYXNzTmFtZSkge1xuICAgICAgdmFyIGZyb21EaXJlY3RvcnkgPSAhX3BhdGhbXCJkZWZhdWx0XCJdLmlzQWJzb2x1dGUoY2xhc3NPYmplY3QpID8gX3BhdGhbXCJkZWZhdWx0XCJdLmRpcm5hbWUodGhpcy5maWxlUGF0aCkgOiAnLyc7XG4gICAgICBmcm9tRGlyZWN0b3J5ID0gdGhpcy5jb250YWluZXIuZGVmYXVsdERpciB8fCBmcm9tRGlyZWN0b3J5O1xuICAgICAgdmFyIGV4cG9ydGVkTW9kdWxlID0gbnVsbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXhwb3J0ZWRNb2R1bGUgPSByZXF1aXJlKF9wYXRoW1wiZGVmYXVsdFwiXS5qb2luKGZyb21EaXJlY3RvcnksIGNsYXNzT2JqZWN0KSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiB0aGUgcGF0aCBpcyBhIHZhbGlkIG5wbSBwYWNrYWdlIG5hbWUsXG4gICAgICAgIC8vIHRyeSB0byBpbXBvcnQgYSBnbG9iYWwgcGFja2FnZS5cbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdNT0RVTEVfTk9UX0ZPVU5EJyAmJiAoMCwgX3ZhbGlkYXRlTnBtUGFja2FnZU5hbWVbXCJkZWZhdWx0XCJdKShjbGFzc09iamVjdCkpIHtcbiAgICAgICAgICBleHBvcnRlZE1vZHVsZSA9IHJlcXVpcmUoY2xhc3NPYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtYWluQ2xhc3MgPSBleHBvcnRlZE1vZHVsZVttYWluQ2xhc3NOYW1lXTtcbiAgICAgIHZhciBkZWZhdWx0Q2xhc3MgPSBleHBvcnRlZE1vZHVsZVtcImRlZmF1bHRcIl07XG5cbiAgICAgIHZhciBmaWxlTmFtZUNsYXNzID0gZXhwb3J0ZWRNb2R1bGVbX3BhdGhbXCJkZWZhdWx0XCJdLmJhc2VuYW1lKGNsYXNzT2JqZWN0KV07XG5cbiAgICAgIHJldHVybiBtYWluQ2xhc3MgfHwgZGVmYXVsdENsYXNzIHx8IGZpbGVOYW1lQ2xhc3MgfHwgZXhwb3J0ZWRNb2R1bGU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiX3BhcnNlVGFnQXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VUYWdBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXNbX2ldO1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVMb2FkZXI7XG59KCk7XG5cbnZhciBfZGVmYXVsdCA9IEZpbGVMb2FkZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9GaWxlTG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRmlsZUxvYWRlclwiKSk7XG5cbnZhciBfQ29uZmlndXJhdGlvbkZpbGVOb3RGb3VuZEV4Y2VwdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL0V4Y2VwdGlvbi9Db25maWd1cmF0aW9uRmlsZU5vdEZvdW5kRXhjZXB0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIEpzRmlsZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ZpbGVMb2FkZXIpIHtcbiAgX2luaGVyaXRzKEpzRmlsZUxvYWRlciwgX0ZpbGVMb2FkZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSnNGaWxlTG9hZGVyKTtcblxuICBmdW5jdGlvbiBKc0ZpbGVMb2FkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpzRmlsZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSnNGaWxlTG9hZGVyLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gZmlsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoSnNGaWxlTG9hZGVyLnByb3RvdHlwZSksIFwiX2NoZWNrRmlsZVwiLCB0aGlzKS5jYWxsKHRoaXMsIGZpbGUpO1xuXG4gICAgICB2YXIgY29udGVudDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUodGhpcy5maWxlUGF0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBfQ29uZmlndXJhdGlvbkZpbGVOb3RGb3VuZEV4Y2VwdGlvbltcImRlZmF1bHRcIl0odGhpcy5maWxlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhcnNlSW1wb3J0cyhjb250ZW50LmltcG9ydHMpO1xuXG4gICAgICB0aGlzLl9wYXJzZVBhcmFtZXRlcnMoY29udGVudC5wYXJhbWV0ZXJzKTtcblxuICAgICAgdGhpcy5fcGFyc2VEZWZpbml0aW9ucyhjb250ZW50LnNlcnZpY2VzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSnNGaWxlTG9hZGVyO1xufShfRmlsZUxvYWRlcjJbXCJkZWZhdWx0XCJdKTtcblxudmFyIF9kZWZhdWx0ID0gSnNGaWxlTG9hZGVyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfSnNGaWxlTG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vSnNGaWxlTG9hZGVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBKc29uRmlsZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0pzRmlsZUxvYWRlcikge1xuICBfaW5oZXJpdHMoSnNvbkZpbGVMb2FkZXIsIF9Kc0ZpbGVMb2FkZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSnNvbkZpbGVMb2FkZXIpO1xuXG4gIGZ1bmN0aW9uIEpzb25GaWxlTG9hZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKc29uRmlsZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gSnNvbkZpbGVMb2FkZXI7XG59KF9Kc0ZpbGVMb2FkZXIyW1wiZGVmYXVsdFwiXSk7XG5cbnZhciBfZGVmYXVsdCA9IEpzb25GaWxlTG9hZGVyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfRmlsZUxvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0ZpbGVMb2FkZXJcIikpO1xuXG52YXIgX2pzWWFtbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpzLXlhbWxcIikpO1xuXG52YXIgZnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiZnNcIikpO1xuXG52YXIgX1NlcnZpY2VGaWxlTm90Rm91bmRFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9FeGNlcHRpb24vU2VydmljZUZpbGVOb3RGb3VuZEV4Y2VwdGlvblwiKSk7XG5cbnZhciBfU2VydmljZUZpbGVOb3RMb2FkZWRFeGNlcHRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9FeGNlcHRpb24vU2VydmljZUZpbGVOb3RMb2FkZWRFeGNlcHRpb25cIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBZYW1sRmlsZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ZpbGVMb2FkZXIpIHtcbiAgX2luaGVyaXRzKFlhbWxGaWxlTG9hZGVyLCBfRmlsZUxvYWRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihZYW1sRmlsZUxvYWRlcik7XG5cbiAgZnVuY3Rpb24gWWFtbEZpbGVMb2FkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlhbWxGaWxlTG9hZGVyKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhZYW1sRmlsZUxvYWRlciwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZpbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgdmFyIGZpbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFlhbWxGaWxlTG9hZGVyLnByb3RvdHlwZSksIFwiX2NoZWNrRmlsZVwiLCB0aGlzKS5jYWxsKHRoaXMsIGZpbGUpO1xuXG4gICAgICB2YXIgcmF3Q29udGVudDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmF3Q29udGVudCA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLmZpbGVQYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9TZXJ2aWNlRmlsZU5vdEZvdW5kRXhjZXB0aW9uW1wiZGVmYXVsdFwiXSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnQgPSBfanNZYW1sW1wiZGVmYXVsdFwiXS5sb2FkKHJhd0NvbnRlbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgX1NlcnZpY2VGaWxlTm90TG9hZGVkRXhjZXB0aW9uW1wiZGVmYXVsdFwiXShlLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYXJzZUltcG9ydHMoY29udGVudC5pbXBvcnRzKTtcblxuICAgICAgdGhpcy5fcGFyc2VQYXJhbWV0ZXJzKGNvbnRlbnQucGFyYW1ldGVycyk7XG5cbiAgICAgIHRoaXMuX3BhcnNlRGVmaW5pdGlvbnMoY29udGVudC5zZXJ2aWNlcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlhbWxGaWxlTG9hZGVyO1xufShfRmlsZUxvYWRlcjJbXCJkZWZhdWx0XCJdKTtcblxudmFyIF9kZWZhdWx0ID0gWWFtbEZpbGVMb2FkZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gKCkgPT4gKFtdKTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1kZXBlbmRlbmN5LWluamVjdGlvbi9kaXN0L2xpYi9Mb2FkZXIgc3luYyByZWN1cnNpdmVcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBQYWNrYWdlUmVmZXJlbmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKi9cbiAgZnVuY3Rpb24gUGFja2FnZVJlZmVyZW5jZShpZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYWNrYWdlUmVmZXJlbmNlKTtcblxuICAgIHRoaXMuX2lkID0gaWQ7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBhY2thZ2VSZWZlcmVuY2UsIFt7XG4gICAga2V5OiBcImlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhY2thZ2VSZWZlcmVuY2U7XG59KCk7XG5cbnZhciBfZGVmYXVsdCA9IFBhY2thZ2VSZWZlcmVuY2U7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFBhc3NDb25maWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXNzQ29uZmlnKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXNzQ29uZmlnKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXNzQ29uZmlnLCBudWxsLCBbe1xuICAgIGtleTogXCJUWVBFX0JFRk9SRV9PUFRJTUlaQVRJT05cIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ2JlZm9yZU9wdGltaXphdGlvbic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUWVBFX09QVElNSVpFXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ29wdGltaXplJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlRZUEVfQkVGT1JFX1JFTU9WSU5HXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ2JlZm9yZVJlbW92aW5nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlRZUEVfUkVNT1ZFXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3JlbW92ZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUWVBFX0FGVEVSX1JFTU9WSU5HXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ2FmdGVyUmVtb3ZpbmcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWxpZFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZFR5cGUodHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMuVFlQRV9CRUZPUkVfT1BUSU1JWkFUSU9OID09PSB0eXBlIHx8IHRoaXMuVFlQRV9PUFRJTUlaRSA9PT0gdHlwZSB8fCB0aGlzLlRZUEVfQkVGT1JFX1JFTU9WSU5HID09PSB0eXBlIHx8IHRoaXMuVFlQRV9SRU1PVkUgPT09IHR5cGUgfHwgdGhpcy5UWVBFX0FGVEVSX1JFTU9WSU5HID09PSB0eXBlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXNzQ29uZmlnO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBhc3NDb25maWc7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgUmVmZXJlbmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG51bGxhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBSZWZlcmVuY2UoaWQpIHtcbiAgICB2YXIgbnVsbGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZmVyZW5jZSk7XG5cbiAgICB0aGlzLl9pZCA9IGlkO1xuICAgIHRoaXMuX251bGxhYmxlID0gbnVsbGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFJlZmVyZW5jZSwgW3tcbiAgICBrZXk6IFwiaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJudWxsYWJsZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX251bGxhYmxlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWZlcmVuY2U7XG59KCk7XG5cbnZhciBfZGVmYXVsdCA9IFJlZmVyZW5jZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgVGFnUmVmZXJlbmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBUYWdSZWZlcmVuY2UobmFtZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWdSZWZlcmVuY2UpO1xuXG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRhZ1JlZmVyZW5jZSwgW3tcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRhZ1JlZmVyZW5jZTtcbn0oKTtcblxudmFyIF9kZWZhdWx0ID0gVGFnUmVmZXJlbmNlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRhaW5lckJ1aWxkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0NvbnRhaW5lckJ1aWxkZXJbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzRmlsZUxvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfSnNGaWxlTG9hZGVyW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uRmlsZUxvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfSnNvbkZpbGVMb2FkZXJbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIllhbWxGaWxlTG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9ZYW1sRmlsZUxvYWRlcltcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFja2FnZVJlZmVyZW5jZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUGFja2FnZVJlZmVyZW5jZVtcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVmZXJlbmNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9SZWZlcmVuY2VbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhc3NDb25maWdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1Bhc3NDb25maWdbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmluaXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0RlZmluaXRpb25bXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRhZ1JlZmVyZW5jZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfVGFnUmVmZXJlbmNlW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG5cbnZhciBfQ29udGFpbmVyQnVpbGRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vQ29udGFpbmVyQnVpbGRlclwiKSk7XG5cbnZhciBfSnNGaWxlTG9hZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Mb2FkZXIvSnNGaWxlTG9hZGVyXCIpKTtcblxudmFyIF9Kc29uRmlsZUxvYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTG9hZGVyL0pzb25GaWxlTG9hZGVyXCIpKTtcblxudmFyIF9ZYW1sRmlsZUxvYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTG9hZGVyL1lhbWxGaWxlTG9hZGVyXCIpKTtcblxudmFyIF9QYWNrYWdlUmVmZXJlbmNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9QYWNrYWdlUmVmZXJlbmNlXCIpKTtcblxudmFyIF9SZWZlcmVuY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlZmVyZW5jZVwiKSk7XG5cbnZhciBfUGFzc0NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUGFzc0NvbmZpZ1wiKSk7XG5cbnZhciBfRGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRGVmaW5pdGlvblwiKSk7XG5cbnZhciBfVGFnUmVmZXJlbmNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9UYWdSZWZlcmVuY2VcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH0iLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9ICgpID0+IChbXSk7XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb24vZGlzdC9saWIgc3luYyByZWN1cnNpdmVcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDsiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vbGliL2xvYWRlcicpO1xudmFyIGR1bXBlciA9IHJlcXVpcmUoJy4vbGliL2R1bXBlcicpO1xuXG5cbmZ1bmN0aW9uIHJlbmFtZWQoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHlhbWwuJyArIGZyb20gKyAnIGlzIHJlbW92ZWQgaW4ganMteWFtbCA0LiAnICtcbiAgICAgICdVc2UgeWFtbC4nICsgdG8gKyAnIGluc3RlYWQsIHdoaWNoIGlzIG5vdyBzYWZlIGJ5IGRlZmF1bHQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEnKTtcbm1vZHVsZS5leHBvcnRzLkZBSUxTQUZFX1NDSEVNQSAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEvanNvbicpO1xubW9kdWxlLmV4cG9ydHMuQ09SRV9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS9jb3JlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NDSEVNQSAgICAgID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hL2RlZmF1bHQnKTtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgICAgICAgICAgPSBsb2FkZXIubG9hZDtcbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLllBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2xpYi9leGNlcHRpb24nKTtcblxuLy8gUmUtZXhwb3J0IGFsbCB0eXBlcyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGN1c3RvbSBzY2hlbWFcbm1vZHVsZS5leHBvcnRzLnR5cGVzID0ge1xuICBiaW5hcnk6ICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvYmluYXJ5JyksXG4gIGZsb2F0OiAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9mbG9hdCcpLFxuICBtYXA6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvbWFwJyksXG4gIG51bGw6ICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9udWxsJyksXG4gIHBhaXJzOiAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9wYWlycycpLFxuICBzZXQ6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvc2V0JyksXG4gIHRpbWVzdGFtcDogcmVxdWlyZSgnLi9saWIvdHlwZS90aW1lc3RhbXAnKSxcbiAgYm9vbDogICAgICByZXF1aXJlKCcuL2xpYi90eXBlL2Jvb2wnKSxcbiAgaW50OiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL2ludCcpLFxuICBtZXJnZTogICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvbWVyZ2UnKSxcbiAgb21hcDogICAgICByZXF1aXJlKCcuL2xpYi90eXBlL29tYXAnKSxcbiAgc2VxOiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL3NlcScpLFxuICBzdHI6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvc3RyJylcbn07XG5cbi8vIFJlbW92ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAzLjAueFxubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVMb2FkJywgJ2xvYWQnKTtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkQWxsICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZEFsbCcsICdsb2FkQWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUR1bXAnLCAnZHVtcCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfU0NIRU1BICAgICAgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0Jyk7XG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX0JPTSAgICAgICAgICAgICAgICAgID0gMHhGRUZGO1xudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxudmFyIERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCA9IC9eWy0rXT9bMC05X10rKD86OlswLTlfXSspKyg/OlxcLlswLTlfXSopPyQvO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignY29kZSBwb2ludCB3aXRoaW4gYSBzdHJpbmcgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gMHhGRkZGRkZGRicpO1xuICB9XG5cbiAgcmV0dXJuICdcXFxcJyArIGhhbmRsZSArIGNvbW1vbi5yZXBlYXQoJzAnLCBsZW5ndGggLSBzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn1cblxuXG52YXIgUVVPVElOR19UWVBFX1NJTkdMRSA9IDEsXG4gICAgUVVPVElOR19UWVBFX0RPVUJMRSA9IDI7XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICAgID0gb3B0aW9uc1snc2NoZW1hJ10gfHwgREVGQVVMVF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgICA9IE1hdGgubWF4KDEsIChvcHRpb25zWydpbmRlbnQnXSB8fCAyKSk7XG4gIHRoaXMubm9BcnJheUluZGVudCA9IG9wdGlvbnNbJ25vQXJyYXlJbmRlbnQnXSB8fCBmYWxzZTtcbiAgdGhpcy5za2lwSW52YWxpZCAgID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICAgID0gKGNvbW1vbi5pc05vdGhpbmcob3B0aW9uc1snZmxvd0xldmVsJ10pID8gLTEgOiBvcHRpb25zWydmbG93TGV2ZWwnXSk7XG4gIHRoaXMuc3R5bGVNYXAgICAgICA9IGNvbXBpbGVTdHlsZU1hcCh0aGlzLnNjaGVtYSwgb3B0aW9uc1snc3R5bGVzJ10gfHwgbnVsbCk7XG4gIHRoaXMuc29ydEtleXMgICAgICA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoICAgICA9IG9wdGlvbnNbJ2xpbmVXaWR0aCddIHx8IDgwO1xuICB0aGlzLm5vUmVmcyAgICAgICAgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgID0gb3B0aW9uc1snbm9Db21wYXRNb2RlJ10gfHwgZmFsc2U7XG4gIHRoaXMuY29uZGVuc2VGbG93ICA9IG9wdGlvbnNbJ2NvbmRlbnNlRmxvdyddIHx8IGZhbHNlO1xuICB0aGlzLnF1b3RpbmdUeXBlICAgPSBvcHRpb25zWydxdW90aW5nVHlwZSddID09PSAnXCInID8gUVVPVElOR19UWVBFX0RPVUJMRSA6IFFVT1RJTkdfVFlQRV9TSU5HTEU7XG4gIHRoaXMuZm9yY2VRdW90ZXMgICA9IG9wdGlvbnNbJ2ZvcmNlUXVvdGVzJ10gfHwgZmFsc2U7XG4gIHRoaXMucmVwbGFjZXIgICAgICA9IHR5cGVvZiBvcHRpb25zWydyZXBsYWNlciddID09PSAnZnVuY3Rpb24nID8gb3B0aW9uc1sncmVwbGFjZXInXSA6IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG4vLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG5cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBjID09PSBDSEFSX1NQQUNFIHx8IGMgPT09IENIQVJfVEFCO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjYW4gYmUgcHJpbnRlZCB3aXRob3V0IGVzY2FwaW5nLlxuLy8gRnJvbSBZQU1MIDEuMjogXCJhbnkgYWxsb3dlZCBjaGFyYWN0ZXJzIGtub3duIHRvIGJlIG5vbi1wcmludGFibGVcbi8vIHNob3VsZCBhbHNvIGJlIGVzY2FwZWQuIFtIb3dldmVyLF0gVGhpcyBpc27igJl0IG1hbmRhdG9yeVwiXG4vLyBEZXJpdmVkIGZyb20gbmItY2hhciAtIFxcdCAtICN4ODUgLSAjeEEwIC0gI3gyMDI4IC0gI3gyMDI5LlxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gICgweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSlcbiAgICAgIHx8ICgoMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYpICYmIGMgIT09IDB4MjAyOCAmJiBjICE9PSAweDIwMjkpXG4gICAgICB8fCAoKDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEKSAmJiBjICE9PSBDSEFSX0JPTSlcbiAgICAgIHx8ICAoMHgxMDAwMCA8PSBjICYmIGMgPD0gMHgxMEZGRkYpO1xufVxuXG4vLyBbMzRdIG5zLWNoYXIgOjo9IG5iLWNoYXIgLSBzLXdoaXRlXG4vLyBbMjddIG5iLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1jaGFyIC0gYy1ieXRlLW9yZGVyLW1hcmtcbi8vIFsyNl0gYi1jaGFyICA6Oj0gYi1saW5lLWZlZWQgfCBiLWNhcnJpYWdlLXJldHVyblxuLy8gSW5jbHVkaW5nIHMtd2hpdGUgKGZvciBzb21lIHJlYXNvbiwgZXhhbXBsZXMgZG9lc24ndCBtYXRjaCBzcGVjcyBpbiB0aGlzIGFzcGVjdClcbi8vIG5zLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1saW5lLWZlZWQgLSBiLWNhcnJpYWdlLXJldHVybiAtIGMtYnl0ZS1vcmRlci1tYXJrXG5mdW5jdGlvbiBpc05zQ2hhck9yV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBpc1ByaW50YWJsZShjKVxuICAgICYmIGMgIT09IENIQVJfQk9NXG4gICAgLy8gLSBiLWNoYXJcbiAgICAmJiBjICE9PSBDSEFSX0NBUlJJQUdFX1JFVFVSTlxuICAgICYmIGMgIT09IENIQVJfTElORV9GRUVEO1xufVxuXG4vLyBbMTI3XSAgbnMtcGxhaW4tc2FmZShjKSA6Oj0gYyA9IGZsb3ctb3V0ICDih5IgbnMtcGxhaW4tc2FmZS1vdXRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gZmxvdy1pbiAgIOKHkiBucy1wbGFpbi1zYWZlLWluXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGJsb2NrLWtleSDih5IgbnMtcGxhaW4tc2FmZS1vdXRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gZmxvdy1rZXkgIOKHkiBucy1wbGFpbi1zYWZlLWluXG4vLyBbMTI4XSBucy1wbGFpbi1zYWZlLW91dCA6Oj0gbnMtY2hhclxuLy8gWzEyOV0gIG5zLXBsYWluLXNhZmUtaW4gOjo9IG5zLWNoYXIgLSBjLWZsb3ctaW5kaWNhdG9yXG4vLyBbMTMwXSAgbnMtcGxhaW4tY2hhcihjKSA6Oj0gICggbnMtcGxhaW4tc2FmZShjKSAtIOKAnDrigJ0gLSDigJwj4oCdIClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKCAvKiBBbiBucy1jaGFyIHByZWNlZGluZyAqLyDigJwj4oCdIClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKCDigJw64oCdIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykgKi8gKVxuZnVuY3Rpb24gaXNQbGFpblNhZmUoYywgcHJldiwgaW5ibG9jaykge1xuICB2YXIgY0lzTnNDaGFyT3JXaGl0ZXNwYWNlID0gaXNOc0NoYXJPcldoaXRlc3BhY2UoYyk7XG4gIHZhciBjSXNOc0NoYXIgPSBjSXNOc0NoYXJPcldoaXRlc3BhY2UgJiYgIWlzV2hpdGVzcGFjZShjKTtcbiAgcmV0dXJuIChcbiAgICAvLyBucy1wbGFpbi1zYWZlXG4gICAgaW5ibG9jayA/IC8vIGMgPSBmbG93LWluXG4gICAgICBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgIDogY0lzTnNDaGFyT3JXaGl0ZXNwYWNlXG4gICAgICAgIC8vIC0gYy1mbG93LWluZGljYXRvclxuICAgICAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICApXG4gICAgLy8gbnMtcGxhaW4tY2hhclxuICAgICYmIGMgIT09IENIQVJfU0hBUlAgLy8gZmFsc2Ugb24gJyMnXG4gICAgJiYgIShwcmV2ID09PSBDSEFSX0NPTE9OICYmICFjSXNOc0NoYXIpIC8vIGZhbHNlIG9uICc6ICdcbiAgICB8fCAoaXNOc0NoYXJPcldoaXRlc3BhY2UocHJldikgJiYgIWlzV2hpdGVzcGFjZShwcmV2KSAmJiBjID09PSBDSEFSX1NIQVJQKSAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnW14gXSMnXG4gICAgfHwgKHByZXYgPT09IENIQVJfQ09MT04gJiYgY0lzTnNDaGFyKTsgLy8gY2hhbmdlIHRvIHRydWUgb24gJzpbXiBdJ1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUZpcnN0KGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBucy1jaGFyIC0gYy1pbmRpY2F0b3JcbiAgLy8gd2hlcmUgbnMtY2hhciA9IG5iLWNoYXIgLSBzLXdoaXRlLlxuICAvLyBObyBzdXBwb3J0IG9mICggKCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnC3igJ0gKSAvKiBGb2xsb3dlZCBieSBhbiBucy1wbGFpbi1zYWZlKGMpKSAqLyApIHBhcnRcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IENIQVJfQk9NXG4gICAgJiYgIWlzV2hpdGVzcGFjZShjKSAvLyAtIHMtd2hpdGVcbiAgICAvLyAtIChjLWluZGljYXRvciA6Oj1cbiAgICAvLyDigJwt4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJws4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ0gfCDigJx74oCdIHwg4oCcfeKAnVxuICAgICYmIGMgIT09IENIQVJfTUlOVVNcbiAgICAmJiBjICE9PSBDSEFSX1FVRVNUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT0xPTlxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyB8IOKAnCPigJ0gfCDigJwm4oCdIHwg4oCcKuKAnSB8IOKAnCHigJ0gfCDigJx84oCdIHwg4oCcPeKAnSB8IOKAnD7igJ0gfCDigJwn4oCdIHwg4oCcXCLigJ1cbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQXG4gICAgJiYgYyAhPT0gQ0hBUl9BTVBFUlNBTkRcbiAgICAmJiBjICE9PSBDSEFSX0FTVEVSSVNLXG4gICAgJiYgYyAhPT0gQ0hBUl9FWENMQU1BVElPTlxuICAgICYmIGMgIT09IENIQVJfVkVSVElDQUxfTElORVxuICAgICYmIGMgIT09IENIQVJfRVFVQUxTXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkVBVEVSX1RIQU5cbiAgICAmJiBjICE9PSBDSEFSX1NJTkdMRV9RVU9URVxuICAgICYmIGMgIT09IENIQVJfRE9VQkxFX1FVT1RFXG4gICAgLy8gfCDigJwl4oCdIHwg4oCcQOKAnSB8IOKAnGDigJ0pXG4gICAgJiYgYyAhPT0gQ0hBUl9QRVJDRU5UXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NRVJDSUFMX0FUXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkFWRV9BQ0NFTlQ7XG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVMYXN0KGMpIHtcbiAgLy8ganVzdCBub3Qgd2hpdGVzcGFjZSBvciBjb2xvbiwgaXQgd2lsbCBiZSBjaGVja2VkIHRvIGJlIHBsYWluIGNoYXJhY3RlciBsYXRlclxuICByZXR1cm4gIWlzV2hpdGVzcGFjZShjKSAmJiBjICE9PSBDSEFSX0NPTE9OO1xufVxuXG4vLyBTYW1lIGFzICdzdHJpbmcnLmNvZGVQb2ludEF0KHBvcyksIGJ1dCB3b3JrcyBpbiBvbGRlciBicm93c2Vycy5cbmZ1bmN0aW9uIGNvZGVQb2ludEF0KHN0cmluZywgcG9zKSB7XG4gIHZhciBmaXJzdCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyksIHNlY29uZDtcbiAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgcG9zICsgMSA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICBzZWNvbmQgPSBzdHJpbmcuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgIHJldHVybiAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlyc3Q7XG59XG5cbi8vIERldGVybWluZXMgd2hldGhlciBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgaXMgcmVxdWlyZWQuXG5mdW5jdGlvbiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykge1xuICB2YXIgbGVhZGluZ1NwYWNlUmUgPSAvXlxcbiogLztcbiAgcmV0dXJuIGxlYWRpbmdTcGFjZVJlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIFNUWUxFX1BMQUlOICAgPSAxLFxuICAgIFNUWUxFX1NJTkdMRSAgPSAyLFxuICAgIFNUWUxFX0xJVEVSQUwgPSAzLFxuICAgIFNUWUxFX0ZPTERFRCAgPSA0LFxuICAgIFNUWUxFX0RPVUJMRSAgPSA1O1xuXG4vLyBEZXRlcm1pbmVzIHdoaWNoIHNjYWxhciBzdHlsZXMgYXJlIHBvc3NpYmxlIGFuZCByZXR1cm5zIHRoZSBwcmVmZXJyZWQgc3R5bGUuXG4vLyBsaW5lV2lkdGggPSAtMSA9PiBubyBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBzdHIubGVuZ3RoID4gMC5cbi8vIFBvc3QtY29uZGl0aW9uczpcbi8vICAgIFNUWUxFX1BMQUlOIG9yIFNUWUxFX1NJTkdMRSA9PiBubyBcXG4gYXJlIGluIHRoZSBzdHJpbmcuXG4vLyAgICBTVFlMRV9MSVRFUkFMID0+IG5vIGxpbmVzIGFyZSBzdWl0YWJsZSBmb3IgZm9sZGluZyAob3IgbGluZVdpZHRoIGlzIC0xKS5cbi8vICAgIFNUWUxFX0ZPTERFRCA9PiBhIGxpbmUgPiBsaW5lV2lkdGggYW5kIGNhbiBiZSBmb2xkZWQgKGFuZCBsaW5lV2lkdGggIT0gLTEpLlxuZnVuY3Rpb24gY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgaW5kZW50UGVyTGV2ZWwsIGxpbmVXaWR0aCxcbiAgdGVzdEFtYmlndW91c1R5cGUsIHF1b3RpbmdUeXBlLCBmb3JjZVF1b3RlcywgaW5ibG9jaykge1xuXG4gIHZhciBpO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBwcmV2Q2hhciA9IG51bGw7XG4gIHZhciBoYXNMaW5lQnJlYWsgPSBmYWxzZTtcbiAgdmFyIGhhc0ZvbGRhYmxlTGluZSA9IGZhbHNlOyAvLyBvbmx5IGNoZWNrZWQgaWYgc2hvdWxkVHJhY2tXaWR0aFxuICB2YXIgc2hvdWxkVHJhY2tXaWR0aCA9IGxpbmVXaWR0aCAhPT0gLTE7XG4gIHZhciBwcmV2aW91c0xpbmVCcmVhayA9IC0xOyAvLyBjb3VudCB0aGUgZmlyc3QgbGluZSBjb3JyZWN0bHlcbiAgdmFyIHBsYWluID0gaXNQbGFpblNhZmVGaXJzdChjb2RlUG9pbnRBdChzdHJpbmcsIDApKVxuICAgICAgICAgICYmIGlzUGxhaW5TYWZlTGFzdChjb2RlUG9pbnRBdChzdHJpbmcsIHN0cmluZy5sZW5ndGggLSAxKSk7XG5cbiAgaWYgKHNpbmdsZUxpbmVPbmx5IHx8IGZvcmNlUXVvdGVzKSB7XG4gICAgLy8gQ2FzZTogbm8gYmxvY2sgc3R5bGVzLlxuICAgIC8vIENoZWNrIGZvciBkaXNhbGxvd2VkIGNoYXJhY3RlcnMgdG8gcnVsZSBvdXQgcGxhaW4gYW5kIHNpbmdsZS5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICAgIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldkNoYXIsIGluYmxvY2spO1xuICAgICAgcHJldkNoYXIgPSBjaGFyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlOiBibG9jayBzdHlsZXMgcGVybWl0dGVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKGNoYXIgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICAgIGhhc0xpbmVCcmVhayA9IHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIGNhbiBiZSBmb2xkZWQuXG4gICAgICAgIGlmIChzaG91bGRUcmFja1dpZHRoKSB7XG4gICAgICAgICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8XG4gICAgICAgICAgICAvLyBGb2xkYWJsZSBsaW5lID0gdG9vIGxvbmcsIGFuZCBub3QgbW9yZS1pbmRlbnRlZC5cbiAgICAgICAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJyk7XG4gICAgICAgICAgcHJldmlvdXNMaW5lQnJlYWsgPSBpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICAgIC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG4gICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IChzaG91bGRUcmFja1dpZHRoICYmXG4gICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpKTtcbiAgfVxuICAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG4gIGlmICghaGFzTGluZUJyZWFrICYmICFoYXNGb2xkYWJsZUxpbmUpIHtcbiAgICAvLyBTdHJpbmdzIGludGVycHJldGFibGUgYXMgYW5vdGhlciB0eXBlIGhhdmUgdG8gYmUgcXVvdGVkO1xuICAgIC8vIGUuZy4gdGhlIHN0cmluZyAndHJ1ZScgdnMuIHRoZSBib29sZWFuIHRydWUuXG4gICAgaWYgKHBsYWluICYmICFmb3JjZVF1b3RlcyAmJiAhdGVzdEFtYmlndW91c1R5cGUoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIFNUWUxFX1BMQUlOO1xuICAgIH1cbiAgICByZXR1cm4gcXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyBTVFlMRV9ET1VCTEUgOiBTVFlMRV9TSU5HTEU7XG4gIH1cbiAgLy8gRWRnZSBjYXNlOiBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgY2FuIG9ubHkgaGF2ZSBvbmUgZGlnaXQuXG4gIGlmIChpbmRlbnRQZXJMZXZlbCA+IDkgJiYgbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cbiAgaWYgKCFmb3JjZVF1b3Rlcykge1xuICAgIHJldHVybiBoYXNGb2xkYWJsZUxpbmUgPyBTVFlMRV9GT0xERUQgOiBTVFlMRV9MSVRFUkFMO1xuICB9XG4gIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbn1cblxuLy8gTm90ZTogbGluZSBicmVha2luZy9mb2xkaW5nIGlzIGltcGxlbWVudGVkIGZvciBvbmx5IHRoZSBmb2xkZWQgc3R5bGUuXG4vLyBOQi4gV2UgZHJvcCB0aGUgbGFzdCB0cmFpbGluZyBuZXdsaW5lIChpZiBhbnkpIG9mIGEgcmV0dXJuZWQgYmxvY2sgc2NhbGFyXG4vLyAgc2luY2UgdGhlIGR1bXBlciBhZGRzIGl0cyBvd24gbmV3bGluZS4gVGhpcyBhbHdheXMgd29ya3M6XG4vLyAgICDigKIgTm8gZW5kaW5nIG5ld2xpbmUgPT4gdW5hZmZlY3RlZDsgYWxyZWFkeSB1c2luZyBzdHJpcCBcIi1cIiBjaG9tcGluZy5cbi8vICAgIOKAoiBFbmRpbmcgbmV3bGluZSAgICA9PiByZW1vdmVkIHRoZW4gcmVzdG9yZWQuXG4vLyAgSW1wb3J0YW50bHksIHRoaXMga2VlcHMgdGhlIFwiK1wiIGNob21wIGluZGljYXRvciBmcm9tIGdhaW5pbmcgYW4gZXh0cmEgbGluZS5cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHN0YXRlLCBzdHJpbmcsIGxldmVsLCBpc2tleSwgaW5ibG9jaykge1xuICBzdGF0ZS5kdW1wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gJ1wiXCInIDogXCInJ1wiO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm5vQ29tcGF0TW9kZSkge1xuICAgICAgaWYgKERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEgfHwgREVQUkVDQVRFRF9CQVNFNjBfU1lOVEFYLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAoJ1wiJyArIHN0cmluZyArICdcIicpIDogKFwiJ1wiICsgc3RyaW5nICsgXCInXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCDiiaQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aCA9PT0gLTFcbiAgICAgID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTtcblxuICAgIC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG4gICAgdmFyIHNpbmdsZUxpbmVPbmx5ID0gaXNrZXlcbiAgICAgIC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgICB8fCAoc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsKTtcbiAgICBmdW5jdGlvbiB0ZXN0QW1iaWd1aXR5KHN0cmluZykge1xuICAgICAgcmV0dXJuIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIHN0YXRlLmluZGVudCwgbGluZVdpZHRoLFxuICAgICAgdGVzdEFtYmlndWl0eSwgc3RhdGUucXVvdGluZ1R5cGUsIHN0YXRlLmZvcmNlUXVvdGVzICYmICFpc2tleSwgaW5ibG9jaykpIHtcblxuICAgICAgY2FzZSBTVFlMRV9QTEFJTjpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZScpO1xuICAgIH1cbiAgfSgpKTtcbn1cblxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cbmZ1bmN0aW9uIGJsb2NrSGVhZGVyKHN0cmluZywgaW5kZW50UGVyTGV2ZWwpIHtcbiAgdmFyIGluZGVudEluZGljYXRvciA9IG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSA/IFN0cmluZyhpbmRlbnRQZXJMZXZlbCkgOiAnJztcblxuICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG4gIHZhciBjbGlwID0gICAgICAgICAgc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbic7XG4gIHZhciBrZWVwID0gY2xpcCAmJiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAyXSA9PT0gJ1xcbicgfHwgc3RyaW5nID09PSAnXFxuJyk7XG4gIHZhciBjaG9tcCA9IGtlZXAgPyAnKycgOiAoY2xpcCA/ICcnIDogJy0nKTtcblxuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn1cblxuLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuZnVuY3Rpb24gZHJvcEVuZGluZ05ld2xpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbi8vIE5vdGU6IGEgbG9uZyBsaW5lIHdpdGhvdXQgYSBzdWl0YWJsZSBicmVhayBwb2ludCB3aWxsIGV4Y2VlZCB0aGUgd2lkdGggbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogZXZlcnkgY2hhciBpbiBzdHIgaXNQcmludGFibGUsIHN0ci5sZW5ndGggPiAwLCB3aWR0aCA+IDAuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVz4oCUXG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nO1xuXG4gIC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG4gIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0TEYgPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG4gICAgbmV4dExGID0gbmV4dExGICE9PSAtMSA/IG5leHRMRiA6IHN0cmluZy5sZW5ndGg7XG4gICAgbGluZVJlLmxhc3RJbmRleCA9IG5leHRMRjtcbiAgICByZXR1cm4gZm9sZExpbmUoc3RyaW5nLnNsaWNlKDAsIG5leHRMRiksIHdpZHRoKTtcbiAgfSgpKTtcbiAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IHN0cmluZ1swXSA9PT0gJ1xcbicgfHwgc3RyaW5nWzBdID09PSAnICc7XG4gIHZhciBtb3JlSW5kZW50ZWQ7XG5cbiAgLy8gcmVzdCBvZiB0aGUgbGluZXNcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkpIHtcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sIGxpbmUgPSBtYXRjaFsyXTtcbiAgICBtb3JlSW5kZW50ZWQgPSAobGluZVswXSA9PT0gJyAnKTtcbiAgICByZXN1bHQgKz0gcHJlZml4XG4gICAgICArICghcHJldk1vcmVJbmRlbnRlZCAmJiAhbW9yZUluZGVudGVkICYmIGxpbmUgIT09ICcnXG4gICAgICAgID8gJ1xcbicgOiAnJylcbiAgICAgICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgd2lkdGgpIHtcbiAgaWYgKGxpbmUgPT09ICcnIHx8IGxpbmVbMF0gPT09ICcgJykgcmV0dXJuIGxpbmU7XG5cbiAgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG4gIHZhciBicmVha1JlID0gLyBbXiBdL2c7IC8vIG5vdGU6IHRoZSBtYXRjaCBpbmRleCB3aWxsIGFsd2F5cyBiZSA8PSBsZW5ndGgtMi5cbiAgdmFyIG1hdGNoO1xuICAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cbiAgdmFyIHN0YXJ0ID0gMCwgZW5kLCBjdXJyID0gMCwgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG4gIHdoaWxlICgobWF0Y2ggPSBicmVha1JlLmV4ZWMobGluZSkpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIG1haW50YWluIGludmFyaWFudDogY3VyciAtIHN0YXJ0IDw9IHdpZHRoXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSAoY3VyciA+IHN0YXJ0KSA/IGN1cnIgOiBuZXh0OyAvLyBkZXJpdmUgZW5kIDw9IGxlbmd0aC0yXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuICAgICAgc3RhcnQgPSBlbmQgKyAxOyAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuICAgIGN1cnIgPSBuZXh0O1xuICB9XG5cbiAgLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cbiAgcmVzdWx0ICs9ICdcXG4nO1xuICAvLyBJbnNlcnQgYSBicmVhayBpZiB0aGUgcmVtYWluZGVyIGlzIHRvbyBsb25nIGFuZCB0aGVyZSBpcyBhIGJyZWFrIGF2YWlsYWJsZS5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufVxuXG4vLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXIgPSAwO1xuICB2YXIgZXNjYXBlU2VxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgZXNjYXBlU2VxID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyXTtcblxuICAgIGlmICghZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5nW2ldO1xuICAgICAgaWYgKGNoYXIgPj0gMHgxMDAwMCkgcmVzdWx0ICs9IHN0cmluZ1tpICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIHZhbHVlLCBmYWxzZSwgZmFsc2UpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBudWxsLCBmYWxzZSwgZmFsc2UpKSkge1xuXG4gICAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgdmFsdWU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFsdWUgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICB2YWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBTdHJpbmcoaW5kZXgpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cywgcHV0IG51bGwgaW5zdGVhZCBvZiBpbnZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgdmFsdWUsIHRydWUsIHRydWUsIGZhbHNlLCB0cnVlKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG51bGwsIHRydWUsIHRydWUsIGZhbHNlLCB0cnVlKSkpIHtcblxuICAgICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICBwYWlyQnVmZmVyID0gJyc7XG4gICAgaWYgKF9yZXN1bHQgIT09ICcnKSBwYWlyQnVmZmVyICs9ICcsICc7XG5cbiAgICBpZiAoc3RhdGUuY29uZGVuc2VGbG93KSBwYWlyQnVmZmVyICs9ICdcIic7XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdEtleSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCkgcGFpckJ1ZmZlciArPSAnPyAnO1xuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJykgKyAnOicgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJycgOiAnICcpO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RWYWx1ZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgLy8gQWxsb3cgc29ydGluZyBrZXlzIHNvIHRoYXQgdGhlIG91dHB1dCBmaWxlIGlzIGRldGVybWluaXN0aWNcbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIGlmIChleHBsaWNpdCkge1xuICAgICAgICBpZiAodHlwZS5tdWx0aSAmJiB0eXBlLnJlcHJlc2VudE5hbWUpIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnJlcHJlc2VudE5hbWUob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXksIGlzYmxvY2tzZXEpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG4gIHZhciBpbmJsb2NrID0gYmxvY2s7XG4gIHZhciB0YWdTdHI7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ub0FycmF5SW5kZW50ICYmICFpc2Jsb2Nrc2VxICYmIGxldmVsID4gMCkge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwgLSAxLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVuZGVmaW5lZF0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAvLyBOZWVkIHRvIGVuY29kZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgdGhvc2UgYWxsb3dlZCBieSB0aGUgc3BlYzpcbiAgICAgIC8vXG4gICAgICAvLyBbMzVdIG5zLWRlYy1kaWdpdCAgICA6Oj0gIFsjeDMwLSN4MzldIC8qIDAtOSAqL1xuICAgICAgLy8gWzM2XSBucy1oZXgtZGlnaXQgICAgOjo9ICBucy1kZWMtZGlnaXRcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwgWyN4NDEtI3g0Nl0gLyogQS1GICovIHwgWyN4NjEtI3g2Nl0gLyogYS1mICovXG4gICAgICAvLyBbMzddIG5zLWFzY2lpLWxldHRlciA6Oj0gIFsjeDQxLSN4NUFdIC8qIEEtWiAqLyB8IFsjeDYxLSN4N0FdIC8qIGEteiAqL1xuICAgICAgLy8gWzM4XSBucy13b3JkLWNoYXIgICAgOjo9ICBucy1kZWMtZGlnaXQgfCBucy1hc2NpaS1sZXR0ZXIgfCDigJwt4oCdXG4gICAgICAvLyBbMzldIG5zLXVyaS1jaGFyICAgICA6Oj0gIOKAnCXigJ0gbnMtaGV4LWRpZ2l0IG5zLWhleC1kaWdpdCB8IG5zLXdvcmQtY2hhciB8IOKAnCPigJ1cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwg4oCcO+KAnSB8IOKAnC/igJ0gfCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnEDigJ0gfCDigJwm4oCdIHwg4oCcPeKAnSB8IOKAnCvigJ0gfCDigJwk4oCdIHwg4oCcLOKAnVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCDigJxf4oCdIHwg4oCcLuKAnSB8IOKAnCHigJ0gfCDigJx+4oCdIHwg4oCcKuKAnSB8IOKAnCfigJ0gfCDigJwo4oCdIHwg4oCcKeKAnSB8IOKAnFvigJ0gfCDigJxd4oCdXG4gICAgICAvL1xuICAgICAgLy8gQWxzbyBuZWVkIHRvIGVuY29kZSAnIScgYmVjYXVzZSBpdCBoYXMgc3BlY2lhbCBtZWFuaW5nIChlbmQgb2YgdGFnIHByZWZpeCkuXG4gICAgICAvL1xuICAgICAgdGFnU3RyID0gZW5jb2RlVVJJKFxuICAgICAgICBzdGF0ZS50YWdbMF0gPT09ICchJyA/IHN0YXRlLnRhZy5zbGljZSgxKSA6IHN0YXRlLnRhZ1xuICAgICAgKS5yZXBsYWNlKC8hL2csICclMjEnKTtcblxuICAgICAgaWYgKHN0YXRlLnRhZ1swXSA9PT0gJyEnKSB7XG4gICAgICAgIHRhZ1N0ciA9ICchJyArIHRhZ1N0cjtcbiAgICAgIH0gZWxzZSBpZiAodGFnU3RyLnNsaWNlKDAsIDE4KSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOicpIHtcbiAgICAgICAgdGFnU3RyID0gJyEhJyArIHRhZ1N0ci5zbGljZSgxOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdTdHIgPSAnITwnICsgdGFnU3RyICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kdW1wID0gdGFnU3RyICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciBvYmplY3RLZXlMaXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICBkdXBsaWNhdGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W2luZGV4XSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W29iamVjdEtleUxpc3RbaW5kZXhdXSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG5cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5kdW1wID0gZHVtcDtcbiIsIi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcihleGNlcHRpb24sIGNvbXBhY3QpIHtcbiAgdmFyIHdoZXJlID0gJycsIG1lc3NhZ2UgPSBleGNlcHRpb24ucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWV4Y2VwdGlvbi5tYXJrKSByZXR1cm4gbWVzc2FnZTtcblxuICBpZiAoZXhjZXB0aW9uLm1hcmsubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyBleGNlcHRpb24ubWFyay5uYW1lICsgJ1wiICc7XG4gIH1cblxuICB3aGVyZSArPSAnKCcgKyAoZXhjZXB0aW9uLm1hcmsubGluZSArIDEpICsgJzonICsgKGV4Y2VwdGlvbi5tYXJrLmNvbHVtbiArIDEpICsgJyknO1xuXG4gIGlmICghY29tcGFjdCAmJiBleGNlcHRpb24ubWFyay5zbmlwcGV0KSB7XG4gICAgd2hlcmUgKz0gJ1xcblxcbicgKyBleGNlcHRpb24ubWFyay5zbmlwcGV0O1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2UgKyAnICcgKyB3aGVyZTtcbn1cblxuXG5mdW5jdGlvbiBZQU1MRXhjZXB0aW9uKHJlYXNvbiwgbWFyaykge1xuICAvLyBTdXBlciBjb25zdHJ1Y3RvclxuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMubmFtZSA9ICdZQU1MRXhjZXB0aW9uJztcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9IGZvcm1hdEVycm9yKHRoaXMsIGZhbHNlKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyBmb3JtYXRFcnJvcih0aGlzLCBjb21wYWN0KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgbWFrZVNuaXBwZXQgICAgICAgICA9IHJlcXVpcmUoJy4vc25pcHBldCcpO1xudmFyIERFRkFVTFRfU0NIRU1BICAgICAgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0Jyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICB0aGlzLmZpbGVuYW1lICA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gIHx8IG51bGw7XG4gIHRoaXMuc2NoZW1hICAgID0gb3B0aW9uc1snc2NoZW1hJ10gICAgfHwgREVGQVVMVF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgLy8gKEhpZGRlbikgUmVtb3ZlPyBtYWtlcyB0aGUgbG9hZGVyIHRvIGV4cGVjdCBZQU1MIDEuMSBkb2N1bWVudHNcbiAgLy8gaWYgc3VjaCBkb2N1bWVudHMgaGF2ZSBubyBleHBsaWNpdCAlWUFNTCBkaXJlY3RpdmVcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcblxuICB0aGlzLmpzb24gICAgICA9IG9wdGlvbnNbJ2pzb24nXSAgICAgIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyICA9IG9wdGlvbnNbJ2xpc3RlbmVyJ10gIHx8IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICAvLyBwb3NpdGlvbiBvZiBmaXJzdCBsZWFkaW5nIHRhYiBpbiB0aGUgY3VycmVudCBsaW5lLFxuICAvLyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gdGFicyBpbiB0aGUgaW5kZW50YXRpb25cbiAgdGhpcy5maXJzdFRhYkluTGluZSA9IC0xO1xuXG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG5cbiAgLypcbiAgdGhpcy52ZXJzaW9uO1xuICB0aGlzLmNoZWNrTGluZUJyZWFrcztcbiAgdGhpcy50YWdNYXA7XG4gIHRoaXMuYW5jaG9yTWFwO1xuICB0aGlzLnRhZztcbiAgdGhpcy5hbmNob3I7XG4gIHRoaXMua2luZDtcbiAgdGhpcy5yZXN1bHQ7Ki9cblxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdmFyIG1hcmsgPSB7XG4gICAgbmFtZTogICAgIHN0YXRlLmZpbGVuYW1lLFxuICAgIGJ1ZmZlcjogICBzdGF0ZS5pbnB1dC5zbGljZSgwLCAtMSksIC8vIG9taXQgdHJhaWxpbmcgXFwwXG4gICAgcG9zaXRpb246IHN0YXRlLnBvc2l0aW9uLFxuICAgIGxpbmU6ICAgICBzdGF0ZS5saW5lLFxuICAgIGNvbHVtbjogICBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydFxuICB9O1xuXG4gIG1hcmsuc25pcHBldCA9IG1ha2VTbmlwcGV0KG1hcmspO1xuXG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihtZXNzYWdlLCBtYXJrKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJlZml4ID0gZGVjb2RlVVJJQ29tcG9uZW50KHByZWZpeCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHByZWZpeCBpcyBtYWxmb3JtZWQ6ICcgKyBwcmVmaXgpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBzdGFydCwgZW5kLCBjaGVja0pzb24pIHtcbiAgdmFyIF9wb3NpdGlvbiwgX2xlbmd0aCwgX2NoYXJhY3RlciwgX3Jlc3VsdDtcblxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICBfcmVzdWx0ID0gc3RhdGUuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoY2hlY2tKc29uKSB7XG4gICAgICBmb3IgKF9wb3NpdGlvbiA9IDAsIF9sZW5ndGggPSBfcmVzdWx0Lmxlbmd0aDsgX3Bvc2l0aW9uIDwgX2xlbmd0aDsgX3Bvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgX2NoYXJhY3RlciA9IF9yZXN1bHQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuICAgICAgICBpZiAoIShfY2hhcmFjdGVyID09PSAweDA5IHx8XG4gICAgICAgICAgICAgICgweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIHZhbGlkIEpTT04gY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFBBVFRFUk5fTk9OX1BSSU5UQUJMRS50ZXN0KF9yZXN1bHQpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yZXN1bHQgKz0gX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU1hcHBpbmdzKHN0YXRlLCBkZXN0aW5hdGlvbiwgc291cmNlLCBvdmVycmlkYWJsZUtleXMpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICBvdmVycmlkYWJsZUtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsXG4gIHN0YXJ0TGluZSwgc3RhcnRMaW5lU3RhcnQsIHN0YXJ0UG9zKSB7XG5cbiAgdmFyIGluZGV4LCBxdWFudGl0eTtcblxuICAvLyBUaGUgb3V0cHV0IGlzIGEgcGxhaW4gb2JqZWN0IGhlcmUsIHNvIGtleXMgY2FuIG9ubHkgYmUgc3RyaW5ncy5cbiAgLy8gV2UgbmVlZCB0byBjb252ZXJ0IGtleU5vZGUgdG8gYSBzdHJpbmcsIGJ1dCBkb2luZyBzbyBjYW4gaGFuZyB0aGUgcHJvY2Vzc1xuICAvLyAoZGVlcGx5IG5lc3RlZCBhcnJheXMgdGhhdCBleHBsb2RlIGV4cG9uZW50aWFsbHkgdXNpbmcgYWxpYXNlcykuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGUpKSB7XG4gICAga2V5Tm9kZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleU5vZGUpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0ga2V5Tm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGVbaW5kZXhdKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlW2luZGV4XSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIGtleU5vZGVbaW5kZXhdID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXZvaWQgY29kZSBleGVjdXRpb24gaW4gbG9hZCgpIHZpYSB0b1N0cmluZyBwcm9wZXJ0eVxuICAvLyAoc3RpbGwgdXNlIGl0cyBvd24gdG9TdHJpbmcgZm9yIGFycmF5cywgdGltZXN0YW1wcyxcbiAgLy8gYW5kIHdoYXRldmVyIHVzZXIgc2NoZW1hIGV4dGVuc2lvbnMgaGFwcGVuIHRvIGhhdmUgQEB0b1N0cmluZ1RhZylcbiAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAga2V5Tm9kZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cblxuICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xuXG4gIGlmIChfcmVzdWx0ID09PSBudWxsKSB7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9XG5cbiAgaWYgKGtleVRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHZhbHVlTm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlW2luZGV4XSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlLCBvdmVycmlkYWJsZUtleXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0YXRlLmpzb24gJiZcbiAgICAgICAgIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwga2V5Tm9kZSkpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgfHwgc3RhdGUubGluZTtcbiAgICAgIHN0YXRlLmxpbmVTdGFydCA9IHN0YXJ0TGluZVN0YXJ0IHx8IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhcnRQb3MgfHwgc3RhdGUucG9zaXRpb247XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRlZCBtYXBwaW5nIGtleScpO1xuICAgIH1cblxuICAgIC8vIHVzZWQgZm9yIHRoaXMgc3BlY2lmaWMga2V5IG9ubHkgYmVjYXVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgc2xvd1xuICAgIGlmIChrZXlOb2RlID09PSAnX19wcm90b19fJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9yZXN1bHQsIGtleU5vZGUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlTm9kZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XG4gICAgfVxuICAgIGRlbGV0ZSBvdmVycmlkYWJsZUtleXNba2V5Tm9kZV07XG4gIH1cblxuICByZXR1cm4gX3Jlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZExpbmVCcmVhayhzdGF0ZSkge1xuICB2YXIgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4MEEvKiBMRiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MEQvKiBDUiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDBBLyogTEYgKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIGxpbmUgYnJlYWsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgKz0gMTtcbiAgc3RhdGUubGluZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG4gIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGFsbG93Q29tbWVudHMsIGNoZWNrSW5kZW50KSB7XG4gIHZhciBsaW5lQnJlYWtzID0gMCxcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5LyogVGFiICovICYmIHN0YXRlLmZpcnN0VGFiSW5MaW5lID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5maXJzdFRhYkluTGluZSA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd0NvbW1lbnRzICYmIGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9IHdoaWxlIChjaCAhPT0gMHgwQS8qIExGICovICYmIGNoICE9PSAweDBELyogQ1IgKi8gJiYgY2ggIT09IDApO1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGxpbmVCcmVha3MrKztcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgICB3aGlsZSAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrSW5kZW50ICE9PSAtMSAmJiBsaW5lQnJlYWtzICE9PSAwICYmIHN0YXRlLmxpbmVJbmRlbnQgPCBjaGVja0luZGVudCkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ2RlZmljaWVudCBpbmRlbnRhdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVCcmVha3M7XG59XG5cbmZ1bmN0aW9uIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAvLyBDb25kaXRpb24gc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCBpcyB0ZXN0ZWRcbiAgLy8gaW4gcGFyZW50IG9uIGVhY2ggY2FsbCwgZm9yIGVmZmljaWVuY3kuIE5vIG5lZWRzIHRvIHRlc3QgaGVyZSBhZ2Fpbi5cbiAgaWYgKChjaCA9PT0gMHgyRC8qIC0gKi8gfHwgY2ggPT09IDB4MkUvKiAuICovKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpKSB7XG5cbiAgICBfcG9zaXRpb24gKz0gMztcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCwgd2l0aGluRmxvd0NvbGxlY3Rpb24pIHtcbiAgdmFyIHByZWNlZGluZyxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoYXNQZW5kaW5nQ29udGVudCxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9saW5lSW5kZW50LFxuICAgICAgX2tpbmQgPSBzdGF0ZS5raW5kLFxuICAgICAgX3Jlc3VsdCA9IHN0YXRlLnJlc3VsdCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGlzX1dTX09SX0VPTChjaCkgICAgICB8fFxuICAgICAgaXNfRkxPV19JTkRJQ0FUT1IoY2gpIHx8XG4gICAgICBjaCA9PT0gMHgyMy8qICMgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI2LyogJiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MkEvKiAqICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMS8qICEgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDdDLyogfCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4M0UvKiA+ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNy8qICcgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIyLyogXCIgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI1LyogJSAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NDAvKiBAICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBwcmVjZWRpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uIC0gMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0wocHJlY2VkaW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkgfHxcbiAgICAgICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgICAgYnJlYWs7XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBfbGluZUluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgLTEpO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+PSBub2RlSW5kZW50KSB7XG4gICAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbiA9IGNhcHR1cmVFbmQ7XG4gICAgICAgIHN0YXRlLmxpbmUgPSBfbGluZTtcbiAgICAgICAgc3RhdGUubGluZVN0YXJ0ID0gX2xpbmVTdGFydDtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCA9IF9saW5lSW5kZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHN0YXRlLmxpbmUgLSBfbGluZSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcblxuICBpZiAoc3RhdGUucmVzdWx0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gX2tpbmQ7XG4gIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjcvKiAnICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhleExlbmd0aCxcbiAgICAgIGhleFJlc3VsdCxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIyLyogXCIgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyMi8qIFwiICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpO1xuXG4gICAgICAgIC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9wb3MsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQ7LyogXSAqL1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RDsvKiB9ICovXG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgLy8gXCJmbG93IGNvbGxlY3Rpb24gZW50cmllcyBjYW4gbmV2ZXIgYmUgY29tcGxldGVseSBlbXB0eVwiLCBhcyBwZXIgWUFNTCAxLjIsIHNlY3Rpb24gNy40XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCBcImV4cGVjdGVkIHRoZSBub2RlIGNvbnRlbnQsIGJ1dCBmb3VuZCAnLCdcIik7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICBfcG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfbGluZVN0YXJ0LCBfcG9zKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfbGluZVN0YXJ0LCBfcG9zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRpZFJlYWRDb250ZW50ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZEluZGVudCA9IGZhbHNlLFxuICAgICAgdGV4dEluZGVudCAgICAgPSBub2RlSW5kZW50LFxuICAgICAgZW1wdHlMaW5lcyAgICAgPSAwLFxuICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZSxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDdDLyogfCAqLykge1xuICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgzRS8qID4gKi8pIHtcbiAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQi8qICsgKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgICBpZiAoQ0hPTVBJTkdfQ0xJUCA9PT0gY2hvbXBpbmcpIHtcbiAgICAgICAgY2hvbXBpbmcgPSAoY2ggPT09IDB4MkIvKiArICovKSA/IENIT01QSU5HX0tFRVAgOiBDSE9NUElOR19TVFJJUDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYSBjaG9tcGluZyBtb2RlIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHRtcCA9IGZyb21EZWNpbWFsQ29kZShjaCkpID49IDApIHtcbiAgICAgIGlmICh0bXAgPT09IDApIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmUnKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRldGVjdGVkSW5kZW50KSB7XG4gICAgICAgIHRleHRJbmRlbnQgPSBub2RlSW5kZW50ICsgdG1wIC0gMTtcbiAgICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhbiBpbmRlbnRhdGlvbiB3aWR0aCBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgd2hpbGUgKCFpc19FT0woY2gpICYmIChjaCAhPT0gMCkpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIHdoaWxlICgoIWRldGVjdGVkSW5kZW50IHx8IHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSAmJlxuICAgICAgICAgICAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykpIHtcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGVjdGVkSW5kZW50ICYmIHN0YXRlLmxpbmVJbmRlbnQgPiB0ZXh0SW5kZW50KSB7XG4gICAgICB0ZXh0SW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgZW1wdHlMaW5lcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRW5kIG9mIHRoZSBzY2FsYXIuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSB7XG5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGNob21waW5nLlxuICAgICAgaWYgKGNob21waW5nID09PSBDSE9NUElOR19LRUVQKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKGNob21waW5nID09PSBDSE9NUElOR19DTElQKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgdGhlIHNjYWxhciBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJyZWFrIHRoaXMgYHdoaWxlYCBjeWNsZSBhbmQgZ28gdG8gdGhlIGZ1bmNpdG9uJ3MgZXBpbG9ndWUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGb2xkZWQgc3R5bGU6IHVzZSBmYW5jeSBydWxlcyB0byBoYW5kbGUgbGluZSBicmVha3MuXG4gICAgaWYgKGZvbGRpbmcpIHtcblxuICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzIChtb3JlLWluZGVudGVkIGxpbmVzKSBhcmUgbm90IGZvbGRlZC5cbiAgICAgIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICAvLyBleGNlcHQgZm9yIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgKGNmLiBFeGFtcGxlIDguMSlcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmIChlbXB0eUxpbmVzID09PSAwKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGFsbCBsaW5lIGJyZWFrcyBleGNlcHQgdGhlIGhlYWRlciBsaW5lIGJyZWFrLlxuICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICB9XG5cbiAgICBkaWRSZWFkQ29udGVudCA9IHRydWU7XG4gICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgIGVtcHR5TGluZXMgPSAwO1xuICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKCFpc19FT0woY2gpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICAvLyB0aGVyZSBpcyBhIGxlYWRpbmcgdGFiIGJlZm9yZSB0aGlzIHRva2VuLCBzbyBpdCBjYW4ndCBiZSBhIGJsb2NrIHNlcXVlbmNlL21hcHBpbmc7XG4gIC8vIGl0IGNhbiBzdGlsbCBiZSBmbG93IHNlcXVlbmNlL21hcHBpbmcgb3IgYSBzY2FsYXJcbiAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhdGUuZmlyc3RUYWJJbkxpbmU7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFiIGNoYXJhY3RlcnMgbXVzdCBub3QgYmUgdXNlZCBpbiBpbmRlbnRhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIG5vZGVJbmRlbnQsIGZsb3dJbmRlbnQpIHtcbiAgdmFyIGZvbGxvd2luZyxcbiAgICAgIGFsbG93Q29tcGFjdCxcbiAgICAgIF9saW5lLFxuICAgICAgX2tleUxpbmUsXG4gICAgICBfa2V5TGluZVN0YXJ0LFxuICAgICAgX2tleVBvcyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgICAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgICAgICA9IHt9LFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKCFhdEV4cGxpY2l0S2V5ICYmIHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuXG4gICAgLy9cbiAgICAvLyBFeHBsaWNpdCBub3RhdGlvbiBjYXNlLiBUaGVyZSBhcmUgdHdvIHNlcGFyYXRlIGJsb2NrczpcbiAgICAvLyBmaXJzdCBmb3IgdGhlIGtleSAoZGVub3RlZCBieSBcIj9cIikgYW5kIHNlY29uZCBmb3IgdGhlIHZhbHVlIChkZW5vdGVkIGJ5IFwiOlwiKVxuICAgIC8vXG4gICAgaWYgKChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4M0EvKiA6ICovKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZScpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICAgICAgY2ggPSBmb2xsb3dpbmc7XG5cbiAgICAvL1xuICAgIC8vIEltcGxpY2l0IG5vdGF0aW9uIGNhc2UuIEZsb3ctc3R5bGUgbm9kZSBhcyB0aGUga2V5IGZpcnN0LCB0aGVuIFwiOlwiLCBhbmQgdGhlIHZhbHVlLlxuICAgIC8vXG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXlMaW5lID0gc3RhdGUubGluZTtcbiAgICAgIF9rZXlMaW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIGlmICghY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgICAvLyBOZWl0aGVyIGltcGxpY2l0IG5vciBleHBsaWNpdCBub3RhdGlvbi5cbiAgICAgICAgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhbiBpbXBsaWNpdCBtYXBwaW5nIHBhaXI7IGEgY29sb24gaXMgbWlzc2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIF9rZXlMaW5lID0gc3RhdGUubGluZTtcbiAgICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgICAgX2tleVBvcyA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gIH1cblxuICAvLyBFeHBvc2UgdGhlIHJlc3VsdGluZyBtYXBwaW5nLlxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdtYXBwaW5nJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGlzVmVyYmF0aW0gPSBmYWxzZSxcbiAgICAgIGlzTmFtZWQgICAgPSBmYWxzZSxcbiAgICAgIHRhZ0hhbmRsZSxcbiAgICAgIHRhZ05hbWUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGEgdGFnIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDNDLyogPCAqLykge1xuICAgIGlzVmVyYmF0aW0gPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2UgaWYgKGNoID09PSAweDIxLyogISAqLykge1xuICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgIHRhZ0hhbmRsZSA9ICchISc7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgdGFnSGFuZGxlID0gJyEnO1xuICB9XG5cbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiBjaCAhPT0gMHgzRS8qID4gKi8pO1xuXG4gICAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHZlcmJhdGltIHRhZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcblxuICAgICAgaWYgKGNoID09PSAweDIxLyogISAqLykge1xuICAgICAgICBpZiAoIWlzTmFtZWQpIHtcbiAgICAgICAgICB0YWdIYW5kbGUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdCh0YWdIYW5kbGUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZXhjbGFtYXRpb24gbWFya3MnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICB0cnkge1xuICAgIHRhZ05hbWUgPSBkZWNvZGVVUklDb21wb25lbnQodGFnTmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBpcyBtYWxmb3JtZWQ6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlTGlzdCxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAvL1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgLy9cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddLCBzdGF0ZS50YWcpKSB7XG4gICAgICB0eXBlID0gc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddW3N0YXRlLnRhZ107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvb2tpbmcgZm9yIG11bHRpIHR5cGVcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgdHlwZUxpc3QgPSBzdGF0ZS50eXBlTWFwLm11bHRpW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ107XG5cbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gdHlwZUxpc3QubGVuZ3RoOyB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7IHR5cGVJbmRleCArPSAxKSB7XG4gICAgICAgIGlmIChzdGF0ZS50YWcuc2xpY2UoMCwgdHlwZUxpc3RbdHlwZUluZGV4XS50YWcubGVuZ3RoKSA9PT0gdHlwZUxpc3RbdHlwZUluZGV4XS50YWcpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZUxpc3RbdHlwZUluZGV4XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0LCBzdGF0ZS50YWcpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZyk7XG4gICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudGFnICE9PSBudWxsIHx8ICBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0YXRlLmFuY2hvck1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgY2ggIT09IDB4MjUvKiAlICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBkaXJlY3RpdmVOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZSBuYW1lIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBvbmUgY2hhcmFjdGVyIGluIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHdoaWxlIChjaCAhPT0gMCkge1xuICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19FT0woY2gpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSBicmVhaztcblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAwKSByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgICAgID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJELyogLSAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFLyogLiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwQS8qIExGICovICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEQvKiBDUiAqLykge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAoaXRlcmF0b3IgIT09IG51bGwgJiYgdHlwZW9mIGl0ZXJhdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gaXRlcmF0b3I7XG4gICAgaXRlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmICh0eXBlb2YgaXRlcmF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzO1xuICB9XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsID0gbG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgPSBsb2FkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5tdWx0aSA9PT0gY3VycmVudFR5cGUubXVsdGkpIHtcblxuICAgICAgICBuZXdJbmRleCA9IHByZXZpb3VzSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHRbbmV3SW5kZXhdID0gY3VycmVudFR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge30sXG4gICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgc2NhbGFyOiBbXSxcbiAgICAgICAgICBzZXF1ZW5jZTogW10sXG4gICAgICAgICAgbWFwcGluZzogW10sXG4gICAgICAgICAgZmFsbGJhY2s6IFtdXG4gICAgICAgIH1cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlLm11bHRpKSB7XG4gICAgICByZXN1bHQubXVsdGlbdHlwZS5raW5kXS5wdXNoKHR5cGUpO1xuICAgICAgcmVzdWx0Lm11bHRpWydmYWxsYmFjayddLnB1c2godHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xuICByZXR1cm4gdGhpcy5leHRlbmQoZGVmaW5pdGlvbik7XG59XG5cblxuU2NoZW1hLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZGVmaW5pdGlvbikge1xuICB2YXIgaW1wbGljaXQgPSBbXTtcbiAgdmFyIGV4cGxpY2l0ID0gW107XG5cbiAgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh0eXBlKVxuICAgIGV4cGxpY2l0LnB1c2goZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZChbIHR5cGUxLCB0eXBlMiwgLi4uIF0pXG4gICAgZXhwbGljaXQgPSBleHBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChkZWZpbml0aW9uICYmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24uaW1wbGljaXQpIHx8IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi5leHBsaWNpdCkpKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh7IGV4cGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0sIGltcGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0gfSlcbiAgICBpZiAoZGVmaW5pdGlvbi5pbXBsaWNpdCkgaW1wbGljaXQgPSBpbXBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbi5pbXBsaWNpdCk7XG4gICAgaWYgKGRlZmluaXRpb24uZXhwbGljaXQpIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24uZXhwbGljaXQpO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NjaGVtYS5leHRlbmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgVHlwZSwgWyBUeXBlIF0sICcgK1xuICAgICAgJ29yIGEgc2NoZW1hIGRlZmluaXRpb24gKHsgaW1wbGljaXQ6IFsuLi5dLCBleHBsaWNpdDogWy4uLl0gfSknKTtcbiAgfVxuXG4gIGltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5tdWx0aSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbXVsdGkgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gTXVsdGkgdGFncyBjYW4gb25seSBiZSBsaXN0ZWQgYXMgZXhwbGljaXQuJyk7XG4gICAgfVxuICB9KTtcblxuICBleHBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoU2NoZW1hLnByb3RvdHlwZSk7XG5cbiAgcmVzdWx0LmltcGxpY2l0ID0gKHRoaXMuaW1wbGljaXQgfHwgW10pLmNvbmNhdChpbXBsaWNpdCk7XG4gIHJlc3VsdC5leHBsaWNpdCA9ICh0aGlzLmV4cGxpY2l0IHx8IFtdKS5jb25jYXQoZXhwbGljaXQpO1xuXG4gIHJlc3VsdC5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnaW1wbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdleHBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAocmVzdWx0LmNvbXBpbGVkSW1wbGljaXQsIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vanNvbicpO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlJykuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgRmFpbHNhZmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAyMzQ2XG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvc3RyJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXEnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21hcCcpXG4gIF1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWlsc2FmZScpLmV4dGVuZCh7XG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gZ2V0IHNuaXBwZXQgZm9yIGEgc2luZ2xlIGxpbmUsIHJlc3BlY3RpbmcgbWF4TGVuZ3RoXG5mdW5jdGlvbiBnZXRMaW5lKGJ1ZmZlciwgbGluZVN0YXJ0LCBsaW5lRW5kLCBwb3NpdGlvbiwgbWF4TGluZUxlbmd0aCkge1xuICB2YXIgaGVhZCA9ICcnO1xuICB2YXIgdGFpbCA9ICcnO1xuICB2YXIgbWF4SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IobWF4TGluZUxlbmd0aCAvIDIpIC0gMTtcblxuICBpZiAocG9zaXRpb24gLSBsaW5lU3RhcnQgPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgaGVhZCA9ICcgLi4uICc7XG4gICAgbGluZVN0YXJ0ID0gcG9zaXRpb24gLSBtYXhIYWxmTGVuZ3RoICsgaGVhZC5sZW5ndGg7XG4gIH1cblxuICBpZiAobGluZUVuZCAtIHBvc2l0aW9uID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIHRhaWwgPSAnIC4uLic7XG4gICAgbGluZUVuZCA9IHBvc2l0aW9uICsgbWF4SGFsZkxlbmd0aCAtIHRhaWwubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdHI6IGhlYWQgKyBidWZmZXIuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kKS5yZXBsYWNlKC9cXHQvZywgJ+KGkicpICsgdGFpbCxcbiAgICBwb3M6IHBvc2l0aW9uIC0gbGluZVN0YXJ0ICsgaGVhZC5sZW5ndGggLy8gcmVsYXRpdmUgcG9zaXRpb25cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIG1heCkge1xuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIG1heCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VTbmlwcGV0KG1hcmssIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBudWxsKTtcblxuICBpZiAoIW1hcmsuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpZiAoIW9wdGlvbnMubWF4TGVuZ3RoKSBvcHRpb25zLm1heExlbmd0aCA9IDc5O1xuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ICAgICAgIT09ICdudW1iZXInKSBvcHRpb25zLmluZGVudCAgICAgID0gMTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQmVmb3JlICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0JlZm9yZSA9IDM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0FmdGVyICAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNBZnRlciAgPSAyO1xuXG4gIHZhciByZSA9IC9cXHI/XFxufFxccnxcXDAvZztcbiAgdmFyIGxpbmVTdGFydHMgPSBbIDAgXTtcbiAgdmFyIGxpbmVFbmRzID0gW107XG4gIHZhciBtYXRjaDtcbiAgdmFyIGZvdW5kTGluZU5vID0gLTE7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobWFyay5idWZmZXIpKSkge1xuICAgIGxpbmVFbmRzLnB1c2gobWF0Y2guaW5kZXgpO1xuICAgIGxpbmVTdGFydHMucHVzaChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICBpZiAobWFyay5wb3NpdGlvbiA8PSBtYXRjaC5pbmRleCAmJiBmb3VuZExpbmVObyA8IDApIHtcbiAgICAgIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZExpbmVObyA8IDApIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAxO1xuXG4gIHZhciByZXN1bHQgPSAnJywgaSwgbGluZTtcbiAgdmFyIGxpbmVOb0xlbmd0aCA9IE1hdGgubWluKG1hcmsubGluZSArIG9wdGlvbnMubGluZXNBZnRlciwgbGluZUVuZHMubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIG1heExpbmVMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCAtIChvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMpO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0JlZm9yZTsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vIC0gaSA8IDApIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSAtIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJyArIHJlc3VsdDtcbiAgfVxuXG4gIGxpbmUgPSBnZXRMaW5lKG1hcmsuYnVmZmVyLCBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSwgbGluZUVuZHNbZm91bmRMaW5lTm9dLCBtYXJrLnBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKTtcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnLScsIG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyArIGxpbmUucG9zKSArICdeJyArICdcXG4nO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0FmdGVyOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gKyBpID49IGxpbmVFbmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VTbmlwcGV0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG5cbnZhciBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMgPSBbXG4gICdraW5kJyxcbiAgJ211bHRpJyxcbiAgJ3Jlc29sdmUnLFxuICAnY29uc3RydWN0JyxcbiAgJ2luc3RhbmNlT2YnLFxuICAncHJlZGljYXRlJyxcbiAgJ3JlcHJlc2VudCcsXG4gICdyZXByZXNlbnROYW1lJyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMub3B0aW9ucyAgICAgICA9IG9wdGlvbnM7IC8vIGtlZXAgb3JpZ2luYWwgb3B0aW9ucyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gZXh0ZW5kIHRoaXMgdHlwZSBsYXRlclxuICB0aGlzLnRhZyAgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgICB8fCBudWxsO1xuICB0aGlzLnJlc29sdmUgICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgID0gb3B0aW9uc1snY29uc3RydWN0J10gICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgICA9IG9wdGlvbnNbJ3JlcHJlc2VudCddICAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudE5hbWUgPSBvcHRpb25zWydyZXByZXNlbnROYW1lJ10gfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gIHx8IG51bGw7XG4gIHRoaXMubXVsdGkgICAgICAgICA9IG9wdGlvbnNbJ211bHRpJ10gICAgICAgICB8fCBmYWxzZTtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgYml0bGVuICs9IDY7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcbiAgcmV0dXJuIChiaXRsZW4gJSA4KSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBpZHgsIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksIC8vIHJlbW92ZSBDUi9MRiAmIHBhZGRpbmcgdG8gc2ltcGxpZnkgc2NhblxuICAgICAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDQgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA2KSB8IG1hcC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxMCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAyKSAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDQpICYgMHhGRik7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICAnW29iamVjdCBVaW50OEFycmF5XSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OlswLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gaXNIZXhDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB8fFxuICAgICAgICAgKCgweDQxLyogQSAqLyA8PSBjKSAmJiAoYyA8PSAweDQ2LyogRiAqLykpIHx8XG4gICAgICAgICAoKDB4NjEvKiBhICovIDw9IGMpICYmIChjIDw9IDB4NjYvKiBmICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzT2N0Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzcvKiA3ICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVjQ29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sSW50ZWdlcihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaGFzRGlnaXRzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoIW1heCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gZGF0YVtpbmRleF07XG5cbiAgLy8gc2lnblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gbWF4KSByZXR1cm4gdHJ1ZTtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuXG4gICAgaWYgKGNoID09PSAneCcpIHtcbiAgICAgIC8vIGJhc2UgMTZcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICdvJykge1xuICAgICAgLy8gYmFzZSA4XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJhc2UgMTAgKGV4Y2VwdCAwKVxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKCFpc0RlY0NvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNob3VsZCBoYXZlIGRpZ2l0cyBhbmQgc2hvdWxkIG5vdCBlbmQgd2l0aCBgX2BcbiAgaWYgKCFoYXNEaWdpdHMgfHwgY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaDtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgc2lnbiA9IC0xO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gMDtcblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICd4JykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMTYpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ28nKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCA4KTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiZcbiAgICAgICAgIChvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwYicgKyBvYmoudG9TdHJpbmcoMikgOiAnLTBiJyArIG9iai50b1N0cmluZygyKS5zbGljZSgxKTsgfSxcbiAgICBvY3RhbDogICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMG8nICArIG9iai50b1N0cmluZyg4KSA6ICctMG8nICArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTsgfSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSA6ICAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICc8PCcgfHwgZGF0YSA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfSxcbiAgICBlbXB0eTogICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcnOyAgICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgb2JqZWN0S2V5cyA9IFtdLCBpbmRleCwgbGVuZ3RoLCBwYWlyLCBwYWlyS2V5LCBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFpckhhc0tleSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSA9PT0gLTEpIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGlmIChvYmplY3Rba2V5XSAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcbiIsIjsoZnVuY3Rpb24gKHNheCkgeyAvLyB3cmFwcGVyIGZvciBub24tbm9kZSBlbnZzXG4gIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHsgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIH1cbiAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlclxuICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtXG4gIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW1cblxuICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgJ2NvbW1lbnQnLCAnc2dtbERlY2wnLCAndGV4dE5vZGUnLCAndGFnTmFtZScsICdkb2N0eXBlJyxcbiAgICAncHJvY0luc3ROYW1lJywgJ3Byb2NJbnN0Qm9keScsICdlbnRpdHknLCAnYXR0cmliTmFtZScsXG4gICAgJ2F0dHJpYlZhbHVlJywgJ2NkYXRhJywgJ3NjcmlwdCdcbiAgXVxuXG4gIHNheC5FVkVOVFMgPSBbXG4gICAgJ3RleHQnLFxuICAgICdwcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLFxuICAgICdzZ21sZGVjbGFyYXRpb24nLFxuICAgICdkb2N0eXBlJyxcbiAgICAnY29tbWVudCcsXG4gICAgJ29wZW50YWdzdGFydCcsXG4gICAgJ2F0dHJpYnV0ZScsXG4gICAgJ29wZW50YWcnLFxuICAgICdjbG9zZXRhZycsXG4gICAgJ29wZW5jZGF0YScsXG4gICAgJ2NkYXRhJyxcbiAgICAnY2xvc2VjZGF0YScsXG4gICAgJ2Vycm9yJyxcbiAgICAnZW5kJyxcbiAgICAncmVhZHknLFxuICAgICdzY3JpcHQnLFxuICAgICdvcGVubmFtZXNwYWNlJyxcbiAgICAnY2xvc2VuYW1lc3BhY2UnXG4gIF1cblxuICBmdW5jdGlvbiBTQVhQYXJzZXIgKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgY2xlYXJCdWZmZXJzKHBhcnNlcilcbiAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSFxuICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge31cbiAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFnc1xuICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/ICd0b0xvd2VyQ2FzZScgOiAndG9VcHBlckNhc2UnXG4gICAgcGFyc2VyLnRhZ3MgPSBbXVxuICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2VcbiAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdFxuICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KVxuICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5cbiAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzXG4gICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKSA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKVxuICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW11cblxuICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKVxuICAgIH1cblxuICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwXG4gICAgfVxuICAgIGVtaXQocGFyc2VyLCAnb25yZWFkeScpXG4gIH1cblxuICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGZ1bmN0aW9uIEYgKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gb1xuICAgICAgdmFyIG5ld2YgPSBuZXcgRigpXG4gICAgICByZXR1cm4gbmV3ZlxuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYSA9IFtdXG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSlcbiAgICAgIHJldHVybiBhXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGggKHBhcnNlcikge1xuICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMClcbiAgICB2YXIgbWF4QWN0dWFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoXG4gICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Tm9kZSc6XG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ2NkYXRhJzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCAnTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6ICcgKyBidWZmZXJzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbilcbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbFxuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSAnJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyAocGFyc2VyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLmNkYXRhICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuICB9XG5cbiAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHsgZW5kKHRoaXMpIH0sXG4gICAgd3JpdGU6IHdyaXRlLFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgeyB0aGlzLmVycm9yID0gbnVsbDsgcmV0dXJuIHRoaXMgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53cml0ZShudWxsKSB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IGZsdXNoQnVmZmVycyh0aGlzKSB9XG4gIH1cblxuICB2YXIgU3RyZWFtXG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgU3RyZWFtID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgIHJldHVybiBldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2VuZCdcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gIH1cblxuICBmdW5jdGlvbiBTQVhTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIFN0cmVhbS5hcHBseSh0aGlzKVxuXG4gICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG5cbiAgICB2YXIgbWUgPSB0aGlzXG5cbiAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5lbWl0KCdlbmQnKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBtZS5lbWl0KCdlcnJvcicsIGVyKVxuXG4gICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZGVjb2RlciA9IG51bGxcblxuICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdvbicgKyBldiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlclsnb24nICsgZXZdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGhcbiAgICAgICAgICAgIHJldHVybiBoXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lLm9uKGV2LCBoKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICB9XG4gIH0pXG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgICAgIHZhciBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKCd1dGY4JylcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLl9kZWNvZGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgfVxuICAgIHRoaXMuX3BhcnNlci5lbmQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgdmFyIG1lID0gdGhpc1xuICAgIGlmICghbWUuX3BhcnNlclsnb24nICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpXG4gICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpXG4gIH1cblxuICAvLyBjaGFyYWN0ZXIgY2xhc3NlcyBhbmQgdG9rZW5zXG4gIHZhciB3aGl0ZXNwYWNlID0gJ1xcclxcblxcdCAnXG5cbiAgLy8gdGhpcyByZWFsbHkgbmVlZHMgdG8gYmUgcmVwbGFjZWQgd2l0aCBjaGFyYWN0ZXIgY2xhc3Nlcy5cbiAgLy8gWE1MIGFsbG93cyBhbGwgbWFubmVyIG9mIHJpZGljdWxvdXMgbnVtYmVycyBhbmQgZGlnaXRzLlxuICB2YXIgbnVtYmVyID0gJzAxMjQzNTY3ODknXG4gIHZhciBsZXR0ZXIgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWidcblxuICAvLyAoTGV0dGVyIHwgXCJfXCIgfCBcIjpcIilcbiAgdmFyIHF1b3RlID0gJ1xcJ1wiJ1xuICB2YXIgYXR0cmliRW5kID0gd2hpdGVzcGFjZSArICc+J1xuICB2YXIgQ0RBVEEgPSAnW0NEQVRBWydcbiAgdmFyIERPQ1RZUEUgPSAnRE9DVFlQRSdcbiAgdmFyIFhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xuICB2YXIgWE1MTlNfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xuICB2YXIgcm9vdE5TID0geyB4bWw6IFhNTF9OQU1FU1BBQ0UsIHhtbG5zOiBYTUxOU19OQU1FU1BBQ0UgfVxuXG4gIC8vIHR1cm4gYWxsIHRoZSBzdHJpbmcgY2hhcmFjdGVyIHNldHMgaW50byBjaGFyYWN0ZXIgY2xhc3Mgb2JqZWN0cy5cbiAgd2hpdGVzcGFjZSA9IGNoYXJDbGFzcyh3aGl0ZXNwYWNlKVxuICBudW1iZXIgPSBjaGFyQ2xhc3MobnVtYmVyKVxuICBsZXR0ZXIgPSBjaGFyQ2xhc3MobGV0dGVyKVxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVTdGFydENoYXJcbiAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3b3JrcyBvbiBzdHJpbmdzLCBhIHNpbmdsZSBjaGFyYWN0ZXIgYXQgYSB0aW1lXG4gIC8vIGFzIHN1Y2gsIGl0IGNhbm5vdCBldmVyIHN1cHBvcnQgYXN0cmFsLXBsYW5lIGNoYXJhY3RlcnMgKDEwMDAwLUVGRkZGKVxuICAvLyB3aXRob3V0IGEgc2lnbmlmaWNhbnQgYnJlYWtpbmcgY2hhbmdlIHRvIGVpdGhlciB0aGlzICBwYXJzZXIsIG9yIHRoZVxuICAvLyBKYXZhU2NyaXB0IGxhbmd1YWdlLiAgSW1wbGVtZW50YXRpb24gb2YgYW4gZW1vamktY2FwYWJsZSB4bWwgcGFyc2VyXG4gIC8vIGlzIGxlZnQgYXMgYW4gZXhlcmNpc2UgZm9yIHRoZSByZWFkZXIuXG4gIHZhciBuYW1lU3RhcnQgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cblxuICB2YXIgbmFtZUJvZHkgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MFxcLlxcZC1dL1xuXG4gIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cbiAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBcXC5cXGQtXS9cblxuICBxdW90ZSA9IGNoYXJDbGFzcyhxdW90ZSlcbiAgYXR0cmliRW5kID0gY2hhckNsYXNzKGF0dHJpYkVuZClcblxuICBmdW5jdGlvbiBjaGFyQ2xhc3MgKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJycpLnJlZHVjZShmdW5jdGlvbiAocywgYykge1xuICAgICAgc1tjXSA9IHRydWVcbiAgICAgIHJldHVybiBzXG4gICAgfSwge30pXG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZ0V4cCAoYykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG4gIH1cblxuICBmdW5jdGlvbiBpcyAoY2hhcmNsYXNzLCBjKSB7XG4gICAgcmV0dXJuIGlzUmVnRXhwKGNoYXJjbGFzcykgPyAhIWMubWF0Y2goY2hhcmNsYXNzKSA6IGNoYXJjbGFzc1tjXVxuICB9XG5cbiAgZnVuY3Rpb24gbm90IChjaGFyY2xhc3MsIGMpIHtcbiAgICByZXR1cm4gIWlzKGNoYXJjbGFzcywgYylcbiAgfVxuXG4gIHZhciBTID0gMFxuICBzYXguU1RBVEUgPSB7XG4gICAgQkVHSU46IFMrKywgLy8gbGVhZGluZyBieXRlIG9yZGVyIG1hcmsgb3Igd2hpdGVzcGFjZVxuICAgIEJFR0lOX1dISVRFU1BBQ0U6IFMrKywgLy8gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgVEVYVDogUysrLCAvLyBnZW5lcmFsIHN0dWZmXG4gICAgVEVYVF9FTlRJVFk6IFMrKywgLy8gJmFtcCBhbmQgc3VjaC5cbiAgICBPUEVOX1dBS0E6IFMrKywgLy8gPFxuICAgIFNHTUxfREVDTDogUysrLCAvLyA8IUJMQVJHXG4gICAgU0dNTF9ERUNMX1FVT1RFRDogUysrLCAvLyA8IUJMQVJHIGZvbyBcImJhclxuICAgIERPQ1RZUEU6IFMrKywgLy8gPCFET0NUWVBFXG4gICAgRE9DVFlQRV9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXG4gICAgRE9DVFlQRV9EVEQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyAuLi5cbiAgICBET0NUWVBFX0RURF9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyBcImZvb1xuICAgIENPTU1FTlRfU1RBUlRJTkc6IFMrKywgLy8gPCEtXG4gICAgQ09NTUVOVDogUysrLCAvLyA8IS0tXG4gICAgQ09NTUVOVF9FTkRJTkc6IFMrKywgLy8gPCEtLSBibGFoIC1cbiAgICBDT01NRU5UX0VOREVEOiBTKyssIC8vIDwhLS0gYmxhaCAtLVxuICAgIENEQVRBOiBTKyssIC8vIDwhW0NEQVRBWyBzb21ldGhpbmdcbiAgICBDREFUQV9FTkRJTkc6IFMrKywgLy8gXVxuICAgIENEQVRBX0VORElOR18yOiBTKyssIC8vIF1dXG4gICAgUFJPQ19JTlNUOiBTKyssIC8vIDw/aGlcbiAgICBQUk9DX0lOU1RfQk9EWTogUysrLCAvLyA8P2hpIHRoZXJlXG4gICAgUFJPQ19JTlNUX0VORElORzogUysrLCAvLyA8P2hpIFwidGhlcmVcIiA/XG4gICAgT1BFTl9UQUc6IFMrKywgLy8gPHN0cm9uZ1xuICAgIE9QRU5fVEFHX1NMQVNIOiBTKyssIC8vIDxzdHJvbmcgL1xuICAgIEFUVFJJQjogUysrLCAvLyA8YVxuICAgIEFUVFJJQl9OQU1FOiBTKyssIC8vIDxhIGZvb1xuICAgIEFUVFJJQl9OQU1FX1NBV19XSElURTogUysrLCAvLyA8YSBmb28gX1xuICAgIEFUVFJJQl9WQUxVRTogUysrLCAvLyA8YSBmb289XG4gICAgQVRUUklCX1ZBTFVFX1FVT1RFRDogUysrLCAvLyA8YSBmb289XCJiYXJcbiAgICBBVFRSSUJfVkFMVUVfQ0xPU0VEOiBTKyssIC8vIDxhIGZvbz1cImJhclwiXG4gICAgQVRUUklCX1ZBTFVFX1VOUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1iYXJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1E6IFMrKywgLy8gPGZvbyBiYXI9XCImcXVvdDtcIlxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfVTogUysrLCAvLyA8Zm9vIGJhcj0mcXVvdFxuICAgIENMT1NFX1RBRzogUysrLCAvLyA8L2FcbiAgICBDTE9TRV9UQUdfU0FXX1dISVRFOiBTKyssIC8vIDwvYSAgID5cbiAgICBTQ1JJUFQ6IFMrKywgLy8gPHNjcmlwdD4gLi4uXG4gICAgU0NSSVBUX0VORElORzogUysrIC8vIDxzY3JpcHQ+IC4uLiA8XG4gIH1cblxuICBzYXguWE1MX0VOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIlxuICB9XG5cbiAgc2F4LkVOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIixcbiAgICAnQUVsaWcnOiAxOTgsXG4gICAgJ0FhY3V0ZSc6IDE5MyxcbiAgICAnQWNpcmMnOiAxOTQsXG4gICAgJ0FncmF2ZSc6IDE5MixcbiAgICAnQXJpbmcnOiAxOTcsXG4gICAgJ0F0aWxkZSc6IDE5NSxcbiAgICAnQXVtbCc6IDE5NixcbiAgICAnQ2NlZGlsJzogMTk5LFxuICAgICdFVEgnOiAyMDgsXG4gICAgJ0VhY3V0ZSc6IDIwMSxcbiAgICAnRWNpcmMnOiAyMDIsXG4gICAgJ0VncmF2ZSc6IDIwMCxcbiAgICAnRXVtbCc6IDIwMyxcbiAgICAnSWFjdXRlJzogMjA1LFxuICAgICdJY2lyYyc6IDIwNixcbiAgICAnSWdyYXZlJzogMjA0LFxuICAgICdJdW1sJzogMjA3LFxuICAgICdOdGlsZGUnOiAyMDksXG4gICAgJ09hY3V0ZSc6IDIxMSxcbiAgICAnT2NpcmMnOiAyMTIsXG4gICAgJ09ncmF2ZSc6IDIxMCxcbiAgICAnT3NsYXNoJzogMjE2LFxuICAgICdPdGlsZGUnOiAyMTMsXG4gICAgJ091bWwnOiAyMTQsXG4gICAgJ1RIT1JOJzogMjIyLFxuICAgICdVYWN1dGUnOiAyMTgsXG4gICAgJ1VjaXJjJzogMjE5LFxuICAgICdVZ3JhdmUnOiAyMTcsXG4gICAgJ1V1bWwnOiAyMjAsXG4gICAgJ1lhY3V0ZSc6IDIyMSxcbiAgICAnYWFjdXRlJzogMjI1LFxuICAgICdhY2lyYyc6IDIyNixcbiAgICAnYWVsaWcnOiAyMzAsXG4gICAgJ2FncmF2ZSc6IDIyNCxcbiAgICAnYXJpbmcnOiAyMjksXG4gICAgJ2F0aWxkZSc6IDIyNyxcbiAgICAnYXVtbCc6IDIyOCxcbiAgICAnY2NlZGlsJzogMjMxLFxuICAgICdlYWN1dGUnOiAyMzMsXG4gICAgJ2VjaXJjJzogMjM0LFxuICAgICdlZ3JhdmUnOiAyMzIsXG4gICAgJ2V0aCc6IDI0MCxcbiAgICAnZXVtbCc6IDIzNSxcbiAgICAnaWFjdXRlJzogMjM3LFxuICAgICdpY2lyYyc6IDIzOCxcbiAgICAnaWdyYXZlJzogMjM2LFxuICAgICdpdW1sJzogMjM5LFxuICAgICdudGlsZGUnOiAyNDEsXG4gICAgJ29hY3V0ZSc6IDI0MyxcbiAgICAnb2NpcmMnOiAyNDQsXG4gICAgJ29ncmF2ZSc6IDI0MixcbiAgICAnb3NsYXNoJzogMjQ4LFxuICAgICdvdGlsZGUnOiAyNDUsXG4gICAgJ291bWwnOiAyNDYsXG4gICAgJ3N6bGlnJzogMjIzLFxuICAgICd0aG9ybic6IDI1NCxcbiAgICAndWFjdXRlJzogMjUwLFxuICAgICd1Y2lyYyc6IDI1MSxcbiAgICAndWdyYXZlJzogMjQ5LFxuICAgICd1dW1sJzogMjUyLFxuICAgICd5YWN1dGUnOiAyNTMsXG4gICAgJ3l1bWwnOiAyNTUsXG4gICAgJ2NvcHknOiAxNjksXG4gICAgJ3JlZyc6IDE3NCxcbiAgICAnbmJzcCc6IDE2MCxcbiAgICAnaWV4Y2wnOiAxNjEsXG4gICAgJ2NlbnQnOiAxNjIsXG4gICAgJ3BvdW5kJzogMTYzLFxuICAgICdjdXJyZW4nOiAxNjQsXG4gICAgJ3llbic6IDE2NSxcbiAgICAnYnJ2YmFyJzogMTY2LFxuICAgICdzZWN0JzogMTY3LFxuICAgICd1bWwnOiAxNjgsXG4gICAgJ29yZGYnOiAxNzAsXG4gICAgJ2xhcXVvJzogMTcxLFxuICAgICdub3QnOiAxNzIsXG4gICAgJ3NoeSc6IDE3MyxcbiAgICAnbWFjcic6IDE3NSxcbiAgICAnZGVnJzogMTc2LFxuICAgICdwbHVzbW4nOiAxNzcsXG4gICAgJ3N1cDEnOiAxODUsXG4gICAgJ3N1cDInOiAxNzgsXG4gICAgJ3N1cDMnOiAxNzksXG4gICAgJ2FjdXRlJzogMTgwLFxuICAgICdtaWNybyc6IDE4MSxcbiAgICAncGFyYSc6IDE4MixcbiAgICAnbWlkZG90JzogMTgzLFxuICAgICdjZWRpbCc6IDE4NCxcbiAgICAnb3JkbSc6IDE4NixcbiAgICAncmFxdW8nOiAxODcsXG4gICAgJ2ZyYWMxNCc6IDE4OCxcbiAgICAnZnJhYzEyJzogMTg5LFxuICAgICdmcmFjMzQnOiAxOTAsXG4gICAgJ2lxdWVzdCc6IDE5MSxcbiAgICAndGltZXMnOiAyMTUsXG4gICAgJ2RpdmlkZSc6IDI0NyxcbiAgICAnT0VsaWcnOiAzMzgsXG4gICAgJ29lbGlnJzogMzM5LFxuICAgICdTY2Fyb24nOiAzNTIsXG4gICAgJ3NjYXJvbic6IDM1MyxcbiAgICAnWXVtbCc6IDM3NixcbiAgICAnZm5vZic6IDQwMixcbiAgICAnY2lyYyc6IDcxMCxcbiAgICAndGlsZGUnOiA3MzIsXG4gICAgJ0FscGhhJzogOTEzLFxuICAgICdCZXRhJzogOTE0LFxuICAgICdHYW1tYSc6IDkxNSxcbiAgICAnRGVsdGEnOiA5MTYsXG4gICAgJ0Vwc2lsb24nOiA5MTcsXG4gICAgJ1pldGEnOiA5MTgsXG4gICAgJ0V0YSc6IDkxOSxcbiAgICAnVGhldGEnOiA5MjAsXG4gICAgJ0lvdGEnOiA5MjEsXG4gICAgJ0thcHBhJzogOTIyLFxuICAgICdMYW1iZGEnOiA5MjMsXG4gICAgJ011JzogOTI0LFxuICAgICdOdSc6IDkyNSxcbiAgICAnWGknOiA5MjYsXG4gICAgJ09taWNyb24nOiA5MjcsXG4gICAgJ1BpJzogOTI4LFxuICAgICdSaG8nOiA5MjksXG4gICAgJ1NpZ21hJzogOTMxLFxuICAgICdUYXUnOiA5MzIsXG4gICAgJ1Vwc2lsb24nOiA5MzMsXG4gICAgJ1BoaSc6IDkzNCxcbiAgICAnQ2hpJzogOTM1LFxuICAgICdQc2knOiA5MzYsXG4gICAgJ09tZWdhJzogOTM3LFxuICAgICdhbHBoYSc6IDk0NSxcbiAgICAnYmV0YSc6IDk0NixcbiAgICAnZ2FtbWEnOiA5NDcsXG4gICAgJ2RlbHRhJzogOTQ4LFxuICAgICdlcHNpbG9uJzogOTQ5LFxuICAgICd6ZXRhJzogOTUwLFxuICAgICdldGEnOiA5NTEsXG4gICAgJ3RoZXRhJzogOTUyLFxuICAgICdpb3RhJzogOTUzLFxuICAgICdrYXBwYSc6IDk1NCxcbiAgICAnbGFtYmRhJzogOTU1LFxuICAgICdtdSc6IDk1NixcbiAgICAnbnUnOiA5NTcsXG4gICAgJ3hpJzogOTU4LFxuICAgICdvbWljcm9uJzogOTU5LFxuICAgICdwaSc6IDk2MCxcbiAgICAncmhvJzogOTYxLFxuICAgICdzaWdtYWYnOiA5NjIsXG4gICAgJ3NpZ21hJzogOTYzLFxuICAgICd0YXUnOiA5NjQsXG4gICAgJ3Vwc2lsb24nOiA5NjUsXG4gICAgJ3BoaSc6IDk2NixcbiAgICAnY2hpJzogOTY3LFxuICAgICdwc2knOiA5NjgsXG4gICAgJ29tZWdhJzogOTY5LFxuICAgICd0aGV0YXN5bSc6IDk3NyxcbiAgICAndXBzaWgnOiA5NzgsXG4gICAgJ3Bpdic6IDk4MixcbiAgICAnZW5zcCc6IDgxOTQsXG4gICAgJ2Vtc3AnOiA4MTk1LFxuICAgICd0aGluc3AnOiA4MjAxLFxuICAgICd6d25qJzogODIwNCxcbiAgICAnendqJzogODIwNSxcbiAgICAnbHJtJzogODIwNixcbiAgICAncmxtJzogODIwNyxcbiAgICAnbmRhc2gnOiA4MjExLFxuICAgICdtZGFzaCc6IDgyMTIsXG4gICAgJ2xzcXVvJzogODIxNixcbiAgICAncnNxdW8nOiA4MjE3LFxuICAgICdzYnF1byc6IDgyMTgsXG4gICAgJ2xkcXVvJzogODIyMCxcbiAgICAncmRxdW8nOiA4MjIxLFxuICAgICdiZHF1byc6IDgyMjIsXG4gICAgJ2RhZ2dlcic6IDgyMjQsXG4gICAgJ0RhZ2dlcic6IDgyMjUsXG4gICAgJ2J1bGwnOiA4MjI2LFxuICAgICdoZWxsaXAnOiA4MjMwLFxuICAgICdwZXJtaWwnOiA4MjQwLFxuICAgICdwcmltZSc6IDgyNDIsXG4gICAgJ1ByaW1lJzogODI0MyxcbiAgICAnbHNhcXVvJzogODI0OSxcbiAgICAncnNhcXVvJzogODI1MCxcbiAgICAnb2xpbmUnOiA4MjU0LFxuICAgICdmcmFzbCc6IDgyNjAsXG4gICAgJ2V1cm8nOiA4MzY0LFxuICAgICdpbWFnZSc6IDg0NjUsXG4gICAgJ3dlaWVycCc6IDg0NzIsXG4gICAgJ3JlYWwnOiA4NDc2LFxuICAgICd0cmFkZSc6IDg0ODIsXG4gICAgJ2FsZWZzeW0nOiA4NTAxLFxuICAgICdsYXJyJzogODU5MixcbiAgICAndWFycic6IDg1OTMsXG4gICAgJ3JhcnInOiA4NTk0LFxuICAgICdkYXJyJzogODU5NSxcbiAgICAnaGFycic6IDg1OTYsXG4gICAgJ2NyYXJyJzogODYyOSxcbiAgICAnbEFycic6IDg2NTYsXG4gICAgJ3VBcnInOiA4NjU3LFxuICAgICdyQXJyJzogODY1OCxcbiAgICAnZEFycic6IDg2NTksXG4gICAgJ2hBcnInOiA4NjYwLFxuICAgICdmb3JhbGwnOiA4NzA0LFxuICAgICdwYXJ0JzogODcwNixcbiAgICAnZXhpc3QnOiA4NzA3LFxuICAgICdlbXB0eSc6IDg3MDksXG4gICAgJ25hYmxhJzogODcxMSxcbiAgICAnaXNpbic6IDg3MTIsXG4gICAgJ25vdGluJzogODcxMyxcbiAgICAnbmknOiA4NzE1LFxuICAgICdwcm9kJzogODcxOSxcbiAgICAnc3VtJzogODcyMSxcbiAgICAnbWludXMnOiA4NzIyLFxuICAgICdsb3dhc3QnOiA4NzI3LFxuICAgICdyYWRpYyc6IDg3MzAsXG4gICAgJ3Byb3AnOiA4NzMzLFxuICAgICdpbmZpbic6IDg3MzQsXG4gICAgJ2FuZyc6IDg3MzYsXG4gICAgJ2FuZCc6IDg3NDMsXG4gICAgJ29yJzogODc0NCxcbiAgICAnY2FwJzogODc0NSxcbiAgICAnY3VwJzogODc0NixcbiAgICAnaW50JzogODc0NyxcbiAgICAndGhlcmU0JzogODc1NixcbiAgICAnc2ltJzogODc2NCxcbiAgICAnY29uZyc6IDg3NzMsXG4gICAgJ2FzeW1wJzogODc3NixcbiAgICAnbmUnOiA4ODAwLFxuICAgICdlcXVpdic6IDg4MDEsXG4gICAgJ2xlJzogODgwNCxcbiAgICAnZ2UnOiA4ODA1LFxuICAgICdzdWInOiA4ODM0LFxuICAgICdzdXAnOiA4ODM1LFxuICAgICduc3ViJzogODgzNixcbiAgICAnc3ViZSc6IDg4MzgsXG4gICAgJ3N1cGUnOiA4ODM5LFxuICAgICdvcGx1cyc6IDg4NTMsXG4gICAgJ290aW1lcyc6IDg4NTUsXG4gICAgJ3BlcnAnOiA4ODY5LFxuICAgICdzZG90JzogODkwMSxcbiAgICAnbGNlaWwnOiA4OTY4LFxuICAgICdyY2VpbCc6IDg5NjksXG4gICAgJ2xmbG9vcic6IDg5NzAsXG4gICAgJ3JmbG9vcic6IDg5NzEsXG4gICAgJ2xhbmcnOiA5MDAxLFxuICAgICdyYW5nJzogOTAwMixcbiAgICAnbG96JzogOTY3NCxcbiAgICAnc3BhZGVzJzogOTgyNCxcbiAgICAnY2x1YnMnOiA5ODI3LFxuICAgICdoZWFydHMnOiA5ODI5LFxuICAgICdkaWFtcyc6IDk4MzBcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNheC5FTlRJVElFUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGUgPSBzYXguRU5USVRJRVNba2V5XVxuICAgIHZhciBzID0gdHlwZW9mIGUgPT09ICdudW1iZXInID8gU3RyaW5nLmZyb21DaGFyQ29kZShlKSA6IGVcbiAgICBzYXguRU5USVRJRVNba2V5XSA9IHNcbiAgfSlcblxuICBmb3IgKHZhciBzIGluIHNheC5TVEFURSkge1xuICAgIHNheC5TVEFURVtzYXguU1RBVEVbc11dID0gc1xuICB9XG5cbiAgLy8gc2hvcnRoYW5kXG4gIFMgPSBzYXguU1RBVEVcblxuICBmdW5jdGlvbiBlbWl0IChwYXJzZXIsIGV2ZW50LCBkYXRhKSB7XG4gICAgcGFyc2VyW2V2ZW50XSAmJiBwYXJzZXJbZXZlbnRdKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0Tm9kZSAocGFyc2VyLCBub2RlVHlwZSwgZGF0YSkge1xuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgZW1pdChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUZXh0IChwYXJzZXIpIHtcbiAgICBwYXJzZXIudGV4dE5vZGUgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIudGV4dE5vZGUpXG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgZW1pdChwYXJzZXIsICdvbnRleHQnLCBwYXJzZXIudGV4dE5vZGUpXG4gICAgcGFyc2VyLnRleHROb2RlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRvcHRzIChvcHQsIHRleHQpIHtcbiAgICBpZiAob3B0LnRyaW0pIHRleHQgPSB0ZXh0LnRyaW0oKVxuICAgIGlmIChvcHQubm9ybWFsaXplKSB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IgKHBhcnNlciwgZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgZXIgKz0gJ1xcbkxpbmU6ICcgKyBwYXJzZXIubGluZSArXG4gICAgICAgICdcXG5Db2x1bW46ICcgKyBwYXJzZXIuY29sdW1uICtcbiAgICAgICAgJ1xcbkNoYXI6ICcgKyBwYXJzZXIuY1xuICAgIH1cbiAgICBlciA9IG5ldyBFcnJvcihlcilcbiAgICBwYXJzZXIuZXJyb3IgPSBlclxuICAgIGVtaXQocGFyc2VyLCAnb25lcnJvcicsIGVyKVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkgc3RyaWN0RmFpbChwYXJzZXIsICdVbmNsb3NlZCByb290IHRhZycpXG4gICAgaWYgKChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU4pICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOX1dISVRFU1BBQ0UpICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLlRFWFQpKSB7XG4gICAgICBlcnJvcihwYXJzZXIsICdVbmV4cGVjdGVkIGVuZCcpXG4gICAgfVxuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5jbG9zZWQgPSB0cnVlXG4gICAgZW1pdChwYXJzZXIsICdvbmVuZCcpXG4gICAgU0FYUGFyc2VyLmNhbGwocGFyc2VyLCBwYXJzZXIuc3RyaWN0LCBwYXJzZXIub3B0KVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmljdEZhaWwgKHBhcnNlciwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgcGFyc2VyICE9PSAnb2JqZWN0JyB8fCAhKHBhcnNlciBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwgdG8gc3RyaWN0RmFpbCcpXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBlcnJvcihwYXJzZXIsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV3VGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHsgbmFtZTogcGFyc2VyLnRhZ05hbWUsIGF0dHJpYnV0ZXM6IHt9IH1cblxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBpZiB0YWcgY29udGFpbHMgYW4geG1sbnM9XCJmb29cIiBvciB4bWxuczpmb289XCJiYXJcIlxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB0YWcubnMgPSBwYXJlbnQubnNcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZ3N0YXJ0JywgdGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gcW5hbWUgKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKCc6JylcbiAgICB2YXIgcXVhbE5hbWUgPSBpIDwgMCA/IFsgJycsIG5hbWUgXSA6IG5hbWUuc3BsaXQoJzonKVxuICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZVswXVxuICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lWzFdXG5cbiAgICAvLyA8eCBcInhtbG5zXCI9XCJodHRwOi8vZm9vXCI+XG4gICAgaWYgKGF0dHJpYnV0ZSAmJiBuYW1lID09PSAneG1sbnMnKSB7XG4gICAgICBwcmVmaXggPSAneG1sbnMnXG4gICAgICBsb2NhbCA9ICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIGxvY2FsOiBsb2NhbCB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWIgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5hdHRyaWJMaXN0LmluZGV4T2YocGFyc2VyLmF0dHJpYk5hbWUpICE9PSAtMSB8fFxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHBhcnNlci5hdHRyaWJOYW1lKSkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci5hdHRyaWJOYW1lLCB0cnVlKVxuICAgICAgdmFyIHByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdmFyIGxvY2FsID0gcW4ubG9jYWxcblxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3htbG5zJykge1xuICAgICAgICAvLyBuYW1lc3BhY2UgYmluZGluZyBhdHRyaWJ1dGUuIHB1c2ggdGhlIGJpbmRpbmcgaW50byBzY29wZVxuICAgICAgICBpZiAobG9jYWwgPT09ICd4bWwnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbDogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTF9OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsID09PSAneG1sbnMnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sbnM6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxOU19OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgICAgIGlmICh0YWcubnMgPT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgdGFnLm5zID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQubnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZy5uc1tsb2NhbF0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWZlciBvbmF0dHJpYnV0ZSBldmVudHMgdW50aWwgYWxsIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNlZW5cbiAgICAgIC8vIHNvIGFueSBuZXcgYmluZGluZ3MgY2FuIHRha2UgZWZmZWN0LiBwcmVzZXJ2ZSBhdHRyaWJ1dGUgb3JkZXJcbiAgICAgIC8vIHNvIGRlZmVycmVkIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBpbiBkb2N1bWVudCBvcmRlclxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QucHVzaChbcGFyc2VyLmF0dHJpYk5hbWUsIHBhcnNlci5hdHRyaWJWYWx1ZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIG5vbi14bWxucyBtb2RlLCB3ZSBjYW4gZW1pdCB0aGUgZXZlbnQgcmlnaHQgYXdheVxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICB2YWx1ZTogcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5UYWcgKHBhcnNlciwgc2VsZkNsb3NpbmcpIHtcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgLy8gZW1pdCBuYW1lc3BhY2UgYmluZGluZyBldmVudHNcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG5cbiAgICAgIC8vIGFkZCBuYW1lc3BhY2UgaW5mbyB0byB0YWdcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci50YWdOYW1lKVxuICAgICAgdGFnLnByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdGFnLmxvY2FsID0gcW4ubG9jYWxcbiAgICAgIHRhZy51cmkgPSB0YWcubnNbcW4ucHJlZml4XSB8fCAnJ1xuXG4gICAgICBpZiAodGFnLnByZWZpeCAmJiAhdGFnLnVyaSkge1xuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGFyc2VyLnRhZ05hbWUpKVxuICAgICAgICB0YWcudXJpID0gcW4ucHJlZml4XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmICh0YWcubnMgJiYgcGFyZW50Lm5zICE9PSB0YWcubnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVubmFtZXNwYWNlJywge1xuICAgICAgICAgICAgcHJlZml4OiBwLFxuICAgICAgICAgICAgdXJpOiB0YWcubnNbcF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgZGVmZXJyZWQgb25hdHRyaWJ1dGUgZXZlbnRzXG4gICAgICAvLyBOb3RlOiBkbyBub3QgYXBwbHkgZGVmYXVsdCBucyB0byBhdHRyaWJ1dGVzOlxuICAgICAgLy8gICBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLW5hbWVzLyNkZWZhdWx0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbnYgPSBwYXJzZXIuYXR0cmliTGlzdFtpXVxuICAgICAgICB2YXIgbmFtZSA9IG52WzBdXG4gICAgICAgIHZhciB2YWx1ZSA9IG52WzFdXG4gICAgICAgIHZhciBxdWFsTmFtZSA9IHFuYW1lKG5hbWUsIHRydWUpXG4gICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZS5wcmVmaXhcbiAgICAgICAgdmFyIGxvY2FsID0gcXVhbE5hbWUubG9jYWxcbiAgICAgICAgdmFyIHVyaSA9IHByZWZpeCA9PT0gJycgPyAnJyA6ICh0YWcubnNbcHJlZml4XSB8fCAnJylcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgbG9jYWw6IGxvY2FsLFxuICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBhdHRyaWJ1dGVzIHdpdGggYW4gdW5kZWZpbmVkIG5hbWVzcGFjZSxcbiAgICAgICAgLy8gdGhlbiBmYWlsIG9uIHRoZW0gbm93LlxuICAgICAgICBpZiAocHJlZml4ICYmIHByZWZpeCAhPT0gJ3htbG5zJyAmJiAhdXJpKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJlZml4KSlcbiAgICAgICAgICBhLnVyaSA9IHByZWZpeFxuICAgICAgICB9XG4gICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1tuYW1lXSA9IGFcbiAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCBhKVxuICAgICAgfVxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIH1cblxuICAgIHBhcnNlci50YWcuaXNTZWxmQ2xvc2luZyA9ICEhc2VsZkNsb3NpbmdcblxuICAgIC8vIHByb2Nlc3MgdGhlIHRhZ1xuICAgIHBhcnNlci5zYXdSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdzLnB1c2gocGFyc2VyLnRhZylcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWcnLCBwYXJzZXIudGFnKVxuICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPHNjcmlwdD4gaW4gbm9uLXN0cmljdCBtb2RlLlxuICAgICAgaWYgKCFwYXJzZXIubm9zY3JpcHQgJiYgcGFyc2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgfVxuICAgICAgcGFyc2VyLnRhZyA9IG51bGxcbiAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1dlaXJkIGVtcHR5IGNsb3NlIHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8Lz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICBpZiAocGFyc2VyLnRhZ05hbWUgIT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgY2xvc2luZyB0YWcgYWN0dWFsbHkgZXhpc3RzLlxuICAgIC8vIDxhPjxiPjwvYz48L2I+PC9hPiB3aWxsIGNsb3NlIGV2ZXJ5dGhpbmcsIG90aGVyd2lzZS5cbiAgICB2YXIgdCA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHRhZ05hbWUgPSB0YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG4gICAgdmFyIGNsb3NlVG8gPSB0YWdOYW1lXG4gICAgd2hpbGUgKHQtLSkge1xuICAgICAgdmFyIGNsb3NlID0gcGFyc2VyLnRhZ3NbdF1cbiAgICAgIGlmIChjbG9zZS5uYW1lICE9PSBjbG9zZVRvKSB7XG4gICAgICAgIC8vIGZhaWwgdGhlIGZpcnN0IHRpbWUgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmV4cGVjdGVkIGNsb3NlIHRhZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpZG4ndCBmaW5kIGl0LiAgd2UgYWxyZWFkeSBmYWlsZWQgZm9yIHN0cmljdCwgc28ganVzdCBhYm9ydC5cbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5tYXRjaGVkIGNsb3NpbmcgdGFnOiAnICsgcGFyc2VyLnRhZ05hbWUpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBwYXJzZXIudGFnTmFtZSA9IHRhZ05hbWVcbiAgICB2YXIgcyA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHdoaWxlIChzLS0gPiB0KSB7XG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHBhcnNlci50YWdzLnBvcCgpXG4gICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWcubmFtZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZXRhZycsIHBhcnNlci50YWdOYW1lKVxuXG4gICAgICB2YXIgeCA9IHt9XG4gICAgICBmb3IgKHZhciBpIGluIHRhZy5ucykge1xuICAgICAgICB4W2ldID0gdGFnLm5zW2ldXG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zICYmIHRhZy5ucyAhPT0gcGFyZW50Lm5zKSB7XG4gICAgICAgIC8vIHJlbW92ZSBuYW1lc3BhY2UgYmluZGluZ3MgaW50cm9kdWNlZCBieSB0YWdcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIG4gPSB0YWcubnNbcF1cbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlbmFtZXNwYWNlJywgeyBwcmVmaXg6IHAsIHVyaTogbiB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodCA9PT0gMCkgcGFyc2VyLmNsb3NlZFJvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbnRpdHkgKHBhcnNlcikge1xuICAgIHZhciBlbnRpdHkgPSBwYXJzZXIuZW50aXR5XG4gICAgdmFyIGVudGl0eUxDID0gZW50aXR5LnRvTG93ZXJDYXNlKClcbiAgICB2YXIgbnVtXG4gICAgdmFyIG51bVN0ciA9ICcnXG5cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eV0pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5XVxuICAgIH1cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ11cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5TENcbiAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICBpZiAoZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnKSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgyKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDE2KVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMSlcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxMClcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDEwKVxuICAgICAgfVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHkucmVwbGFjZSgvXjArLywgJycpXG4gICAgaWYgKG51bVN0ci50b0xvd2VyQ2FzZSgpICE9PSBlbnRpdHkpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5JylcbiAgICAgIHJldHVybiAnJicgKyBwYXJzZXIuZW50aXR5ICsgJzsnXG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZSAocGFyc2VyLCBjKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgfSBlbHNlIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgIC8vIGhhdmUgdG8gcHJvY2VzcyB0aGlzIGFzIGEgdGV4dCBub2RlLlxuICAgICAgLy8gd2VpcmQsIGJ1dCBoYXBwZW5zLlxuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdOb24td2hpdGVzcGFjZSBiZWZvcmUgZmlyc3QgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgPSBjXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQXQgKGNodW5rLCBpKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgaWYgKGkgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rLmNoYXJBdChpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSAoY2h1bmspIHtcbiAgICB2YXIgcGFyc2VyID0gdGhpc1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yXG4gICAgfVxuICAgIGlmIChwYXJzZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gZXJyb3IocGFyc2VyLFxuICAgICAgICAnQ2Fubm90IHdyaXRlIGFmdGVyIGNsb3NlLiBBc3NpZ24gYW4gb25yZWFkeSBoYW5kbGVyLicpXG4gICAgfVxuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuZChwYXJzZXIpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdvYmplY3QnKSB7XG4gICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGMgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICBwYXJzZXIuYyA9IGNcbiAgICAgIGlmICghYykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgIHBhcnNlci5wb3NpdGlvbisrXG4gICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgIHBhcnNlci5saW5lKytcbiAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4rK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICBjYXNlIFMuQkVHSU46XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTl9XSElURVNQQUNFXG4gICAgICAgICAgaWYgKGMgPT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5CRUdJTl9XSElURVNQQUNFOlxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVDpcbiAgICAgICAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRpID0gaSAtIDFcbiAgICAgICAgICAgIHdoaWxlIChjICYmIGMgIT09ICc8JyAmJiBjICE9PSAnJicpIHtcbiAgICAgICAgICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgICAgICAgICBpZiAoYyAmJiBwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbisrXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjaHVuay5zdWJzdHJpbmcoc3RhcnRpLCBpIC0gMSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICc8JyAmJiAhKHBhcnNlci5zYXdSb290ICYmIHBhcnNlci5jbG9zZWRSb290ICYmICFwYXJzZXIuc3RyaWN0KSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykgJiYgKCFwYXJzZXIuc2F3Um9vdCB8fCBwYXJzZXIuY2xvc2VkUm9vdCkpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdUZXh0IGRhdGEgb3V0c2lkZSBvZiByb290IG5vZGUuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUX0VOVElUWVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0NSSVBUOlxuICAgICAgICAgIC8vIG9ubHkgbm9uLXN0cmljdFxuICAgICAgICAgIGlmIChjID09PSAnPCcpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0NSSVBUX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fV0FLQTpcbiAgICAgICAgICAvLyBlaXRoZXIgYSAvLCA/LCAhLCBvciB0ZXh0IGlzIGNvbWluZyBuZXh0LlxuICAgICAgICAgIGlmIChjID09PSAnIScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGl0Li4uXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmVuY29kZWQgPCcpXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgc29tZSB3aGl0ZXNwYWNlLCB0aGVuIGFkZCB0aGF0IGluLlxuICAgICAgICAgICAgaWYgKHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uICsgMSA8IHBhcnNlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICB2YXIgcGFkID0gcGFyc2VyLnBvc2l0aW9uIC0gcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb25cbiAgICAgICAgICAgICAgYyA9IG5ldyBBcnJheShwYWQpLmpvaW4oJyAnKSArIGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMOlxuICAgICAgICAgIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gQ0RBVEEpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbmNkYXRhJylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNnbWxEZWNsICsgYyA9PT0gJy0tJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IERPQ1RZUEUpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgICAgaWYgKHBhcnNlci5kb2N0eXBlIHx8IHBhcnNlci5zYXdSb290KSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgICAgICdJbmFwcHJvcHJpYXRlbHkgbG9jYXRlZCBkb2N0eXBlIGRlY2xhcmF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2dtbGRlY2xhcmF0aW9uJywgcGFyc2VyLnNnbWxEZWNsKVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmRvY3R5cGUnLCBwYXJzZXIuZG9jdHlwZSlcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZSAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URURcbiAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhxdW90ZSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERfUVVPVEVEXG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVERfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VOREVEXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci5jb21tZW50KVxuICAgICAgICAgICAgaWYgKHBhcnNlci5jb21tZW50KSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY29tbWVudCcsIHBhcnNlci5jb21tZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSAnLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ01hbGZvcm1lZCBjb21tZW50JylcbiAgICAgICAgICAgIC8vIGFsbG93IDwhLS0gYmxhaCAtLSBibG9vIC0tPiBpbiBub24tc3RyaWN0IG1vZGUsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBhIGNvbW1lbnQgb2YgXCIgYmxhaCAtLSBibG9vIFwiXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSAnLS0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdfMlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ10nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkdfMjpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmNkYXRhKSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ10nXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXV0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1Q6XG4gICAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5wcm9jSW5zdE5hbWUsXG4gICAgICAgICAgICAgIGJvZHk6IHBhcnNlci5wcm9jSW5zdEJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSAnPycgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHOlxuICAgICAgICAgIGlmIChpcyhuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGFnKHBhcnNlcilcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobm90KHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiB0YWcgbmFtZScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUdfU0xBU0g6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIsIHRydWUpXG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnRm9yd2FyZC1zbGFzaCBpbiBvcGVuaW5nIHRhZyBub3QgZm9sbG93ZWQgYnkgPicpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUI6XG4gICAgICAgICAgLy8gaGF2ZW4ndCByZWFkIHRoZSBhdHRyaWJ1dGUgbmFtZSB5ZXQuXG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lXG4gICAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFOlxuICAgICAgICAgIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHF1b3RlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1FcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9DTE9TRURcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfQ0xPU0VEOlxuICAgICAgICAgIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ6XG4gICAgICAgICAgaWYgKG5vdChhdHRyaWJFbmQsIGMpKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHOlxuICAgICAgICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub3QobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIGNcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm90KHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHX1NBV19XSElURVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUdfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVycyBpbiBjbG9zaW5nIHRhZycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgIHZhciByZXR1cm5TdGF0ZVxuICAgICAgICAgIHZhciBidWZmZXJcbiAgICAgICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgICAgICBidWZmZXIgPSAndGV4dE5vZGUnXG4gICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgICBidWZmZXIgPSAnYXR0cmliVmFsdWUnXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09ICc7Jykge1xuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gcGFyc2VFbnRpdHkocGFyc2VyKVxuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMocGFyc2VyLmVudGl0eS5sZW5ndGggPyBlbnRpdHlCb2R5IDogZW50aXR5U3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiBlbnRpdHkgbmFtZScpXG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSAnJicgKyBwYXJzZXIuZW50aXR5ICsgY1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyLCAnVW5rbm93biBzdGF0ZTogJyArIHBhcnNlci5zdGF0ZSlcbiAgICAgIH1cbiAgICB9IC8vIHdoaWxlXG5cbiAgICBpZiAocGFyc2VyLnBvc2l0aW9uID49IHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uKSB7XG4gICAgICBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpXG4gICAgfVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIC8qISBodHRwOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjEuMCBieSBAbWF0aGlhcyAqL1xuICBpZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yXG4gICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwXG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXVxuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZVxuICAgICAgICB2YXIgbG93U3Vycm9nYXRlXG4gICAgICAgIHZhciBpbmRleCA9IC0xXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikgeyAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KVxuICAgICAgICAgIH0gZWxzZSB7IC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMFxuICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4REMwMFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cylcbiAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZywgJ2Zyb21Db2RlUG9pbnQnLCB7XG4gICAgICAgICAgdmFsdWU6IGZyb21Db2RlUG9pbnQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBTdHJpbmcuZnJvbUNvZGVQb2ludCA9IGZyb21Db2RlUG9pbnRcbiAgICAgIH1cbiAgICB9KCkpXG4gIH1cbn0pKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2F4ID0ge30gOiBleHBvcnRzKVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNSRUFURV9ERUZJTklUSU9OUyA9IGV4cG9ydHMucmVnaXN0ZXIgPSB2b2lkIDA7XG5jb25zdCBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEgPSByZXF1aXJlKFwibm9kZS1kZXBlbmRlbmN5LWluamVjdGlvblwiKTtcbmNvbnN0IENvbW1lcmNlQ3JlYXRvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYmFja29mZmljZS1jb250ZXh0cy9jb21tZXJjZXMvYXBwL2NyZWF0ZS9Db21tZXJjZUNyZWF0b3JcIikpO1xuY29uc3QgRHluYW1vQ29tbWVyY2VSZXBvc2l0b3J5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9pbmZyYS9wZXJzaXN0ZW5jZS9keW5hbW9kYi9EeW5hbW9Db21tZXJjZVJlcG9zaXRvcnlcIikpO1xuY29uc3QgZHluYW1vZGJfMSA9IHJlcXVpcmUoXCJhd3Mtc2RrL2NsaWVudHMvZHluYW1vZGJcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfZGlfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvZGVwZW5kZW5jaWVzLmRpXCIpO1xuY29uc3QgQ29tbWVyY2VDcmVhdG9ySGFuZGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYmFja29mZmljZS1jb250ZXh0cy9jb21tZXJjZXMvYXBwL2NyZWF0ZS9Db21tZXJjZUNyZWF0b3JIYW5kbGVyXCIpKTtcbmNvbnN0IENSRUFURV9ERUZJTklUSU9OUyA9IHtcbiAgICBDb21tZXJjZUNyZWF0b3I6IFwiQ29tbWVyY2VDcmVhdG9yXCIsXG4gICAgQ29tbWVyY2VSZXBvc2l0b3J5OiBcIkNvbW1lcmNlUmVwb3NpdG9yeVwiLFxuICAgIEhhbmRsZXI6IFwiQ29tbWVyY2VDcmVhdG9ySGFuZGxlclwiXG59LCByZWdpc3RlciA9IChjb250YWluZXIpID0+IHtcbiAgICBjb250YWluZXJcbiAgICAgICAgLnJlZ2lzdGVyKENSRUFURV9ERUZJTklUSU9OUy5Db21tZXJjZVJlcG9zaXRvcnksIER5bmFtb0NvbW1lcmNlUmVwb3NpdG9yeV8xLmRlZmF1bHQpXG4gICAgICAgIC5hZGRBcmd1bWVudChuZXcgZHluYW1vZGJfMS5Eb2N1bWVudENsaWVudCgpKVxuICAgICAgICAuYWRkQXJndW1lbnQocHJvY2Vzcy5lbnYuVEFCTEVfTkFNRSlcbiAgICAgICAgLmFkZEFyZ3VtZW50KFwiZW1haWxJbmRleFwiKTtcbiAgICBjb250YWluZXJcbiAgICAgICAgLnJlZ2lzdGVyKENSRUFURV9ERUZJTklUSU9OUy5Db21tZXJjZUNyZWF0b3IsIENvbW1lcmNlQ3JlYXRvcl8xLmRlZmF1bHQpXG4gICAgICAgIC5hZGRBcmd1bWVudChuZXcgbm9kZV9kZXBlbmRlbmN5X2luamVjdGlvbl8xLlJlZmVyZW5jZShDUkVBVEVfREVGSU5JVElPTlMuQ29tbWVyY2VSZXBvc2l0b3J5KSlcbiAgICAgICAgLmFkZEFyZ3VtZW50KG5ldyBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEuUmVmZXJlbmNlKGRlcGVuZGVuY2llc19kaV8xLkRFRklOSVRJT05TLk1lbW9yeUJ1c2VzLkV2ZW50QnVzKSk7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IG5ldyBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEuRGVmaW5pdGlvbihDb21tZXJjZUNyZWF0b3JIYW5kbGVyXzEuZGVmYXVsdCk7XG4gICAgZGVmaW5pdGlvbi5hZGRBcmd1bWVudChuZXcgbm9kZV9kZXBlbmRlbmN5X2luamVjdGlvbl8xLlJlZmVyZW5jZShDUkVBVEVfREVGSU5JVElPTlMuQ29tbWVyY2VDcmVhdG9yKSk7XG4gICAgZGVmaW5pdGlvbi5hZGRUYWcoZGVwZW5kZW5jaWVzX2RpXzEuREVGSU5JVElPTlMuVGFncy5Db21tYW5kSGFuZGxlcik7XG4gICAgY29udGFpbmVyLnNldERlZmluaXRpb24oQ1JFQVRFX0RFRklOSVRJT05TLkhhbmRsZXIsIGRlZmluaXRpb24pO1xufTtcbmV4cG9ydHMuQ1JFQVRFX0RFRklOSVRJT05TID0gQ1JFQVRFX0RFRklOSVRJT05TO1xuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1pZGR5L2NvcmVcIikpO1xuY29uc3QgaHR0cF9jb3JzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtaWRkeS9odHRwLWNvcnNcIikpO1xuY29uc3QgZGVwZW5kZW5jaWVzX2RpXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2RlcGVuZGVuY2llcy5kaVwiKTtcbmNvbnN0IGRlcGVuZGVuY2llc19kaV8yID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzLmRpXCIpO1xuY29uc3Qgbm9kZV9kZXBlbmRlbmN5X2luamVjdGlvbl8xID0gcmVxdWlyZShcIm5vZGUtZGVwZW5kZW5jeS1pbmplY3Rpb25cIik7XG5jb25zdCBDcmVhdGVDb21tZXJjZUNvbW1hbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ3JlYXRlQ29tbWVyY2VDb21tYW5kXCIpKTtcbmNvbnN0IEFscmVhZHlFeGlzdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vQWxyZWFkeUV4aXN0c1wiKSk7XG5jb25zdCBjb25zb2xlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjb25zb2xlXCIpKTtcbmNvbnN0IGNvbnRhaW5lciA9IG5ldyBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEuQ29udGFpbmVyQnVpbGRlcigpO1xuKDAsIGRlcGVuZGVuY2llc19kaV8xLnJlZ2lzdGVyKShjb250YWluZXIpO1xuKDAsIGRlcGVuZGVuY2llc19kaV8yLnJlZ2lzdGVyKShjb250YWluZXIpO1xuY29uc3QgbG9nZ2VyID0gY29udGFpbmVyLmdldChkZXBlbmRlbmNpZXNfZGlfMS5ERUZJTklUSU9OUy5Mb2dnZXIpLCBoYW5kbGVyQ3JlYXRvciA9IGNvbnRhaW5lci5nZXQoZGVwZW5kZW5jaWVzX2RpXzIuQ1JFQVRFX0RFRklOSVRJT05TLkhhbmRsZXIpLCBleGVjdXRlID0gYXN5bmMgKGV2ZW50LCBfY29udGV4dCkgPT4ge1xuICAgIGxvZ2dlci5pbmZvKGBSRVFVRVNUIFBBVEg6ICR7ZXZlbnQucGF0aH1gKTtcbiAgICBsb2dnZXIuaW5mbyhgUkVRVUVTVCBCT0RZOiAke2V2ZW50LmJvZHl9YCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBlbWFpbCwgZGVzY3JpcHRpb24sIGFkZHJlc3MsIGlkLCBwaG9uZSB9ID0gSlNPTi5wYXJzZShldmVudC5ib2R5KSwgY3JlYXRlQ29tbWVyY2VDb21tYW5kID0gbmV3IENyZWF0ZUNvbW1lcmNlQ29tbWFuZF8xLmRlZmF1bHQoaWQsIG5hbWUsIGVtYWlsLCBkZXNjcmlwdGlvbiwgcGhvbmUsIGFkZHJlc3MpLCBjb21tZXJjZSA9IGF3YWl0IGhhbmRsZXJDcmVhdG9yLmhhbmRsZShjcmVhdGVDb21tZXJjZUNvbW1hbmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY29tbWVyY2UuZGF0YS50b1ByaW1pdGl2ZXMoKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGUpO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFscmVhZHlFeGlzdHNfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgICAgICBib2R5OiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgICAgICAgICBib2R5OiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMuaGFuZGxlciA9ICgwLCBjb3JlXzEuZGVmYXVsdCkoZXhlY3V0ZSlcbiAgICAudXNlKCgwLCBodHRwX2NvcnNfMS5kZWZhdWx0KSgpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZJTklUSU9OUyA9IGV4cG9ydHMucmVnaXN0ZXIgPSB2b2lkIDA7XG5jb25zdCBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEgPSByZXF1aXJlKFwibm9kZS1kZXBlbmRlbmN5LWluamVjdGlvblwiKTtcbmNvbnN0IENvbW1hbmRIYW5kbGVyc0luZm9ybWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvaW5mcmEvYnVzL2NvbW1hbmQvQ29tbWFuZEhhbmRsZXJzSW5mb3JtYXRpb25cIikpO1xuY29uc3QgSW5NZW1vcnlDb21tYW5kQnVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvaW5mcmEvYnVzL2NvbW1hbmQvSW5NZW1vcnlDb21tYW5kQnVzXCIpKTtcbmNvbnN0IExvZ2dlckV2ZW50QnVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvaW5mcmEvYnVzL2V2ZW50L0xvZ2dlckV2ZW50QnVzXCIpKTtcbmNvbnN0IENvbnNvbGVMb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9pbmZyYS9Db25zb2xlTG9nZ2VyXCIpKTtcbmNvbnN0IFF1ZXJ5SGFuZGxlcnNJbmZvcm1hdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2luZnJhL2J1cy9xdWVyeS9RdWVyeUhhbmRsZXJzSW5mb3JtYXRpb25cIikpO1xuY29uc3QgSW5NZW1vcnlRdWVyeUJ1c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2luZnJhL2J1cy9xdWVyeS9Jbk1lbW9yeVF1ZXJ5QnVzXCIpKTtcbmNvbnN0IERFRklOSVRJT05TID0ge1xuICAgIExvZ2dlcjogXCJTaGFyZWQuTG9nZ2VyXCIsXG4gICAgRG9tYWluRXZlbnRNYXBwaW5nOiBcIlNoYXJlZC5Eb21haW5FdmVudE1hcHBpbmdcIixcbiAgICBRdWVyeUhhbmRsZXJzSW5mbzogXCJTaGFyZWQuUXVlcnlIYW5kbGVyc0luZm9cIixcbiAgICBDb21tYW5kSGFuZGxlcnNJbmZvOiBcIlNoYXJlZC5Db21tYW5kSGFuZGxlcnNJbmZvXCIsXG4gICAgVGFnczoge1xuICAgICAgICBFdmVudEhhbmRsZXI6IFwiRXZlbnRIYW5kbGVyXCIsXG4gICAgICAgIENvbW1hbmRIYW5kbGVyOiBcIkNvbW1hbmRIYW5kbGVyXCIsXG4gICAgICAgIFF1ZXJ5SGFuZGxlcjogXCJRdWVyeUhhbmRsZXJcIlxuICAgIH0sXG4gICAgTWVtb3J5QnVzZXM6IHtcbiAgICAgICAgQ29tbWFuZEJ1czogXCJTaGFyZWQuQ29tbWFuZEJ1c1wiLFxuICAgICAgICBRdWVyeUJ1czogXCJTaGFyZWQuUXVlcnlCdXNcIixcbiAgICAgICAgRXZlbnRCdXM6IFwiU2hhcmVkLkV2ZW50QnVzXCJcbiAgICB9XG59LCByZWdpc3RlciA9IChjb250YWluZXIpID0+IHtcbiAgICBjb250YWluZXIucmVnaXN0ZXIoREVGSU5JVElPTlMuTG9nZ2VyLCBDb25zb2xlTG9nZ2VyXzEuZGVmYXVsdCk7XG4gICAgY29udGFpbmVyXG4gICAgICAgIC5yZWdpc3RlcihERUZJTklUSU9OUy5RdWVyeUhhbmRsZXJzSW5mbywgUXVlcnlIYW5kbGVyc0luZm9ybWF0aW9uXzEuZGVmYXVsdClcbiAgICAgICAgLmFkZEFyZ3VtZW50KG5ldyBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEuVGFnUmVmZXJlbmNlKERFRklOSVRJT05TLlRhZ3MuUXVlcnlIYW5kbGVyKSk7XG4gICAgY29udGFpbmVyXG4gICAgICAgIC5yZWdpc3RlcihERUZJTklUSU9OUy5NZW1vcnlCdXNlcy5RdWVyeUJ1cywgSW5NZW1vcnlRdWVyeUJ1c18xLmRlZmF1bHQpXG4gICAgICAgIC5hZGRBcmd1bWVudChuZXcgbm9kZV9kZXBlbmRlbmN5X2luamVjdGlvbl8xLlJlZmVyZW5jZShERUZJTklUSU9OUy5RdWVyeUhhbmRsZXJzSW5mbykpO1xuICAgIGNvbnRhaW5lclxuICAgICAgICAucmVnaXN0ZXIoREVGSU5JVElPTlMuQ29tbWFuZEhhbmRsZXJzSW5mbywgQ29tbWFuZEhhbmRsZXJzSW5mb3JtYXRpb25fMS5kZWZhdWx0KVxuICAgICAgICAuYWRkQXJndW1lbnQobmV3IG5vZGVfZGVwZW5kZW5jeV9pbmplY3Rpb25fMS5UYWdSZWZlcmVuY2UoREVGSU5JVElPTlMuVGFncy5Db21tYW5kSGFuZGxlcikpO1xuICAgIGNvbnRhaW5lclxuICAgICAgICAucmVnaXN0ZXIoREVGSU5JVElPTlMuTWVtb3J5QnVzZXMuQ29tbWFuZEJ1cywgSW5NZW1vcnlDb21tYW5kQnVzXzEuZGVmYXVsdClcbiAgICAgICAgLmFkZEFyZ3VtZW50KG5ldyBub2RlX2RlcGVuZGVuY3lfaW5qZWN0aW9uXzEuUmVmZXJlbmNlKERFRklOSVRJT05TLkNvbW1hbmRIYW5kbGVyc0luZm8pKTtcbiAgICBjb250YWluZXIucmVnaXN0ZXIoREVGSU5JVElPTlMuTWVtb3J5QnVzZXMuRXZlbnRCdXMsIExvZ2dlckV2ZW50QnVzXzEuZGVmYXVsdCk7XG59O1xuZXhwb3J0cy5ERUZJTklUSU9OUyA9IERFRklOSVRJT05TO1xuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21tZXJjZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYmFja29mZmljZS1jb250ZXh0cy9jb21tZXJjZXMvZG9tYWluL0NvbW1lcmNlXCIpKTtcbmNvbnN0IEFscmVhZHlFeGlzdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vQWxyZWFkeUV4aXN0c1wiKSk7XG5jbGFzcyBDb21tZXJjZUNyZWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcG8sIGV2ZW50QnVzKSB7XG4gICAgICAgIHRoaXMucmVwbyA9IHJlcG87XG4gICAgICAgIHRoaXMuZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB9XG4gICAgYXN5bmMgcnVuKGlkLCBuYW1lLCBlbWFpbCwgZGVzY3JpcHRpb24sIHBob25lLCBhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lcmNlID0gQ29tbWVyY2VfMS5kZWZhdWx0LmNyZWF0ZShpZCwgbmFtZSwgZW1haWwsIGRlc2NyaXB0aW9uLCBwaG9uZSwgYWRkcmVzcyksIFtjb21tZXJjZUJ5RW1haWwsIGNvbW1lcmNlQnlJZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnJlcG8uZmluZEJ5RW1haWwoZW1haWwpLFxuICAgICAgICAgICAgdGhpcy5yZXBvLmZpbmRCeUlkKGlkKVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGNvbW1lcmNlQnlFbWFpbCB8fCBjb21tZXJjZUJ5SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbHJlYWR5RXhpc3RzXzEuZGVmYXVsdChcIkNvbW1lcmNlIHdpdGggaWQgXCIgKyBpZCArIFwiIG9yIGVtYWlsIFwiICsgZW1haWwgKyBcIiBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnJlcG8uc2F2ZShjb21tZXJjZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuZXZlbnRCdXMucHVibGlzaChjb21tZXJjZS5wdWxsRG9tYWluRXZlbnRzKCkpO1xuICAgICAgICByZXR1cm4gY29tbWVyY2U7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbWVyY2VDcmVhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDcmVhdGVDb21tZXJjZUNvbW1hbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ3JlYXRlQ29tbWVyY2VDb21tYW5kXCIpKTtcbmNvbnN0IENyZWF0ZUNvbW1lcmNlUmVzcG9uc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL2FwcC9jcmVhdGUvQ3JlYXRlQ29tbWVyY2VSZXNwb25zZVwiKSk7XG5jb25zdCBVdWlkVm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vVXVpZFZvXCIpKTtcbmNvbnN0IENvbW1lcmNlTmFtZVZvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9kb21haW4vQ29tbWVyY2VOYW1lVm9cIikpO1xuY29uc3QgRW1haWxWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9FbWFpbFZvXCIpKTtcbmNvbnN0IENvbW1lcmNlRGVzY3JpcHRpb25Wb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYmFja29mZmljZS1jb250ZXh0cy9jb21tZXJjZXMvZG9tYWluL0NvbW1lcmNlRGVzY3JpcHRpb25Wb1wiKSk7XG5jb25zdCBQaG9uZVZvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvZG9tYWluL1Bob25lVm9cIikpO1xuY29uc3QgQWRkcmVzc1ZvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvZG9tYWluL0FkZHJlc3NWb1wiKSk7XG5jbGFzcyBDb21tZXJjZUNyZWF0b3JIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdG9yKSB7XG4gICAgICAgIHRoaXMuY3JlYXRvciA9IGNyZWF0b3I7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZSh7IGlkLCBkZXNjcmlwdGlvbiwgZW1haWwsIHBob25lLCBuYW1lLCBhZGRyZXNzIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNyZWF0b3IucnVuKG5ldyBVdWlkVm9fMS5kZWZhdWx0KGlkKSwgbmV3IENvbW1lcmNlTmFtZVZvXzEuZGVmYXVsdChuYW1lKSwgbmV3IEVtYWlsVm9fMS5kZWZhdWx0KGVtYWlsKSwgbmV3IENvbW1lcmNlRGVzY3JpcHRpb25Wb18xLmRlZmF1bHQoZGVzY3JpcHRpb24pLCBuZXcgUGhvbmVWb18xLmRlZmF1bHQocGhvbmUpLCBuZXcgQWRkcmVzc1ZvXzEuZGVmYXVsdChhZGRyZXNzKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ3JlYXRlQ29tbWVyY2VSZXNwb25zZV8xLmRlZmF1bHQocmVzcG9uc2UpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVkVG8oKSB7XG4gICAgICAgIHJldHVybiBDcmVhdGVDb21tZXJjZUNvbW1hbmRfMS5kZWZhdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbW1lcmNlQ3JlYXRvckhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENyZWF0ZUNvbW1lcmNlQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoaWQsIG5hbWUsIGVtYWlsLCBkZXNjcmlwdGlvbiwgcGhvbmUsIGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmVtYWlsID0gZW1haWw7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5waG9uZSA9IHBob25lO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENyZWF0ZUNvbW1lcmNlQ29tbWFuZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tbWFuZFJlc3BvbnNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvZG9tYWluL2J1cy9jb21tYW5kL0NvbW1hbmRSZXNwb25zZVwiKSk7XG5jbGFzcyBDcmVhdGVDb21tZXJjZVJlc3BvbnNlIGV4dGVuZHMgQ29tbWFuZFJlc3BvbnNlXzEuZGVmYXVsdCB7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDcmVhdGVDb21tZXJjZVJlc3BvbnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBZ2dyZWdhdGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vQWdncmVnYXRlXCIpKTtcbmNvbnN0IFV1aWRWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9VdWlkVm9cIikpO1xuY29uc3QgUGhvbmVWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9QaG9uZVZvXCIpKTtcbmNvbnN0IENvbW1lcmNlTmFtZVZvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9kb21haW4vQ29tbWVyY2VOYW1lVm9cIikpO1xuY29uc3QgRW1haWxWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9FbWFpbFZvXCIpKTtcbmNvbnN0IENvbW1lcmNlRGVzY3JpcHRpb25Wb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYmFja29mZmljZS1jb250ZXh0cy9jb21tZXJjZXMvZG9tYWluL0NvbW1lcmNlRGVzY3JpcHRpb25Wb1wiKSk7XG5jb25zdCBBZGRyZXNzVm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vQWRkcmVzc1ZvXCIpKTtcbmNvbnN0IENvbW1lcmNlQ3JlYXRlZEV2ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBiYWNrb2ZmaWNlLWNvbnRleHRzL2NvbW1lcmNlcy9kb21haW4vQ29tbWVyY2VDcmVhdGVkRXZlbnRcIikpO1xuY2xhc3MgQ29tbWVyY2UgZXh0ZW5kcyBBZ2dyZWdhdGVfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbmFtZSwgZW1haWwsIGRlc2NyaXB0aW9uLCBwaG9uZSwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZW1haWwgPSBlbWFpbDtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnBob25lID0gcGhvbmU7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoaWQsIG5hbWUsIGVtYWlsLCBkZXNjcmlwdGlvbiwgcGhvbmUsIGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgY29tbWVyY2UgPSBuZXcgQ29tbWVyY2UoaWQsIG5hbWUsIGVtYWlsLCBkZXNjcmlwdGlvbiwgcGhvbmUsIGFkZHJlc3MpO1xuICAgICAgICBjb21tZXJjZS5yZWNvcmQobmV3IENvbW1lcmNlQ3JlYXRlZEV2ZW50XzEuZGVmYXVsdChjb21tZXJjZS50b1ByaW1pdGl2ZXMoKSkpO1xuICAgICAgICByZXR1cm4gY29tbWVyY2U7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpbWl0aXZlcyh7IGFkZHJlc3MsIHBob25lLCBuYW1lLCBkZXNjcmlwdGlvbiwgaWQsIGVtYWlsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21tZXJjZShuZXcgVXVpZFZvXzEuZGVmYXVsdChpZCksIG5ldyBDb21tZXJjZU5hbWVWb18xLmRlZmF1bHQobmFtZSksIG5ldyBFbWFpbFZvXzEuZGVmYXVsdChlbWFpbCksIG5ldyBDb21tZXJjZURlc2NyaXB0aW9uVm9fMS5kZWZhdWx0KGRlc2NyaXB0aW9uKSwgbmV3IFBob25lVm9fMS5kZWZhdWx0KHBob25lKSwgbmV3IEFkZHJlc3NWb18xLmRlZmF1bHQoYWRkcmVzcykpO1xuICAgIH1cbiAgICB0b1ByaW1pdGl2ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZC52YWx1ZSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZS52YWx1ZSxcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLnZhbHVlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24udmFsdWUsXG4gICAgICAgICAgICBwaG9uZTogdGhpcy5waG9uZS52YWx1ZSxcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcy52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tZXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRG9tYWluRXZlbnRfMSA9IHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9idXMvZXZlbnQvRG9tYWluRXZlbnRcIik7XG5jbGFzcyBDb21tZXJjZUNyZWF0ZWRFdmVudCBleHRlbmRzIERvbWFpbkV2ZW50XzEuRG9tYWluRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJvZHkpIHtcbiAgICAgICAgc3VwZXIoQ29tbWVyY2VDcmVhdGVkRXZlbnQuRVZFTlRfTkFNRSwgYm9keS5pZCk7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHRvUHJpbWl0aXZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tZXJjZUNyZWF0ZWRFdmVudDtcbkNvbW1lcmNlQ3JlYXRlZEV2ZW50LkVWRU5UX05BTUUgPSAnYmFja29mZmljZS5jb21tZXJjZXMuQ29tbWVyY2VDcmVhdGVkRXZlbnQnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9TdHJpbmdWb1wiKSk7XG5jbGFzcyBDb21tZXJjZURlc2NyaXB0aW9uVm8gZXh0ZW5kcyBTdHJpbmdWb18xLmRlZmF1bHQge1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbWVyY2VEZXNjcmlwdGlvblZvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9TdHJpbmdWb1wiKSk7XG5jbGFzcyBDb21tZXJjZU5hbWVWbyBleHRlbmRzIFN0cmluZ1ZvXzEuZGVmYXVsdCB7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tZXJjZU5hbWVWbztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tbWVyY2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGJhY2tvZmZpY2UtY29udGV4dHMvY29tbWVyY2VzL2RvbWFpbi9Db21tZXJjZVwiKSk7XG5jb25zdCBjb21wb3NlS2V5ID0gKGlkKSA9PiBcImNvbW1lcmNlOlwiICsgaWQudG9TdHJpbmcoKTtcbmNsYXNzIER5bmFtb0NvbW1lcmNlUmVwb3NpdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCB0YWJsZU5hbWUsIGVtYWlsSW5kZXgpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgICAgICB0aGlzLmVtYWlsSW5kZXggPSBlbWFpbEluZGV4O1xuICAgIH1cbiAgICBhc3luYyBmaW5kQnlFbWFpbChlbWFpbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNsaWVudC5xdWVyeSh7XG4gICAgICAgICAgICBUYWJsZU5hbWU6IHRoaXMudGFibGVOYW1lLFxuICAgICAgICAgICAgSW5kZXhOYW1lOiB0aGlzLmVtYWlsSW5kZXgsXG4gICAgICAgICAgICBLZXlDb25kaXRpb25FeHByZXNzaW9uOiBcImVtYWlsID0gOmVtYWlsXCIsXG4gICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgXCI6ZW1haWxcIjogZW1haWwudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5wcm9taXNlKCk7XG4gICAgICAgIHJldHVybiAoKF9hID0gcmVzcC5JdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPyBDb21tZXJjZV8xLmRlZmF1bHQuZnJvbVByaW1pdGl2ZXMoT2JqZWN0LmFzc2lnbih7fSwgcmVzcC5JdGVtc1swXSkpIDogbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZEJ5SWQoaWQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gY29tcG9zZUtleShpZCksIHJlc3AgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXQoe1xuICAgICAgICAgICAgVGFibGVOYW1lOiB0aGlzLnRhYmxlTmFtZSxcbiAgICAgICAgICAgIEtleToge1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbktleToga2V5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucHJvbWlzZSgpO1xuICAgICAgICByZXR1cm4gcmVzcC5JdGVtID8gQ29tbWVyY2VfMS5kZWZhdWx0LmZyb21QcmltaXRpdmVzKE9iamVjdC5hc3NpZ24oe30sIHJlc3AuSXRlbSkpIDogbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc2F2ZShjb21tZXJjZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBjb21wb3NlS2V5KGNvbW1lcmNlLmlkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQucHV0KHtcbiAgICAgICAgICAgIFRhYmxlTmFtZTogdGhpcy50YWJsZU5hbWUsXG4gICAgICAgICAgICBJdGVtOiBPYmplY3QuYXNzaWduKHsgcGFydGl0aW9uS2V5OiBrZXkgfSwgY29tbWVyY2UudG9QcmltaXRpdmVzKCkpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucHJvbWlzZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IER5bmFtb0NvbW1lcmNlUmVwb3NpdG9yeTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nVm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vU3RyaW5nVm9cIikpO1xuY2xhc3MgQWRkcmVzc1ZvIGV4dGVuZHMgU3RyaW5nVm9fMS5kZWZhdWx0IHtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFkZHJlc3NWbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQWdncmVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kb21haW5FdmVudHMgPSBbXTtcbiAgICB9XG4gICAgcHVsbERvbWFpbkV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5kb21haW5FdmVudHM7XG4gICAgICAgIHRoaXMuZG9tYWluRXZlbnRzID0gW107XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfVxuICAgIHJlY29yZChldmVudCkge1xuICAgICAgICB0aGlzLmRvbWFpbkV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBZ2dyZWdhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEFscmVhZHlFeGlzdHMgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBbHJlYWR5RXhpc3RzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9TdHJpbmdWb1wiKSk7XG5jbGFzcyBFbWFpbFZvIGV4dGVuZHMgU3RyaW5nVm9fMS5kZWZhdWx0IHtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEVtYWlsVm87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gSW52YWxpZEFyZ3VtZW50RXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ1ZvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvZG9tYWluL1N0cmluZ1ZvXCIpKTtcbmNsYXNzIFBob25lVm8gZXh0ZW5kcyBTdHJpbmdWb18xLmRlZmF1bHQge1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGhvbmVWbztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVmFsdWVPYmplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vVmFsdWVPYmplY3RcIikpO1xuY2xhc3MgU3RyaW5nVm8gZXh0ZW5kcyBWYWx1ZU9iamVjdF8xLmRlZmF1bHQge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmluZ1ZvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBJbnZhbGlkQXJndW1lbnRFcnJvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9JbnZhbGlkQXJndW1lbnRFcnJvclwiKSk7XG5jb25zdCBTdHJpbmdWb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc2hhcmVkL2RvbWFpbi9TdHJpbmdWb1wiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IHV1aWRfdmFsaWRhdGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXVpZC12YWxpZGF0ZVwiKSk7XG5jbGFzcyBVdWlkVm8gZXh0ZW5kcyBTdHJpbmdWb18xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIFV1aWRWby5lbnN1cmVJc1ZhbGlkVXVpZCh2YWx1ZSk7XG4gICAgICAgIHN1cGVyKHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVdWlkVm8oKDAsIHV1aWRfMS52NCkoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBlbnN1cmVJc1ZhbGlkVXVpZChpZCkge1xuICAgICAgICBpZiAoISgwLCB1dWlkX3ZhbGlkYXRlXzEuZGVmYXVsdCkoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3JfMS5kZWZhdWx0KGA8JHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9PiBkb2VzIG5vdCBhbGxvdyB0aGUgdmFsdWUgPCR7aWR9PmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxdWFsc1RvKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lcXVhbHNUbyhvdGhlcik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVXVpZFZvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBWYWx1ZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcXVhbHNUbyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdmFsdWUudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVmFsdWVPYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvbW1hbmROb3RSZWdpc3RlcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZCkge1xuICAgICAgICBzdXBlcihgVGhlIGNvbW1hbmQgPCR7Y29tbWFuZC5jb25zdHJ1Y3Rvci5uYW1lfT4gaGFzbid0IGEgY29tbWFuZCBoYW5kbGVyIGFzc29jaWF0ZWRgKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tYW5kTm90UmVnaXN0ZXJlZEVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDb21tYW5kUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tYW5kUmVzcG9uc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9tYWluRXZlbnQgPSB2b2lkIDA7XG5jb25zdCBVdWlkVm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vVXVpZFZvXCIpKTtcbmNsYXNzIERvbWFpbkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihldmVudE5hbWUsIGFnZ3JlZ2F0ZUlkLCBldmVudElkLCBvY2N1cnJlZE9uKSB7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlSWQgPSBhZ2dyZWdhdGVJZDtcbiAgICAgICAgdGhpcy5ldmVudElkID0gZXZlbnRJZCB8fCBVdWlkVm9fMS5kZWZhdWx0LnJhbmRvbSgpLnZhbHVlO1xuICAgICAgICB0aGlzLm9jY3VycmVkT24gPSBvY2N1cnJlZE9uIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgIH1cbn1cbmV4cG9ydHMuRG9tYWluRXZlbnQgPSBEb21haW5FdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUXVlcnlOb3RSZWdpc3RlcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocXVlcnkpIHtcbiAgICAgICAgc3VwZXIoYFRoZSBxdWVyeSA8JHtxdWVyeS5jb25zdHJ1Y3Rvci5uYW1lfT4gaGFzbid0IGEgcXVlcnkgaGFuZGxlciBhc3NvY2lhdGVkYCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnlOb3RSZWdpc3RlcmVkRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvbnNvbGVMb2dnZXIge1xuICAgIGRlYnVnKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpbmZvKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnNvbGVMb2dnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbW1hbmROb3RSZWdpc3RlcmVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzaGFyZWQvZG9tYWluL2J1cy9jb21tYW5kL0NvbW1hbmROb3RSZWdpc3RlcmVkXCIpKTtcbmNsYXNzIENvbW1hbmRIYW5kbGVyc0luZm9ybWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kSGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kSGFuZGxlcnNNYXAgPSB0aGlzLmZvcm1hdEhhbmRsZXJzKGNvbW1hbmRIYW5kbGVycyk7XG4gICAgfVxuICAgIHNlYXJjaChjb21tYW5kKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRIYW5kbGVyID0gdGhpcy5jb21tYW5kSGFuZGxlcnNNYXAuZ2V0KGNvbW1hbmQuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIWNvbW1hbmRIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tbWFuZE5vdFJlZ2lzdGVyZWRfMS5kZWZhdWx0KGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kSGFuZGxlcjtcbiAgICB9XG4gICAgZm9ybWF0SGFuZGxlcnMoY29tbWFuZEhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb21tYW5kSGFuZGxlcnMuZm9yRWFjaCgoY29tbWFuZEhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJzTWFwLnNldChjb21tYW5kSGFuZGxlci5zdWJzY3JpYmVkVG8oKSwgY29tbWFuZEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzTWFwO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbW1hbmRIYW5kbGVyc0luZm9ybWF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBJbk1lbW9yeUNvbW1hbmRCdXMge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRIYW5kbGVyc0luZm9ybWF0aW9uKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZEhhbmRsZXJzSW5mb3JtYXRpb24gPSBjb21tYW5kSGFuZGxlcnNJbmZvcm1hdGlvbjtcbiAgICB9XG4gICAgZGlzcGF0Y2goY29tbWFuZCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5jb21tYW5kSGFuZGxlcnNJbmZvcm1hdGlvbi5zZWFyY2goY29tbWFuZCk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmhhbmRsZShjb21tYW5kKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBJbk1lbW9yeUNvbW1hbmRCdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIExvZ2dlckV2ZW50QnVzIHtcbiAgICBhc3luYyBwdWJsaXNoKGV2ZW50cykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2ZW50cyB0byBiZSBwdWJsaXNoZWQ6XCIgKyBKU09OLnN0cmluZ2lmeShldmVudHMpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dnZXJFdmVudEJ1cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgSW5NZW1vcnlRdWVyeUJ1cyB7XG4gICAgY29uc3RydWN0b3IocXVlcnlIYW5kbGVyc0luZm9ybWF0aW9uKSB7XG4gICAgICAgIHRoaXMucXVlcnlIYW5kbGVyc0luZm9ybWF0aW9uID0gcXVlcnlIYW5kbGVyc0luZm9ybWF0aW9uO1xuICAgIH1cbiAgICBhc2socXVlcnkpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucXVlcnlIYW5kbGVyc0luZm9ybWF0aW9uLnNlYXJjaChxdWVyeSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmhhbmRsZShxdWVyeSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSW5NZW1vcnlRdWVyeUJ1cztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUXVlcnlOb3RSZWdpc3RlcmVkRXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHNoYXJlZC9kb21haW4vYnVzL3F1ZXJ5L1F1ZXJ5Tm90UmVnaXN0ZXJlZEVycm9yXCIpKTtcbmNsYXNzIFF1ZXJ5SGFuZGxlcnNJbmZvcm1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IocXVlcnlIYW5kbGVycykge1xuICAgICAgICB0aGlzLnF1ZXJ5SGFuZGxlcnNNYXAgPSB0aGlzLmZvcm1hdEhhbmRsZXJzKHF1ZXJ5SGFuZGxlcnMpO1xuICAgIH1cbiAgICBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlIYW5kbGVyID0gdGhpcy5xdWVyeUhhbmRsZXJzTWFwLmdldChxdWVyeS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghcXVlcnlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUXVlcnlOb3RSZWdpc3RlcmVkRXJyb3JfMS5kZWZhdWx0KHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnlIYW5kbGVyO1xuICAgIH1cbiAgICBmb3JtYXRIYW5kbGVycyhxdWVyeUhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBxdWVyeUhhbmRsZXJzLmZvckVhY2goKHF1ZXJ5SGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaGFuZGxlcnNNYXAuc2V0KHF1ZXJ5SGFuZGxlci5zdWJzY3JpYmVkVG8oKSwgcXVlcnlIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyc01hcDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeUhhbmRsZXJzSW5mb3JtYXRpb247XG4iLCIvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBmb3IgYmFzaWMgcGFyc2luZyBvZiB0aGUgdXVpZC5cbnZhciBwYXR0ZXJuID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaTtcblxuLyoqXG4gKiBVbnBhcnNlcyBhIFVVSUQgYnVmZmVyIHRvIGEgc3RyaW5nLiBGcm9tIG5vZGUtdXVpZDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtdXVpZC9ibG9iL21hc3Rlci91dWlkLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbiAqIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmXG4gKiBAcGFyYW0gIHtOdW1iZXI9MH0gb2Zmc2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBfYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB1dWlkIGlzIHZhbGlkLCBjb252ZXJ0aW5nXG4gKiBpdCBmcm9tIGEgYnVmZmVyIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8QnVmZmVyfSAgdXVpZFxuICogQHBhcmFtICB7TnVtYmVyPX0gIHZlcnNpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHV1aWQsIHZlcnNpb24pIHtcbiAgICB2YXIgcGFyc2VkVXVpZDtcbiAgICAvLyBJZiB0aGUgdXVpZCBpcyBhIGJpZmZlciwgcGFyc2UgaXQuLi5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHV1aWQpKSB7XG4gICAgICAgIHBhcnNlZFV1aWQgPSB1bnBhcnNlKHV1aWQpO1xuICAgIH1cbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nLCBpdCdzIGFscmVhZHkgZ29vZC5cbiAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodXVpZCkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgIHBhcnNlZFV1aWQgPSB1dWlkO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGl0J3Mgbm90IHZhbGlkLlxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyc2VkVXVpZCA9IHBhcnNlZFV1aWQudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEFsbCBVVUlEcyBmaXQgYSBiYXNpYyBzY2hlbWEuIE1hdGNoIHRoYXQuXG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QocGFyc2VkVXVpZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE5vdyBleHRyYWN0IHRoZSB2ZXJzaW9uLi4uXG4gICAgaWYgKHZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24ocGFyc2VkVXVpZCk7XG4gICAgfSBlbHNlIGlmIChleHRyYWN0VmVyc2lvbihwYXJzZWRVdWlkKSAhPT0gdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgIC8vIEZvciBjZXJ0YWluIHZlcnNpb25zLCB0aGUgY2hlY2tzIHdlIGRpZCB1cCB0byB0aGlzIHBvaW50IGFyZSBmaW5lLlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIEZvciB2ZXJzaW9ucyAzIGFuZCA0LCB0aGV5IG11c3Qgc3BlY2lmeSBhIHZhcmlhbnQuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gWyc4JywgJzknLCAnYScsICdiJ10uaW5kZXhPZihwYXJzZWRVdWlkLmNoYXJBdCgxOSkpICE9PSAtMTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgYmUgYWJsZSB0byByZWFjaCB0aGlzIGlmIHRoZSBjb25zdW1lciBleHBsaWNpdGx5XG4gICAgICAgICAgICAvLyBwcm92aWRlZCBhbiBpbnZhbGlkIHZlcnNpb24uIFByaW9yIHRvIGV4dHJhY3RWZXJzaW9uIHdlIGNoZWNrXG4gICAgICAgICAgICAvLyB0aGF0IGl0J3MgMS00IGluIHRoZSByZWdleC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uIHByb3ZpZGVkLicpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIHZlcnNpb24gZnJvbSB0aGUgVVVJRCwgd2hpY2ggaXMgKGJ5IGRlZmluaXRpb24pIHRoZSBNIGluXG4gKiB4eHh4eHh4eC14eHh4LU14eHgtTnh4eC14eHh4eHh4eHh4eHhcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHV1aWRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGV4dHJhY3RWZXJzaW9uID0gbW9kdWxlLmV4cG9ydHMudmVyc2lvbiA9IGZ1bmN0aW9uICh1dWlkKSB7XG4gICAgcmV0dXJuIHV1aWQuY2hhckF0KDE0KXwwO1xufTtcbiIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW1xuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXG4gIF0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIG5vZGUuanNcbi8vIHRoaXMgaXMgcHJldHR5IHN0cmFpZ2h0LWZvcndhcmQgLSB3ZSB1c2UgdGhlIGNyeXB0byBBUEkuXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub2RlUk5HKCkge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbn07XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xudmFyIF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBzY29wZWRQYWNrYWdlUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oPzpAKFteL10rPylbL10pPyhbXi9dKz8pJCcpXG52YXIgYnVpbHRpbnMgPSByZXF1aXJlKCdidWlsdGlucycpXG52YXIgYmxhY2tsaXN0ID0gW1xuICAnbm9kZV9tb2R1bGVzJyxcbiAgJ2Zhdmljb24uaWNvJ1xuXVxuXG52YXIgdmFsaWRhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciB3YXJuaW5ncyA9IFtdXG4gIHZhciBlcnJvcnMgPSBbXVxuXG4gIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgZXJyb3JzLnB1c2goJ25hbWUgY2Fubm90IGJlIG51bGwnKVxuICAgIHJldHVybiBkb25lKHdhcm5pbmdzLCBlcnJvcnMpXG4gIH1cblxuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyb3JzLnB1c2goJ25hbWUgY2Fubm90IGJlIHVuZGVmaW5lZCcpXG4gICAgcmV0dXJuIGRvbmUod2FybmluZ3MsIGVycm9ycylcbiAgfVxuXG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBlcnJvcnMucHVzaCgnbmFtZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICByZXR1cm4gZG9uZSh3YXJuaW5ncywgZXJyb3JzKVxuICB9XG5cbiAgaWYgKCFuYW1lLmxlbmd0aCkge1xuICAgIGVycm9ycy5wdXNoKCduYW1lIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJylcbiAgfVxuXG4gIGlmIChuYW1lLm1hdGNoKC9eXFwuLykpIHtcbiAgICBlcnJvcnMucHVzaCgnbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCBhIHBlcmlvZCcpXG4gIH1cblxuICBpZiAobmFtZS5tYXRjaCgvXl8vKSkge1xuICAgIGVycm9ycy5wdXNoKCduYW1lIGNhbm5vdCBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUnKVxuICB9XG5cbiAgaWYgKG5hbWUudHJpbSgpICE9PSBuYW1lKSB7XG4gICAgZXJyb3JzLnB1c2goJ25hbWUgY2Fubm90IGNvbnRhaW4gbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMnKVxuICB9XG5cbiAgLy8gTm8gZnVubnkgYnVzaW5lc3NcbiAgYmxhY2tsaXN0LmZvckVhY2goZnVuY3Rpb24gKGJsYWNrbGlzdGVkTmFtZSkge1xuICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09IGJsYWNrbGlzdGVkTmFtZSkge1xuICAgICAgZXJyb3JzLnB1c2goYmxhY2tsaXN0ZWROYW1lICsgJyBpcyBhIGJsYWNrbGlzdGVkIG5hbWUnKVxuICAgIH1cbiAgfSlcblxuICAvLyBHZW5lcmF0ZSB3YXJuaW5ncyBmb3Igc3R1ZmYgdGhhdCB1c2VkIHRvIGJlIGFsbG93ZWRcblxuICAvLyBjb3JlIG1vZHVsZSBuYW1lcyBsaWtlIGh0dHAsIGV2ZW50cywgdXRpbCwgZXRjXG4gIGJ1aWx0aW5zLmZvckVhY2goZnVuY3Rpb24gKGJ1aWx0aW4pIHtcbiAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSBidWlsdGluKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGJ1aWx0aW4gKyAnIGlzIGEgY29yZSBtb2R1bGUgbmFtZScpXG4gICAgfVxuICB9KVxuXG4gIC8vIHJlYWxseS1sb25nLXBhY2thZ2UtbmFtZXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tc3VjaC0tbGVuZ3RoLS0tLS1tYW55LS0td293XG4gIC8vIHRoZSB0aGlzaXNhcmVhbGx5cmVhbGx5bG9uZ3BhY2thZ2VuYW1laXRzaG91bGRwdWJsaXNoZG93ZW5vd2hhdmVhbGltaXR0b3RoZWxlbmd0aG9mcGFja2FnZW5hbWVzLXBvY2guXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIxNCkge1xuICAgIHdhcm5pbmdzLnB1c2goJ25hbWUgY2FuIG5vIGxvbmdlciBjb250YWluIG1vcmUgdGhhbiAyMTQgY2hhcmFjdGVycycpXG4gIH1cblxuICAvLyBtSXhlRCBDYVNlIG5BTUVzXG4gIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgIT09IG5hbWUpIHtcbiAgICB3YXJuaW5ncy5wdXNoKCduYW1lIGNhbiBubyBsb25nZXIgY29udGFpbiBjYXBpdGFsIGxldHRlcnMnKVxuICB9XG5cbiAgaWYgKC9bfichKCkqXS8udGVzdChuYW1lLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdKSkge1xuICAgIHdhcm5pbmdzLnB1c2goJ25hbWUgY2FuIG5vIGxvbmdlciBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycyAoXCJ+XFwnISgpKlwiKScpXG4gIH1cblxuICBpZiAoZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICE9PSBuYW1lKSB7XG4gICAgLy8gTWF5YmUgaXQncyBhIHNjb3BlZCBwYWNrYWdlIG5hbWUsIGxpa2UgQHVzZXIvcGFja2FnZVxuICAgIHZhciBuYW1lTWF0Y2ggPSBuYW1lLm1hdGNoKHNjb3BlZFBhY2thZ2VQYXR0ZXJuKVxuICAgIGlmIChuYW1lTWF0Y2gpIHtcbiAgICAgIHZhciB1c2VyID0gbmFtZU1hdGNoWzFdXG4gICAgICB2YXIgcGtnID0gbmFtZU1hdGNoWzJdXG4gICAgICBpZiAoZW5jb2RlVVJJQ29tcG9uZW50KHVzZXIpID09PSB1c2VyICYmIGVuY29kZVVSSUNvbXBvbmVudChwa2cpID09PSBwa2cpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUod2FybmluZ3MsIGVycm9ycylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlcnJvcnMucHVzaCgnbmFtZSBjYW4gb25seSBjb250YWluIFVSTC1mcmllbmRseSBjaGFyYWN0ZXJzJylcbiAgfVxuXG4gIHJldHVybiBkb25lKHdhcm5pbmdzLCBlcnJvcnMpXG59XG5cbnZhbGlkYXRlLnNjb3BlZFBhY2thZ2VQYXR0ZXJuID0gc2NvcGVkUGFja2FnZVBhdHRlcm5cblxudmFyIGRvbmUgPSBmdW5jdGlvbiAod2FybmluZ3MsIGVycm9ycykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHZhbGlkRm9yTmV3UGFja2FnZXM6IGVycm9ycy5sZW5ndGggPT09IDAgJiYgd2FybmluZ3MubGVuZ3RoID09PSAwLFxuICAgIHZhbGlkRm9yT2xkUGFja2FnZXM6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH1cbiAgaWYgKCFyZXN1bHQud2FybmluZ3MubGVuZ3RoKSBkZWxldGUgcmVzdWx0Lndhcm5pbmdzXG4gIGlmICghcmVzdWx0LmVycm9ycy5sZW5ndGgpIGRlbGV0ZSByZXN1bHQuZXJyb3JzXG4gIHJldHVybiByZXN1bHRcbn1cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBleHBvcnRzLnN0cmlwQk9NID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKHN0clswXSA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIGJ1aWxkZXIsIGRlZmF1bHRzLCBlc2NhcGVDREFUQSwgcmVxdWlyZXNDREFUQSwgd3JhcENEQVRBLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBidWlsZGVyID0gcmVxdWlyZSgneG1sYnVpbGRlcicpO1xuXG4gIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpLmRlZmF1bHRzO1xuXG4gIHJlcXVpcmVzQ0RBVEEgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgJiYgKGVudHJ5LmluZGV4T2YoJyYnKSA+PSAwIHx8IGVudHJ5LmluZGV4T2YoJz4nKSA+PSAwIHx8IGVudHJ5LmluZGV4T2YoJzwnKSA+PSAwKTtcbiAgfTtcblxuICB3cmFwQ0RBVEEgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBcIjwhW0NEQVRBW1wiICsgKGVzY2FwZUNEQVRBKGVudHJ5KSkgKyBcIl1dPlwiO1xuICB9O1xuXG4gIGVzY2FwZUNEQVRBID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkucmVwbGFjZSgnXV0+JywgJ11dXV0+PCFbQ0RBVEFbPicpO1xuICB9O1xuXG4gIGV4cG9ydHMuQnVpbGRlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBCdWlsZGVyKG9wdHMpIHtcbiAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHJlZiA9IGRlZmF1bHRzW1wiMC4yXCJdO1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBvcHRzKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9wdHMsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IG9wdHNba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBCdWlsZGVyLnByb3RvdHlwZS5idWlsZE9iamVjdCA9IGZ1bmN0aW9uKHJvb3RPYmopIHtcbiAgICAgIHZhciBhdHRya2V5LCBjaGFya2V5LCByZW5kZXIsIHJvb3RFbGVtZW50LCByb290TmFtZTtcbiAgICAgIGF0dHJrZXkgPSB0aGlzLm9wdGlvbnMuYXR0cmtleTtcbiAgICAgIGNoYXJrZXkgPSB0aGlzLm9wdGlvbnMuY2hhcmtleTtcbiAgICAgIGlmICgoT2JqZWN0LmtleXMocm9vdE9iaikubGVuZ3RoID09PSAxKSAmJiAodGhpcy5vcHRpb25zLnJvb3ROYW1lID09PSBkZWZhdWx0c1snMC4yJ10ucm9vdE5hbWUpKSB7XG4gICAgICAgIHJvb3ROYW1lID0gT2JqZWN0LmtleXMocm9vdE9iailbMF07XG4gICAgICAgIHJvb3RPYmogPSByb290T2JqW3Jvb3ROYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3ROYW1lID0gdGhpcy5vcHRpb25zLnJvb3ROYW1lO1xuICAgICAgfVxuICAgICAgcmVuZGVyID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBvYmopIHtcbiAgICAgICAgICB2YXIgYXR0ciwgY2hpbGQsIGVudHJ5LCBpbmRleCwga2V5LCB2YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNkYXRhICYmIHJlcXVpcmVzQ0RBVEEob2JqKSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJhdyh3cmFwQ0RBVEEob2JqKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnR4dChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKGluZGV4IGluIG9iaikge1xuICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChvYmosIGluZGV4KSkgY29udGludWU7XG4gICAgICAgICAgICAgIGNoaWxkID0gb2JqW2luZGV4XTtcbiAgICAgICAgICAgICAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IGNoaWxkW2tleV07XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHJlbmRlcihlbGVtZW50LmVsZShrZXkpLCBlbnRyeSkudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2hpbGQgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gYXR0cmtleSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoYXR0ciBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoaWxkW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5hdHQoYXR0ciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGNoYXJrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jZGF0YSAmJiByZXF1aXJlc0NEQVRBKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmF3KHdyYXBDREFUQShjaGlsZCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC50eHQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKGNoaWxkLCBpbmRleCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgZW50cnkgPSBjaGlsZFtpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jZGF0YSAmJiByZXF1aXJlc0NEQVRBKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXkpLnJhdyh3cmFwQ0RBVEEoZW50cnkpKS51cCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXksIGVudHJ5KS51cCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVuZGVyKGVsZW1lbnQuZWxlKGtleSksIGVudHJ5KS51cCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVuZGVyKGVsZW1lbnQuZWxlKGtleSksIGNoaWxkKS51cCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnICYmIF90aGlzLm9wdGlvbnMuY2RhdGEgJiYgcmVxdWlyZXNDREFUQShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXkpLnJhdyh3cmFwQ0RBVEEoY2hpbGQpKS51cCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlKGtleSwgY2hpbGQudG9TdHJpbmcoKSkudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHJvb3RFbGVtZW50ID0gYnVpbGRlci5jcmVhdGUocm9vdE5hbWUsIHRoaXMub3B0aW9ucy54bWxkZWMsIHRoaXMub3B0aW9ucy5kb2N0eXBlLCB7XG4gICAgICAgIGhlYWRsZXNzOiB0aGlzLm9wdGlvbnMuaGVhZGxlc3MsXG4gICAgICAgIGFsbG93U3Vycm9nYXRlQ2hhcnM6IHRoaXMub3B0aW9ucy5hbGxvd1N1cnJvZ2F0ZUNoYXJzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZW5kZXIocm9vdEVsZW1lbnQsIHJvb3RPYmopLmVuZCh0aGlzLm9wdGlvbnMucmVuZGVyT3B0cyk7XG4gICAgfTtcblxuICAgIHJldHVybiBCdWlsZGVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIFwiMC4xXCI6IHtcbiAgICAgIGV4cGxpY2l0Q2hhcmtleTogZmFsc2UsXG4gICAgICB0cmltOiB0cnVlLFxuICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICAgICAgbm9ybWFsaXplVGFnczogZmFsc2UsXG4gICAgICBhdHRya2V5OiBcIkBcIixcbiAgICAgIGNoYXJrZXk6IFwiI1wiLFxuICAgICAgZXhwbGljaXRBcnJheTogZmFsc2UsXG4gICAgICBpZ25vcmVBdHRyczogZmFsc2UsXG4gICAgICBtZXJnZUF0dHJzOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Um9vdDogZmFsc2UsXG4gICAgICB2YWxpZGF0b3I6IG51bGwsXG4gICAgICB4bWxuczogZmFsc2UsXG4gICAgICBleHBsaWNpdENoaWxkcmVuOiBmYWxzZSxcbiAgICAgIGNoaWxka2V5OiAnQEAnLFxuICAgICAgY2hhcnNBc0NoaWxkcmVuOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVXaGl0ZUNoYXJzOiBmYWxzZSxcbiAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGF0dHJOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIGF0dHJWYWx1ZVByb2Nlc3NvcnM6IG51bGwsXG4gICAgICB0YWdOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIGVtcHR5VGFnOiAnJ1xuICAgIH0sXG4gICAgXCIwLjJcIjoge1xuICAgICAgZXhwbGljaXRDaGFya2V5OiBmYWxzZSxcbiAgICAgIHRyaW06IGZhbHNlLFxuICAgICAgbm9ybWFsaXplOiBmYWxzZSxcbiAgICAgIG5vcm1hbGl6ZVRhZ3M6IGZhbHNlLFxuICAgICAgYXR0cmtleTogXCIkXCIsXG4gICAgICBjaGFya2V5OiBcIl9cIixcbiAgICAgIGV4cGxpY2l0QXJyYXk6IHRydWUsXG4gICAgICBpZ25vcmVBdHRyczogZmFsc2UsXG4gICAgICBtZXJnZUF0dHJzOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Um9vdDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRvcjogbnVsbCxcbiAgICAgIHhtbG5zOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Q2hpbGRyZW46IGZhbHNlLFxuICAgICAgcHJlc2VydmVDaGlsZHJlbk9yZGVyOiBmYWxzZSxcbiAgICAgIGNoaWxka2V5OiAnJCQnLFxuICAgICAgY2hhcnNBc0NoaWxkcmVuOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVXaGl0ZUNoYXJzOiBmYWxzZSxcbiAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGF0dHJOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIGF0dHJWYWx1ZVByb2Nlc3NvcnM6IG51bGwsXG4gICAgICB0YWdOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHJvb3ROYW1lOiAncm9vdCcsXG4gICAgICB4bWxkZWM6IHtcbiAgICAgICAgJ3ZlcnNpb24nOiAnMS4wJyxcbiAgICAgICAgJ2VuY29kaW5nJzogJ1VURi04JyxcbiAgICAgICAgJ3N0YW5kYWxvbmUnOiB0cnVlXG4gICAgICB9LFxuICAgICAgZG9jdHlwZTogbnVsbCxcbiAgICAgIHJlbmRlck9wdHM6IHtcbiAgICAgICAgJ3ByZXR0eSc6IHRydWUsXG4gICAgICAgICdpbmRlbnQnOiAnICAnLFxuICAgICAgICAnbmV3bGluZSc6ICdcXG4nXG4gICAgICB9LFxuICAgICAgaGVhZGxlc3M6IGZhbHNlLFxuICAgICAgY2h1bmtTaXplOiAxMDAwMCxcbiAgICAgIGVtcHR5VGFnOiAnJyxcbiAgICAgIGNkYXRhOiBmYWxzZVxuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgYm9tLCBkZWZhdWx0cywgZXZlbnRzLCBpc0VtcHR5LCBwcm9jZXNzSXRlbSwgcHJvY2Vzc29ycywgc2F4LCBzZXRJbW1lZGlhdGUsXG4gICAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBzYXggPSByZXF1aXJlKCdzYXgnKTtcblxuICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuICBib20gPSByZXF1aXJlKCcuL2JvbScpO1xuXG4gIHByb2Nlc3NvcnMgPSByZXF1aXJlKCcuL3Byb2Nlc3NvcnMnKTtcblxuICBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG5cbiAgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJykuZGVmYXVsdHM7XG5cbiAgaXNFbXB0eSA9IGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiAodGhpbmcgIT0gbnVsbCkgJiYgT2JqZWN0LmtleXModGhpbmcpLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICBwcm9jZXNzSXRlbSA9IGZ1bmN0aW9uKHByb2Nlc3NvcnMsIGl0ZW0sIGtleSkge1xuICAgIHZhciBpLCBsZW4sIHByb2Nlc3M7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcHJvY2Vzc29ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcHJvY2VzcyA9IHByb2Nlc3NvcnNbaV07XG4gICAgICBpdGVtID0gcHJvY2VzcyhpdGVtLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuICBleHBvcnRzLlBhcnNlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBhcnNlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0cykge1xuICAgICAgdGhpcy5wYXJzZVN0cmluZyA9IGJpbmQodGhpcy5wYXJzZVN0cmluZywgdGhpcyk7XG4gICAgICB0aGlzLnJlc2V0ID0gYmluZCh0aGlzLnJlc2V0LCB0aGlzKTtcbiAgICAgIHRoaXMuYXNzaWduT3JQdXNoID0gYmluZCh0aGlzLmFzc2lnbk9yUHVzaCwgdGhpcyk7XG4gICAgICB0aGlzLnByb2Nlc3NBc3luYyA9IGJpbmQodGhpcy5wcm9jZXNzQXN5bmMsIHRoaXMpO1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBleHBvcnRzLlBhcnNlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlBhcnNlcihvcHRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgcmVmID0gZGVmYXVsdHNbXCIwLjJcIl07XG4gICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5IGluIG9wdHMpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob3B0cywga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gb3B0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy54bWxucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMueG1sbnNrZXkgPSB0aGlzLm9wdGlvbnMuYXR0cmtleSArIFwibnNcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9ybWFsaXplVGFncykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycy51bnNoaWZ0KHByb2Nlc3NvcnMubm9ybWFsaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNodW5rLCBlcnI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcubGVuZ3RoIDw9IHRoaXMub3B0aW9ucy5jaHVua1NpemUpIHtcbiAgICAgICAgICBjaHVuayA9IHRoaXMucmVtYWluaW5nO1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gJyc7XG4gICAgICAgICAgdGhpcy5zYXhQYXJzZXIgPSB0aGlzLnNheFBhcnNlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHIoMCwgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHIodGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgdGhpcy5yZW1haW5pbmcubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnNheFBhcnNlciA9IHRoaXMuc2F4UGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKHRoaXMucHJvY2Vzc0FzeW5jKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgIGVyciA9IGVycm9yMTtcbiAgICAgICAgaWYgKCF0aGlzLnNheFBhcnNlci5lcnJUaHJvd24pIHtcbiAgICAgICAgICB0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFzc2lnbk9yUHVzaCA9IGZ1bmN0aW9uKG9iaiwga2V5LCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKCEoa2V5IGluIG9iaikpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhwbGljaXRBcnJheSkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IFtuZXdWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKG9ialtrZXldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpba2V5XS5wdXNoKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJrZXksIGNoYXJrZXksIG9udGV4dCwgc3RhY2s7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIgPSBzYXgucGFyc2VyKHRoaXMub3B0aW9ucy5zdHJpY3QsIHtcbiAgICAgICAgdHJpbTogZmFsc2UsXG4gICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsXG4gICAgICAgIHhtbG5zOiB0aGlzLm9wdGlvbnMueG1sbnNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYXhQYXJzZXIuZXJyVGhyb3duID0gZmFsc2U7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmVycm9yID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIF90aGlzLnNheFBhcnNlci5yZXN1bWUoKTtcbiAgICAgICAgICBpZiAoIV90aGlzLnNheFBhcnNlci5lcnJUaHJvd24pIHtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmVuZCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5zYXhQYXJzZXIuZW5kZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcImVuZFwiLCBfdGhpcy5yZXN1bHRPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIuZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuRVhQTElDSVRfQ0hBUktFWSA9IHRoaXMub3B0aW9ucy5leHBsaWNpdENoYXJrZXk7XG4gICAgICB0aGlzLnJlc3VsdE9iamVjdCA9IG51bGw7XG4gICAgICBzdGFjayA9IFtdO1xuICAgICAgYXR0cmtleSA9IHRoaXMub3B0aW9ucy5hdHRya2V5O1xuICAgICAgY2hhcmtleSA9IHRoaXMub3B0aW9ucy5jaGFya2V5O1xuICAgICAgdGhpcy5zYXhQYXJzZXIub25vcGVudGFnID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGtleSwgbmV3VmFsdWUsIG9iaiwgcHJvY2Vzc2VkS2V5LCByZWY7XG4gICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgb2JqW2NoYXJrZXldID0gXCJcIjtcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuaWdub3JlQXR0cnMpIHtcbiAgICAgICAgICAgIHJlZiA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpZiAoIShhdHRya2V5IGluIG9iaikgJiYgIV90aGlzLm9wdGlvbnMubWVyZ2VBdHRycykge1xuICAgICAgICAgICAgICAgIG9ialthdHRya2V5XSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5hdHRyVmFsdWVQcm9jZXNzb3JzID8gcHJvY2Vzc0l0ZW0oX3RoaXMub3B0aW9ucy5hdHRyVmFsdWVQcm9jZXNzb3JzLCBub2RlLmF0dHJpYnV0ZXNba2V5XSwga2V5KSA6IG5vZGUuYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICBwcm9jZXNzZWRLZXkgPSBfdGhpcy5vcHRpb25zLmF0dHJOYW1lUHJvY2Vzc29ycyA/IHByb2Nlc3NJdGVtKF90aGlzLm9wdGlvbnMuYXR0ck5hbWVQcm9jZXNzb3JzLCBrZXkpIDoga2V5O1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5tZXJnZUF0dHJzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXNzaWduT3JQdXNoKG9iaiwgcHJvY2Vzc2VkS2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2F0dHJrZXldW3Byb2Nlc3NlZEtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpbXCIjbmFtZVwiXSA9IF90aGlzLm9wdGlvbnMudGFnTmFtZVByb2Nlc3NvcnMgPyBwcm9jZXNzSXRlbShfdGhpcy5vcHRpb25zLnRhZ05hbWVQcm9jZXNzb3JzLCBub2RlLm5hbWUpIDogbm9kZS5uYW1lO1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnhtbG5zKSB7XG4gICAgICAgICAgICBvYmpbX3RoaXMub3B0aW9ucy54bWxuc2tleV0gPSB7XG4gICAgICAgICAgICAgIHVyaTogbm9kZS51cmksXG4gICAgICAgICAgICAgIGxvY2FsOiBub2RlLmxvY2FsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RhY2sucHVzaChvYmopO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmNsb3NldGFnID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY2RhdGEsIGVtcHR5U3RyLCBrZXksIG5vZGUsIG5vZGVOYW1lLCBvYmosIG9iakNsb25lLCBvbGQsIHMsIHhwYXRoO1xuICAgICAgICAgIG9iaiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIG5vZGVOYW1lID0gb2JqW1wiI25hbWVcIl07XG4gICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmV4cGxpY2l0Q2hpbGRyZW4gfHwgIV90aGlzLm9wdGlvbnMucHJlc2VydmVDaGlsZHJlbk9yZGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW1wiI25hbWVcIl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmouY2RhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNkYXRhID0gb2JqLmNkYXRhO1xuICAgICAgICAgICAgZGVsZXRlIG9iai5jZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChvYmpbY2hhcmtleV0ubWF0Y2goL15cXHMqJC8pICYmICFjZGF0YSkge1xuICAgICAgICAgICAgZW1wdHlTdHIgPSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgICBkZWxldGUgb2JqW2NoYXJrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy50cmltKSB7XG4gICAgICAgICAgICAgIG9ialtjaGFya2V5XSA9IG9ialtjaGFya2V5XS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgb2JqW2NoYXJrZXldID0gb2JqW2NoYXJrZXldLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtjaGFya2V5XSA9IF90aGlzLm9wdGlvbnMudmFsdWVQcm9jZXNzb3JzID8gcHJvY2Vzc0l0ZW0oX3RoaXMub3B0aW9ucy52YWx1ZVByb2Nlc3NvcnMsIG9ialtjaGFya2V5XSwgbm9kZU5hbWUpIDogb2JqW2NoYXJrZXldO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAxICYmIGNoYXJrZXkgaW4gb2JqICYmICFfdGhpcy5FWFBMSUNJVF9DSEFSS0VZKSB7XG4gICAgICAgICAgICAgIG9iaiA9IG9ialtjaGFya2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRW1wdHkob2JqKSkge1xuICAgICAgICAgICAgb2JqID0gX3RoaXMub3B0aW9ucy5lbXB0eVRhZyAhPT0gJycgPyBfdGhpcy5vcHRpb25zLmVtcHR5VGFnIDogZW1wdHlTdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnZhbGlkYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICB4cGF0aCA9IFwiL1wiICsgKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZVtcIiNuYW1lXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCkpLmNvbmNhdChub2RlTmFtZSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBlcnI7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiA9IF90aGlzLm9wdGlvbnMudmFsaWRhdG9yKHhwYXRoLCBzICYmIHNbbm9kZU5hbWVdLCBvYmopO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlcnJvcjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5leHBsaWNpdENoaWxkcmVuICYmICFfdGhpcy5vcHRpb25zLm1lcmdlQXR0cnMgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5wcmVzZXJ2ZUNoaWxkcmVuT3JkZXIpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IHt9O1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hdHRya2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIG5vZGVbX3RoaXMub3B0aW9ucy5hdHRya2V5XSA9IG9ialtfdGhpcy5vcHRpb25zLmF0dHJrZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbX3RoaXMub3B0aW9ucy5hdHRya2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2hhcnNBc0NoaWxkcmVuICYmIF90aGlzLm9wdGlvbnMuY2hhcmtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBub2RlW190aGlzLm9wdGlvbnMuY2hhcmtleV0gPSBvYmpbX3RoaXMub3B0aW9ucy5jaGFya2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW190aGlzLm9wdGlvbnMuY2hhcmtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0gPSBvYmo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocykge1xuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldID0gc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgb2JqQ2xvbmUgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBvYmpDbG9uZVtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XS5wdXNoKG9iakNsb25lKTtcbiAgICAgICAgICAgICAgZGVsZXRlIG9ialtcIiNuYW1lXCJdO1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDEgJiYgY2hhcmtleSBpbiBvYmogJiYgIV90aGlzLkVYUExJQ0lUX0NIQVJLRVkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hc3NpZ25PclB1c2gocywgbm9kZU5hbWUsIG9iaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmV4cGxpY2l0Um9vdCkge1xuICAgICAgICAgICAgICBvbGQgPSBvYmo7XG4gICAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgICAgICBvYmpbbm9kZU5hbWVdID0gb2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVzdWx0T2JqZWN0ID0gb2JqO1xuICAgICAgICAgICAgX3RoaXMuc2F4UGFyc2VyLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KFwiZW5kXCIsIF90aGlzLnJlc3VsdE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBvbnRleHQgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICB2YXIgY2hhckNoaWxkLCBzO1xuICAgICAgICAgIHMgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgc1tjaGFya2V5XSArPSB0ZXh0O1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXhwbGljaXRDaGlsZHJlbiAmJiBfdGhpcy5vcHRpb25zLnByZXNlcnZlQ2hpbGRyZW5PcmRlciAmJiBfdGhpcy5vcHRpb25zLmNoYXJzQXNDaGlsZHJlbiAmJiAoX3RoaXMub3B0aW9ucy5pbmNsdWRlV2hpdGVDaGFycyB8fCB0ZXh0LnJlcGxhY2UoL1xcXFxuL2csICcnKS50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldID0gc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgY2hhckNoaWxkID0ge1xuICAgICAgICAgICAgICAgICcjbmFtZSc6ICdfX3RleHRfXydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY2hhckNoaWxkW2NoYXJrZXldID0gdGV4dDtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgY2hhckNoaWxkW2NoYXJrZXldID0gY2hhckNoaWxkW2NoYXJrZXldLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldLnB1c2goY2hhckNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIub250ZXh0ID0gb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLm9uY2RhdGEgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICB2YXIgcztcbiAgICAgICAgICBzID0gb250ZXh0KHRleHQpO1xuICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5jZGF0YSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbihzdHIsIGNiKSB7XG4gICAgICB2YXIgZXJyO1xuICAgICAgaWYgKChjYiAhPSBudWxsKSAmJiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdHIudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBib20uc3RyaXBCT00oc3RyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3luYykge1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gc3RyO1xuICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLnByb2Nlc3NBc3luYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNheFBhcnNlci53cml0ZShzdHIpLmNsb3NlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgZXJyID0gZXJyb3IxO1xuICAgICAgICBpZiAoISh0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gfHwgdGhpcy5zYXhQYXJzZXIuZW5kZWQpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLmVyclRocm93biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zYXhQYXJzZXIuZW5kZWQpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcblxuICB9KShldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuICBleHBvcnRzLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBhLCBiKSB7XG4gICAgdmFyIGNiLCBvcHRpb25zLCBwYXJzZXI7XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gYjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IGE7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlBhcnNlcihvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlU3RyaW5nKHN0ciwgY2IpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBwcmVmaXhNYXRjaDtcblxuICBwcmVmaXhNYXRjaCA9IG5ldyBSZWdFeHAoLyg/IXhtbG5zKV4uKjovKTtcblxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICBleHBvcnRzLmZpcnN0Q2hhckxvd2VyQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH07XG5cbiAgZXhwb3J0cy5zdHJpcFByZWZpeCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShwcmVmaXhNYXRjaCwgJycpO1xuICB9O1xuXG4gIGV4cG9ydHMucGFyc2VOdW1iZXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFpc05hTihzdHIpKSB7XG4gICAgICBzdHIgPSBzdHIgJSAxID09PSAwID8gcGFyc2VJbnQoc3RyLCAxMCkgOiBwYXJzZUZsb2F0KHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgZXhwb3J0cy5wYXJzZUJvb2xlYW5zID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKC9eKD86dHJ1ZXxmYWxzZSkkL2kudGVzdChzdHIpKSB7XG4gICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBidWlsZGVyLCBkZWZhdWx0cywgcGFyc2VyLCBwcm9jZXNzb3JzLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbiAgYnVpbGRlciA9IHJlcXVpcmUoJy4vYnVpbGRlcicpO1xuXG4gIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5cbiAgcHJvY2Vzc29ycyA9IHJlcXVpcmUoJy4vcHJvY2Vzc29ycycpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cy5kZWZhdWx0cztcblxuICBleHBvcnRzLnByb2Nlc3NvcnMgPSBwcm9jZXNzb3JzO1xuXG4gIGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVmFsaWRhdGlvbkVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIGV4cG9ydHMuQnVpbGRlciA9IGJ1aWxkZXIuQnVpbGRlcjtcblxuICBleHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5cbiAgZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlci5wYXJzZVN0cmluZztcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBhc3NpZ24sIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LFxuICAgIHNsaWNlID0gW10uc2xpY2UsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGFzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBrZXksIGxlbiwgc291cmNlLCBzb3VyY2VzLCB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdLCBzb3VyY2VzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgaWYgKGlzRnVuY3Rpb24oT2JqZWN0LmFzc2lnbikpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gISF2YWwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG5cbiAgaXNPYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAhIXZhbCAmJiAoKHJlZiA9IHR5cGVvZiB2YWwpID09PSAnZnVuY3Rpb24nIHx8IHJlZiA9PT0gJ29iamVjdCcpO1xuICB9O1xuXG4gIGlzQXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihBcnJheS5pc0FycmF5KSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cbiAgfTtcblxuICBpc0VtcHR5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gIXZhbC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIHZhbCkge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh2YWwsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBjdG9yLCBwcm90bztcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiAocHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSkgJiYgKGN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcikgJiYgKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nKSAmJiAoY3RvciBpbnN0YW5jZW9mIGN0b3IpICYmIChGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjdG9yKSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoT2JqZWN0KSk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTEF0dHJpYnV0ZShwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBwYXJlbnQub3B0aW9ucztcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gcGFyZW50LnN0cmluZ2lmeTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGUgbmFtZSBvZiBlbGVtZW50IFwiICsgcGFyZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUgKyBcIiBvZiBlbGVtZW50IFwiICsgcGFyZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuYXR0TmFtZShuYW1lKTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5hdHRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgWE1MQXR0cmlidXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTEF0dHJpYnV0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuYXR0cmlidXRlKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQXR0cmlidXRlO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTE5vZGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxDRGF0YSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTENEYXRhLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTENEYXRhKHBhcmVudCwgdGV4dCkge1xuICAgICAgWE1MQ0RhdGEuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBDREFUQSB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdHJpbmdpZnkuY2RhdGEodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MQ0RhdGEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MQ0RhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmNkYXRhKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQ0RhdGE7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ29tbWVudCwgWE1MTm9kZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTENvbW1lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxDb21tZW50LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTENvbW1lbnQocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxDb21tZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY29tbWVudCB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdHJpbmdpZnkuY29tbWVudCh0ZXh0KTtcbiAgICB9XG5cbiAgICBYTUxDb21tZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTENvbW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmNvbW1lbnQodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxDb21tZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERUREF0dExpc3QsIFhNTE5vZGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERBdHRMaXN0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRFREQXR0TGlzdCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEVERBdHRMaXN0KHBhcmVudCwgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgWE1MRFREQXR0TGlzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKGVsZW1lbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgZWxlbWVudCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cmlidXRlVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVmYXVsdFZhbHVlVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgZGVmYXVsdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlLmluZGV4T2YoJyMnKSAhPT0gMCkge1xuICAgICAgICBkZWZhdWx0VmFsdWVUeXBlID0gJyMnICsgZGVmYXVsdFZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVmYXVsdFZhbHVlVHlwZS5tYXRjaCgvXigjUkVRVUlSRUR8I0lNUExJRUR8I0ZJWEVEfCNERUZBVUxUKSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRlZmF1bHQgdmFsdWUgdHlwZTsgZXhwZWN0ZWQ6ICNSRVFVSVJFRCwgI0lNUExJRUQsICNGSVhFRCBvciAjREVGQVVMVFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgJiYgIWRlZmF1bHRWYWx1ZVR5cGUubWF0Y2goL14oI0ZJWEVEfCNERUZBVUxUKSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IHZhbHVlIG9ubHkgYXBwbGllcyB0byAjRklYRUQgb3IgI0RFRkFVTFRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnROYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShlbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSB0aGlzLnN0cmluZ2lmeS5hdHROYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVUeXBlID0gdGhpcy5zdHJpbmdpZnkuZHRkQXR0VHlwZShhdHRyaWJ1dGVUeXBlKTtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkQXR0RGVmYXVsdChkZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWVUeXBlID0gZGVmYXVsdFZhbHVlVHlwZTtcbiAgICB9XG5cbiAgICBYTUxEVERBdHRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGRBdHRMaXN0KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFREQXR0TGlzdDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERFbGVtZW50LCBYTUxOb2RlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRFRERWxlbWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTERUREVsZW1lbnQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MRFRERWxlbWVudChwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBYTUxEVERFbGVtZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSAnKCNQQ0RBVEEpJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9ICcoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkRWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBYTUxEVERFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGRFbGVtZW50KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFRERWxlbWVudDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERFbnRpdHksIFhNTE5vZGUsIGlzT2JqZWN0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgaXNPYmplY3QgPSByZXF1aXJlKCcuL1V0aWxpdHknKS5pc09iamVjdDtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERFbnRpdHkgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEVERFbnRpdHksIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MRFRERW50aXR5KHBhcmVudCwgcGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBYTUxEVERFbnRpdHkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbnRpdHkgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZW50aXR5IHZhbHVlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wZSA9ICEhcGU7XG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVOYW1lKG5hbWUpO1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmR0ZEVudGl0eVZhbHVlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmFsdWUucHViSUQgJiYgIXZhbHVlLnN5c0lEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGljIGFuZC9vciBzeXN0ZW0gaWRlbnRpZmllcnMgYXJlIHJlcXVpcmVkIGZvciBhbiBleHRlcm5hbCBlbnRpdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSBpZGVudGlmaWVyIGlzIHJlcXVpcmVkIGZvciBhIHB1YmxpYyBleHRlcm5hbCBlbnRpdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnB1YklEICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnB1YklEID0gdGhpcy5zdHJpbmdpZnkuZHRkUHViSUQodmFsdWUucHViSUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5zeXNJRCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zeXNJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFN5c0lEKHZhbHVlLnN5c0lEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubkRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubkRhdGEgPSB0aGlzLnN0cmluZ2lmeS5kdGRORGF0YSh2YWx1ZS5uRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGUgJiYgdGhpcy5uRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdGF0aW9uIGRlY2xhcmF0aW9uIGlzIG5vdCBhbGxvd2VkIGluIGEgcGFyYW1ldGVyIGVudGl0eVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERUREVudGl0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZHRkRW50aXR5KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFRERW50aXR5O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERURE5vdGF0aW9uLCBYTUxOb2RlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRFRETm90YXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEVEROb3RhdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEVEROb3RhdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBYTUxEVEROb3RhdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG5vdGF0aW9uIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMgb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIGlmICh2YWx1ZS5wdWJJRCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRCh2YWx1ZS5wdWJJRCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUuc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQodmFsdWUuc3lzSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERURE5vdGF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGROb3RhdGlvbih0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERURE5vdGF0aW9uO1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERlY2xhcmF0aW9uLCBYTUxOb2RlLCBpc09iamVjdCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9VdGlsaXR5JykuaXNPYmplY3Q7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEZWNsYXJhdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEZWNsYXJhdGlvbihwYXJlbnQsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgWE1MRGVjbGFyYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChpc09iamVjdCh2ZXJzaW9uKSkge1xuICAgICAgICByZWYgPSB2ZXJzaW9uLCB2ZXJzaW9uID0gcmVmLnZlcnNpb24sIGVuY29kaW5nID0gcmVmLmVuY29kaW5nLCBzdGFuZGFsb25lID0gcmVmLnN0YW5kYWxvbmU7XG4gICAgICB9XG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgdmVyc2lvbiA9ICcxLjAnO1xuICAgICAgfVxuICAgICAgdGhpcy52ZXJzaW9uID0gdGhpcy5zdHJpbmdpZnkueG1sVmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgIGlmIChlbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSB0aGlzLnN0cmluZ2lmeS54bWxFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhbmRhbG9uZSA9IHRoaXMuc3RyaW5naWZ5LnhtbFN0YW5kYWxvbmUoc3RhbmRhbG9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRGVjbGFyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmRlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRGVjbGFyYXRpb247XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFREQXR0TGlzdCwgWE1MRFRERWxlbWVudCwgWE1MRFRERW50aXR5LCBYTUxEVEROb3RhdGlvbiwgWE1MRG9jVHlwZSwgWE1MTm9kZSwgaXNPYmplY3QsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBpc09iamVjdCA9IHJlcXVpcmUoJy4vVXRpbGl0eScpLmlzT2JqZWN0O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBYTUxEVERBdHRMaXN0ID0gcmVxdWlyZSgnLi9YTUxEVERBdHRMaXN0Jyk7XG5cbiAgWE1MRFRERW50aXR5ID0gcmVxdWlyZSgnLi9YTUxEVERFbnRpdHknKTtcblxuICBYTUxEVERFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxEVERFbGVtZW50Jyk7XG5cbiAgWE1MRFRETm90YXRpb24gPSByZXF1aXJlKCcuL1hNTERURE5vdGF0aW9uJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2NUeXBlID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRG9jVHlwZSwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEb2NUeXBlKHBhcmVudCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICB2YXIgcmVmLCByZWYxO1xuICAgICAgWE1MRG9jVHlwZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgdGhpcy5kb2N1bWVudE9iamVjdCA9IHBhcmVudDtcbiAgICAgIGlmIChpc09iamVjdChwdWJJRCkpIHtcbiAgICAgICAgcmVmID0gcHViSUQsIHB1YklEID0gcmVmLnB1YklELCBzeXNJRCA9IHJlZi5zeXNJRDtcbiAgICAgIH1cbiAgICAgIGlmIChzeXNJRCA9PSBudWxsKSB7XG4gICAgICAgIHJlZjEgPSBbcHViSUQsIHN5c0lEXSwgc3lzSUQgPSByZWYxWzBdLCBwdWJJRCA9IHJlZjFbMV07XG4gICAgICB9XG4gICAgICBpZiAocHViSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnB1YklEID0gdGhpcy5zdHJpbmdpZnkuZHRkUHViSUQocHViSUQpO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zeXNJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFN5c0lEKHN5c0lEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVsZW1lbnQodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5hdHRMaXN0ID0gZnVuY3Rpb24oZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFREQXR0TGlzdCh0aGlzLCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCBmYWxzZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5wRW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCB0cnVlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLm5vdGF0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERURE5vdGF0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZG9jVHlwZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5hdHQgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRMaXN0KGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUucGVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wRW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdGF0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QoKSB8fCB0aGlzLmRvY3VtZW50T2JqZWN0O1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRG9jVHlwZTtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEb2N1bWVudCwgWE1MTm9kZSwgWE1MU3RyaW5nV3JpdGVyLCBYTUxTdHJpbmdpZmllciwgaXNQbGFpbk9iamVjdCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL1V0aWxpdHknKS5pc1BsYWluT2JqZWN0O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBYTUxTdHJpbmdpZmllciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5naWZpZXInKTtcblxuICBYTUxTdHJpbmdXcml0ZXIgPSByZXF1aXJlKCcuL1hNTFN0cmluZ1dyaXRlcicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRG9jdW1lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEb2N1bWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEb2N1bWVudChvcHRpb25zKSB7XG4gICAgICBYTUxEb2N1bWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBpZiAoIW9wdGlvbnMud3JpdGVyKSB7XG4gICAgICAgIG9wdGlvbnMud3JpdGVyID0gbmV3IFhNTFN0cmluZ1dyaXRlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gbmV3IFhNTFN0cmluZ2lmaWVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5pc0RvY3VtZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBYTUxEb2N1bWVudC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICB2YXIgd3JpdGVyT3B0aW9ucztcbiAgICAgIGlmICghd3JpdGVyKSB7XG4gICAgICAgIHdyaXRlciA9IHRoaXMub3B0aW9ucy53cml0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qod3JpdGVyKSkge1xuICAgICAgICB3cml0ZXJPcHRpb25zID0gd3JpdGVyO1xuICAgICAgICB3cml0ZXIgPSB0aGlzLm9wdGlvbnMud3JpdGVyLnNldCh3cml0ZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cml0ZXIuZG9jdW1lbnQodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kb2N1bWVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERvY3VtZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEF0dHJpYnV0ZSwgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERUREF0dExpc3QsIFhNTERUREVsZW1lbnQsIFhNTERUREVudGl0eSwgWE1MRFRETm90YXRpb24sIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxEb2N1bWVudENCLCBYTUxFbGVtZW50LCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MU3RyaW5nV3JpdGVyLCBYTUxTdHJpbmdpZmllciwgWE1MVGV4dCwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QsIHJlZixcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGlzT2JqZWN0ID0gcmVmLmlzT2JqZWN0LCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb24sIGlzUGxhaW5PYmplY3QgPSByZWYuaXNQbGFpbk9iamVjdDtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgWE1MQ0RhdGEgPSByZXF1aXJlKCcuL1hNTENEYXRhJyk7XG5cbiAgWE1MQ29tbWVudCA9IHJlcXVpcmUoJy4vWE1MQ29tbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTERUREF0dExpc3QgPSByZXF1aXJlKCcuL1hNTERUREF0dExpc3QnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVEROb3RhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRFRETm90YXRpb24nKTtcblxuICBYTUxBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL1hNTEF0dHJpYnV0ZScpO1xuXG4gIFhNTFN0cmluZ2lmaWVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdpZmllcicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2N1bWVudENCID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTERvY3VtZW50Q0Iob3B0aW9ucywgb25EYXRhLCBvbkVuZCkge1xuICAgICAgdmFyIHdyaXRlck9wdGlvbnM7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgaWYgKCFvcHRpb25zLndyaXRlcikge1xuICAgICAgICBvcHRpb25zLndyaXRlciA9IG5ldyBYTUxTdHJpbmdXcml0ZXIob3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qob3B0aW9ucy53cml0ZXIpKSB7XG4gICAgICAgIHdyaXRlck9wdGlvbnMgPSBvcHRpb25zLndyaXRlcjtcbiAgICAgICAgb3B0aW9ucy53cml0ZXIgPSBuZXcgWE1MU3RyaW5nV3JpdGVyKHdyaXRlck9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMud3JpdGVyID0gb3B0aW9ucy53cml0ZXI7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IG5ldyBYTUxTdHJpbmdpZmllcihvcHRpb25zKTtcbiAgICAgIHRoaXMub25EYXRhQ2FsbGJhY2sgPSBvbkRhdGEgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICAgIHRoaXMub25FbmRDYWxsYmFjayA9IG9uRW5kIHx8IGZ1bmN0aW9uKCkge307XG4gICAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudExldmVsID0gLTE7XG4gICAgICB0aGlzLm9wZW5UYWdzID0ge307XG4gICAgICB0aGlzLmRvY3VtZW50U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kb2N1bWVudENvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIHJlZjE7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgbm9kZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLmN1cnJlbnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9jdW1lbnQgY2FuIG9ubHkgaGF2ZSBvbmUgcm9vdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJlZjEgPSBbYXR0cmlidXRlcywgdGV4dF0sIHRleHQgPSByZWYxWzBdLCBhdHRyaWJ1dGVzID0gcmVmMVsxXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBuZXcgWE1MRWxlbWVudCh0aGlzLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsKys7XG4gICAgICB0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudGV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgJiYgdGhpcy5jdXJyZW50Tm9kZSBpbnN0YW5jZW9mIFhNTERvY1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHRkRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBhdHRWYWx1ZTtcbiAgICAgIGlmICghdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLmN1cnJlbnROb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dCgpIGNhbiBvbmx5IGJlIHVzZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW4gZWxlKCkgY2FsbCBpbiBjYWxsYmFjayBtb2RlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChhdHROYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChuYW1lLCBhdHROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0VmFsdWUgPSBuYW1lW2F0dE5hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dE5hbWUsIGF0dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBOdWxsQXR0cmlidXRlcyB8fCAodmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlLmF0dHJpYnV0ZXNbbmFtZV0gPSBuZXcgWE1MQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBub2RlID0gbmV3IFhNTFRleHQodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIudGV4dChub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MQ0RhdGEodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuY2RhdGEobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuY29tbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MQ29tbWVudCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5jb21tZW50KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MUmF3KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLnJhdyhub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBpLCBpbnNUYXJnZXQsIGluc1ZhbHVlLCBsZW4sIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YXJnZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpbnNUYXJnZXQgPSB0YXJnZXRbaV07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgZm9yIChpbnNUYXJnZXQgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwodGFyZ2V0LCBpbnNUYXJnZXQpKSBjb250aW51ZTtcbiAgICAgICAgICBpbnNWYWx1ZSA9IHRhcmdldFtpbnNUYXJnZXRdO1xuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24oaW5zVGFyZ2V0LCBpbnNWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIucHJvY2Vzc2luZ0luc3RydWN0aW9uKG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmRlY2xhcmF0aW9uID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgaWYgKHRoaXMuZG9jdW1lbnRTdGFydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY2xhcmF0aW9uKCkgbXVzdCBiZSB0aGUgZmlyc3Qgbm9kZVwiKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgWE1MRGVjbGFyYXRpb24odGhpcywgdmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZGVjbGFyYXRpb24obm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZG9jdHlwZSA9IGZ1bmN0aW9uKHJvb3QsIHB1YklELCBzeXNJRCkge1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgaWYgKHJvb3QgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJvb3Qgbm9kZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdGQoKSBtdXN0IGNvbWUgYmVmb3JlIHRoZSByb290IG5vZGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnROb2RlID0gbmV3IFhNTERvY1R5cGUodGhpcywgcHViSUQsIHN5c0lEKTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUucm9vdE5vZGVOYW1lID0gcm9vdDtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsKys7XG4gICAgICB0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZHRkRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFRERWxlbWVudCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kdGRFbGVtZW50KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmF0dExpc3QgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFREQXR0TGlzdCh0aGlzLCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEF0dExpc3Qobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbnRpdHkodGhpcywgZmFsc2UsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEVudGl0eShub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5wRW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbnRpdHkodGhpcywgdHJ1ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZHRkRW50aXR5KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vdGF0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVEROb3RhdGlvbih0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kdGROb3RhdGlvbihub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZG9jdW1lbnQgbm9kZSBoYXMgbm8gcGFyZW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLmNsb3NlTm9kZSh0aGlzLmN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wZW5Ob2RlKHRoaXMuY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZU5vZGUodGhpcy5vcGVuVGFnc1t0aGlzLmN1cnJlbnRMZXZlbF0pO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMub3BlblRhZ3NbdGhpcy5jdXJyZW50TGV2ZWxdO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwtLTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnRMZXZlbCA+PSAwKSB7XG4gICAgICAgIHRoaXMudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9uRW5kKCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9wZW5DdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlLmNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbk5vZGUodGhpcy5jdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9wZW5Ob2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLmlzT3Blbikge1xuICAgICAgICBpZiAoIXRoaXMucm9vdCAmJiB0aGlzLmN1cnJlbnRMZXZlbCA9PT0gMCAmJiBub2RlIGluc3RhbmNlb2YgWE1MRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIub3Blbk5vZGUobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuY2xvc2VOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmNsb3NlTm9kZShub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCkpO1xuICAgICAgICByZXR1cm4gbm9kZS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICB0aGlzLmRvY3VtZW50U3RhcnRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5vbkRhdGFDYWxsYmFjayhjaHVuayk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvY3VtZW50Q29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm9uRW5kQ2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vZCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnR4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZGF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuY29tID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5pbnMgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZGVjID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZHRkID0gZnVuY3Rpb24ocm9vdCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N0eXBlKHJvb3QsIHB1YklELCBzeXNJRCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5uID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZGF0YSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuaSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5hdHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlICYmIHRoaXMuY3VycmVudE5vZGUgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dExpc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5hID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSAmJiB0aGlzLmN1cnJlbnROb2RlIGluc3RhbmNlb2YgWE1MRG9jVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRMaXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudGl0eShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnBlbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucEVudGl0eShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RhdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEb2N1bWVudENCO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlLCBYTUxFbGVtZW50LCBYTUxOb2RlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVmLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGlzT2JqZWN0ID0gcmVmLmlzT2JqZWN0LCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb247XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIFhNTEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vWE1MQXR0cmlidXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxFbGVtZW50ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRWxlbWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxFbGVtZW50KHBhcmVudCwgbmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgWE1MRWxlbWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUoYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlzRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5pc1Jvb3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmRvY3VtZW50T2JqZWN0ID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQucm9vdE9iamVjdCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHQsIGF0dE5hbWUsIGNsb25lZFNlbGYsIHJlZjE7XG4gICAgICBjbG9uZWRTZWxmID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgIGlmIChjbG9uZWRTZWxmLmlzUm9vdCkge1xuICAgICAgICBjbG9uZWRTZWxmLmRvY3VtZW50T2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsb25lZFNlbGYuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgcmVmMSA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAoYXR0TmFtZSBpbiByZWYxKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZjEsIGF0dE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgYXR0ID0gcmVmMVthdHROYW1lXTtcbiAgICAgICAgY2xvbmVkU2VsZi5hdHRyaWJ1dGVzW2F0dE5hbWVdID0gYXR0LmNsb25lKCk7XG4gICAgICB9XG4gICAgICBjbG9uZWRTZWxmLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIGNsb25lZENoaWxkO1xuICAgICAgICBjbG9uZWRDaGlsZCA9IGNoaWxkLmNsb25lKCk7XG4gICAgICAgIGNsb25lZENoaWxkLnBhcmVudCA9IGNsb25lZFNlbGY7XG4gICAgICAgIHJldHVybiBjbG9uZWRTZWxmLmNoaWxkcmVuLnB1c2goY2xvbmVkQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xvbmVkU2VsZjtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBhdHRWYWx1ZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIGZvciAoYXR0TmFtZSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwgYXR0TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dFZhbHVlID0gbmFtZVthdHROYW1lXTtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHROYW1lLCBhdHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwTnVsbEF0dHJpYnV0ZXMgfHwgKHZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gbmV3IFhNTEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgYXR0TmFtZSwgaSwgbGVuO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGF0dE5hbWUgPSBuYW1lW2ldO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZWxlbWVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYXR0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLmEgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEVsZW1lbnQ7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxFbGVtZW50LCBYTUxOb2RlLCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MVGV4dCwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJlZixcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGlzT2JqZWN0ID0gcmVmLmlzT2JqZWN0LCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb24sIGlzRW1wdHkgPSByZWYuaXNFbXB0eTtcblxuICBYTUxFbGVtZW50ID0gbnVsbDtcblxuICBYTUxDRGF0YSA9IG51bGw7XG5cbiAgWE1MQ29tbWVudCA9IG51bGw7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSBudWxsO1xuXG4gIFhNTERvY1R5cGUgPSBudWxsO1xuXG4gIFhNTFJhdyA9IG51bGw7XG5cbiAgWE1MVGV4dCA9IG51bGw7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gbnVsbDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTE5vZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MTm9kZShwYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucGFyZW50Lm9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5ID0gdGhpcy5wYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKCFYTUxFbGVtZW50KSB7XG4gICAgICAgIFhNTEVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTEVsZW1lbnQnKTtcbiAgICAgICAgWE1MQ0RhdGEgPSByZXF1aXJlKCcuL1hNTENEYXRhJyk7XG4gICAgICAgIFhNTENvbW1lbnQgPSByZXF1aXJlKCcuL1hNTENvbW1lbnQnKTtcbiAgICAgICAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG4gICAgICAgIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcbiAgICAgICAgWE1MUmF3ID0gcmVxdWlyZSgnLi9YTUxSYXcnKTtcbiAgICAgICAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuICAgICAgICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSByZXF1aXJlKCcuL1hNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgY2hpbGROb2RlLCBpdGVtLCBqLCBrLCBrZXksIGxhc3RDaGlsZCwgbGVuLCBsZW4xLCByZWYxLCB2YWw7XG4gICAgICBsYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJlZjEgPSBbYXR0cmlidXRlcywgdGV4dF0sIHRleHQgPSByZWYxWzBdLCBhdHRyaWJ1dGVzID0gcmVmMVsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGl0ZW0gPSBuYW1lW2pdO1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChuYW1lLmFwcGx5KCkpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgdmFsID0gbmFtZVtrZXldO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGlzT2JqZWN0KHZhbCkpICYmIChpc0VtcHR5KHZhbCkpKSB7XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzICYmIHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRBdHRLZXkgJiYga2V5LmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleSkgPT09IDApIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuYXR0cmlidXRlKGtleS5zdWJzdHIodGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleS5sZW5ndGgpLCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5zZXBhcmF0ZUFycmF5SXRlbXMgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdmFsLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICBpdGVtID0gdmFsW2tdO1xuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSB7fTtcbiAgICAgICAgICAgICAgY2hpbGROb2RlW2tleV0gPSBpdGVtO1xuICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChrZXkpO1xuICAgICAgICAgICAgbGFzdENoaWxkLmVsZW1lbnQodmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGtleSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFRleHRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRUZXh0S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMudGV4dCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENEYXRhS2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q0RhdGFLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5jZGF0YSh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENvbW1lbnRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDb21tZW50S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuY29tbWVudCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFJhd0tleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFJhd0tleSkgPT09IDApIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLnJhdyh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFBJS2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5pbnN0cnVjdGlvbihuYW1lLnN1YnN0cih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkubGVuZ3RoKSwgdGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdENoaWxkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBhbnkgZWxlbWVudHMgd2l0aDogXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5zZXJ0IGVsZW1lbnRzIGF0IHJvb3QgbGV2ZWxcIik7XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnNlcnQgZWxlbWVudHMgYXQgcm9vdCBsZXZlbFwiKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHJlZjE7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgcm9vdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICBbXS5zcGxpY2UuYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIFtpLCBpIC0gaSArIDFdLmNvbmNhdChyZWYxID0gW10pKSwgcmVmMTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZCwgcmVmMTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KTtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnZhbHVlT2YoKTtcbiAgICAgIGlmICghaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgcmVmMSA9IFthdHRyaWJ1dGVzLCB0ZXh0XSwgdGV4dCA9IHJlZjFbMF0sIGF0dHJpYnV0ZXMgPSByZWYxWzFdO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBuZXcgWE1MRWxlbWVudCh0aGlzLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgY2hpbGQudGV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MVGV4dCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTENEYXRhKHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY29tbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxDb21tZW50KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY29tbWVudEJlZm9yZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmNvbW1lbnQodmFsdWUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNvbW1lbnRBZnRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSArIDEpO1xuICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudC5jb21tZW50KHZhbHVlKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MUmF3KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgaW5zVGFyZ2V0LCBpbnNWYWx1ZSwgaW5zdHJ1Y3Rpb24sIGosIGxlbjtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGluc1RhcmdldCA9IHRhcmdldFtqXTtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9uKGluc1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBmb3IgKGluc1RhcmdldCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh0YXJnZXQsIGluc1RhcmdldCkpIGNvbnRpbnVlO1xuICAgICAgICAgIGluc1ZhbHVlID0gdGFyZ2V0W2luc1RhcmdldF07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQsIGluc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RydWN0aW9uID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbnN0cnVjdGlvbkJlZm9yZSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zdHJ1Y3Rpb25BZnRlciA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50Lmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRlY2xhcmF0aW9uID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciBkb2MsIHhtbGRlYztcbiAgICAgIGRvYyA9IHRoaXMuZG9jdW1lbnQoKTtcbiAgICAgIHhtbGRlYyA9IG5ldyBYTUxEZWNsYXJhdGlvbihkb2MsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICAgIGlmIChkb2MuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBYTUxEZWNsYXJhdGlvbikge1xuICAgICAgICBkb2MuY2hpbGRyZW5bMF0gPSB4bWxkZWM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2MuY2hpbGRyZW4udW5zaGlmdCh4bWxkZWMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvYy5yb290KCkgfHwgZG9jO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2N0eXBlID0gZnVuY3Rpb24ocHViSUQsIHN5c0lEKSB7XG4gICAgICB2YXIgY2hpbGQsIGRvYywgZG9jdHlwZSwgaSwgaiwgaywgbGVuLCBsZW4xLCByZWYxLCByZWYyO1xuICAgICAgZG9jID0gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgZG9jdHlwZSA9IG5ldyBYTUxEb2NUeXBlKGRvYywgcHViSUQsIHN5c0lEKTtcbiAgICAgIHJlZjEgPSBkb2MuY2hpbGRyZW47XG4gICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKSB7XG4gICAgICAgICAgZG9jLmNoaWxkcmVuW2ldID0gZG9jdHlwZTtcbiAgICAgICAgICByZXR1cm4gZG9jdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVmMiA9IGRvYy5jaGlsZHJlbjtcbiAgICAgIGZvciAoaSA9IGsgPSAwLCBsZW4xID0gcmVmMi5sZW5ndGg7IGsgPCBsZW4xOyBpID0gKytrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmMltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmlzUm9vdCkge1xuICAgICAgICAgIGRvYy5jaGlsZHJlbi5zcGxpY2UoaSwgMCwgZG9jdHlwZSk7XG4gICAgICAgICAgcmV0dXJuIGRvY3R5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvYy5jaGlsZHJlbi5wdXNoKGRvY3R5cGUpO1xuICAgICAgcmV0dXJuIGRvY3R5cGU7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJvb3Qgbm9kZSBoYXMgbm8gcGFyZW50LiBVc2UgZG9jKCkgaWYgeW91IG5lZWQgdG8gZ2V0IHRoZSBkb2N1bWVudCBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIG5vZGUgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNEb2N1bWVudCkge1xuICAgICAgICAgIHJldHVybiBub2RlLnJvb3RPYmplY3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc1Jvb3QpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgbm9kZSA9IHRoaXM7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc0RvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCkuZW5kKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgYXQgdGhlIGZpcnN0IG5vZGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW5baSAtIDFdO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPT09IC0xIHx8IGkgPT09IHRoaXMucGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdCB0aGUgbGFzdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuW2kgKyAxXTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW1wb3J0RG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBjbG9uZWRSb290O1xuICAgICAgY2xvbmVkUm9vdCA9IGRvYy5yb290KCkuY2xvbmUoKTtcbiAgICAgIGNsb25lZFJvb3QucGFyZW50ID0gdGhpcztcbiAgICAgIGNsb25lZFJvb3QuaXNSb290ID0gZmFsc2U7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2xvbmVkUm9vdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubm9kID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudHh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRlYyA9IGZ1bmN0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmR0ZCA9IGZ1bmN0aW9uKHB1YklELCBzeXNJRCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdHlwZShwdWJJRCwgc3lzSUQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubiA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmkgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXAoKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW1wb3J0WE1MQnVpbGRlciA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0RG9jdW1lbnQoZG9jKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTE5vZGU7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxOb2RlLCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHBhcmVudCwgdGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBpbnN0cnVjdGlvbiB0YXJnZXRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldCA9IHRoaXMuc3RyaW5naWZ5Lmluc1RhcmdldCh0YXJnZXQpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5pbnNWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykucHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTE5vZGUsIFhNTFJhdyxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFJhdyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFJhdywgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxSYXcocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxSYXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByYXcgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5yYXcodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MUmF3LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTFJhdy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykucmF3KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MUmF3O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTENEYXRhLCBYTUxDb21tZW50LCBYTUxEVERBdHRMaXN0LCBYTUxEVERFbGVtZW50LCBYTUxEVERFbnRpdHksIFhNTERURE5vdGF0aW9uLCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRWxlbWVudCwgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBYTUxSYXcsIFhNTFN0cmVhbVdyaXRlciwgWE1MVGV4dCwgWE1MV3JpdGVyQmFzZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9YTUxEZWNsYXJhdGlvbicpO1xuXG4gIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcblxuICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcblxuICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG5cbiAgWE1MRWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRWxlbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRFREQXR0TGlzdCA9IHJlcXVpcmUoJy4vWE1MRFREQXR0TGlzdCcpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERURE5vdGF0aW9uID0gcmVxdWlyZSgnLi9YTUxEVEROb3RhdGlvbicpO1xuXG4gIFhNTFdyaXRlckJhc2UgPSByZXF1aXJlKCcuL1hNTFdyaXRlckJhc2UnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFN0cmVhbVdyaXRlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFN0cmVhbVdyaXRlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxTdHJlYW1Xcml0ZXIoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICBYTUxTdHJlYW1Xcml0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICB9XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmRvY3VtZW50ID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIGosIGxlbiwgbGVuMSwgcmVmLCByZWYxLCByZXN1bHRzO1xuICAgICAgcmVmID0gZG9jLmNoaWxkcmVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICBjaGlsZC5pc0xhc3RSb290Tm9kZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZG9jLmNoaWxkcmVuW2RvYy5jaGlsZHJlbi5sZW5ndGggLSAxXS5pc0xhc3RSb290Tm9kZSA9IHRydWU7XG4gICAgICByZWYxID0gZG9jLmNoaWxkcmVuO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmMVtqXTtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERlY2xhcmF0aW9uKTpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmRlY2xhcmF0aW9uKGNoaWxkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKTpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmRvY1R5cGUoY2hpbGQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuY29tbWVudChjaGlsZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKTpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmVsZW1lbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24oYXR0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUoJyAnICsgYXR0Lm5hbWUgKyAnPVwiJyArIGF0dC52YWx1ZSArICdcIicpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IVtDREFUQVsnICsgbm9kZS50ZXh0ICsgJ11dPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhLS0gJyArIG5vZGUudGV4dCArICcgLS0+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkpO1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJzw/eG1sIHZlcnNpb249XCInICsgbm9kZS52ZXJzaW9uICsgJ1wiJyk7XG4gICAgICBpZiAobm9kZS5lbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgZW5jb2Rpbmc9XCInICsgbm9kZS5lbmNvZGluZyArICdcIicpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgc3RhbmRhbG9uZT1cIicgKyBub2RlLnN0YW5kYWxvbmUgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc/PicpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZG9jVHlwZSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSk7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPCFET0NUWVBFICcgKyBub2RlLnJvb3QoKS5uYW1lKTtcbiAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIicpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFsnKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICAgICAgcmVmID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRFREQXR0TGlzdCk6XG4gICAgICAgICAgICAgIHRoaXMuZHRkQXR0TGlzdChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERFbGVtZW50KTpcbiAgICAgICAgICAgICAgdGhpcy5kdGRFbGVtZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERUREVudGl0eSk6XG4gICAgICAgICAgICAgIHRoaXMuZHRkRW50aXR5KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERURE5vdGF0aW9uKTpcbiAgICAgICAgICAgICAgdGhpcy5kdGROb3RhdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDRGF0YSk6XG4gICAgICAgICAgICAgIHRoaXMuY2RhdGEoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MQ29tbWVudCk6XG4gICAgICAgICAgICAgIHRoaXMuY29tbWVudChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIERURCBub2RlIHR5cGU6IFwiICsgY2hpbGQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCddJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgYXR0LCBjaGlsZCwgaSwgbGVuLCBuYW1lLCByZWYsIHJlZjEsIHNwYWNlO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IHRoaXMuc3BhY2UobGV2ZWwpO1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoc3BhY2UgKyAnPCcgKyBub2RlLm5hbWUpO1xuICAgICAgcmVmID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgYXR0ID0gcmVmW25hbWVdO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHQpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IG5vZGUuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS52YWx1ZSA9PT0gJyc7XG4gICAgICB9KSkge1xuICAgICAgICBpZiAodGhpcy5hbGxvd0VtcHR5KSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJz48LycgKyBub2RlLm5hbWUgKyAnPicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICcvPicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJldHR5ICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChub2RlLmNoaWxkcmVuWzBdLnZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc+Jyk7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKG5vZGUuY2hpbGRyZW5bMF0udmFsdWUpO1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPC8nICsgbm9kZS5uYW1lICsgJz4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc+JyArIHRoaXMubmV3bGluZSk7XG4gICAgICAgIHJlZjEgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENEYXRhKTpcbiAgICAgICAgICAgICAgdGhpcy5jZGF0YShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDb21tZW50KTpcbiAgICAgICAgICAgICAgdGhpcy5jb21tZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTEVsZW1lbnQpOlxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MUmF3KTpcbiAgICAgICAgICAgICAgdGhpcy5yYXcoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MVGV4dCk6XG4gICAgICAgICAgICAgIHRoaXMudGV4dChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFhNTCBub2RlIHR5cGU6IFwiICsgY2hpbGQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHNwYWNlICsgJzwvJyArIG5vZGUubmFtZSArICc+Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkgKyAnPD8nICsgbm9kZS50YXJnZXQpO1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyAnICsgbm9kZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz8+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArIG5vZGUudmFsdWUgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgbm9kZS52YWx1ZSArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZHRkQXR0TGlzdCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IUFUVExJU1QgJyArIG5vZGUuZWxlbWVudE5hbWUgKyAnICcgKyBub2RlLmF0dHJpYnV0ZU5hbWUgKyAnICcgKyBub2RlLmF0dHJpYnV0ZVR5cGUpO1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlVHlwZSAhPT0gJyNERUZBVUxUJykge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnICcgKyBub2RlLmRlZmF1bHRWYWx1ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgXCInICsgbm9kZS5kZWZhdWx0VmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmR0ZEVsZW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkgKyAnPCFFTEVNRU5UICcgKyBub2RlLm5hbWUgKyAnICcgKyBub2RlLnZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmR0ZEVudGl0eSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IUVOVElUWScpO1xuICAgICAgaWYgKG5vZGUucGUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyAlJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSgnICcgKyBub2RlLm5hbWUpO1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBcIicgKyBub2RlLnZhbHVlICsgJ1wiJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5wdWJJRCAmJiBub2RlLnN5c0lEKSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgU1lTVEVNIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uRGF0YSkge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgTkRBVEEgJyArIG5vZGUubkRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5kdGROb3RhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IU5PVEFUSU9OICcgKyBub2RlLm5hbWUpO1xuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5wdWJJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZW5kbGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZS5pc0xhc3RSb290Tm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gWE1MU3RyZWFtV3JpdGVyO1xuXG4gIH0pKFhNTFdyaXRlckJhc2UpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTENEYXRhLCBYTUxDb21tZW50LCBYTUxEVERBdHRMaXN0LCBYTUxEVERFbGVtZW50LCBYTUxEVERFbnRpdHksIFhNTERURE5vdGF0aW9uLCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRWxlbWVudCwgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBYTUxSYXcsIFhNTFN0cmluZ1dyaXRlciwgWE1MVGV4dCwgWE1MV3JpdGVyQmFzZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9YTUxEZWNsYXJhdGlvbicpO1xuXG4gIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcblxuICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcblxuICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG5cbiAgWE1MRWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRWxlbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRFREQXR0TGlzdCA9IHJlcXVpcmUoJy4vWE1MRFREQXR0TGlzdCcpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERURE5vdGF0aW9uID0gcmVxdWlyZSgnLi9YTUxEVEROb3RhdGlvbicpO1xuXG4gIFhNTFdyaXRlckJhc2UgPSByZXF1aXJlKCcuL1hNTFdyaXRlckJhc2UnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFN0cmluZ1dyaXRlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFN0cmluZ1dyaXRlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxTdHJpbmdXcml0ZXIob3B0aW9ucykge1xuICAgICAgWE1MU3RyaW5nV3JpdGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByLCByZWY7XG4gICAgICB0aGlzLnRleHRpc3ByZXNlbnQgPSBmYWxzZTtcbiAgICAgIHIgPSAnJztcbiAgICAgIHJlZiA9IGRvYy5jaGlsZHJlbjtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgciArPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRGVjbGFyYXRpb24pOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbihjaGlsZCk7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jVHlwZShjaGlsZCk7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDb21tZW50KTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudChjaGlsZCk7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oY2hpbGQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChjaGlsZCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJldHR5ICYmIHIuc2xpY2UoLXRoaXMubmV3bGluZS5sZW5ndGgpID09PSB0aGlzLm5ld2xpbmUpIHtcbiAgICAgICAgciA9IHIuc2xpY2UoMCwgLXRoaXMubmV3bGluZS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24oYXR0KSB7XG4gICAgICByZXR1cm4gJyAnICsgYXR0Lm5hbWUgKyAnPVwiJyArIGF0dC52YWx1ZSArICdcIic7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhW0NEQVRBWycgKyBub2RlLnRleHQgKyAnXV0+JyArIHRoaXMubmV3bGluZTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYWNlKGxldmVsKSArICc8IS0tICcgKyBub2RlLnRleHQgKyAnIC0tPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICByID0gdGhpcy5zcGFjZShsZXZlbCk7XG4gICAgICByICs9ICc8P3htbCB2ZXJzaW9uPVwiJyArIG5vZGUudmVyc2lvbiArICdcIic7XG4gICAgICBpZiAobm9kZS5lbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHIgKz0gJyBlbmNvZGluZz1cIicgKyBub2RlLmVuY29kaW5nICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnN0YW5kYWxvbmUgIT0gbnVsbCkge1xuICAgICAgICByICs9ICcgc3RhbmRhbG9uZT1cIicgKyBub2RlLnN0YW5kYWxvbmUgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPz4nO1xuICAgICAgciArPSB0aGlzLm5ld2xpbmU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kb2NUeXBlID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByLCByZWY7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKTtcbiAgICAgIHIgKz0gJzwhRE9DVFlQRSAnICsgbm9kZS5yb290KCkubmFtZTtcbiAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHIgKz0gJyBbJztcbiAgICAgICAgciArPSB0aGlzLm5ld2xpbmU7XG4gICAgICAgIHJlZiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgIHIgKz0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERBdHRMaXN0KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kdGRBdHRMaXN0KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERFbGVtZW50KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kdGRFbGVtZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERFbnRpdHkpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR0ZEVudGl0eShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRFRETm90YXRpb24pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR0ZE5vdGF0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDRGF0YSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RhdGEoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ0luc3RydWN0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gRFREIG5vZGUgdHlwZTogXCIgKyBjaGlsZC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gJ10nO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPic7XG4gICAgICByICs9IHRoaXMubmV3bGluZTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIGF0dCwgY2hpbGQsIGksIGosIGxlbiwgbGVuMSwgbmFtZSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZSwgdGV4dGlzcHJlc2VudHdhc3NldDtcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgdGV4dGlzcHJlc2VudHdhc3NldCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMudGV4dGlzcHJlc2VudCkge1xuICAgICAgICB0aGlzLm5ld2xpbmUgPSAnJztcbiAgICAgICAgdGhpcy5wcmV0dHkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmV3bGluZSA9IHRoaXMubmV3bGluZWRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJldHR5ID0gdGhpcy5wcmV0dHlkZWZhdWx0O1xuICAgICAgfVxuICAgICAgc3BhY2UgPSB0aGlzLnNwYWNlKGxldmVsKTtcbiAgICAgIHIgPSAnJztcbiAgICAgIHIgKz0gc3BhY2UgKyAnPCcgKyBub2RlLm5hbWU7XG4gICAgICByZWYgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBhdHQgPSByZWZbbmFtZV07XG4gICAgICAgIHIgKz0gdGhpcy5hdHRyaWJ1dGUoYXR0KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBub2RlLmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudmFsdWUgPT09ICcnO1xuICAgICAgfSkpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dFbXB0eSkge1xuICAgICAgICAgIHIgKz0gJz48LycgKyBub2RlLm5hbWUgKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnLz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJldHR5ICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChub2RlLmNoaWxkcmVuWzBdLnZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgIHIgKz0gJz4nO1xuICAgICAgICByICs9IG5vZGUuY2hpbGRyZW5bMF0udmFsdWU7XG4gICAgICAgIHIgKz0gJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRvbnRwcmV0dHl0ZXh0bm9kZXMpIHtcbiAgICAgICAgICByZWYxID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZjFbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnRleHRpc3ByZXNlbnQrKztcbiAgICAgICAgICAgICAgdGV4dGlzcHJlc2VudHdhc3NldCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXh0aXNwcmVzZW50KSB7XG4gICAgICAgICAgdGhpcy5uZXdsaW5lID0gJyc7XG4gICAgICAgICAgdGhpcy5wcmV0dHkgPSBmYWxzZTtcbiAgICAgICAgICBzcGFjZSA9IHRoaXMuc3BhY2UobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICByZWYyID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjIubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYyW2pdO1xuICAgICAgICAgIHIgKz0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDRGF0YSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RhdGEoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTEVsZW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFJhdyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxUZXh0KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFhNTCBub2RlIHR5cGU6IFwiICsgY2hpbGQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dGlzcHJlc2VudHdhc3NldCkge1xuICAgICAgICAgIHRoaXMudGV4dGlzcHJlc2VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50ZXh0aXNwcmVzZW50KSB7XG4gICAgICAgICAgdGhpcy5uZXdsaW5lID0gdGhpcy5uZXdsaW5lZGVmYXVsdDtcbiAgICAgICAgICB0aGlzLnByZXR0eSA9IHRoaXMucHJldHR5ZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByICs9IHNwYWNlICsgJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8PycgKyBub2RlLnRhcmdldDtcbiAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHIgKz0gJyAnICsgbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz8+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyBub2RlLnZhbHVlICsgdGhpcy5uZXdsaW5lO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgbm9kZS52YWx1ZSArIHRoaXMubmV3bGluZTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kdGRBdHRMaXN0ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgciA9IHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhQVRUTElTVCAnICsgbm9kZS5lbGVtZW50TmFtZSArICcgJyArIG5vZGUuYXR0cmlidXRlTmFtZSArICcgJyArIG5vZGUuYXR0cmlidXRlVHlwZTtcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZVR5cGUgIT09ICcjREVGQVVMVCcpIHtcbiAgICAgICAgciArPSAnICcgKyBub2RlLmRlZmF1bHRWYWx1ZVR5cGU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgciArPSAnIFwiJyArIG5vZGUuZGVmYXVsdFZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZHRkRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCFFTEVNRU5UICcgKyBub2RlLm5hbWUgKyAnICcgKyBub2RlLnZhbHVlICsgdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmR0ZEVudGl0eSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8IUVOVElUWSc7XG4gICAgICBpZiAobm9kZS5wZSkge1xuICAgICAgICByICs9ICcgJSc7XG4gICAgICB9XG4gICAgICByICs9ICcgJyArIG5vZGUubmFtZTtcbiAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHIgKz0gJyBcIicgKyBub2RlLnZhbHVlICsgJ1wiJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubkRhdGEpIHtcbiAgICAgICAgICByICs9ICcgTkRBVEEgJyArIG5vZGUubkRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZHRkTm90YXRpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICByID0gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCFOT1RBVElPTiAnICsgbm9kZS5uYW1lO1xuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUucHViSUQpIHtcbiAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5vcGVuTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgYXR0LCBuYW1lLCByLCByZWY7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgWE1MRWxlbWVudCkge1xuICAgICAgICByID0gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCcgKyBub2RlLm5hbWU7XG4gICAgICAgIHJlZiA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dCA9IHJlZltuYW1lXTtcbiAgICAgICAgICByICs9IHRoaXMuYXR0cmlidXRlKGF0dCk7XG4gICAgICAgIH1cbiAgICAgICAgciArPSAobm9kZS5jaGlsZHJlbiA/ICc+JyA6ICcvPicpICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8IURPQ1RZUEUgJyArIG5vZGUucm9vdE5vZGVOYW1lO1xuICAgICAgICBpZiAobm9kZS5wdWJJRCAmJiBub2RlLnN5c0lEKSB7XG4gICAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gKG5vZGUuY2hpbGRyZW4gPyAnIFsnIDogJz4nKSArIHRoaXMubmV3bGluZTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuY2xvc2VOb2RlID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICEobm9kZSBpbnN0YW5jZW9mIFhNTEVsZW1lbnQpOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNwYWNlKGxldmVsKSArICc8LycgKyBub2RlLm5hbWUgKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIGNhc2UgIShub2RlIGluc3RhbmNlb2YgWE1MRG9jVHlwZSk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgJ10+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTFN0cmluZ1dyaXRlcjtcblxuICB9KShYTUxXcml0ZXJCYXNlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxTdHJpbmdpZmllcixcbiAgICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxTdHJpbmdpZmllciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxTdHJpbmdpZmllcihvcHRpb25zKSB7XG4gICAgICB0aGlzLmFzc2VydExlZ2FsQ2hhciA9IGJpbmQodGhpcy5hc3NlcnRMZWdhbENoYXIsIHRoaXMpO1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICB0aGlzLm5vRG91YmxlRW5jb2RpbmcgPSBvcHRpb25zLm5vRG91YmxlRW5jb2Rpbmc7XG4gICAgICByZWYgPSBvcHRpb25zLnN0cmluZ2lmeSB8fCB7fTtcbiAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZWxlTmFtZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmVsZVRleHQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHRoaXMuZWxFc2NhcGUodmFsKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgnXV0+JywgJ11dXV0+PCFbQ0RBVEFbPicpO1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICh2YWwubWF0Y2goLy0tLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudCB0ZXh0IGNhbm5vdCBjb250YWluIGRvdWJsZS1oeXBlbjogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dE5hbWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHJldHVybiB0aGlzLmF0dEVzY2FwZSh2YWwpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuaW5zVGFyZ2V0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5pbnNWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAodmFsLm1hdGNoKC9cXD8+LykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9jZXNzaW5nIGluc3RydWN0aW9uIHZhbHVlOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUueG1sVmVyc2lvbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAoIXZhbC5tYXRjaCgvMVxcLlswLTldKy8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbiBudW1iZXI6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxFbmNvZGluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAoIXZhbC5tYXRjaCgvXltBLVphLXpdKD86W0EtWmEtejAtOS5fLV0pKiQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVuY29kaW5nOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUueG1sU3RhbmRhbG9uZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICByZXR1cm4gXCJ5ZXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIm5vXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRQdWJJRCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkU3lzSUQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkQXR0VHlwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkQXR0RGVmYXVsdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRFbnRpdHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkTkRhdGEgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRBdHRLZXkgPSAnQCc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydFBJS2V5ID0gJz8nO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRUZXh0S2V5ID0gJyN0ZXh0JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0Q0RhdGFLZXkgPSAnI2NkYXRhJztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0Q29tbWVudEtleSA9ICcjY29tbWVudCc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydFJhd0tleSA9ICcjcmF3JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5hc3NlcnRMZWdhbENoYXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXM7XG4gICAgICByZXMgPSBzdHIubWF0Y2goL1tcXDBcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gc3RyaW5nOiBcIiArIHN0ciArIFwiIGF0IGluZGV4IFwiICsgcmVzLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5lbEVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGFtcHJlZ2V4O1xuICAgICAgYW1wcmVnZXggPSB0aGlzLm5vRG91YmxlRW5jb2RpbmcgPyAvKD8hJlxcUys7KSYvZyA6IC8mL2c7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYW1wcmVnZXgsICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFxyL2csICcmI3hEOycpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXR0RXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYW1wcmVnZXg7XG4gICAgICBhbXByZWdleCA9IHRoaXMubm9Eb3VibGVFbmNvZGluZyA/IC8oPyEmXFxTKzspJi9nIDogLyYvZztcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShhbXByZWdleCwgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC9cXHQvZywgJyYjeDk7JykucmVwbGFjZSgvXFxuL2csICcmI3hBOycpLnJlcGxhY2UoL1xcci9nLCAnJiN4RDsnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTFN0cmluZ2lmaWVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MTm9kZSwgWE1MVGV4dCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFRleHQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxUZXh0LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTFRleHQocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxUZXh0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZWxlbWVudCB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmVsZVRleHQodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MVGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxUZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS50ZXh0KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MVGV4dDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxXcml0ZXJCYXNlLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFdyaXRlckJhc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MV3JpdGVyQmFzZShvcHRpb25zKSB7XG4gICAgICB2YXIga2V5LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHZhbHVlO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHRoaXMucHJldHR5ID0gb3B0aW9ucy5wcmV0dHkgfHwgZmFsc2U7XG4gICAgICB0aGlzLmFsbG93RW1wdHkgPSAocmVmID0gb3B0aW9ucy5hbGxvd0VtcHR5KSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG4gICAgICBpZiAodGhpcy5wcmV0dHkpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAocmVmMSA9IG9wdGlvbnMuaW5kZW50KSAhPSBudWxsID8gcmVmMSA6ICcgICc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9IChyZWYyID0gb3B0aW9ucy5uZXdsaW5lKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgICB0aGlzLm9mZnNldCA9IChyZWYzID0gb3B0aW9ucy5vZmZzZXQpICE9IG51bGwgPyByZWYzIDogMDtcbiAgICAgICAgdGhpcy5kb250cHJldHR5dGV4dG5vZGVzID0gKHJlZjQgPSBvcHRpb25zLmRvbnRwcmV0dHl0ZXh0bm9kZXMpICE9IG51bGwgPyByZWY0IDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gJyc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9ICcnO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZG9udHByZXR0eXRleHRub2RlcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPSAocmVmNSA9IG9wdGlvbnMuc3BhY2ViZWZvcmVzbGFzaCkgIT0gbnVsbCA/IHJlZjUgOiAnJztcbiAgICAgIGlmICh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zcGFjZWJlZm9yZXNsYXNoID0gJyAnO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXdsaW5lZGVmYXVsdCA9IHRoaXMubmV3bGluZTtcbiAgICAgIHRoaXMucHJldHR5ZGVmYXVsdCA9IHRoaXMucHJldHR5O1xuICAgICAgcmVmNiA9IG9wdGlvbnMud3JpdGVyIHx8IHt9O1xuICAgICAgZm9yIChrZXkgaW4gcmVmNikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWY2LCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWY2W2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTFdyaXRlckJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgaWYgKFwicHJldHR5XCIgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnByZXR0eSA9IG9wdGlvbnMucHJldHR5O1xuICAgICAgfVxuICAgICAgaWYgKFwiYWxsb3dFbXB0eVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hbGxvd0VtcHR5ID0gb3B0aW9ucy5hbGxvd0VtcHR5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJldHR5KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gXCJpbmRlbnRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbmRlbnQgOiAnICAnO1xuICAgICAgICB0aGlzLm5ld2xpbmUgPSBcIm5ld2xpbmVcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5uZXdsaW5lIDogJ1xcbic7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gXCJvZmZzZXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5vZmZzZXQgOiAwO1xuICAgICAgICB0aGlzLmRvbnRwcmV0dHl0ZXh0bm9kZXMgPSBcImRvbnRwcmV0dHl0ZXh0bm9kZXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kb250cHJldHR5dGV4dG5vZGVzIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gJyc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9ICcnO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZG9udHByZXR0eXRleHRub2RlcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPSBcInNwYWNlYmVmb3Jlc2xhc2hcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zcGFjZWJlZm9yZXNsYXNoIDogJyc7XG4gICAgICBpZiAodGhpcy5zcGFjZWJlZm9yZXNsYXNoID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3BhY2ViZWZvcmVzbGFzaCA9ICcgJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV3bGluZWRlZmF1bHQgPSB0aGlzLm5ld2xpbmU7XG4gICAgICB0aGlzLnByZXR0eWRlZmF1bHQgPSB0aGlzLnByZXR0eTtcbiAgICAgIHJlZiA9IG9wdGlvbnMud3JpdGVyIHx8IHt9O1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTFdyaXRlckJhc2UucHJvdG90eXBlLnNwYWNlID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQ7XG4gICAgICBpZiAodGhpcy5wcmV0dHkpIHtcbiAgICAgICAgaW5kZW50ID0gKGxldmVsIHx8IDApICsgdGhpcy5vZmZzZXQgKyAxO1xuICAgICAgICBpZiAoaW5kZW50ID4gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkoaW5kZW50KS5qb2luKHRoaXMuaW5kZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTFdyaXRlckJhc2U7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEb2N1bWVudCwgWE1MRG9jdW1lbnRDQiwgWE1MU3RyZWFtV3JpdGVyLCBYTUxTdHJpbmdXcml0ZXIsIGFzc2lnbiwgaXNGdW5jdGlvbiwgcmVmO1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4vVXRpbGl0eScpLCBhc3NpZ24gPSByZWYuYXNzaWduLCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb247XG5cbiAgWE1MRG9jdW1lbnQgPSByZXF1aXJlKCcuL1hNTERvY3VtZW50Jyk7XG5cbiAgWE1MRG9jdW1lbnRDQiA9IHJlcXVpcmUoJy4vWE1MRG9jdW1lbnRDQicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgWE1MU3RyZWFtV3JpdGVyID0gcmVxdWlyZSgnLi9YTUxTdHJlYW1Xcml0ZXInKTtcblxuICBtb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lLCB4bWxkZWMsIGRvY3R5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jLCByb290O1xuICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgZWxlbWVudCBuZWVkcyBhIG5hbWVcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIHhtbGRlYywgZG9jdHlwZSwgb3B0aW9ucyk7XG4gICAgZG9jID0gbmV3IFhNTERvY3VtZW50KG9wdGlvbnMpO1xuICAgIHJvb3QgPSBkb2MuZWxlbWVudChuYW1lKTtcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGxlc3MpIHtcbiAgICAgIGRvYy5kZWNsYXJhdGlvbihvcHRpb25zKTtcbiAgICAgIGlmICgob3B0aW9ucy5wdWJJRCAhPSBudWxsKSB8fCAob3B0aW9ucy5zeXNJRCAhPSBudWxsKSkge1xuICAgICAgICBkb2MuZG9jdHlwZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuYmVnaW4gPSBmdW5jdGlvbihvcHRpb25zLCBvbkRhdGEsIG9uRW5kKSB7XG4gICAgdmFyIHJlZjE7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgIHJlZjEgPSBbb3B0aW9ucywgb25EYXRhXSwgb25EYXRhID0gcmVmMVswXSwgb25FbmQgPSByZWYxWzFdO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob25EYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTERvY3VtZW50Q0Iob3B0aW9ucywgb25EYXRhLCBvbkVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgWE1MRG9jdW1lbnQob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLnN0cmluZ1dyaXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFhNTFN0cmluZ1dyaXRlcihvcHRpb25zKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5zdHJlYW1Xcml0ZXIgPSBmdW5jdGlvbihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFhNTFN0cmVhbVdyaXRlcihzdHJlYW0sIG9wdGlvbnMpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29uc29sZVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGdyYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZG9tYWluXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9zXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmluZ19kZWNvZGVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRpbWVyc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgbWlkZHkgPSAoYmFzZUhhbmRsZXIgPSAoKSA9PiB7fSwgcGx1Z2luKSA9PiB7XG4gIHZhciBfcGx1Z2luJGJlZm9yZVByZWZldGM7XG5cbiAgcGx1Z2luID09PSBudWxsIHx8IHBsdWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wbHVnaW4kYmVmb3JlUHJlZmV0YyA9IHBsdWdpbi5iZWZvcmVQcmVmZXRjaCkgPT09IG51bGwgfHwgX3BsdWdpbiRiZWZvcmVQcmVmZXRjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGx1Z2luJGJlZm9yZVByZWZldGMuY2FsbChwbHVnaW4pO1xuICBjb25zdCBiZWZvcmVNaWRkbGV3YXJlcyA9IFtdO1xuICBjb25zdCBhZnRlck1pZGRsZXdhcmVzID0gW107XG4gIGNvbnN0IG9uRXJyb3JNaWRkbGV3YXJlcyA9IFtdO1xuXG4gIGNvbnN0IGluc3RhbmNlID0gKGV2ZW50ID0ge30sIGNvbnRleHQgPSB7fSkgPT4ge1xuICAgIHZhciBfcGx1Z2luJHJlcXVlc3RTdGFydDtcblxuICAgIHBsdWdpbiA9PT0gbnVsbCB8fCBwbHVnaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcGx1Z2luJHJlcXVlc3RTdGFydCA9IHBsdWdpbi5yZXF1ZXN0U3RhcnQpID09PSBudWxsIHx8IF9wbHVnaW4kcmVxdWVzdFN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGx1Z2luJHJlcXVlc3RTdGFydC5jYWxsKHBsdWdpbik7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGV2ZW50LFxuICAgICAgY29udGV4dCxcbiAgICAgIHJlc3BvbnNlOiB1bmRlZmluZWQsXG4gICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHt9XG4gICAgfTtcbiAgICByZXR1cm4gcnVuUmVxdWVzdChyZXF1ZXN0LCBbLi4uYmVmb3JlTWlkZGxld2FyZXNdLCBiYXNlSGFuZGxlciwgWy4uLmFmdGVyTWlkZGxld2FyZXNdLCBbLi4ub25FcnJvck1pZGRsZXdhcmVzXSwgcGx1Z2luKTtcbiAgfTtcblxuICBpbnN0YW5jZS51c2UgPSBtaWRkbGV3YXJlcyA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWlkZGxld2FyZXMpKSB7XG4gICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgbWlkZGxld2FyZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuYXBwbHlNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlLmFwcGx5TWlkZGxld2FyZShtaWRkbGV3YXJlcyk7XG4gIH07XG5cbiAgaW5zdGFuY2UuYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYmVmb3JlLFxuICAgICAgYWZ0ZXIsXG4gICAgICBvbkVycm9yXG4gICAgfSA9IG1pZGRsZXdhcmU7XG5cbiAgICBpZiAoIWJlZm9yZSAmJiAhYWZ0ZXIgJiYgIW9uRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlkZGxld2FyZSBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBrZXkgYW1vbmcgXCJiZWZvcmVcIiwgXCJhZnRlclwiLCBcIm9uRXJyb3JcIicpO1xuICAgIH1cblxuICAgIGlmIChiZWZvcmUpIGluc3RhbmNlLmJlZm9yZShiZWZvcmUpO1xuICAgIGlmIChhZnRlcikgaW5zdGFuY2UuYWZ0ZXIoYWZ0ZXIpO1xuICAgIGlmIChvbkVycm9yKSBpbnN0YW5jZS5vbkVycm9yKG9uRXJyb3IpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTsgLy8gSW5saW5lIE1pZGRsZXdhcmVzXG5cblxuICBpbnN0YW5jZS5iZWZvcmUgPSBiZWZvcmVNaWRkbGV3YXJlID0+IHtcbiAgICBiZWZvcmVNaWRkbGV3YXJlcy5wdXNoKGJlZm9yZU1pZGRsZXdhcmUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBpbnN0YW5jZS5hZnRlciA9IGFmdGVyTWlkZGxld2FyZSA9PiB7XG4gICAgYWZ0ZXJNaWRkbGV3YXJlcy51bnNoaWZ0KGFmdGVyTWlkZGxld2FyZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLm9uRXJyb3IgPSBvbkVycm9yTWlkZGxld2FyZSA9PiB7XG4gICAgb25FcnJvck1pZGRsZXdhcmVzLnB1c2gob25FcnJvck1pZGRsZXdhcmUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBpbnN0YW5jZS5fX21pZGRsZXdhcmVzID0ge1xuICAgIGJlZm9yZTogYmVmb3JlTWlkZGxld2FyZXMsXG4gICAgYWZ0ZXI6IGFmdGVyTWlkZGxld2FyZXMsXG4gICAgb25FcnJvcjogb25FcnJvck1pZGRsZXdhcmVzXG4gIH07XG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbmNvbnN0IHJ1blJlcXVlc3QgPSBhc3luYyAocmVxdWVzdCwgYmVmb3JlTWlkZGxld2FyZXMsIGJhc2VIYW5kbGVyLCBhZnRlck1pZGRsZXdhcmVzLCBvbkVycm9yTWlkZGxld2FyZXMsIHBsdWdpbikgPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IHJ1bk1pZGRsZXdhcmVzKHJlcXVlc3QsIGJlZm9yZU1pZGRsZXdhcmVzLCBwbHVnaW4pOyAvLyBDaGVjayBpZiBiZWZvcmUgc3RhY2sgaGFzbid0IGV4aXQgZWFybHlcblxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfcGx1Z2luJGJlZm9yZUhhbmRsZXIsIF9wbHVnaW4kYWZ0ZXJIYW5kbGVyO1xuXG4gICAgICBwbHVnaW4gPT09IG51bGwgfHwgcGx1Z2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3BsdWdpbiRiZWZvcmVIYW5kbGVyID0gcGx1Z2luLmJlZm9yZUhhbmRsZXIpID09PSBudWxsIHx8IF9wbHVnaW4kYmVmb3JlSGFuZGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BsdWdpbiRiZWZvcmVIYW5kbGVyLmNhbGwocGx1Z2luKTtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2UgPSBhd2FpdCBiYXNlSGFuZGxlcihyZXF1ZXN0LmV2ZW50LCByZXF1ZXN0LmNvbnRleHQpO1xuICAgICAgcGx1Z2luID09PSBudWxsIHx8IHBsdWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wbHVnaW4kYWZ0ZXJIYW5kbGVyID0gcGx1Z2luLmFmdGVySGFuZGxlcikgPT09IG51bGwgfHwgX3BsdWdpbiRhZnRlckhhbmRsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wbHVnaW4kYWZ0ZXJIYW5kbGVyLmNhbGwocGx1Z2luKTtcbiAgICAgIGF3YWl0IHJ1bk1pZGRsZXdhcmVzKHJlcXVlc3QsIGFmdGVyTWlkZGxld2FyZXMsIHBsdWdpbik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUmVzZXQgcmVzcG9uc2UgY2hhbmdlcyBtYWRlIGJ5IGFmdGVyIHN0YWNrIGJlZm9yZSBlcnJvciB0aHJvd25cbiAgICByZXF1ZXN0LnJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIHJlcXVlc3QuZXJyb3IgPSBlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJ1bk1pZGRsZXdhcmVzKHJlcXVlc3QsIG9uRXJyb3JNaWRkbGV3YXJlcywgcGx1Z2luKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBTYXZlIGVycm9yIHRoYXQgd2Fzbid0IGhhbmRsZWRcbiAgICAgIGUub3JpZ2luYWxFcnJvciA9IHJlcXVlc3QuZXJyb3I7XG4gICAgICByZXF1ZXN0LmVycm9yID0gZTtcbiAgICAgIHRocm93IHJlcXVlc3QuZXJyb3I7XG4gICAgfSAvLyBDYXRjaCBpZiBvbkVycm9yIHN0YWNrIGhhc24ndCBoYW5kbGVkIHRoZSBlcnJvclxuXG5cbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB0aHJvdyByZXF1ZXN0LmVycm9yO1xuICB9IGZpbmFsbHkge1xuICAgIHZhciBfcGx1Z2luJHJlcXVlc3RFbmQ7XG5cbiAgICBhd2FpdCAocGx1Z2luID09PSBudWxsIHx8IHBsdWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wbHVnaW4kcmVxdWVzdEVuZCA9IHBsdWdpbi5yZXF1ZXN0RW5kKSA9PT0gbnVsbCB8fCBfcGx1Z2luJHJlcXVlc3RFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wbHVnaW4kcmVxdWVzdEVuZC5jYWxsKHBsdWdpbiwgcmVxdWVzdCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2U7XG59O1xuXG5jb25zdCBydW5NaWRkbGV3YXJlcyA9IGFzeW5jIChyZXF1ZXN0LCBtaWRkbGV3YXJlcywgcGx1Z2luKSA9PiB7XG4gIGZvciAoY29uc3QgbmV4dE1pZGRsZXdhcmUgb2YgbWlkZGxld2FyZXMpIHtcbiAgICB2YXIgX3BsdWdpbiRiZWZvcmVNaWRkbGV3LCBfcGx1Z2luJGFmdGVyTWlkZGxld2E7XG5cbiAgICBwbHVnaW4gPT09IG51bGwgfHwgcGx1Z2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3BsdWdpbiRiZWZvcmVNaWRkbGV3ID0gcGx1Z2luLmJlZm9yZU1pZGRsZXdhcmUpID09PSBudWxsIHx8IF9wbHVnaW4kYmVmb3JlTWlkZGxldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BsdWdpbiRiZWZvcmVNaWRkbGV3LmNhbGwocGx1Z2luLCBuZXh0TWlkZGxld2FyZSA9PT0gbnVsbCB8fCBuZXh0TWlkZGxld2FyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dE1pZGRsZXdhcmUubmFtZSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgKG5leHRNaWRkbGV3YXJlID09PSBudWxsIHx8IG5leHRNaWRkbGV3YXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0TWlkZGxld2FyZShyZXF1ZXN0KSk7XG4gICAgcGx1Z2luID09PSBudWxsIHx8IHBsdWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wbHVnaW4kYWZ0ZXJNaWRkbGV3YSA9IHBsdWdpbi5hZnRlck1pZGRsZXdhcmUpID09PSBudWxsIHx8IF9wbHVnaW4kYWZ0ZXJNaWRkbGV3YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BsdWdpbiRhZnRlck1pZGRsZXdhLmNhbGwocGx1Z2luLCBuZXh0TWlkZGxld2FyZSA9PT0gbnVsbCB8fCBuZXh0TWlkZGxld2FyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dE1pZGRsZXdhcmUubmFtZSk7IC8vIHNob3J0IGNpcmN1aXQgY2hhaW5pbmcgYW5kIHJlc3BvbmQgZWFybHlcblxuICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZSA9IHJlcztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWlkZHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3Qge1xuICBub3JtYWxpemVIdHRwUmVzcG9uc2Vcbn0gPSByZXF1aXJlKCdAbWlkZHkvdXRpbCcpO1xuXG5jb25zdCBnZXRPcmlnaW4gPSAoaW5jb21pbmdPcmlnaW4sIG9wdGlvbnMpID0+IHtcbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3JpZ2lucy5sZW5ndGgpID4gMCkge1xuICAgIGlmIChpbmNvbWluZ09yaWdpbiAmJiBvcHRpb25zLm9yaWdpbnMuaW5jbHVkZXMoaW5jb21pbmdPcmlnaW4pKSB7XG4gICAgICByZXR1cm4gaW5jb21pbmdPcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9yaWdpbnNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpbmNvbWluZ09yaWdpbiAmJiBvcHRpb25zLmNyZWRlbnRpYWxzICYmIG9wdGlvbnMub3JpZ2luID09PSAnKicpIHtcbiAgICAgIHJldHVybiBpbmNvbWluZ09yaWdpbjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucy5vcmlnaW47XG4gIH1cbn07XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBnZXRPcmlnaW4sXG4gIGNyZWRlbnRpYWxzOiB1bmRlZmluZWQsXG4gIGhlYWRlcnM6IHVuZGVmaW5lZCxcbiAgbWV0aG9kczogdW5kZWZpbmVkLFxuICBvcmlnaW46ICcqJyxcbiAgb3JpZ2luczogW10sXG4gIGV4cG9zZUhlYWRlcnM6IHVuZGVmaW5lZCxcbiAgbWF4QWdlOiB1bmRlZmluZWQsXG4gIHJlcXVlc3RIZWFkZXJzOiB1bmRlZmluZWQsXG4gIHJlcXVlc3RNZXRob2RzOiB1bmRlZmluZWQsXG4gIGNhY2hlQ29udHJvbDogdW5kZWZpbmVkXG59O1xuXG5jb25zdCBodHRwQ29yc01pZGRsZXdhcmUgPSAob3B0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRzLFxuICAgIC4uLm9wdHNcbiAgfTtcblxuICBjb25zdCBodHRwQ29yc01pZGRsZXdhcmVBZnRlciA9IGFzeW5jIHJlcXVlc3QgPT4ge1xuICAgIHZhciBfcmVxdWVzdCRldmVudCwgX3JlcXVlc3QkZXZlbnQyLCBfcmVxdWVzdCRldmVudDIkcmVxdWUsIF9yZXF1ZXN0JGV2ZW50MiRyZXF1ZTI7XG5cbiAgICAvLyBBUEkgR2F0ZXdheSB2MSAmIHYyXG4gICAgaWYgKCEoKF9yZXF1ZXN0JGV2ZW50ID0gcmVxdWVzdC5ldmVudCkgIT09IG51bGwgJiYgX3JlcXVlc3QkZXZlbnQgIT09IHZvaWQgMCAmJiBfcmVxdWVzdCRldmVudC5odHRwTWV0aG9kKSAmJiAhKChfcmVxdWVzdCRldmVudDIgPSByZXF1ZXN0LmV2ZW50KSAhPT0gbnVsbCAmJiBfcmVxdWVzdCRldmVudDIgIT09IHZvaWQgMCAmJiAoX3JlcXVlc3QkZXZlbnQyJHJlcXVlID0gX3JlcXVlc3QkZXZlbnQyLnJlcXVlc3RDb250ZXh0KSAhPT0gbnVsbCAmJiBfcmVxdWVzdCRldmVudDIkcmVxdWUgIT09IHZvaWQgMCAmJiAoX3JlcXVlc3QkZXZlbnQyJHJlcXVlMiA9IF9yZXF1ZXN0JGV2ZW50MiRyZXF1ZS5odHRwKSAhPT0gbnVsbCAmJiBfcmVxdWVzdCRldmVudDIkcmVxdWUyICE9PSB2b2lkIDAgJiYgX3JlcXVlc3QkZXZlbnQyJHJlcXVlMi5tZXRob2QpKSByZXR1cm47XG4gICAgcmVxdWVzdC5yZXNwb25zZSA9IG5vcm1hbGl6ZUh0dHBSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICBjb25zdCBleGlzdGluZ0hlYWRlcnMgPSBPYmplY3Qua2V5cyhyZXF1ZXN0LnJlc3BvbnNlLmhlYWRlcnMpOyAvLyBDaGVjayBpZiBhbHJlYWR5IHNldHVwIHRoZSBoZWFkZXIgQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcblxuICAgIGlmIChleGlzdGluZ0hlYWRlcnMuaW5jbHVkZXMoJ0FjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzJykpIHtcbiAgICAgIG9wdGlvbnMuY3JlZGVudGlhbHMgPSByZXF1ZXN0LnJlc3BvbnNlLmhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzJ10gPT09ICd0cnVlJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZS5oZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscyddID0gU3RyaW5nKG9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgIH0gLy8gQ2hlY2sgaWYgYWxyZWFkeSBzZXR1cCBBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXG5cblxuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgJiYgIWV4aXN0aW5nSGVhZGVycy5pbmNsdWRlcygnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycycpKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlLmhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnXSA9IG9wdGlvbnMuaGVhZGVycztcbiAgICB9IC8vIENoZWNrIGlmIGFscmVhZHkgc2V0dXAgQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc1xuXG5cbiAgICBpZiAob3B0aW9ucy5tZXRob2RzICYmICFleGlzdGluZ0hlYWRlcnMuaW5jbHVkZXMoJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnKSkge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZS5oZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJ10gPSBvcHRpb25zLm1ldGhvZHM7XG4gICAgfSAvLyBDaGVjayBpZiBhbHJlYWR5IHNldHVwIHRoZSBoZWFkZXIgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXG5cblxuICAgIGlmICghZXhpc3RpbmdIZWFkZXJzLmluY2x1ZGVzKCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nKSkge1xuICAgICAgdmFyIF9yZXF1ZXN0JGV2ZW50JGhlYWRlciwgX3JlcXVlc3QkZXZlbnQzLCBfZXZlbnRIZWFkZXJzJG9yaWdpbjtcblxuICAgICAgY29uc3QgZXZlbnRIZWFkZXJzID0gKF9yZXF1ZXN0JGV2ZW50JGhlYWRlciA9IChfcmVxdWVzdCRldmVudDMgPSByZXF1ZXN0LmV2ZW50KSA9PT0gbnVsbCB8fCBfcmVxdWVzdCRldmVudDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXF1ZXN0JGV2ZW50My5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfcmVxdWVzdCRldmVudCRoZWFkZXIgIT09IHZvaWQgMCA/IF9yZXF1ZXN0JGV2ZW50JGhlYWRlciA6IHt9O1xuICAgICAgY29uc3QgaW5jb21pbmdPcmlnaW4gPSAoX2V2ZW50SGVhZGVycyRvcmlnaW4gPSBldmVudEhlYWRlcnMub3JpZ2luKSAhPT0gbnVsbCAmJiBfZXZlbnRIZWFkZXJzJG9yaWdpbiAhPT0gdm9pZCAwID8gX2V2ZW50SGVhZGVycyRvcmlnaW4gOiBldmVudEhlYWRlcnMuT3JpZ2luO1xuICAgICAgcmVxdWVzdC5yZXNwb25zZS5oZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nXSA9IG9wdGlvbnMuZ2V0T3JpZ2luKGluY29taW5nT3JpZ2luLCBvcHRpb25zKTtcbiAgICB9IC8vIENoZWNrIGlmIGFscmVhZHkgc2V0dXAgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNcblxuXG4gICAgaWYgKG9wdGlvbnMuZXhwb3NlSGVhZGVycyAmJiAhZXhpc3RpbmdIZWFkZXJzLmluY2x1ZGVzKCdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycpKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlLmhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzJ10gPSBvcHRpb25zLmV4cG9zZUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmICFleGlzdGluZ0hlYWRlcnMuaW5jbHVkZXMoJ0FjY2Vzcy1Db250cm9sLU1heC1BZ2UnKSkge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZS5oZWFkZXJzWydBY2Nlc3MtQ29udHJvbC1NYXgtQWdlJ10gPSBTdHJpbmcob3B0aW9ucy5tYXhBZ2UpO1xuICAgIH0gLy8gQ2hlY2sgaWYgYWxyZWFkeSBzZXR1cCBBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNcblxuXG4gICAgaWYgKG9wdGlvbnMucmVxdWVzdEhlYWRlcnMgJiYgIWV4aXN0aW5nSGVhZGVycy5pbmNsdWRlcygnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJykpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2UuaGVhZGVyc1snQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJ10gPSBvcHRpb25zLnJlcXVlc3RIZWFkZXJzO1xuICAgIH0gLy8gQ2hlY2sgaWYgYWxyZWFkeSBzZXR1cCBBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZHNcblxuXG4gICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMucmVxdWVzdE1ldGhvZHMgJiYgIWV4aXN0aW5nSGVhZGVycy5pbmNsdWRlcygnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2RzJykpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2UuaGVhZGVyc1snQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2RzJ10gPSBvcHRpb25zLnJlcXVlc3RNZXRob2RzO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmV2ZW50Lmh0dHBNZXRob2QgPT09ICdPUFRJT05TJykge1xuICAgICAgaWYgKG9wdGlvbnMuY2FjaGVDb250cm9sICYmICFleGlzdGluZ0hlYWRlcnMuaW5jbHVkZXMoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlLmhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXSA9IFN0cmluZyhvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGh0dHBDb3JzTWlkZGxld2FyZU9uRXJyb3IgPSBodHRwQ29yc01pZGRsZXdhcmVBZnRlcjtcbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogaHR0cENvcnNNaWRkbGV3YXJlQWZ0ZXIsXG4gICAgb25FcnJvcjogaHR0cENvcnNNaWRkbGV3YXJlT25FcnJvclxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBodHRwQ29yc01pZGRsZXdhcmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3Qge1xuICBBZ2VudFxufSA9IHJlcXVpcmUoJ2h0dHBzJyk7IC8vIGNvbnN0IHsgTm9kZUh0dHBIYW5kbGVyIH0gPSByZXF1aXJlKCdAYXdzLXNkay9ub2RlLWh0dHAtaGFuZGxlcicpIC8vIGF3cy1zZGsgdjNcblxuXG5jb25zdCBhd3NDbGllbnREZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gQVdTIFNESyB2M1xuICAvLyBEb2NzOiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vc2RrLWZvci1qYXZhc2NyaXB0L3YzL2RldmVsb3Blci1ndWlkZS9lbmZvcmNpbmctdGxzLmh0bWxcblxuICAvKiByZXF1ZXN0SGFuZGxlcjogbmV3IE5vZGVIdHRwSGFuZGxlcih7XG4gICAgaHR0cHNBZ2VudDogbmV3IEFnZW50KFxuICAgICAge1xuICAgICAgICBzZWN1cmVQcm90b2NvbDogJ1RMU3YxXzJfbWV0aG9kJ1xuICAgICAgfVxuICAgIClcbiAgfSkgKi9cbiAgLy8gRG9jczogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3Nkay1mb3ItamF2YXNjcmlwdC92Mi9kZXZlbG9wZXItZ3VpZGUvZW5mb3JjaW5nLXRscy5odG1sXG4gIGh0dHBPcHRpb25zOiB7XG4gICAgYWdlbnQ6IG5ldyBBZ2VudCh7XG4gICAgICBzZWN1cmVQcm90b2NvbDogJ1RMU3YxXzJfbWV0aG9kJ1xuICAgIH0pXG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVByZWZldGNoQ2xpZW50ID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGF3c0NsaWVudE9wdGlvbnMgPSB7IC4uLmF3c0NsaWVudERlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnMuYXdzQ2xpZW50T3B0aW9uc1xuICB9O1xuICBjb25zdCBjbGllbnQgPSBuZXcgb3B0aW9ucy5Bd3NDbGllbnQoYXdzQ2xpZW50T3B0aW9ucyk7IC8vIEFXUyBYUmF5XG5cbiAgaWYgKG9wdGlvbnMuYXdzQ2xpZW50Q2FwdHVyZSkge1xuICAgIHJldHVybiBvcHRpb25zLmF3c0NsaWVudENhcHR1cmUoY2xpZW50KTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnQ7XG59O1xuXG5jb25zdCBjcmVhdGVDbGllbnQgPSBhc3luYyAob3B0aW9ucywgcmVxdWVzdCkgPT4ge1xuICBsZXQgYXdzQ2xpZW50Q3JlZGVudGlhbHMgPSB7fTsgLy8gUm9sZSBDcmVkZW50aWFsc1xuXG4gIGlmIChvcHRpb25zLmF3c0NsaWVudEFzc3VtZVJvbGUpIHtcbiAgICBpZiAoIXJlcXVlc3QpIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCByZXF1aXJlZCB3aGVuIGFzc3VtaW5nIHJvbGUnKTtcbiAgICBhd3NDbGllbnRDcmVkZW50aWFscyA9IGF3YWl0IGdldEludGVybmFsKHtcbiAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLmF3c0NsaWVudEFzc3VtZVJvbGVcbiAgICB9LCByZXF1ZXN0KTtcbiAgfVxuXG4gIGF3c0NsaWVudENyZWRlbnRpYWxzID0geyAuLi5hd3NDbGllbnRDcmVkZW50aWFscyxcbiAgICAuLi5vcHRpb25zLmF3c0NsaWVudE9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZVByZWZldGNoQ2xpZW50KHsgLi4ub3B0aW9ucyxcbiAgICBhd3NDbGllbnRPcHRpb25zOiBhd3NDbGllbnRDcmVkZW50aWFsc1xuICB9KTtcbn07XG5cbmNvbnN0IGNhblByZWZldGNoID0gb3B0aW9ucyA9PiB7XG4gIHJldHVybiAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYXdzQ2xpZW50QXNzdW1lUm9sZSkgJiYgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmRpc2FibGVQcmVmZXRjaCk7XG59OyAvLyBJbnRlcm5hbCBDb250ZXh0XG5cblxuY29uc3QgZ2V0SW50ZXJuYWwgPSBhc3luYyAodmFyaWFibGVzLCByZXF1ZXN0KSA9PiB7XG4gIGlmICghdmFyaWFibGVzIHx8ICFyZXF1ZXN0KSByZXR1cm4ge307XG4gIGxldCBrZXlzID0gW107XG4gIGxldCB2YWx1ZXMgPSBbXTtcblxuICBpZiAodmFyaWFibGVzID09PSB0cnVlKSB7XG4gICAga2V5cyA9IHZhbHVlcyA9IE9iamVjdC5rZXlzKHJlcXVlc3QuaW50ZXJuYWwpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5cyA9IHZhbHVlcyA9IFt2YXJpYWJsZXNdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFyaWFibGVzKSkge1xuICAgIGtleXMgPSB2YWx1ZXMgPSB2YXJpYWJsZXM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlcyA9PT0gJ29iamVjdCcpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFyaWFibGVzKTtcbiAgICB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHZhcmlhYmxlcyk7XG4gIH1cblxuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gIGZvciAoY29uc3QgaW50ZXJuYWxLZXkgb2YgdmFsdWVzKSB7XG4gICAgdmFyIF92YWx1ZVByb21pc2U7XG5cbiAgICAvLyAnaW50ZXJuYWwua2V5LnN1Yl92YWx1ZScgLT4geyBba2V5XTogaW50ZXJuYWwua2V5LnN1Yl92YWx1ZSB9XG4gICAgY29uc3QgcGF0aE9wdGlvbktleSA9IGludGVybmFsS2V5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgcm9vdE9wdGlvbktleSA9IHBhdGhPcHRpb25LZXkuc2hpZnQoKTtcbiAgICBsZXQgdmFsdWVQcm9taXNlID0gcmVxdWVzdC5pbnRlcm5hbFtyb290T3B0aW9uS2V5XTtcblxuICAgIGlmICh0eXBlb2YgKChfdmFsdWVQcm9taXNlID0gdmFsdWVQcm9taXNlKSA9PT0gbnVsbCB8fCBfdmFsdWVQcm9taXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmFsdWVQcm9taXNlLnRoZW4pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodmFsdWVQcm9taXNlKTtcbiAgICB9XG5cbiAgICBwcm9taXNlcy5wdXNoKHZhbHVlUHJvbWlzZS50aGVuKHZhbHVlID0+IHBhdGhPcHRpb25LZXkucmVkdWNlKChwLCBjKSA9PiBwID09PSBudWxsIHx8IHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBbY10sIHZhbHVlKSkpO1xuICB9IC8vIGVuc3VyZSBwcm9taXNlIGhhcyByZXNvbHZlZCBieSB0aGUgdGltZSBpdCdzIG5lZWRlZFxuICAvLyBJZiBvbmUgb2YgdGhlIHByb21pc2VzIHRocm93cyBpdCB3aWxsIGJ1YmJsZSB1cCB0byBAbWlkZHkvY29yZVxuXG5cbiAgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcbiAgY29uc3QgZXJyb3JzID0gdmFsdWVzLmZpbHRlcihyZXMgPT4gcmVzLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykubWFwKHJlcyA9PiByZXMucmVhc29uLm1lc3NhZ2UpO1xuICBpZiAoZXJyb3JzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGVycm9ycykpO1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKG9iaiwga2V5LCBpbmRleCkgPT4gKHsgLi4ub2JqLFxuICAgIFtzYW5pdGl6ZUtleShrZXkpXTogdmFsdWVzW2luZGV4XS52YWx1ZVxuICB9KSwge30pO1xufTtcblxuY29uc3Qgc2FuaXRpemVLZXlQcmVmaXhMZWFkaW5nTnVtYmVyID0gL14oWzAtOV0pLztcbmNvbnN0IHNhbml0aXplS2V5UmVtb3ZlRGlzYWxsb3dlZENoYXIgPSAvW15hLXpBLVowLTldKy9nO1xuXG5jb25zdCBzYW5pdGl6ZUtleSA9IGtleSA9PiB7XG4gIHJldHVybiBrZXkucmVwbGFjZShzYW5pdGl6ZUtleVByZWZpeExlYWRpbmdOdW1iZXIsICdfJDEnKS5yZXBsYWNlKHNhbml0aXplS2V5UmVtb3ZlRGlzYWxsb3dlZENoYXIsICdfJyk7XG59OyAvLyBmZXRjaCBDYWNoZVxuXG5cbmNvbnN0IGNhY2hlID0ge307IC8vIGtleTogeyB2YWx1ZTp7ZmV0Y2hLZXk6UHJvbWlzZX0sIGV4cGlyeSB9XG5cbmNvbnN0IHByb2Nlc3NDYWNoZSA9IChvcHRpb25zLCBmZXRjaCA9ICgpID0+IHVuZGVmaW5lZCwgcmVxdWVzdCkgPT4ge1xuICBjb25zdCB7XG4gICAgY2FjaGVFeHBpcnksXG4gICAgY2FjaGVLZXlcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKGNhY2hlRXhwaXJ5KSB7XG4gICAgY29uc3QgY2FjaGVkID0gZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuICAgIGNvbnN0IHVuZXhwaXJlZCA9IGNhY2hlZCAmJiAoY2FjaGVFeHBpcnkgPCAwIHx8IGNhY2hlZC5leHBpcnkgPiBEYXRlLm5vdygpKTtcblxuICAgIGlmICh1bmV4cGlyZWQgJiYgY2FjaGVkLm1vZGlmaWVkKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZldGNoKHJlcXVlc3QsIGNhY2hlZC52YWx1ZSk7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgIHZhbHVlOiB7IC4uLmNhY2hlZC52YWx1ZSxcbiAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBleHBpcnk6IGNhY2hlZC5leHBpcnlcbiAgICAgIH07XG4gICAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuICAgIH1cblxuICAgIGlmICh1bmV4cGlyZWQpIHtcbiAgICAgIHJldHVybiB7IC4uLmNhY2hlZCxcbiAgICAgICAgY2FjaGU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBmZXRjaChyZXF1ZXN0KTtcbiAgY29uc3QgZXhwaXJ5ID0gRGF0ZS5ub3coKSArIGNhY2hlRXhwaXJ5O1xuXG4gIGlmIChjYWNoZUV4cGlyeSkge1xuICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZXhwaXJ5XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgZXhwaXJ5XG4gIH07XG59O1xuXG5jb25zdCBnZXRDYWNoZSA9IGtleSA9PiB7XG4gIHJldHVybiBjYWNoZVtrZXldO1xufTsgLy8gVXNlZCB0byByZW1vdmUgcGFydHMgb2YgYSBjYWNoZVxuXG5cbmNvbnN0IG1vZGlmeUNhY2hlID0gKGNhY2hlS2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAoIWNhY2hlW2NhY2hlS2V5XSkgcmV0dXJuO1xuICBjYWNoZVtjYWNoZUtleV0gPSB7IC4uLmNhY2hlW2NhY2hlS2V5XSxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllZDogdHJ1ZVxuICB9O1xufTtcblxuY29uc3QgY2xlYXJDYWNoZSA9IChrZXlzID0gbnVsbCkgPT4ge1xuICB2YXIgX2tleXM7XG5cbiAga2V5cyA9IChfa2V5cyA9IGtleXMpICE9PSBudWxsICYmIF9rZXlzICE9PSB2b2lkIDAgPyBfa2V5cyA6IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSBrZXlzID0gW2tleXNdO1xuXG4gIGZvciAoY29uc3QgY2FjaGVLZXkgb2Yga2V5cykge1xuICAgIGNhY2hlW2NhY2hlS2V5XSA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuY29uc3QganNvblNhZmVQYXJzZSA9IChzdHJpbmcsIHJldml2ZXIpID0+IHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSByZXR1cm4gc3RyaW5nO1xuICBjb25zdCBmaXJzdENoYXIgPSBzdHJpbmdbMF07XG4gIGlmIChmaXJzdENoYXIgIT09ICd7JyAmJiBmaXJzdENoYXIgIT09ICdbJyAmJiBmaXJzdENoYXIgIT09ICdcIicpIHJldHVybiBzdHJpbmc7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcsIHJldml2ZXIpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5jb25zdCBub3JtYWxpemVIdHRwUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gIHZhciBfcmVzcG9uc2UkaGVhZGVycywgX3Jlc3BvbnNlO1xuXG4gIC8vIE1heSByZXF1aXJlIHVwZGF0aW5nIHRvIGNhdGNoIG90aGVyIHR5cGVzXG4gIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzcG9uc2UgPSB7fTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSB8fCB0eXBlb2YgcmVzcG9uc2UgIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgcmVzcG9uc2UgPSB7XG4gICAgICBib2R5OiByZXNwb25zZVxuICAgIH07XG4gIH1cblxuICByZXNwb25zZS5oZWFkZXJzID0gKF9yZXNwb25zZSRoZWFkZXJzID0gKF9yZXNwb25zZSA9IHJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXNwb25zZS5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfcmVzcG9uc2UkaGVhZGVycyAhPT0gdm9pZCAwID8gX3Jlc3BvbnNlJGhlYWRlcnMgOiB7fTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTsgLy8gc21hbGxlciB2ZXJzaW9uIG9mIGBodHRwLWVycm9yc2BcblxuXG5jb25zdCBzdGF0dXNlcyA9IHJlcXVpcmUoJy4vY29kZXMuanNvbicpO1xuXG5jb25zdCB7XG4gIGluaGVyaXRzXG59ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBjcmVhdGVFcnJvclJlZ2V4cCA9IC9bXmEtekEtWl0vZztcblxuY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbWVzc2FnZSwgcHJvcGVydGllcyA9IHt9KSA9PiB7XG4gIGNvbnN0IG5hbWUgPSBzdGF0dXNlc1tjb2RlXS5yZXBsYWNlKGNyZWF0ZUVycm9yUmVnZXhwLCAnJyk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IG5hbWUuc3Vic3RyKC01KSAhPT0gJ0Vycm9yJyA/IG5hbWUgKyAnRXJyb3InIDogbmFtZTtcblxuICBmdW5jdGlvbiBIdHRwRXJyb3IobWVzc2FnZSkge1xuICAgIC8vIGNyZWF0ZSB0aGUgZXJyb3Igb2JqZWN0XG4gICAgY29uc3QgbXNnID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogc3RhdHVzZXNbY29kZV07XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7IC8vIGNhcHR1cmUgYSBzdGFjayB0cmFjZSB0byB0aGUgY29uc3RydWN0aW9uIHBvaW50XG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIEh0dHBFcnJvcik7IC8vIGFkanVzdCB0aGUgW1tQcm90b3R5cGVdXVxuXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVyciwgSHR0cEVycm9yLnByb3RvdHlwZSk7IC8vIHJlZGVmaW5lIHRoZSBlcnJvciBtZXNzYWdlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbXNnLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTsgLy8gcmVkZWZpbmUgdGhlIGVycm9yIG5hbWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICduYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogY2xhc3NOYW1lLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgaW5oZXJpdHMoSHR0cEVycm9yLCBFcnJvcik7XG4gIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEh0dHBFcnJvciwgJ25hbWUnKTtcbiAgZGVzYy52YWx1ZSA9IGNsYXNzTmFtZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0dHBFcnJvciwgJ25hbWUnLCBkZXNjKTtcbiAgT2JqZWN0LmFzc2lnbihIdHRwRXJyb3IucHJvdG90eXBlLCB7XG4gICAgc3RhdHVzOiBjb2RlLFxuICAgIHN0YXR1c0NvZGU6IGNvZGUsXG4gICAgZXhwb3NlOiBjb2RlIDwgNTAwXG4gIH0sIHByb3BlcnRpZXMpO1xuICByZXR1cm4gbmV3IEh0dHBFcnJvcihtZXNzYWdlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVQcmVmZXRjaENsaWVudCxcbiAgY3JlYXRlQ2xpZW50LFxuICBjYW5QcmVmZXRjaCxcbiAgZ2V0SW50ZXJuYWwsXG4gIHNhbml0aXplS2V5LFxuICBwcm9jZXNzQ2FjaGUsXG4gIGdldENhY2hlLFxuICBtb2RpZnlDYWNoZSxcbiAgY2xlYXJDYWNoZSxcbiAganNvblNhZmVQYXJzZSxcbiAgbm9ybWFsaXplSHR0cFJlc3BvbnNlLFxuICBjcmVhdGVFcnJvclxufTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9sYW1iZGEvcG9zdC1jb250cm9sbGVyL2hhbmRsZXIudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=